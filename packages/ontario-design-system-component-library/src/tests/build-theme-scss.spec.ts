import mock from 'mock-fs'; // Mocking file system for testing
import {
	checkOutputFolderExists,
	getSlottedStyleFiles,
	generateThemeSCSSContent,
	writeGeneratedSCSSToTheme,
	generateThemeSCSS,
} from '../../scripts/build-theme-scss'; // Importing the functions being tested
import * as fs from 'fs'; // File system module for interacting with the mock file system
import * as path from 'path'; // Path module for handling and transforming file paths

describe('SCSS Theme Generation Functions', () => {
	let files: string[];
	let sourceFolder: string;
	let targetFolder: string;
	let expectedContent: string;

	// Setup before each test: mock the file system and set common variables
	beforeEach(() => {
		// Mock file system structure
		mock({
			'/mock-folder': {
				'file1.scss': '',
				'file2.scss': '',
				'file3.css': '',
				'file4.txt': '',
			},
			'/src/styles/slotted-styles': {
				'file1.scss': '',
				'file2.scss': '',
			},
			'/src/styles': {},
		});

		// Common variables for tests
		files = ['style1.scss', 'style2.scss'];
		sourceFolder = 'mock-source';
		targetFolder = 'mock-target';
		expectedContent =
			'// WARNING: This file is autogenerated. Do not edit manually.\n' +
			'// Changes will be overwritten during the build process.\n\n' +
			"@forward '@ongov/ontario-design-system-global-styles/dist/styles/scss/theme.scss';\n\n" +
			"@use './../mock-source/style1.scss';\n" +
			"@use './../mock-source/style2.scss';\n";
	});

	// Cleanup after each test to restore the file system to its original state
	afterEach(() => {
		mock.restore();
	});

	describe('checkOutputFolderExists', () => {
		it('should create the folder if it does not exist', () => {
			// Assert that the folder does not exist before calling the function
			expect(fs.existsSync('/test-folder')).toBe(false);

			// Call the function to create the folder
			checkOutputFolderExists('/test-folder');

			// Assert that the folder now exists
			expect(fs.existsSync('/test-folder')).toBe(true);
		});

		it('should not create the folder if it exists', () => {
			// Assert that the folder exists before calling the function
			expect(fs.existsSync('/mock-folder')).toBe(true);

			// Call the function (folder should not be created again)
			checkOutputFolderExists('/mock-folder');

			// Assert that the folder still exists (no changes)
			expect(fs.existsSync('/mock-folder')).toBe(true);
		});
	});

	describe('getSlottedStyleFiles', () => {
		it('should return only SCSS files', () => {
			// Call the function to get SCSS files from the mock folder
			const files = getSlottedStyleFiles('/mock-folder');

			// Assert that only SCSS files are returned
			expect(files).toEqual(['file1.scss', 'file2.scss']);
		});

		it('should warn if no SCSS files are found', () => {
			// Mock console.warn to spy on it
			const consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation(() => {});

			// Mock an empty folder to simulate no SCSS files
			mock({
				'/empty-folder': {},
			});

			// Call the function (this should trigger a warning)
			getSlottedStyleFiles('/empty-folder');

			// Assert that a warning was logged
			expect(consoleWarnSpy).toHaveBeenCalledWith('No SCSS files found in the source folder.');

			// Restore the original console.warn functionality
			consoleWarnSpy.mockRestore();
		});
	});

	describe('generateThemeSCSSContent', () => {
		it('should return the correct SCSS content including header and imports', () => {
			// Call the function and compare the result with the expected output
			expect(generateThemeSCSSContent(files, sourceFolder, targetFolder)).toBe(expectedContent);
		});

		it('should handle path normalization correctly', () => {
			// Call the function and compare the result with the expected output
			expect(generateThemeSCSSContent(files, sourceFolder, targetFolder)).toBe(expectedContent);

			// Additional test for path normalization
			const windowsPath = 'C:\\mock-source\\style1.scss';
			const normalizedPath = `./${path.relative(targetFolder, windowsPath).replace(/\\/g, '/')}`;
			expect(normalizedPath).toBe('./C:/mock-source/style1.scss');
		});
	});

	describe('writeGeneratedSCSSToTheme', () => {
		it('should write content to file', () => {
			// Mock console.log to spy on it
			const consoleLogSpy = jest.spyOn(console, 'log').mockImplementation(() => {});

			// Ensure the directory exists for the file to be written to
			mock({
				'/some': {}, // Create the directory
			});

			// Call the function to write content to a .scss file
			writeGeneratedSCSSToTheme('/some/path.scss', 'content');

			// Assert that the file was written correctly
			expect(fs.readFileSync('/some/path.scss', 'utf8')).toBe('content');

			// Assert that a success message was logged
			expect(consoleLogSpy).toHaveBeenCalledWith('Generated theme.scss at /some/path.scss');

			// Restore the original console.log functionality
			consoleLogSpy.mockRestore();
		});

		it('should handle file writing errors', () => {
			// Mock console.error to spy on it
			const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation(() => {});

			// Mock file system to throw an error on write
			mock({
				'/some': mock.directory({
					mode: 0o000, // No permissions
					items: {
						'path.scss': mock.file({
							content: '', // File content
							mode: 0o000, // No read/write/execute permissions permitted
						}),
					},
				}),
			});

			// Call the function to write content to a .scss file (this should trigger an error)
			expect(() => writeGeneratedSCSSToTheme('/some/path.scss', 'content')).toThrow();

			// Assert that an error message was logged
			expect(consoleErrorSpy).toHaveBeenCalledWith(expect.stringContaining('Error writing to /some/path.scss'));

			// Restore the original console.error functionality
			consoleErrorSpy.mockRestore();
		});
	});

	describe('generateThemeSCSS', () => {
		it('should execute full process', () => {
			// Mock console.log to spy on it
			const consoleLogSpy = jest.spyOn(console, 'log').mockImplementation(() => {});

			// Mock folders and files to simulate a typical scenario
			mock({
				'/mock-folder': {
					'style1.scss': '',
					'style2.scss': '',
				},
				'/mock-output': {}, // Output folder for the generated theme
			});

			// Call the function to generate the theme.scss file
			generateThemeSCSS('/mock-folder', '/mock-output', '/mock-output/theme.scss');

			// Assert that the generated theme.scss file exists
			expect(fs.existsSync('/mock-output/theme.scss')).toBe(true);

			// Assert that the generated content matches the expected SCSS content
			expect(fs.readFileSync('/mock-output/theme.scss', 'utf8')).toBe(
				'// WARNING: This file is autogenerated. Do not edit manually.\n' +
					'// Changes will be overwritten during the build process.\n\n' +
					"@forward '@ongov/ontario-design-system-global-styles/dist/styles/scss/theme.scss';\n\n" +
					"@use './../mock-folder/style1.scss';\n" +
					"@use './../mock-folder/style2.scss';\n",
			);

			// Restore the original console.log functionality
			consoleLogSpy.mockRestore();
		});

		it('should handle errors during the process', () => {
			// Mock console.error to spy on it
			const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation(() => {});

			// Mock file system to throw an error on write
			mock({
				'/mock-folder': {
					'style1.scss': '',
					'style2.scss': '',
				},
				'/mock-output': mock.directory({
					mode: 0o000, // No read/write/execute permissions permitted
					items: {
						'theme.scss': mock.file({
							content: '', // File content
							mode: 0o000, // No read/write/execute permissions permitted
						}),
					},
				}),
			});

			// Call the function to generate the theme.scss file (this should trigger an error)
			expect(() => generateThemeSCSS('/mock-folder', '/mock-output', '/mock-output/theme.scss')).toThrow();

			// Assert that an error message was logged
			expect(consoleErrorSpy).toHaveBeenCalledWith(expect.stringContaining('Error writing to /mock-output/theme.scss'));

			// Restore the original console.error functionality
			consoleErrorSpy.mockRestore();
		});
	});
});
