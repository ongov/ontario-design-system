import mock from 'mock-fs'; // Mocking file system for testing
import {
	checkOutputFolderExists,
	createOutputFolder,
	getSlottedStyleFiles,
	generateThemeSCSSContent,
	writeGeneratedSCSSToTheme,
	generateThemeSCSS,
} from '../../scripts/build-theme-scss'; // Importing the functions being tested
import * as fs from 'fs'; // File system module for interacting with the mock file system
import * as path from 'path'; // Path module for handling and transforming file paths

describe('SCSS Theme Generation Functions', () => {
	let files: string[];
	let sourceFolder: string;
	let targetFolder: string;
	let expectedContent: string;
	let content: string = 'content';

	// Mock file system structure
	const mockFolderStructure = {
		'/mock-folder': {
			'file1.scss': '',
			'file2.scss': '',
			'file3.css': '',
			'file4.txt': '',
		},
		'/src/styles/slotted-styles': {
			'file1.scss': '',
			'file2.scss': '',
		},
		'/src/styles': {},
	};

	// Setup before each test: mock the file system and set common variables
	beforeEach(() => {
		mock(mockFolderStructure);

		// Common variables for tests
		files = ['style1.scss', 'style2.scss'];
		sourceFolder = 'mock-source';
		targetFolder = 'mock-target';
		expectedContent =
			'// WARNING: This file is autogenerated. Do not edit manually.\n' +
			'// Changes will be overwritten during the build process.\n\n' +
			"@forward '@ongov/ontario-design-system-global-styles/dist/styles/scss/theme.scss';\n\n" +
			"@use './../mock-source/style1.scss';\n" +
			"@use './../mock-source/style2.scss';\n";
	});

	// Cleanup after each test to restore the file system to its original state
	afterEach(() => {
		mock.restore();
	});

	describe('checkOutputFolderExists', () => {
		it('should return false if the folder does not exist', () => {
			// Call the function with a non-existent folder
			const exists = checkOutputFolderExists('/test-folder');

			// Assert that the folder does not exist
			expect(exists).toBe(false);
		});

		it('should return true if the folder exists', () => {
			// Call the function with an existing folder
			const exists = checkOutputFolderExists('/mock-folder');

			// Assert that the folder exists
			expect(exists).toBe(true);
		});
	});

	describe('createOutputFolder', () => {
		it('should create the folder if it does not exist', () => {
			// Call the function with a non-existent folder
			createOutputFolder('/test-folder');

			// Assert that the folder got created
			expect(fs.existsSync('/test-folder')).toBe(true);
		});

		it('should not create the folder if it exists', () => {
			// Call the function with an existing folder
			createOutputFolder('/mock-folder');

			// Assert that no new folder was created
			expect(fs.existsSync('/mock-folder')).toBe(true);
		});
	});

	describe('getSlottedStyleFiles', () => {
		it('should return only SCSS files', () => {
			// Call the function to get SCSS files from the mock folder
			const files = getSlottedStyleFiles('/mock-folder');

			// Assert that only SCSS files are returned from the mock folder
			const expectedFiles = Object.keys(mockFolderStructure['/mock-folder']).filter((file) => file.endsWith('.scss'));
			expect(files).toEqual(expectedFiles);
		});

		it('should warn if no SCSS files are found', () => {
			// Mock console.warn to spy on it
			const consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation(() => {});
			// Mock an empty folder to simulate no SCSS files
			mock({ '/empty-folder': {} });

			// Call the function (this should trigger a warning)
			getSlottedStyleFiles('/empty-folder');

			// Assert that the warning was logged
			expect(consoleWarnSpy).toHaveBeenCalledWith('No SCSS files found in the source folder.');
			// Restore the console.warn function
			consoleWarnSpy.mockRestore();
		});
	});

	describe('generateThemeSCSSContent', () => {
		it('should return the correct SCSS content including header and imports', () => {
			// Call the function with the mock files and folders
			const content = generateThemeSCSSContent(files, sourceFolder, targetFolder);

			// Assert that the content is as expected
			expect(content).toBe(expectedContent);
		});

		it('should handle path normalization correctly', () => {
			// Mock a Windows-style path
			const windowsPath = 'C:\\mock-source\\style1.scss';
			// Call the function with the Windows-style path
			const normalizedPath = `./${path.relative(targetFolder, windowsPath).replace(/\\/g, '/')}`;
			// Expected normalized path
			const expectedNormalizedPath = `./${path.relative(targetFolder, windowsPath).replace(/\\/g, '/')}`;

			// Assert that the path normalization is correct
			expect(normalizedPath).toBe(expectedNormalizedPath);
		});

		it('should set default parameters if none are passed', () => {
			// Expected content based on the mock file structure
			const expectedContent =
				'// WARNING: This file is autogenerated. Do not edit manually.\n' +
				'// Changes will be overwritten during the build process.\n\n' +
				"@forward '@ongov/ontario-design-system-global-styles/dist/styles/scss/theme.scss';\n\n";

			// Call the function without parameters to use defaults
			const content = generateThemeSCSSContent();

			// Assert that the generated content matches the expected content
			expect(content.trim()).toBe(expectedContent.trim());
		});
	});

	describe('writeGeneratedSCSSToTheme', () => {
		it('should write content to file', () => {
			// Mock console.log to spy on it
			const consoleLogSpy = jest.spyOn(console, 'log').mockImplementation(() => {});
			// Ensure the directory exists for the file to be written to
			mock({ '/some': {} });

			// Call the function to write content to a .scss file
			writeGeneratedSCSSToTheme('/some/path.scss', content);

			// Assert that the file was written and the log was printed
			expect(fs.readFileSync('/some/path.scss', 'utf8')).toBe(content);
			expect(consoleLogSpy).toHaveBeenCalledWith('Generated theme.scss at /some/path.scss');

			// Restore the console.log function
			consoleLogSpy.mockRestore();
		});

		it('should handle file writing errors', () => {
			// Mock the file system to simulate a non-writable directory
			mock({
				'/restricted': mock.directory({ mode: 0o400 }), // Read-only permissions
			});

			// Attempt to write to the read-only directory and expect an error to be thrown
			expect(() => writeGeneratedSCSSToTheme('/restricted/theme.scss', content)).toThrow();

			// Restore the mock file system
			mock.restore();
		});
	});

	describe('generateThemeSCSS', () => {
		it('should execute full process', () => {
			// Mock console.log to spy on it
			const consoleLogSpy = jest.spyOn(console, 'log').mockImplementation(() => {});
			// Mock filders and files to simulate a typical setup
			mock({
				'/mock-folder': {
					'style1.scss': '',
					'style2.scss': '',
				},
				'/mock-output': {}, // Output folder for the generated theme.scss
			});

			// Call the function to generate the theme.scss file
			generateThemeSCSS('/mock-folder', '/mock-output', '/mock-output/theme.scss');

			// Assert that the generated theme.scss file is correct and the log was printed
			expect(fs.existsSync('/mock-output/theme.scss')).toBe(true);
			expect(fs.readFileSync('/mock-output/theme.scss', 'utf8')).toBe(
				'// WARNING: This file is autogenerated. Do not edit manually.\n' +
					'// Changes will be overwritten during the build process.\n\n' +
					"@forward '@ongov/ontario-design-system-global-styles/dist/styles/scss/theme.scss';\n\n" +
					"@use './../mock-folder/style1.scss';\n" +
					"@use './../mock-folder/style2.scss';\n",
			);

			// Restore the console.log function
			consoleLogSpy.mockRestore();
		});

		it('should handle errors during the process', () => {
			// Mock the file system with a read-only output directory
			mock({
				'/mock-folder': {
					'style1.scss': '',
					'style2.scss': '',
				},
				'/mock-output': mock.directory({
					mode: 0o400, // Read-only permissions
					items: {},
				}),
			});

			// Attempt to generate the theme.scss file in the read-only directory and expect an error to be thrown
			expect(() => generateThemeSCSS('/mock-folder', '/mock-output', '/mock-output/theme.scss')).toThrow();

			// Restore the mock file system
			mock.restore();
		});
	});
});
