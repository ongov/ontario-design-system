'use strict';

var stream = require('stream');

const modeResolutionChain = [];

function hydrateFactory(
	$stencilWindow,
	$stencilHydrateOpts,
	$stencilHydrateResults,
	$stencilAfterHydrate,
	$stencilHydrateResolve,
) {
	var globalThis = $stencilWindow;
	var self = $stencilWindow;
	var top = $stencilWindow;
	var parent = $stencilWindow;

	var addEventListener = $stencilWindow.addEventListener.bind($stencilWindow);
	var alert = $stencilWindow.alert.bind($stencilWindow);
	var blur = $stencilWindow.blur.bind($stencilWindow);
	var cancelAnimationFrame = $stencilWindow.cancelAnimationFrame.bind($stencilWindow);
	var cancelIdleCallback = $stencilWindow.cancelIdleCallback.bind($stencilWindow);
	var clearInterval = $stencilWindow.clearInterval.bind($stencilWindow);
	var clearTimeout = $stencilWindow.clearTimeout.bind($stencilWindow);
	var close = () => {};
	var confirm = $stencilWindow.confirm.bind($stencilWindow);
	var dispatchEvent = $stencilWindow.dispatchEvent.bind($stencilWindow);
	var focus = $stencilWindow.focus.bind($stencilWindow);
	var getComputedStyle = $stencilWindow.getComputedStyle.bind($stencilWindow);
	var matchMedia = $stencilWindow.matchMedia.bind($stencilWindow);
	var open = $stencilWindow.open.bind($stencilWindow);
	var prompt = $stencilWindow.prompt.bind($stencilWindow);
	var removeEventListener = $stencilWindow.removeEventListener.bind($stencilWindow);
	var requestAnimationFrame = $stencilWindow.requestAnimationFrame.bind($stencilWindow);
	var requestIdleCallback = $stencilWindow.requestIdleCallback.bind($stencilWindow);
	var setInterval = $stencilWindow.setInterval.bind($stencilWindow);
	var setTimeout = $stencilWindow.setTimeout.bind($stencilWindow);

	var CharacterData = $stencilWindow.CharacterData;
	var CSS = $stencilWindow.CSS;
	var CustomEvent = $stencilWindow.CustomEvent;
	var Document = $stencilWindow.Document;
	var ShadowRoot = $stencilWindow.ShadowRoot;
	var DocumentFragment = $stencilWindow.DocumentFragment;
	var DocumentType = $stencilWindow.DocumentType;
	var DOMTokenList = $stencilWindow.DOMTokenList;
	var Element = $stencilWindow.Element;
	var Event = $stencilWindow.Event;
	var HTMLAnchorElement = $stencilWindow.HTMLAnchorElement;
	var HTMLBaseElement = $stencilWindow.HTMLBaseElement;
	var HTMLButtonElement = $stencilWindow.HTMLButtonElement;
	var HTMLCanvasElement = $stencilWindow.HTMLCanvasElement;
	var HTMLElement = $stencilWindow.HTMLElement;
	var HTMLFormElement = $stencilWindow.HTMLFormElement;
	var HTMLImageElement = $stencilWindow.HTMLImageElement;
	var HTMLInputElement = $stencilWindow.HTMLInputElement;
	var HTMLLinkElement = $stencilWindow.HTMLLinkElement;
	var HTMLMetaElement = $stencilWindow.HTMLMetaElement;
	var HTMLScriptElement = $stencilWindow.HTMLScriptElement;
	var HTMLStyleElement = $stencilWindow.HTMLStyleElement;
	var HTMLTemplateElement = $stencilWindow.HTMLTemplateElement;
	var HTMLTitleElement = $stencilWindow.HTMLTitleElement;
	var IntersectionObserver = $stencilWindow.IntersectionObserver;
	var ResizeObserver = $stencilWindow.ResizeObserver;
	var KeyboardEvent = $stencilWindow.KeyboardEvent;
	var MouseEvent = $stencilWindow.MouseEvent;
	var Node = $stencilWindow.Node;
	var NodeList = $stencilWindow.NodeList;
	var URL = $stencilWindow.URL;

	var console = $stencilWindow.console;
	var customElements = $stencilWindow.customElements;
	var history = $stencilWindow.history;
	var localStorage = $stencilWindow.localStorage;
	var location = $stencilWindow.location;
	var navigator = $stencilWindow.navigator;
	var performance = $stencilWindow.performance;
	var sessionStorage = $stencilWindow.sessionStorage;

	var devicePixelRatio = $stencilWindow.devicePixelRatio;
	var innerHeight = $stencilWindow.innerHeight;
	var innerWidth = $stencilWindow.innerWidth;
	var origin = $stencilWindow.origin;
	var pageXOffset = $stencilWindow.pageXOffset;
	var pageYOffset = $stencilWindow.pageYOffset;
	var screen = $stencilWindow.screen;
	var screenLeft = $stencilWindow.screenLeft;
	var screenTop = $stencilWindow.screenTop;
	var screenX = $stencilWindow.screenX;
	var screenY = $stencilWindow.screenY;
	var scrollX = $stencilWindow.scrollX;
	var scrollY = $stencilWindow.scrollY;
	var exports = {};

	var fetch, FetchError, Headers, Request, Response;

	if (typeof $stencilWindow.fetch === 'function') {
		fetch = $stencilWindow.fetch;
	} else {
		fetch = $stencilWindow.fetch = function () {
			throw new Error('fetch() is not implemented');
		};
	}

	if (typeof $stencilWindow.FetchError === 'function') {
		FetchError = $stencilWindow.FetchError;
	} else {
		FetchError = $stencilWindow.FetchError = class FetchError {
			constructor() {
				throw new Error('FetchError is not implemented');
			}
		};
	}

	if (typeof $stencilWindow.Headers === 'function') {
		Headers = $stencilWindow.Headers;
	} else {
		Headers = $stencilWindow.Headers = class Headers {
			constructor() {
				throw new Error('Headers is not implemented');
			}
		};
	}

	if (typeof $stencilWindow.Request === 'function') {
		Request = $stencilWindow.Request;
	} else {
		Request = $stencilWindow.Request = class Request {
			constructor() {
				throw new Error('Request is not implemented');
			}
		};
	}

	if (typeof $stencilWindow.Response === 'function') {
		Response = $stencilWindow.Response;
	} else {
		Response = $stencilWindow.Response = class Response {
			constructor() {
				throw new Error('Response is not implemented');
			}
		};
	}

	function hydrateAppClosure($stencilWindow) {
		const window = $stencilWindow;
		const document = $stencilWindow.document;
		/*hydrateAppClosure start*/

		const NAMESPACE = 'ontario-design-system-components';
		const BUILD = /* ontario-design-system-components */ {
			hydratedSelectorName: 'hydrated',
			slotRelocation: true,
			updatable: true,
		};

		setMode((elm) => {
			// NOTE: you can write whatever you want here - it's up to you. This
			// function must return one of the style "modes" defined in step 1.
			return elm.type;
		});

		/*
 Stencil Hydrate Platform v4.30.0 | MIT Licensed | https://stenciljs.com
 */
		var __defProp = Object.defineProperty;
		var __export = (target, all) => {
			for (var name in all) __defProp(target, name, { get: all[name], enumerable: true });
		};

		// src/utils/constants.ts
		var SVG_NS = 'http://www.w3.org/2000/svg';
		var HTML_NS = 'http://www.w3.org/1999/xhtml';
		var PrimitiveType = /* @__PURE__ */ ((PrimitiveType2) => {
			PrimitiveType2['Undefined'] = 'undefined';
			PrimitiveType2['Null'] = 'null';
			PrimitiveType2['String'] = 'string';
			PrimitiveType2['Number'] = 'number';
			PrimitiveType2['SpecialNumber'] = 'number';
			PrimitiveType2['Boolean'] = 'boolean';
			PrimitiveType2['BigInt'] = 'bigint';
			return PrimitiveType2;
		})(PrimitiveType || {});
		var NonPrimitiveType = /* @__PURE__ */ ((NonPrimitiveType2) => {
			NonPrimitiveType2['Array'] = 'array';
			NonPrimitiveType2['Date'] = 'date';
			NonPrimitiveType2['Map'] = 'map';
			NonPrimitiveType2['Object'] = 'object';
			NonPrimitiveType2['RegularExpression'] = 'regexp';
			NonPrimitiveType2['Set'] = 'set';
			NonPrimitiveType2['Channel'] = 'channel';
			NonPrimitiveType2['Symbol'] = 'symbol';
			return NonPrimitiveType2;
		})(NonPrimitiveType || {});
		var TYPE_CONSTANT = 'type';
		var VALUE_CONSTANT = 'value';
		var SERIALIZED_PREFIX = 'serialized:';

		// src/utils/es2022-rewire-class-members.ts
		var reWireGetterSetter = (instance, hostRef) => {
			var _a;
			const cmpMeta = hostRef.$cmpMeta$;
			const members = Object.entries((_a = cmpMeta.$members$) != null ? _a : {});
			members.map(([memberName, [memberFlags]]) => {
				if (memberFlags & 31 /* Prop */ || memberFlags & 32 /* State */) {
					const ogValue = instance[memberName];
					const ogDescriptor = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(instance), memberName);
					Object.defineProperty(instance, memberName, {
						get() {
							return ogDescriptor.get.call(this);
						},
						set(newValue) {
							ogDescriptor.set.call(this, newValue);
						},
						configurable: true,
						enumerable: true,
					});
					instance[memberName] = hostRef.$instanceValues$.has(memberName)
						? hostRef.$instanceValues$.get(memberName)
						: ogValue;
				}
			});
		};

		// src/runtime/asset-path.ts
		var getAssetPath = (path) => {
			const assetUrl = new URL(path, plt.$resourcesUrl$);
			return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;
		};

		// src/utils/helpers.ts
		var isDef = (v) => v != null && v !== void 0;
		var isComplexType = (o) => {
			o = typeof o;
			return o === 'object' || o === 'function';
		};

		// src/utils/query-nonce-meta-tag-content.ts
		function queryNonceMetaTagContent(doc) {
			var _a, _b, _c;
			return (_c =
				(_b = (_a = doc.head) == null ? void 0 : _a.querySelector('meta[name="csp-nonce"]')) == null
					? void 0
					: _b.getAttribute('content')) != null
				? _c
				: void 0;
		}

		// src/utils/regular-expression.ts
		var escapeRegExpSpecialCharacters = (text) => {
			return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
		};

		// src/utils/remote-value.ts
		var RemoteValue = class _RemoteValue {
			/**
			 * Deserializes a LocalValue serialized object back to its original JavaScript representation
			 *
			 * @param serialized The serialized LocalValue object
			 * @returns The original JavaScript value/object
			 */
			static fromLocalValue(serialized) {
				const type = serialized[TYPE_CONSTANT];
				const value = VALUE_CONSTANT in serialized ? serialized[VALUE_CONSTANT] : void 0;
				switch (type) {
					case 'string' /* String */:
						return value;
					case 'boolean' /* Boolean */:
						return value;
					case 'bigint' /* BigInt */:
						return BigInt(value);
					case 'undefined' /* Undefined */:
						return void 0;
					case 'null' /* Null */:
						return null;
					case 'number' /* Number */:
						if (value === 'NaN') return NaN;
						if (value === '-0') return -0;
						if (value === 'Infinity') return Infinity;
						if (value === '-Infinity') return -Infinity;
						return value;
					case 'array' /* Array */:
						return value.map((item) => _RemoteValue.fromLocalValue(item));
					case 'date' /* Date */:
						return new Date(value);
					case 'map' /* Map */:
						const map2 = /* @__PURE__ */ new Map();
						for (const [key, val] of value) {
							const deserializedKey = typeof key === 'object' && key !== null ? _RemoteValue.fromLocalValue(key) : key;
							const deserializedValue = _RemoteValue.fromLocalValue(val);
							map2.set(deserializedKey, deserializedValue);
						}
						return map2;
					case 'object' /* Object */:
						const obj = {};
						for (const [key, val] of value) {
							obj[key] = _RemoteValue.fromLocalValue(val);
						}
						return obj;
					case 'regexp' /* RegularExpression */:
						const { pattern, flags } = value;
						return new RegExp(pattern, flags);
					case 'set' /* Set */:
						const set = /* @__PURE__ */ new Set();
						for (const item of value) {
							set.add(_RemoteValue.fromLocalValue(item));
						}
						return set;
					case 'symbol' /* Symbol */:
						return Symbol(value);
					default:
						throw new Error(`Unsupported type: ${type}`);
				}
			}
			/**
			 * Utility method to deserialize multiple LocalValues at once
			 *
			 * @param serializedValues Array of serialized LocalValue objects
			 * @returns Array of deserialized JavaScript values
			 */
			static fromLocalValueArray(serializedValues) {
				return serializedValues.map((value) => _RemoteValue.fromLocalValue(value));
			}
			/**
			 * Verifies if the given object matches the structure of a serialized LocalValue
			 *
			 * @param obj Object to verify
			 * @returns boolean indicating if the object has LocalValue structure
			 */
			static isLocalValueObject(obj) {
				if (typeof obj !== 'object' || obj === null) {
					return false;
				}
				if (!obj.hasOwnProperty(TYPE_CONSTANT)) {
					return false;
				}
				const type = obj[TYPE_CONSTANT];
				const hasTypeProperty = Object.values({ ...PrimitiveType, ...NonPrimitiveType }).includes(type);
				if (!hasTypeProperty) {
					return false;
				}
				if (type !== 'null' /* Null */ && type !== 'undefined' /* Undefined */) {
					return obj.hasOwnProperty(VALUE_CONSTANT);
				}
				return true;
			}
		};

		// src/utils/result.ts
		var result_exports = {};
		__export(result_exports, {
			err: () => err,
			map: () => map,
			ok: () => ok,
			unwrap: () => unwrap,
			unwrapErr: () => unwrapErr,
		});
		var ok = (value) => ({
			isOk: true,
			isErr: false,
			value,
		});
		var err = (value) => ({
			isOk: false,
			isErr: true,
			value,
		});
		function map(result, fn) {
			if (result.isOk) {
				const val = fn(result.value);
				if (val instanceof Promise) {
					return val.then((newVal) => ok(newVal));
				} else {
					return ok(val);
				}
			}
			if (result.isErr) {
				const value = result.value;
				return err(value);
			}
			throw 'should never get here';
		}
		var unwrap = (result) => {
			if (result.isOk) {
				return result.value;
			} else {
				throw result.value;
			}
		};
		var unwrapErr = (result) => {
			if (result.isErr) {
				return result.value;
			} else {
				throw result.value;
			}
		};

		// src/utils/serialize.ts
		function deserializeProperty(value) {
			if (typeof value !== 'string' || !value.startsWith(SERIALIZED_PREFIX)) {
				return value;
			}
			return RemoteValue.fromLocalValue(JSON.parse(atob(value.slice(SERIALIZED_PREFIX.length))));
		}

		// src/runtime/runtime-constants.ts
		var CONTENT_REF_ID = 'r';
		var ORG_LOCATION_ID = 'o';
		var SLOT_NODE_ID = 's';
		var TEXT_NODE_ID = 't';
		var COMMENT_NODE_ID = 'c';
		var HYDRATE_ID = 's-id';
		var HYDRATED_STYLE_ID = 'sty-id';
		var HYDRATE_CHILD_ID = 'c-id';
		var STENCIL_DOC_DATA = '_stencilDocData';
		var DEFAULT_DOC_DATA = {
			hostIds: 0,
			rootLevelIds: 0,
			staticComponents: /* @__PURE__ */ new Set(),
		};
		var SLOT_FB_CSS = 'slot-fb{display:contents}slot-fb[hidden]{display:none}';
		var XLINK_NS = 'http://www.w3.org/1999/xlink';

		// src/runtime/slot-polyfill-utils.ts
		var updateFallbackSlotVisibility = (elm) => {
			const childNodes = internalCall(elm, 'childNodes');
			if (elm.tagName && elm.tagName.includes('-') && elm['s-cr'] && elm.tagName !== 'SLOT-FB') {
				getHostSlotNodes(childNodes, elm.tagName).forEach((slotNode) => {
					if (slotNode.nodeType === 1 /* ElementNode */ && slotNode.tagName === 'SLOT-FB') {
						if (getSlotChildSiblings(slotNode, getSlotName(slotNode), false).length) {
							slotNode.hidden = true;
						} else {
							slotNode.hidden = false;
						}
					}
				});
			}
			let i2 = 0;
			for (i2 = 0; i2 < childNodes.length; i2++) {
				const childNode = childNodes[i2];
				if (childNode.nodeType === 1 /* ElementNode */ && internalCall(childNode, 'childNodes').length) {
					updateFallbackSlotVisibility(childNode);
				}
			}
		};
		var getSlottedChildNodes = (childNodes) => {
			const result = [];
			for (let i2 = 0; i2 < childNodes.length; i2++) {
				const slottedNode = childNodes[i2]['s-nr'] || void 0;
				if (slottedNode && slottedNode.isConnected) {
					result.push(slottedNode);
				}
			}
			return result;
		};
		function getHostSlotNodes(childNodes, hostName, slotName) {
			let i2 = 0;
			let slottedNodes = [];
			let childNode;
			for (; i2 < childNodes.length; i2++) {
				childNode = childNodes[i2];
				if (childNode['s-sr'] && (!hostName || childNode['s-hn'] === hostName) && slotName === void 0) {
					slottedNodes.push(childNode);
				}
				slottedNodes = [...slottedNodes, ...getHostSlotNodes(childNode.childNodes, hostName, slotName)];
			}
			return slottedNodes;
		}
		var getSlotChildSiblings = (slot, slotName, includeSlot = true) => {
			const childNodes = [];
			if ((includeSlot && slot['s-sr']) || !slot['s-sr']) childNodes.push(slot);
			let node = slot;
			while ((node = node.nextSibling)) {
				if (getSlotName(node) === slotName && (includeSlot || !node['s-sr'])) childNodes.push(node);
			}
			return childNodes;
		};
		var isNodeLocatedInSlot = (nodeToRelocate, slotName) => {
			if (nodeToRelocate.nodeType === 1 /* ElementNode */) {
				if (nodeToRelocate.getAttribute('slot') === null && slotName === '') {
					return true;
				}
				if (nodeToRelocate.getAttribute('slot') === slotName) {
					return true;
				}
				return false;
			}
			if (nodeToRelocate['s-sn'] === slotName) {
				return true;
			}
			return slotName === '';
		};
		var addSlotRelocateNode = (newChild, slotNode, prepend, position) => {
			if (newChild['s-ol'] && newChild['s-ol'].isConnected) {
				return;
			}
			const slottedNodeLocation = document.createTextNode('');
			slottedNodeLocation['s-nr'] = newChild;
			if (!slotNode['s-cr'] || !slotNode['s-cr'].parentNode) return;
			const parent = slotNode['s-cr'].parentNode;
			const appendMethod = internalCall(parent, 'appendChild');
			if (typeof position !== 'undefined') {
				slottedNodeLocation['s-oo'] = position;
				const childNodes = internalCall(parent, 'childNodes');
				const slotRelocateNodes = [slottedNodeLocation];
				childNodes.forEach((n) => {
					if (n['s-nr']) slotRelocateNodes.push(n);
				});
				slotRelocateNodes.sort((a, b) => {
					if (!a['s-oo'] || a['s-oo'] < (b['s-oo'] || 0)) return -1;
					else if (!b['s-oo'] || b['s-oo'] < a['s-oo']) return 1;
					return 0;
				});
				slotRelocateNodes.forEach((n) => appendMethod.call(parent, n));
			} else {
				appendMethod.call(parent, slottedNodeLocation);
			}
			newChild['s-ol'] = slottedNodeLocation;
			newChild['s-sh'] = slotNode['s-hn'];
		};
		var getSlotName = (node) =>
			typeof node['s-sn'] === 'string' ? node['s-sn'] : (node.nodeType === 1 && node.getAttribute('slot')) || void 0;
		function patchSlotNode(node) {
			if (node.assignedElements || node.assignedNodes || !node['s-sr']) return;
			const assignedFactory = (elementsOnly) =>
				function (opts) {
					const toReturn = [];
					const slotName = this['s-sn'];
					if (opts == null ? void 0 : opts.flatten) {
						console.error(`
          Flattening is not supported for Stencil non-shadow slots. 
          You can use \`.childNodes\` to nested slot fallback content.
          If you have a particular use case, please open an issue on the Stencil repo.
        `);
					}
					const parent = this['s-cr'].parentElement;
					const slottedNodes = parent.__childNodes ? parent.childNodes : getSlottedChildNodes(parent.childNodes);
					slottedNodes.forEach((n) => {
						if (slotName === getSlotName(n)) {
							toReturn.push(n);
						}
					});
					if (elementsOnly) {
						return toReturn.filter((n) => n.nodeType === 1 /* ElementNode */);
					}
					return toReturn;
				}.bind(node);
			node.assignedElements = assignedFactory(true);
			node.assignedNodes = assignedFactory(false);
		}
		function internalCall(node, method) {
			if ('__' + method in node) {
				const toReturn = node['__' + method];
				if (typeof toReturn !== 'function') return toReturn;
				return toReturn.bind(node);
			} else {
				if (typeof node[method] !== 'function') return node[method];
				return node[method].bind(node);
			}
		}
		var createTime = (fnName, tagName = '') => {
			{
				return () => {
					return;
				};
			}
		};
		var uniqueTime = (key, measureText) => {
			{
				return () => {
					return;
				};
			}
		};
		var h = (nodeName, vnodeData, ...children) => {
			let child = null;
			let key = null;
			let slotName = null;
			let simple = false;
			let lastSimple = false;
			const vNodeChildren = [];
			const walk = (c) => {
				for (let i2 = 0; i2 < c.length; i2++) {
					child = c[i2];
					if (Array.isArray(child)) {
						walk(child);
					} else if (child != null && typeof child !== 'boolean') {
						if ((simple = typeof nodeName !== 'function' && !isComplexType(child))) {
							child = String(child);
						}
						if (simple && lastSimple) {
							vNodeChildren[vNodeChildren.length - 1].$text$ += child;
						} else {
							vNodeChildren.push(simple ? newVNode(null, child) : child);
						}
						lastSimple = simple;
					}
				}
			};
			walk(children);
			if (vnodeData) {
				if (vnodeData.key) {
					key = vnodeData.key;
				}
				if (vnodeData.name) {
					slotName = vnodeData.name;
				}
				{
					const classData = vnodeData.className || vnodeData.class;
					if (classData) {
						vnodeData.class =
							typeof classData !== 'object'
								? classData
								: Object.keys(classData)
										.filter((k) => classData[k])
										.join(' ');
					}
				}
			}
			if (typeof nodeName === 'function') {
				return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);
			}
			const vnode = newVNode(nodeName, null);
			vnode.$attrs$ = vnodeData;
			if (vNodeChildren.length > 0) {
				vnode.$children$ = vNodeChildren;
			}
			{
				vnode.$key$ = key;
			}
			{
				vnode.$name$ = slotName;
			}
			return vnode;
		};
		var newVNode = (tag, text) => {
			const vnode = {
				$flags$: 0,
				$tag$: tag,
				$text$: text,
				$elm$: null,
				$children$: null,
			};
			{
				vnode.$attrs$ = null;
			}
			{
				vnode.$key$ = null;
			}
			{
				vnode.$name$ = null;
			}
			return vnode;
		};
		var Host = {};
		var isHost = (node) => node && node.$tag$ === Host;
		var vdomFnUtils = {
			forEach: (children, cb) => children.map(convertToPublic).forEach(cb),
			map: (children, cb) => children.map(convertToPublic).map(cb).map(convertToPrivate),
		};
		var convertToPublic = (node) => ({
			vattrs: node.$attrs$,
			vchildren: node.$children$,
			vkey: node.$key$,
			vname: node.$name$,
			vtag: node.$tag$,
			vtext: node.$text$,
		});
		var convertToPrivate = (node) => {
			if (typeof node.vtag === 'function') {
				const vnodeData = { ...node.vattrs };
				if (node.vkey) {
					vnodeData.key = node.vkey;
				}
				if (node.vname) {
					vnodeData.name = node.vname;
				}
				return h(node.vtag, vnodeData, ...(node.vchildren || []));
			}
			const vnode = newVNode(node.vtag, node.vtext);
			vnode.$attrs$ = node.vattrs;
			vnode.$children$ = node.vchildren;
			vnode.$key$ = node.vkey;
			vnode.$name$ = node.vname;
			return vnode;
		};

		// src/runtime/client-hydrate.ts
		var initializeClientHydrate = (hostElm, tagName, hostId, hostRef) => {
			var _a;
			const endHydrate = createTime('hydrateClient', tagName);
			const shadowRoot = hostElm.shadowRoot;
			const childRenderNodes = [];
			const slotNodes = [];
			const slottedNodes = [];
			const shadowRootNodes = shadowRoot ? [] : null;
			const vnode = newVNode(tagName, null);
			vnode.$elm$ = hostElm;
			const members = Object.entries(((_a = hostRef.$cmpMeta$) == null ? void 0 : _a.$members$) || {});
			members.forEach(([memberName, [memberFlags, metaAttributeName]]) => {
				var _a2;
				if (!((memberFlags & 31) /* Prop */)) {
					return;
				}
				const attributeName = metaAttributeName || memberName;
				const attrVal = hostElm.getAttribute(attributeName);
				if (attrVal !== null) {
					const attrPropVal = parsePropertyValue(attrVal, memberFlags);
					(_a2 = hostRef == null ? void 0 : hostRef.$instanceValues$) == null
						? void 0
						: _a2.set(memberName, attrPropVal);
				}
			});
			if (win.document && (!plt.$orgLocNodes$ || !plt.$orgLocNodes$.size)) {
				initializeDocumentHydrate(win.document.body, (plt.$orgLocNodes$ = /* @__PURE__ */ new Map()));
			}
			hostElm[HYDRATE_ID] = hostId;
			hostElm.removeAttribute(HYDRATE_ID);
			hostRef.$vnode$ = clientHydrate(
				vnode,
				childRenderNodes,
				slotNodes,
				shadowRootNodes,
				hostElm,
				hostElm,
				hostId,
				slottedNodes,
			);
			let crIndex = 0;
			const crLength = childRenderNodes.length;
			let childRenderNode;
			for (crIndex; crIndex < crLength; crIndex++) {
				childRenderNode = childRenderNodes[crIndex];
				const orgLocationId = childRenderNode.$hostId$ + '.' + childRenderNode.$nodeId$;
				const orgLocationNode = plt.$orgLocNodes$.get(orgLocationId);
				const node = childRenderNode.$elm$;
				if (!shadowRoot) {
					node['s-hn'] = tagName.toUpperCase();
					if (childRenderNode.$tag$ === 'slot') {
						node['s-cr'] = hostElm['s-cr'];
					}
				}
				if (childRenderNode.$tag$ === 'slot') {
					childRenderNode.$name$ = childRenderNode.$elm$['s-sn'] || childRenderNode.$elm$['name'] || null;
					if (childRenderNode.$children$) {
						childRenderNode.$flags$ |= 2 /* isSlotFallback */;
						if (!childRenderNode.$elm$.childNodes.length) {
							childRenderNode.$children$.forEach((c) => {
								childRenderNode.$elm$.appendChild(c.$elm$);
							});
						}
					} else {
						childRenderNode.$flags$ |= 1 /* isSlotReference */;
					}
				}
				if (orgLocationNode && orgLocationNode.isConnected) {
					if (shadowRoot && orgLocationNode['s-en'] === '') {
						orgLocationNode.parentNode.insertBefore(node, orgLocationNode.nextSibling);
					}
					orgLocationNode.parentNode.removeChild(orgLocationNode);
					if (!shadowRoot) {
						node['s-oo'] = parseInt(childRenderNode.$nodeId$);
					}
				}
				plt.$orgLocNodes$.delete(orgLocationId);
			}
			const hosts = [];
			const snLen = slottedNodes.length;
			let snIndex = 0;
			let slotGroup;
			let snGroupIdx;
			let snGroupLen;
			let slottedItem;
			for (snIndex; snIndex < snLen; snIndex++) {
				slotGroup = slottedNodes[snIndex];
				if (!slotGroup || !slotGroup.length) continue;
				snGroupLen = slotGroup.length;
				snGroupIdx = 0;
				for (snGroupIdx; snGroupIdx < snGroupLen; snGroupIdx++) {
					slottedItem = slotGroup[snGroupIdx];
					if (!hosts[slottedItem.hostId]) {
						hosts[slottedItem.hostId] = plt.$orgLocNodes$.get(slottedItem.hostId);
					}
					if (!hosts[slottedItem.hostId]) continue;
					const hostEle = hosts[slottedItem.hostId];
					if (!hostEle.shadowRoot || !shadowRoot) {
						slottedItem.slot['s-cr'] = hostEle['s-cr'];
						if (!slottedItem.slot['s-cr'] && hostEle.shadowRoot) {
							slottedItem.slot['s-cr'] = hostEle;
						} else {
							slottedItem.slot['s-cr'] = (hostEle.__childNodes || hostEle.childNodes)[0];
						}
						addSlotRelocateNode(slottedItem.node, slottedItem.slot, false, slottedItem.node['s-oo']);
					}
					if (hostEle.shadowRoot && slottedItem.node.parentElement !== hostEle) {
						hostEle.appendChild(slottedItem.node);
					}
				}
			}
			if (shadowRoot && !shadowRoot.childNodes.length) {
				let rnIdex = 0;
				const rnLen = shadowRootNodes.length;
				if (rnLen) {
					for (rnIdex; rnIdex < rnLen; rnIdex++) {
						shadowRoot.appendChild(shadowRootNodes[rnIdex]);
					}
					Array.from(hostElm.childNodes).forEach((node) => {
						if (typeof node['s-sn'] !== 'string') {
							if (node.nodeType === 1 /* ElementNode */ && node.slot && node.hidden) {
								node.removeAttribute('hidden');
							} else if (
								node.nodeType === 8 /* CommentNode */ ||
								(node.nodeType === 3 /* TextNode */ && !node.wholeText.trim())
							) {
								node.parentNode.removeChild(node);
							}
						}
					});
				}
			}
			plt.$orgLocNodes$.delete(hostElm['s-id']);
			hostRef.$hostElement$ = hostElm;
			endHydrate();
		};
		var clientHydrate = (
			parentVNode,
			childRenderNodes,
			slotNodes,
			shadowRootNodes,
			hostElm,
			node,
			hostId,
			slottedNodes = [],
		) => {
			let childNodeType;
			let childIdSplt;
			let childVNode;
			let i2;
			if (node.nodeType === 1 /* ElementNode */) {
				childNodeType = node.getAttribute(HYDRATE_CHILD_ID);
				if (childNodeType) {
					childIdSplt = childNodeType.split('.');
					if (childIdSplt[0] === hostId || childIdSplt[0] === '0') {
						childVNode = createSimpleVNode({
							$flags$: 0,
							$hostId$: childIdSplt[0],
							$nodeId$: childIdSplt[1],
							$depth$: childIdSplt[2],
							$index$: childIdSplt[3],
							$tag$: node.tagName.toLowerCase(),
							$elm$: node,
							// If we don't add the initial classes to the VNode, the first `vdom-render.ts` patch
							// won't try to reconcile them. Classes set on the node will be blown away.
							$attrs$: { class: node.className || '' },
						});
						childRenderNodes.push(childVNode);
						node.removeAttribute(HYDRATE_CHILD_ID);
						if (!parentVNode.$children$) {
							parentVNode.$children$ = [];
						}
						const slotName = childVNode.$elm$.getAttribute('s-sn');
						if (typeof slotName === 'string') {
							if (childVNode.$tag$ === 'slot-fb') {
								addSlot(
									slotName,
									childIdSplt[2],
									childVNode,
									node,
									parentVNode,
									childRenderNodes,
									slotNodes,
									shadowRootNodes,
									slottedNodes,
								);
							}
							childVNode.$elm$['s-sn'] = slotName;
							childVNode.$elm$.removeAttribute('s-sn');
						}
						if (childVNode.$index$ !== void 0) {
							parentVNode.$children$[childVNode.$index$] = childVNode;
						}
						parentVNode = childVNode;
						if (shadowRootNodes && childVNode.$depth$ === '0') {
							shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
						}
					}
				}
				if (node.shadowRoot) {
					for (i2 = node.shadowRoot.childNodes.length - 1; i2 >= 0; i2--) {
						clientHydrate(
							parentVNode,
							childRenderNodes,
							slotNodes,
							shadowRootNodes,
							hostElm,
							node.shadowRoot.childNodes[i2],
							hostId,
							slottedNodes,
						);
					}
				}
				const nonShadowNodes = node.__childNodes || node.childNodes;
				for (i2 = nonShadowNodes.length - 1; i2 >= 0; i2--) {
					clientHydrate(
						parentVNode,
						childRenderNodes,
						slotNodes,
						shadowRootNodes,
						hostElm,
						nonShadowNodes[i2],
						hostId,
						slottedNodes,
					);
				}
			} else if (node.nodeType === 8 /* CommentNode */) {
				childIdSplt = node.nodeValue.split('.');
				if (childIdSplt[1] === hostId || childIdSplt[1] === '0') {
					childNodeType = childIdSplt[0];
					childVNode = createSimpleVNode({
						$hostId$: childIdSplt[1],
						$nodeId$: childIdSplt[2],
						$depth$: childIdSplt[3],
						$index$: childIdSplt[4] || '0',
						$elm$: node,
						$attrs$: null,
						$children$: null,
						$key$: null,
						$name$: null,
						$tag$: null,
						$text$: null,
					});
					if (childNodeType === TEXT_NODE_ID) {
						childVNode.$elm$ = findCorrespondingNode(node, 3 /* TextNode */);
						if (childVNode.$elm$ && childVNode.$elm$.nodeType === 3 /* TextNode */) {
							childVNode.$text$ = childVNode.$elm$.textContent;
							childRenderNodes.push(childVNode);
							node.remove();
							if (hostId === childVNode.$hostId$) {
								if (!parentVNode.$children$) {
									parentVNode.$children$ = [];
								}
								parentVNode.$children$[childVNode.$index$] = childVNode;
							}
							if (shadowRootNodes && childVNode.$depth$ === '0') {
								shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
							}
						}
					} else if (childNodeType === COMMENT_NODE_ID) {
						childVNode.$elm$ = findCorrespondingNode(node, 8 /* CommentNode */);
						if (childVNode.$elm$ && childVNode.$elm$.nodeType === 8 /* CommentNode */) {
							childRenderNodes.push(childVNode);
							node.remove();
						}
					} else if (childVNode.$hostId$ === hostId) {
						if (childNodeType === SLOT_NODE_ID) {
							const slotName = (node['s-sn'] = childIdSplt[5] || '');
							addSlot(
								slotName,
								childIdSplt[2],
								childVNode,
								node,
								parentVNode,
								childRenderNodes,
								slotNodes,
								shadowRootNodes,
								slottedNodes,
							);
						} else if (childNodeType === CONTENT_REF_ID) {
							if (shadowRootNodes) {
								node.remove();
							} else {
								hostElm['s-cr'] = node;
								node['s-cn'] = true;
							}
						}
					}
				}
			} else if (parentVNode && parentVNode.$tag$ === 'style') {
				const vnode = newVNode(null, node.textContent);
				vnode.$elm$ = node;
				vnode.$index$ = '0';
				parentVNode.$children$ = [vnode];
			} else {
				if (node.nodeType === 3 /* TextNode */ && !node.wholeText.trim()) {
					node.remove();
				}
			}
			return parentVNode;
		};
		var initializeDocumentHydrate = (node, orgLocNodes) => {
			if (node.nodeType === 1 /* ElementNode */) {
				const componentId = node[HYDRATE_ID] || node.getAttribute(HYDRATE_ID);
				if (componentId) {
					orgLocNodes.set(componentId, node);
				}
				let i2 = 0;
				if (node.shadowRoot) {
					for (; i2 < node.shadowRoot.childNodes.length; i2++) {
						initializeDocumentHydrate(node.shadowRoot.childNodes[i2], orgLocNodes);
					}
				}
				const nonShadowNodes = node.__childNodes || node.childNodes;
				for (i2 = 0; i2 < nonShadowNodes.length; i2++) {
					initializeDocumentHydrate(nonShadowNodes[i2], orgLocNodes);
				}
			} else if (node.nodeType === 8 /* CommentNode */) {
				const childIdSplt = node.nodeValue.split('.');
				if (childIdSplt[0] === ORG_LOCATION_ID) {
					orgLocNodes.set(childIdSplt[1] + '.' + childIdSplt[2], node);
					node.nodeValue = '';
					node['s-en'] = childIdSplt[3];
				}
			}
		};
		var createSimpleVNode = (vnode) => {
			const defaultVNode = {
				$flags$: 0,
				$hostId$: null,
				$nodeId$: null,
				$depth$: null,
				$index$: '0',
				$elm$: null,
				$attrs$: null,
				$children$: null,
				$key$: null,
				$name$: null,
				$tag$: null,
				$text$: null,
			};
			return { ...defaultVNode, ...vnode };
		};
		function addSlot(
			slotName,
			slotId,
			childVNode,
			node,
			parentVNode,
			childRenderNodes,
			slotNodes,
			shadowRootNodes,
			slottedNodes,
		) {
			node['s-sr'] = true;
			childVNode.$name$ = slotName || null;
			childVNode.$tag$ = 'slot';
			const parentNodeId = (parentVNode == null ? void 0 : parentVNode.$elm$)
				? parentVNode.$elm$['s-id'] || parentVNode.$elm$.getAttribute('s-id')
				: '';
			if (shadowRootNodes && win.document) {
				const slot = (childVNode.$elm$ = win.document.createElement(childVNode.$tag$));
				if (childVNode.$name$) {
					childVNode.$elm$.setAttribute('name', slotName);
				}
				if (parentNodeId && parentNodeId !== childVNode.$hostId$) {
					parentVNode.$elm$.insertBefore(slot, parentVNode.$elm$.children[0]);
				} else {
					node.parentNode.insertBefore(childVNode.$elm$, node);
				}
				addSlottedNodes(slottedNodes, slotId, slotName, node, childVNode.$hostId$);
				node.remove();
				if (childVNode.$depth$ === '0') {
					shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
				}
			} else {
				const slot = childVNode.$elm$;
				const shouldMove = parentNodeId && parentNodeId !== childVNode.$hostId$ && parentVNode.$elm$.shadowRoot;
				addSlottedNodes(slottedNodes, slotId, slotName, node, shouldMove ? parentNodeId : childVNode.$hostId$);
				patchSlotNode(node);
				if (shouldMove) {
					parentVNode.$elm$.insertBefore(slot, parentVNode.$elm$.children[0]);
				}
				childRenderNodes.push(childVNode);
			}
			slotNodes.push(childVNode);
			if (!parentVNode.$children$) {
				parentVNode.$children$ = [];
			}
			parentVNode.$children$[childVNode.$index$] = childVNode;
		}
		var addSlottedNodes = (slottedNodes, slotNodeId, slotName, slotNode, hostId) => {
			let slottedNode = slotNode.nextSibling;
			slottedNodes[slotNodeId] = slottedNodes[slotNodeId] || [];
			while (
				slottedNode &&
				(((slottedNode['getAttribute'] && slottedNode.getAttribute('slot')) || slottedNode['s-sn']) === slotName ||
					(slotName === '' &&
						!slottedNode['s-sn'] &&
						((slottedNode.nodeType === 8 /* CommentNode */ && slottedNode.nodeValue.indexOf('.') !== 1) ||
							slottedNode.nodeType === 3)) /* TextNode */)
			) {
				slottedNode['s-sn'] = slotName;
				slottedNodes[slotNodeId].push({ slot: slotNode, node: slottedNode, hostId });
				slottedNode = slottedNode.nextSibling;
			}
		};
		var findCorrespondingNode = (node, type) => {
			let sibling = node;
			do {
				sibling = sibling.nextSibling;
			} while (sibling && (sibling.nodeType !== type || !sibling.nodeValue));
			return sibling;
		};

		// src/utils/shadow-css.ts
		/**
		 * @license
		 * Copyright Google Inc. All Rights Reserved.
		 *
		 * Use of this source code is governed by an MIT-style license that can be
		 * found in the LICENSE file at https://angular.io/license
		 *
		 * This file is a port of shadowCSS from `webcomponents.js` to TypeScript.
		 * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js
		 * https://github.com/angular/angular/blob/master/packages/compiler/src/shadow_css.ts
		 */
		var safeSelector = (selector) => {
			const placeholders = [];
			let index = 0;
			selector = selector.replace(/(\[[^\]]*\])/g, (_, keep) => {
				const replaceBy = `__ph-${index}__`;
				placeholders.push(keep);
				index++;
				return replaceBy;
			});
			const content = selector.replace(/(:nth-[-\w]+)(\([^)]+\))/g, (_, pseudo, exp) => {
				const replaceBy = `__ph-${index}__`;
				placeholders.push(exp);
				index++;
				return pseudo + replaceBy;
			});
			const ss = {
				content,
				placeholders,
			};
			return ss;
		};
		var restoreSafeSelector = (placeholders, content) => {
			return content.replace(/__ph-(\d+)__/g, (_, index) => placeholders[+index]);
		};
		var _polyfillHost = '-shadowcsshost';
		var _polyfillSlotted = '-shadowcssslotted';
		var _polyfillHostContext = '-shadowcsscontext';
		var _parenSuffix = ')(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))?([^,{]*)';
		var _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');
		var _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');
		var _cssColonSlottedRe = new RegExp('(' + _polyfillSlotted + _parenSuffix, 'gim');
		var _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';
		var _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\s]*)/;
		var _shadowDOMSelectorsRe = [/::shadow/g, /::content/g];
		var _selectorReSuffix = '([>\\s~+[.,{:][\\s\\S]*)?$';
		var _polyfillHostRe = /-shadowcsshost/gim;
		var createSupportsRuleRe = (selector) => {
			const safeSelector2 = escapeRegExpSpecialCharacters(selector);
			return new RegExp(
				// First capture group: match any context before the selector that's not inside @supports selector()
				// Using negative lookahead to avoid matching inside @supports selector(...) condition
				`(^|[^@]|@(?!supports\\s+selector\\s*\\([^{]*?${safeSelector2}))(${safeSelector2}\\b)`,
				'g',
			);
		};
		var _colonSlottedRe = createSupportsRuleRe('::slotted');
		var _colonHostRe = createSupportsRuleRe(':host');
		var _colonHostContextRe = createSupportsRuleRe(':host-context');
		var _commentRe = /\/\*\s*[\s\S]*?\*\//g;
		var stripComments = (input) => {
			return input.replace(_commentRe, '');
		};
		var _commentWithHashRe = /\/\*\s*#\s*source(Mapping)?URL=[\s\S]+?\*\//g;
		var extractCommentsWithHash = (input) => {
			return input.match(_commentWithHashRe) || [];
		};
		var _ruleRe = /(\s*)([^;\{\}]+?)(\s*)((?:{%BLOCK%}?\s*;?)|(?:\s*;))/g;
		var _curlyRe = /([{}])/g;
		var _selectorPartsRe = /(^.*?[^\\])??((:+)(.*)|$)/;
		var OPEN_CURLY = '{';
		var CLOSE_CURLY = '}';
		var BLOCK_PLACEHOLDER = '%BLOCK%';
		var processRules = (input, ruleCallback) => {
			const inputWithEscapedBlocks = escapeBlocks(input);
			let nextBlockIndex = 0;
			return inputWithEscapedBlocks.escapedString.replace(_ruleRe, (...m) => {
				const selector = m[2];
				let content = '';
				let suffix = m[4];
				let contentPrefix = '';
				if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {
					content = inputWithEscapedBlocks.blocks[nextBlockIndex++];
					suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);
					contentPrefix = '{';
				}
				const cssRule = {
					selector,
					content,
				};
				const rule = ruleCallback(cssRule);
				return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;
			});
		};
		var escapeBlocks = (input) => {
			const inputParts = input.split(_curlyRe);
			const resultParts = [];
			const escapedBlocks = [];
			let bracketCount = 0;
			let currentBlockParts = [];
			for (let partIndex = 0; partIndex < inputParts.length; partIndex++) {
				const part = inputParts[partIndex];
				if (part === CLOSE_CURLY) {
					bracketCount--;
				}
				if (bracketCount > 0) {
					currentBlockParts.push(part);
				} else {
					if (currentBlockParts.length > 0) {
						escapedBlocks.push(currentBlockParts.join(''));
						resultParts.push(BLOCK_PLACEHOLDER);
						currentBlockParts = [];
					}
					resultParts.push(part);
				}
				if (part === OPEN_CURLY) {
					bracketCount++;
				}
			}
			if (currentBlockParts.length > 0) {
				escapedBlocks.push(currentBlockParts.join(''));
				resultParts.push(BLOCK_PLACEHOLDER);
			}
			const strEscapedBlocks = {
				escapedString: resultParts.join(''),
				blocks: escapedBlocks,
			};
			return strEscapedBlocks;
		};
		var insertPolyfillHostInCssText = (cssText) => {
			const supportsBlocks = [];
			cssText = cssText.replace(/@supports\s+selector\s*\(\s*([^)]*)\s*\)/g, (_, selectorContent) => {
				const placeholder = `__supports_${supportsBlocks.length}__`;
				supportsBlocks.push(selectorContent);
				return `@supports selector(${placeholder})`;
			});
			cssText = cssText
				.replace(_colonHostContextRe, `$1${_polyfillHostContext}`)
				.replace(_colonHostRe, `$1${_polyfillHost}`)
				.replace(_colonSlottedRe, `$1${_polyfillSlotted}`);
			supportsBlocks.forEach((originalSelector, index) => {
				cssText = cssText.replace(`__supports_${index}__`, originalSelector);
			});
			return cssText;
		};
		var convertColonRule = (cssText, regExp, partReplacer) => {
			return cssText.replace(regExp, (...m) => {
				if (m[2]) {
					const parts = m[2].split(',');
					const r = [];
					for (let i2 = 0; i2 < parts.length; i2++) {
						const p = parts[i2].trim();
						if (!p) break;
						r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));
					}
					return r.join(',');
				} else {
					return _polyfillHostNoCombinator + m[3];
				}
			});
		};
		var colonHostPartReplacer = (host, part, suffix) => {
			return host + part.replace(_polyfillHost, '') + suffix;
		};
		var convertColonHost = (cssText) => {
			return convertColonRule(cssText, _cssColonHostRe, colonHostPartReplacer);
		};
		var colonHostContextPartReplacer = (host, part, suffix) => {
			if (part.indexOf(_polyfillHost) > -1) {
				return colonHostPartReplacer(host, part, suffix);
			} else {
				return host + part + suffix + ', ' + part + ' ' + host + suffix;
			}
		};
		var convertColonSlotted = (cssText, slotScopeId) => {
			const slotClass = '.' + slotScopeId + ' > ';
			const selectors = [];
			cssText = cssText.replace(_cssColonSlottedRe, (...m) => {
				if (m[2]) {
					const compound = m[2].trim();
					const suffix = m[3];
					const slottedSelector = slotClass + compound + suffix;
					let prefixSelector = '';
					for (let i2 = m[4] - 1; i2 >= 0; i2--) {
						const char = m[5][i2];
						if (char === '}' || char === ',') {
							break;
						}
						prefixSelector = char + prefixSelector;
					}
					const orgSelector = (prefixSelector + slottedSelector).trim();
					const addedSelector = `${prefixSelector.trimEnd()}${slottedSelector.trim()}`.trim();
					if (orgSelector !== addedSelector) {
						const updatedSelector = `${addedSelector}, ${orgSelector}`;
						selectors.push({
							orgSelector,
							updatedSelector,
						});
					}
					return slottedSelector;
				} else {
					return _polyfillHostNoCombinator + m[3];
				}
			});
			return {
				selectors,
				cssText,
			};
		};
		var convertColonHostContext = (cssText) => {
			return convertColonRule(cssText, _cssColonHostContextRe, colonHostContextPartReplacer);
		};
		var convertShadowDOMSelectors = (cssText) => {
			return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, ' '), cssText);
		};
		var makeScopeMatcher = (scopeSelector2) => {
			const lre = /\[/g;
			const rre = /\]/g;
			scopeSelector2 = scopeSelector2.replace(lre, '\\[').replace(rre, '\\]');
			return new RegExp('^(' + scopeSelector2 + ')' + _selectorReSuffix, 'm');
		};
		var selectorNeedsScoping = (selector, scopeSelector2) => {
			const re = makeScopeMatcher(scopeSelector2);
			return !re.test(selector);
		};
		var injectScopingSelector = (selector, scopingSelector) => {
			return selector.replace(_selectorPartsRe, (_, before = '', _colonGroup, colon = '', after = '') => {
				return before + scopingSelector + colon + after;
			});
		};
		var applySimpleSelectorScope = (selector, scopeSelector2, hostSelector) => {
			_polyfillHostRe.lastIndex = 0;
			if (_polyfillHostRe.test(selector)) {
				const replaceBy = `.${hostSelector}`;
				return selector
					.replace(_polyfillHostNoCombinatorRe, (_, selector2) => injectScopingSelector(selector2, replaceBy))
					.replace(_polyfillHostRe, replaceBy + ' ');
			}
			return scopeSelector2 + ' ' + selector;
		};
		var applyStrictSelectorScope = (selector, scopeSelector2, hostSelector) => {
			const isRe = /\[is=([^\]]*)\]/g;
			scopeSelector2 = scopeSelector2.replace(isRe, (_, ...parts) => parts[0]);
			const className = '.' + scopeSelector2;
			const _scopeSelectorPart = (p) => {
				let scopedP = p.trim();
				if (!scopedP) {
					return '';
				}
				if (p.indexOf(_polyfillHostNoCombinator) > -1) {
					scopedP = applySimpleSelectorScope(p, scopeSelector2, hostSelector);
				} else {
					const t = p.replace(_polyfillHostRe, '');
					if (t.length > 0) {
						scopedP = injectScopingSelector(t, className);
					}
				}
				return scopedP;
			};
			const safeContent = safeSelector(selector);
			selector = safeContent.content;
			let scopedSelector = '';
			let startIndex = 0;
			let res;
			const sep = /( |>|\+|~(?!=))\s*/g;
			const hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1;
			let shouldScope = !hasHost;
			while ((res = sep.exec(selector)) !== null) {
				const separator = res[1];
				const part2 = selector.slice(startIndex, res.index).trim();
				shouldScope = shouldScope || part2.indexOf(_polyfillHostNoCombinator) > -1;
				const scopedPart = shouldScope ? _scopeSelectorPart(part2) : part2;
				scopedSelector += `${scopedPart} ${separator} `;
				startIndex = sep.lastIndex;
			}
			const part = selector.substring(startIndex);
			shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;
			scopedSelector += shouldScope ? _scopeSelectorPart(part) : part;
			return restoreSafeSelector(safeContent.placeholders, scopedSelector);
		};
		var scopeSelector = (selector, scopeSelectorText, hostSelector, slotSelector) => {
			return selector
				.split(',')
				.map((shallowPart) => {
					if (slotSelector && shallowPart.indexOf('.' + slotSelector) > -1) {
						return shallowPart.trim();
					}
					if (selectorNeedsScoping(shallowPart, scopeSelectorText)) {
						return applyStrictSelectorScope(shallowPart, scopeSelectorText, hostSelector).trim();
					} else {
						return shallowPart.trim();
					}
				})
				.join(', ');
		};
		var scopeSelectors = (cssText, scopeSelectorText, hostSelector, slotSelector, commentOriginalSelector) => {
			return processRules(cssText, (rule) => {
				let selector = rule.selector;
				let content = rule.content;
				if (rule.selector[0] !== '@') {
					selector = scopeSelector(rule.selector, scopeSelectorText, hostSelector, slotSelector);
				} else if (
					rule.selector.startsWith('@media') ||
					rule.selector.startsWith('@supports') ||
					rule.selector.startsWith('@page') ||
					rule.selector.startsWith('@document')
				) {
					content = scopeSelectors(rule.content, scopeSelectorText, hostSelector, slotSelector);
				}
				const cssRule = {
					selector: selector.replace(/\s{2,}/g, ' ').trim(),
					content,
				};
				return cssRule;
			});
		};
		var scopeCssText = (cssText, scopeId2, hostScopeId, slotScopeId, commentOriginalSelector) => {
			cssText = insertPolyfillHostInCssText(cssText);
			cssText = convertColonHost(cssText);
			cssText = convertColonHostContext(cssText);
			const slotted = convertColonSlotted(cssText, slotScopeId);
			cssText = slotted.cssText;
			cssText = convertShadowDOMSelectors(cssText);
			if (scopeId2) {
				cssText = scopeSelectors(cssText, scopeId2, hostScopeId, slotScopeId);
			}
			cssText = replaceShadowCssHost(cssText, hostScopeId);
			cssText = cssText.replace(/>\s*\*\s+([^{, ]+)/gm, ' $1 ');
			return {
				cssText: cssText.trim(),
				// We need to replace the shadow CSS host string in each of these selectors since we created
				// them prior to the replacement happening in the components CSS text.
				slottedSelectors: slotted.selectors.map((ref) => ({
					orgSelector: replaceShadowCssHost(ref.orgSelector, hostScopeId),
					updatedSelector: replaceShadowCssHost(ref.updatedSelector, hostScopeId),
				})),
			};
		};
		var replaceShadowCssHost = (cssText, hostScopeId) => {
			return cssText.replace(/-shadowcsshost-no-combinator/g, `.${hostScopeId}`);
		};
		var scopeCss = (cssText, scopeId2, commentOriginalSelector) => {
			const hostScopeId = scopeId2 + '-h';
			const slotScopeId = scopeId2 + '-s';
			const commentsWithHash = extractCommentsWithHash(cssText);
			cssText = stripComments(cssText);
			const orgSelectors = [];
			{
				const processCommentedSelector = (rule) => {
					const placeholder = `/*!@___${orgSelectors.length}___*/`;
					const comment = `/*!@${rule.selector}*/`;
					orgSelectors.push({ placeholder, comment });
					rule.selector = placeholder + rule.selector;
					return rule;
				};
				cssText = processRules(cssText, (rule) => {
					if (rule.selector[0] !== '@') {
						return processCommentedSelector(rule);
					} else if (
						rule.selector.startsWith('@media') ||
						rule.selector.startsWith('@supports') ||
						rule.selector.startsWith('@page') ||
						rule.selector.startsWith('@document')
					) {
						rule.content = processRules(rule.content, processCommentedSelector);
						return rule;
					}
					return rule;
				});
			}
			const scoped = scopeCssText(cssText, scopeId2, hostScopeId, slotScopeId);
			cssText = [scoped.cssText, ...commentsWithHash].join('\n');
			{
				orgSelectors.forEach(({ placeholder, comment }) => {
					cssText = cssText.replace(placeholder, comment);
				});
			}
			scoped.slottedSelectors.forEach((slottedSelector) => {
				const regex = new RegExp(escapeRegExpSpecialCharacters(slottedSelector.orgSelector), 'g');
				cssText = cssText.replace(regex, slottedSelector.updatedSelector);
			});
			return cssText;
		};

		// src/runtime/mode.ts
		var computeMode = (elm) => modeResolutionChain.map((h2) => h2(elm)).find((m) => !!m);
		var setMode = (handler) => modeResolutionChain.push(handler);
		var parsePropertyValue = (propValue, propType) => {
			if (
				typeof propValue === 'string' &&
				((propValue.startsWith('{') && propValue.endsWith('}')) ||
					(propValue.startsWith('[') && propValue.endsWith(']')))
			) {
				try {
					propValue = JSON.parse(propValue);
					return propValue;
				} catch (e) {}
			}
			if (typeof propValue === 'string' && propValue.startsWith(SERIALIZED_PREFIX)) {
				propValue = deserializeProperty(propValue);
				return propValue;
			}
			if (propValue != null && !isComplexType(propValue)) {
				if (propType & 4 /* Boolean */) {
					return propValue === 'false' ? false : propValue === '' || !!propValue;
				}
				if (propType & 2 /* Number */) {
					return typeof propValue === 'string'
						? parseFloat(propValue)
						: typeof propValue === 'number'
							? propValue
							: NaN;
				}
				if (propType & 1 /* String */) {
					return String(propValue);
				}
				return propValue;
			}
			return propValue;
		};
		var getElement = (ref) => getHostRef(ref).$hostElement$;

		// src/runtime/event-emitter.ts
		var createEvent = (ref, name, flags) => {
			const elm = getElement(ref);
			return {
				emit: (detail) => {
					return emitEvent$1(elm, name, {
						bubbles: true,
						composed: true,
						cancelable: true,
						detail,
					});
				},
			};
		};
		var emitEvent$1 = (elm, name, opts) => {
			const ev = plt.ce(name, opts);
			elm.dispatchEvent(ev);
			return ev;
		};
		var rootAppliedStyles = /* @__PURE__ */ new WeakMap();
		var registerStyle = (scopeId2, cssText, allowCS) => {
			let style = styles.get(scopeId2);
			{
				style = cssText;
			}
			styles.set(scopeId2, style);
		};
		var addStyle = (styleContainerNode, cmpMeta, mode) => {
			var _a;
			const scopeId2 = getScopeId(cmpMeta, mode);
			const style = styles.get(scopeId2);
			if (!win.document) {
				return scopeId2;
			}
			styleContainerNode =
				styleContainerNode.nodeType === 11 /* DocumentFragment */ ? styleContainerNode : win.document;
			if (style) {
				if (typeof style === 'string') {
					styleContainerNode = styleContainerNode.head || styleContainerNode;
					let appliedStyles = rootAppliedStyles.get(styleContainerNode);
					let styleElm;
					if (!appliedStyles) {
						rootAppliedStyles.set(styleContainerNode, (appliedStyles = /* @__PURE__ */ new Set()));
					}
					if (!appliedStyles.has(scopeId2)) {
						if (
							styleContainerNode.host &&
							(styleElm = styleContainerNode.querySelector(`[${HYDRATED_STYLE_ID}="${scopeId2}"]`))
						) {
							styleElm.innerHTML = style;
						} else {
							styleElm =
								document.querySelector(`[${HYDRATED_STYLE_ID}="${scopeId2}"]`) || win.document.createElement('style');
							styleElm.innerHTML = style;
							const nonce = (_a = plt.$nonce$) != null ? _a : queryNonceMetaTagContent(win.document);
							if (nonce != null) {
								styleElm.setAttribute('nonce', nonce);
							}
							if (
								cmpMeta.$flags$ & 2 /* scopedCssEncapsulation */ ||
								cmpMeta.$flags$ & 128 /* shadowNeedsScopedCss */
							) {
								styleElm.setAttribute(HYDRATED_STYLE_ID, scopeId2);
							}
							if (!((cmpMeta.$flags$ & 1) /* shadowDomEncapsulation */)) {
								if (styleContainerNode.nodeName === 'HEAD') {
									const preconnectLinks = styleContainerNode.querySelectorAll('link[rel=preconnect]');
									const referenceNode2 =
										preconnectLinks.length > 0
											? preconnectLinks[preconnectLinks.length - 1].nextSibling
											: styleContainerNode.querySelector('style');
									styleContainerNode.insertBefore(
										styleElm,
										(referenceNode2 == null ? void 0 : referenceNode2.parentNode) === styleContainerNode
											? referenceNode2
											: null,
									);
								} else if ('host' in styleContainerNode) {
									{
										const existingStyleContainer = styleContainerNode.querySelector('style');
										if (existingStyleContainer) {
											existingStyleContainer.innerHTML = style + existingStyleContainer.innerHTML;
										} else {
											styleContainerNode.prepend(styleElm);
										}
									}
								} else {
									styleContainerNode.append(styleElm);
								}
							}
							if (cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {
								styleContainerNode.insertBefore(styleElm, null);
							}
						}
						if (cmpMeta.$flags$ & 4 /* hasSlotRelocation */) {
							styleElm.innerHTML += SLOT_FB_CSS;
						}
						if (appliedStyles) {
							appliedStyles.add(scopeId2);
						}
					}
				}
			}
			return scopeId2;
		};
		var attachStyles = (hostRef) => {
			const cmpMeta = hostRef.$cmpMeta$;
			const elm = hostRef.$hostElement$;
			const flags = cmpMeta.$flags$;
			const endAttachStyles = createTime('attachStyles', cmpMeta.$tagName$);
			const scopeId2 = addStyle(elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, hostRef.$modeName$);
			if (flags & 10 /* needsScopedEncapsulation */) {
				elm['s-sc'] = scopeId2;
				elm.classList.add(scopeId2 + '-h');
			}
			endAttachStyles();
		};
		var getScopeId = (cmp, mode) =>
			'sc-' + (mode && cmp.$flags$ & 32 /* hasMode */ ? cmp.$tagName$ + '-' + mode : cmp.$tagName$);
		var setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags, initialRender) => {
			if (oldValue === newValue) {
				return;
			}
			let isProp = isMemberInElement(elm, memberName);
			let ln = memberName.toLowerCase();
			if (memberName === 'class') {
				const classList = elm.classList;
				const oldClasses = parseClassList(oldValue);
				let newClasses = parseClassList(newValue);
				if (elm['s-si'] && initialRender) {
					newClasses.push(elm['s-si']);
					oldClasses.forEach((c) => {
						if (c.startsWith(elm['s-si'])) newClasses.push(c);
					});
					newClasses = [...new Set(newClasses)];
					classList.add(...newClasses);
				} else {
					classList.remove(...oldClasses.filter((c) => c && !newClasses.includes(c)));
					classList.add(...newClasses.filter((c) => c && !oldClasses.includes(c)));
				}
			} else if (memberName === 'style') {
				{
					for (const prop in oldValue) {
						if (!newValue || newValue[prop] == null) {
							{
								elm.style[prop] = '';
							}
						}
					}
				}
				for (const prop in newValue) {
					if (!oldValue || newValue[prop] !== oldValue[prop]) {
						{
							elm.style[prop] = newValue[prop];
						}
					}
				}
			} else if (memberName === 'key');
			else if (memberName === 'ref') {
				if (newValue) {
					newValue(elm);
				}
			} else if (!isProp && memberName[0] === 'o' && memberName[1] === 'n') {
				if (memberName[2] === '-') {
					memberName = memberName.slice(3);
				} else if (isMemberInElement(win, ln)) {
					memberName = ln.slice(2);
				} else {
					memberName = ln[2] + memberName.slice(3);
				}
				if (oldValue || newValue) {
					const capture = memberName.endsWith(CAPTURE_EVENT_SUFFIX);
					memberName = memberName.replace(CAPTURE_EVENT_REGEX, '');
					if (oldValue) {
						plt.rel(elm, memberName, oldValue, capture);
					}
					if (newValue) {
						plt.ael(elm, memberName, newValue, capture);
					}
				}
			} else {
				const isComplex = isComplexType(newValue);
				if ((isProp || (isComplex && newValue !== null)) && !isSvg) {
					try {
						if (!elm.tagName.includes('-')) {
							const n = newValue == null ? '' : newValue;
							if (memberName === 'list') {
								isProp = false;
							} else if (oldValue == null || elm[memberName] != n) {
								if (typeof elm.__lookupSetter__(memberName) === 'function') {
									elm[memberName] = n;
								} else {
									elm.setAttribute(memberName, n);
								}
							}
						} else if (elm[memberName] !== newValue) {
							elm[memberName] = newValue;
						}
					} catch (e) {}
				}
				let xlink = false;
				{
					if (ln !== (ln = ln.replace(/^xlink\:?/, ''))) {
						memberName = ln;
						xlink = true;
					}
				}
				if (newValue == null || newValue === false) {
					if (newValue !== false || elm.getAttribute(memberName) === '') {
						if (xlink) {
							elm.removeAttributeNS(XLINK_NS, memberName);
						} else {
							elm.removeAttribute(memberName);
						}
					}
				} else if ((!isProp || flags & 4 /* isHost */ || isSvg) && !isComplex && elm.nodeType === 1 /* ElementNode */) {
					newValue = newValue === true ? '' : newValue;
					if (xlink) {
						elm.setAttributeNS(XLINK_NS, memberName, newValue);
					} else {
						elm.setAttribute(memberName, newValue);
					}
				}
			}
		};
		var parseClassListRegex = /\s/;
		var parseClassList = (value) => {
			if (typeof value === 'object' && value && 'baseVal' in value) {
				value = value.baseVal;
			}
			if (!value || typeof value !== 'string') {
				return [];
			}
			return value.split(parseClassListRegex);
		};
		var CAPTURE_EVENT_SUFFIX = 'Capture';
		var CAPTURE_EVENT_REGEX = new RegExp(CAPTURE_EVENT_SUFFIX + '$');

		// src/runtime/vdom/update-element.ts
		var updateElement = (oldVnode, newVnode, isSvgMode2, isInitialRender) => {
			const elm =
				newVnode.$elm$.nodeType === 11 /* DocumentFragment */ && newVnode.$elm$.host
					? newVnode.$elm$.host
					: newVnode.$elm$;
			const oldVnodeAttrs = (oldVnode && oldVnode.$attrs$) || {};
			const newVnodeAttrs = newVnode.$attrs$ || {};
			{
				for (const memberName of sortedAttrNames(Object.keys(oldVnodeAttrs))) {
					if (!(memberName in newVnodeAttrs)) {
						setAccessor(
							elm,
							memberName,
							oldVnodeAttrs[memberName],
							void 0,
							isSvgMode2,
							newVnode.$flags$,
							isInitialRender,
						);
					}
				}
			}
			for (const memberName of sortedAttrNames(Object.keys(newVnodeAttrs))) {
				setAccessor(
					elm,
					memberName,
					oldVnodeAttrs[memberName],
					newVnodeAttrs[memberName],
					isSvgMode2,
					newVnode.$flags$,
					isInitialRender,
				);
			}
		};
		function sortedAttrNames(attrNames) {
			return attrNames.includes('ref')
				? // we need to sort these to ensure that `'ref'` is the last attr
					[...attrNames.filter((attr) => attr !== 'ref'), 'ref']
				: // no need to sort, return the original array
					attrNames;
		}

		// src/runtime/vdom/vdom-render.ts
		var scopeId;
		var contentRef;
		var hostTagName;
		var useNativeShadowDom = false;
		var checkSlotFallbackVisibility = false;
		var checkSlotRelocate = false;
		var isSvgMode = false;
		var createElm = (oldParentVNode, newParentVNode, childIndex) => {
			var _a;
			const newVNode2 = newParentVNode.$children$[childIndex];
			let i2 = 0;
			let elm;
			let childNode;
			let oldVNode;
			if (!useNativeShadowDom) {
				checkSlotRelocate = true;
				if (newVNode2.$tag$ === 'slot') {
					newVNode2.$flags$ |= newVNode2.$children$
						? // slot element has fallback content
							// still create an element that "mocks" the slot element
							2 /* isSlotFallback */
						: // slot element does not have fallback content
							// create an html comment we'll use to always reference
							// where actual slot content should sit next to
							1 /* isSlotReference */;
				}
			}
			if (newVNode2.$text$ !== null) {
				elm = newVNode2.$elm$ = win.document.createTextNode(newVNode2.$text$);
			} else if (newVNode2.$flags$ & 1 /* isSlotReference */) {
				elm = newVNode2.$elm$ = slotReferenceDebugNode(newVNode2);
				{
					updateElement(null, newVNode2, isSvgMode);
				}
			} else {
				if (!isSvgMode) {
					isSvgMode = newVNode2.$tag$ === 'svg';
				}
				if (!win.document) {
					throw new Error(
						"You are trying to render a Stencil component in an environment that doesn't support the DOM. Make sure to populate the [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window/window) object before rendering a component.",
					);
				}
				elm = newVNode2.$elm$ = win.document.createElementNS(
					isSvgMode ? SVG_NS : HTML_NS,
					!useNativeShadowDom && BUILD.slotRelocation && newVNode2.$flags$ & 2 /* isSlotFallback */
						? 'slot-fb'
						: newVNode2.$tag$,
				);
				if (isSvgMode && newVNode2.$tag$ === 'foreignObject') {
					isSvgMode = false;
				}
				{
					updateElement(null, newVNode2, isSvgMode);
				}
				if (isDef(scopeId) && elm['s-si'] !== scopeId) {
					elm.classList.add((elm['s-si'] = scopeId));
				}
				if (newVNode2.$children$) {
					for (i2 = 0; i2 < newVNode2.$children$.length; ++i2) {
						childNode = createElm(oldParentVNode, newVNode2, i2);
						if (childNode) {
							elm.appendChild(childNode);
						}
					}
				}
				{
					if (newVNode2.$tag$ === 'svg') {
						isSvgMode = false;
					} else if (elm.tagName === 'foreignObject') {
						isSvgMode = true;
					}
				}
			}
			elm['s-hn'] = hostTagName;
			{
				if (newVNode2.$flags$ & (2 /* isSlotFallback */ | 1) /* isSlotReference */) {
					elm['s-sr'] = true;
					elm['s-cr'] = contentRef;
					elm['s-sn'] = newVNode2.$name$ || '';
					elm['s-rf'] = (_a = newVNode2.$attrs$) == null ? void 0 : _a.ref;
					patchSlotNode(elm);
					oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];
					if (oldVNode && oldVNode.$tag$ === newVNode2.$tag$ && oldParentVNode.$elm$) {
						{
							putBackInOriginalLocation(oldParentVNode.$elm$, false);
						}
					}
					{
						addRemoveSlotScopedClass(
							contentRef,
							elm,
							newParentVNode.$elm$,
							oldParentVNode == null ? void 0 : oldParentVNode.$elm$,
						);
					}
				}
			}
			return elm;
		};
		var putBackInOriginalLocation = (parentElm, recursive) => {
			plt.$flags$ |= 1 /* isTmpDisconnected */;
			const oldSlotChildNodes = Array.from(parentElm.__childNodes || parentElm.childNodes);
			for (let i2 = oldSlotChildNodes.length - 1; i2 >= 0; i2--) {
				const childNode = oldSlotChildNodes[i2];
				if (childNode['s-hn'] !== hostTagName && childNode['s-ol']) {
					insertBefore(referenceNode(childNode).parentNode, childNode, referenceNode(childNode));
					childNode['s-ol'].remove();
					childNode['s-ol'] = void 0;
					childNode['s-sh'] = void 0;
					checkSlotRelocate = true;
				}
				if (recursive) {
					putBackInOriginalLocation(childNode, recursive);
				}
			}
			plt.$flags$ &= -2 /* isTmpDisconnected */;
		};
		var addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {
			let containerElm = (parentElm['s-cr'] && parentElm['s-cr'].parentNode) || parentElm;
			let childNode;
			if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {
				containerElm = containerElm.shadowRoot;
			}
			for (; startIdx <= endIdx; ++startIdx) {
				if (vnodes[startIdx]) {
					childNode = createElm(null, parentVNode, startIdx);
					if (childNode) {
						vnodes[startIdx].$elm$ = childNode;
						insertBefore(containerElm, childNode, referenceNode(before));
					}
				}
			}
		};
		var removeVnodes = (vnodes, startIdx, endIdx) => {
			for (let index = startIdx; index <= endIdx; ++index) {
				const vnode = vnodes[index];
				if (vnode) {
					const elm = vnode.$elm$;
					nullifyVNodeRefs(vnode);
					if (elm) {
						{
							checkSlotFallbackVisibility = true;
							if (elm['s-ol']) {
								elm['s-ol'].remove();
							} else {
								putBackInOriginalLocation(elm, true);
							}
						}
						elm.remove();
					}
				}
			}
		};
		var updateChildren = (parentElm, oldCh, newVNode2, newCh, isInitialRender = false) => {
			let oldStartIdx = 0;
			let newStartIdx = 0;
			let idxInOld = 0;
			let i2 = 0;
			let oldEndIdx = oldCh.length - 1;
			let oldStartVnode = oldCh[0];
			let oldEndVnode = oldCh[oldEndIdx];
			let newEndIdx = newCh.length - 1;
			let newStartVnode = newCh[0];
			let newEndVnode = newCh[newEndIdx];
			let node;
			let elmToMove;
			while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
				if (oldStartVnode == null) {
					oldStartVnode = oldCh[++oldStartIdx];
				} else if (oldEndVnode == null) {
					oldEndVnode = oldCh[--oldEndIdx];
				} else if (newStartVnode == null) {
					newStartVnode = newCh[++newStartIdx];
				} else if (newEndVnode == null) {
					newEndVnode = newCh[--newEndIdx];
				} else if (isSameVnode(oldStartVnode, newStartVnode, isInitialRender)) {
					patch(oldStartVnode, newStartVnode, isInitialRender);
					oldStartVnode = oldCh[++oldStartIdx];
					newStartVnode = newCh[++newStartIdx];
				} else if (isSameVnode(oldEndVnode, newEndVnode, isInitialRender)) {
					patch(oldEndVnode, newEndVnode, isInitialRender);
					oldEndVnode = oldCh[--oldEndIdx];
					newEndVnode = newCh[--newEndIdx];
				} else if (isSameVnode(oldStartVnode, newEndVnode, isInitialRender)) {
					if (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot') {
						putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);
					}
					patch(oldStartVnode, newEndVnode, isInitialRender);
					insertBefore(parentElm, oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
					oldStartVnode = oldCh[++oldStartIdx];
					newEndVnode = newCh[--newEndIdx];
				} else if (isSameVnode(oldEndVnode, newStartVnode, isInitialRender)) {
					if (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot') {
						putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);
					}
					patch(oldEndVnode, newStartVnode, isInitialRender);
					insertBefore(parentElm, oldEndVnode.$elm$, oldStartVnode.$elm$);
					oldEndVnode = oldCh[--oldEndIdx];
					newStartVnode = newCh[++newStartIdx];
				} else {
					idxInOld = -1;
					{
						for (i2 = oldStartIdx; i2 <= oldEndIdx; ++i2) {
							if (oldCh[i2] && oldCh[i2].$key$ !== null && oldCh[i2].$key$ === newStartVnode.$key$) {
								idxInOld = i2;
								break;
							}
						}
					}
					if (idxInOld >= 0) {
						elmToMove = oldCh[idxInOld];
						if (elmToMove.$tag$ !== newStartVnode.$tag$) {
							node = createElm(oldCh && oldCh[newStartIdx], newVNode2, idxInOld);
						} else {
							patch(elmToMove, newStartVnode, isInitialRender);
							oldCh[idxInOld] = void 0;
							node = elmToMove.$elm$;
						}
						newStartVnode = newCh[++newStartIdx];
					} else {
						node = createElm(oldCh && oldCh[newStartIdx], newVNode2, newStartIdx);
						newStartVnode = newCh[++newStartIdx];
					}
					if (node) {
						{
							insertBefore(referenceNode(oldStartVnode.$elm$).parentNode, node, referenceNode(oldStartVnode.$elm$));
						}
					}
				}
			}
			if (oldStartIdx > oldEndIdx) {
				addVnodes(
					parentElm,
					newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$,
					newVNode2,
					newCh,
					newStartIdx,
					newEndIdx,
				);
			} else if (newStartIdx > newEndIdx) {
				removeVnodes(oldCh, oldStartIdx, oldEndIdx);
			}
		};
		var isSameVnode = (leftVNode, rightVNode, isInitialRender = false) => {
			if (leftVNode.$tag$ === rightVNode.$tag$) {
				if (leftVNode.$tag$ === 'slot') {
					return leftVNode.$name$ === rightVNode.$name$;
				}
				if (!isInitialRender) {
					return leftVNode.$key$ === rightVNode.$key$;
				}
				if (isInitialRender && !leftVNode.$key$ && rightVNode.$key$) {
					leftVNode.$key$ = rightVNode.$key$;
				}
				return true;
			}
			return false;
		};
		var referenceNode = (node) => (node && node['s-ol']) || node;
		var patch = (oldVNode, newVNode2, isInitialRender = false) => {
			const elm = (newVNode2.$elm$ = oldVNode.$elm$);
			const oldChildren = oldVNode.$children$;
			const newChildren = newVNode2.$children$;
			const tag = newVNode2.$tag$;
			const text = newVNode2.$text$;
			let defaultHolder;
			if (text === null) {
				{
					isSvgMode = tag === 'svg' ? true : tag === 'foreignObject' ? false : isSvgMode;
				}
				{
					updateElement(oldVNode, newVNode2, isSvgMode, isInitialRender);
				}
				if (oldChildren !== null && newChildren !== null) {
					updateChildren(elm, oldChildren, newVNode2, newChildren, isInitialRender);
				} else if (newChildren !== null) {
					if (oldVNode.$text$ !== null) {
						elm.textContent = '';
					}
					addVnodes(elm, null, newVNode2, newChildren, 0, newChildren.length - 1);
				} else if (
					// don't do this on initial render as it can cause non-hydrated content to be removed
					!isInitialRender &&
					BUILD.updatable &&
					oldChildren !== null
				) {
					removeVnodes(oldChildren, 0, oldChildren.length - 1);
				}
				if (isSvgMode && tag === 'svg') {
					isSvgMode = false;
				}
			} else if ((defaultHolder = elm['s-cr'])) {
				defaultHolder.parentNode.textContent = text;
			} else if (oldVNode.$text$ !== text) {
				elm.data = text;
			}
		};
		var relocateNodes = [];
		var markSlotContentForRelocation = (elm) => {
			let node;
			let hostContentNodes;
			let j;
			const children = elm.__childNodes || elm.childNodes;
			for (const childNode of children) {
				if (childNode['s-sr'] && (node = childNode['s-cr']) && node.parentNode) {
					hostContentNodes = node.parentNode.__childNodes || node.parentNode.childNodes;
					const slotName = childNode['s-sn'];
					for (j = hostContentNodes.length - 1; j >= 0; j--) {
						node = hostContentNodes[j];
						if (!node['s-cn'] && !node['s-nr'] && node['s-hn'] !== childNode['s-hn'] && true) {
							if (isNodeLocatedInSlot(node, slotName)) {
								let relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);
								checkSlotFallbackVisibility = true;
								node['s-sn'] = node['s-sn'] || slotName;
								if (relocateNodeData) {
									relocateNodeData.$nodeToRelocate$['s-sh'] = childNode['s-hn'];
									relocateNodeData.$slotRefNode$ = childNode;
								} else {
									node['s-sh'] = childNode['s-hn'];
									relocateNodes.push({
										$slotRefNode$: childNode,
										$nodeToRelocate$: node,
									});
								}
								if (node['s-sr']) {
									relocateNodes.map((relocateNode) => {
										if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node['s-sn'])) {
											relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);
											if (relocateNodeData && !relocateNode.$slotRefNode$) {
												relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;
											}
										}
									});
								}
							} else if (!relocateNodes.some((r) => r.$nodeToRelocate$ === node)) {
								relocateNodes.push({
									$nodeToRelocate$: node,
								});
							}
						}
					}
				}
				if (childNode.nodeType === 1 /* ElementNode */) {
					markSlotContentForRelocation(childNode);
				}
			}
		};
		var nullifyVNodeRefs = (vNode) => {
			{
				vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
				vNode.$children$ && vNode.$children$.map(nullifyVNodeRefs);
			}
		};
		var insertBefore = (parent, newNode, reference) => {
			{
				return parent == null ? void 0 : parent.insertBefore(newNode, reference);
			}
		};
		function addRemoveSlotScopedClass(reference, slotNode, newParent, oldParent) {
			var _a, _b;
			let scopeId2;
			if (
				reference &&
				typeof slotNode['s-sn'] === 'string' &&
				!!slotNode['s-sr'] &&
				reference.parentNode &&
				reference.parentNode['s-sc'] &&
				(scopeId2 = slotNode['s-si'] || reference.parentNode['s-sc'])
			) {
				const scopeName = slotNode['s-sn'];
				const hostName = slotNode['s-hn'];
				(_a = newParent.classList) == null ? void 0 : _a.add(scopeId2 + '-s');
				if (oldParent && ((_b = oldParent.classList) == null ? void 0 : _b.contains(scopeId2 + '-s'))) {
					let child = (oldParent.__childNodes || oldParent.childNodes)[0];
					let found = false;
					while (child) {
						if (child['s-sn'] !== scopeName && child['s-hn'] === hostName && !!child['s-sr']) {
							found = true;
							break;
						}
						child = child.nextSibling;
					}
					if (!found) oldParent.classList.remove(scopeId2 + '-s');
				}
			}
		}
		var renderVdom = (hostRef, renderFnResults, isInitialLoad = false) => {
			var _c, _d;
			const hostElm = hostRef.$hostElement$;
			const cmpMeta = hostRef.$cmpMeta$;
			const oldVNode = hostRef.$vnode$ || newVNode(null, null);
			const isHostElement = isHost(renderFnResults);
			const rootVnode = isHostElement ? renderFnResults : h(null, null, renderFnResults);
			hostTagName = hostElm.tagName;
			if (isInitialLoad && rootVnode.$attrs$) {
				for (const key of Object.keys(rootVnode.$attrs$)) {
					if (hostElm.hasAttribute(key) && !['key', 'ref', 'style', 'class'].includes(key)) {
						rootVnode.$attrs$[key] = hostElm[key];
					}
				}
			}
			rootVnode.$tag$ = null;
			rootVnode.$flags$ |= 4 /* isHost */;
			hostRef.$vnode$ = rootVnode;
			rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm;
			{
				scopeId = hostElm['s-sc'];
			}
			useNativeShadowDom =
				!!((cmpMeta.$flags$ & 1) /* shadowDomEncapsulation */) && !((cmpMeta.$flags$ & 128) /* shadowNeedsScopedCss */);
			{
				contentRef = hostElm['s-cr'];
				checkSlotFallbackVisibility = false;
			}
			patch(oldVNode, rootVnode, isInitialLoad);
			{
				plt.$flags$ |= 1 /* isTmpDisconnected */;
				if (checkSlotRelocate) {
					markSlotContentForRelocation(rootVnode.$elm$);
					for (const relocateData of relocateNodes) {
						const nodeToRelocate = relocateData.$nodeToRelocate$;
						if (!nodeToRelocate['s-ol'] && win.document) {
							const orgLocationNode = originalLocationDebugNode(nodeToRelocate);
							orgLocationNode['s-nr'] = nodeToRelocate;
							insertBefore(nodeToRelocate.parentNode, (nodeToRelocate['s-ol'] = orgLocationNode), nodeToRelocate);
						}
					}
					for (const relocateData of relocateNodes) {
						const nodeToRelocate = relocateData.$nodeToRelocate$;
						const slotRefNode = relocateData.$slotRefNode$;
						if (slotRefNode) {
							const parentNodeRef = slotRefNode.parentNode;
							let insertBeforeNode = slotRefNode.nextSibling;
							const parent = nodeToRelocate.__parentNode || nodeToRelocate.parentNode;
							const nextSibling = nodeToRelocate.__nextSibling || nodeToRelocate.nextSibling;
							if ((!insertBeforeNode && parentNodeRef !== parent) || nextSibling !== insertBeforeNode) {
								if (nodeToRelocate !== insertBeforeNode) {
									if (!nodeToRelocate['s-hn'] && nodeToRelocate['s-ol']) {
										nodeToRelocate['s-hn'] = nodeToRelocate['s-ol'].parentNode.nodeName;
									}
									insertBefore(parentNodeRef, nodeToRelocate, insertBeforeNode);
									if (nodeToRelocate.nodeType === 1 /* ElementNode */ && nodeToRelocate.tagName !== 'SLOT-FB') {
										nodeToRelocate.hidden = (_c = nodeToRelocate['s-ih']) != null ? _c : false;
									}
								}
							}
							nodeToRelocate && typeof slotRefNode['s-rf'] === 'function' && slotRefNode['s-rf'](slotRefNode);
						} else {
							if (nodeToRelocate.nodeType === 1 /* ElementNode */) {
								if (isInitialLoad) {
									nodeToRelocate['s-ih'] = (_d = nodeToRelocate.hidden) != null ? _d : false;
								}
								nodeToRelocate.hidden = true;
							}
						}
					}
				}
				if (checkSlotFallbackVisibility) {
					updateFallbackSlotVisibility(rootVnode.$elm$);
				}
				plt.$flags$ &= -2 /* isTmpDisconnected */;
				relocateNodes.length = 0;
			}
			contentRef = void 0;
		};
		var slotReferenceDebugNode = (slotVNode) => {
			var _a;
			return (_a = win.document) == null
				? void 0
				: _a.createComment(
						`<slot${slotVNode.$name$ ? ' name="' + slotVNode.$name$ + '"' : ''}> (host=${hostTagName.toLowerCase()})`,
					);
		};
		var originalLocationDebugNode = (nodeToRelocate) => {
			var _a;
			return (_a = win.document) == null
				? void 0
				: _a.createComment(
						`org-location for ` +
							(nodeToRelocate.localName
								? `<${nodeToRelocate.localName}> (host=${nodeToRelocate['s-hn']})`
								: `[${nodeToRelocate.textContent}]`),
					);
		};

		// src/runtime/update-component.ts
		var attachToAncestor = (hostRef, ancestorComponent) => {
			if (ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent['s-p']) {
				const index = ancestorComponent['s-p'].push(
					new Promise(
						(r) =>
							(hostRef.$onRenderResolve$ = () => {
								ancestorComponent['s-p'].splice(index - 1, 1);
								r();
							}),
					),
				);
			}
		};
		var scheduleUpdate = (hostRef, isInitialLoad) => {
			{
				hostRef.$flags$ |= 16 /* isQueuedForUpdate */;
			}
			if (hostRef.$flags$ & 4 /* isWaitingForChildren */) {
				hostRef.$flags$ |= 512 /* needsRerender */;
				return;
			}
			attachToAncestor(hostRef, hostRef.$ancestorComponent$);
			const dispatch = () => dispatchHooks(hostRef, isInitialLoad);
			return writeTask(dispatch);
		};
		var dispatchHooks = (hostRef, isInitialLoad) => {
			const elm = hostRef.$hostElement$;
			const endSchedule = createTime('scheduleUpdate', hostRef.$cmpMeta$.$tagName$);
			const instance = hostRef.$lazyInstance$;
			if (!instance) {
				throw new Error(
					`Can't render component <${elm.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \`externalRuntime: true\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`,
				);
			}
			let maybePromise;
			if (isInitialLoad) {
				{
					hostRef.$flags$ |= 256 /* isListenReady */;
					if (hostRef.$queuedListeners$) {
						hostRef.$queuedListeners$.map(([methodName, event]) => safeCall(instance, methodName, event, elm));
						hostRef.$queuedListeners$ = void 0;
					}
				}
				maybePromise = safeCall(instance, 'componentWillLoad', void 0, elm);
			} else {
				maybePromise = safeCall(instance, 'componentWillUpdate', void 0, elm);
			}
			maybePromise = enqueue(maybePromise, () => safeCall(instance, 'componentWillRender', void 0, elm));
			endSchedule();
			return enqueue(maybePromise, () => updateComponent(hostRef, instance, isInitialLoad));
		};
		var enqueue = (maybePromise, fn) =>
			isPromisey(maybePromise)
				? maybePromise.then(fn).catch((err2) => {
						console.error(err2);
						fn();
					})
				: fn();
		var isPromisey = (maybePromise) =>
			maybePromise instanceof Promise || (maybePromise && maybePromise.then && typeof maybePromise.then === 'function');
		var updateComponent = async (hostRef, instance, isInitialLoad) => {
			var _a;
			const elm = hostRef.$hostElement$;
			const endUpdate = createTime('update', hostRef.$cmpMeta$.$tagName$);
			const rc = elm['s-rc'];
			if (isInitialLoad) {
				attachStyles(hostRef);
			}
			const endRender = createTime('render', hostRef.$cmpMeta$.$tagName$);
			{
				await callRender(hostRef, instance, elm, isInitialLoad);
			}
			{
				try {
					serverSideConnected(elm);
					if (isInitialLoad) {
						if (hostRef.$cmpMeta$.$flags$ & 1 /* shadowDomEncapsulation */) {
							elm['s-en'] = '';
						} else if (hostRef.$cmpMeta$.$flags$ & 2 /* scopedCssEncapsulation */) {
							elm['s-en'] = 'c';
						}
					}
				} catch (e) {
					consoleError(e, elm);
				}
			}
			if (rc) {
				rc.map((cb) => cb());
				elm['s-rc'] = void 0;
			}
			endRender();
			endUpdate();
			{
				const childrenPromises = (_a = elm['s-p']) != null ? _a : [];
				const postUpdate = () => postUpdateComponent(hostRef);
				if (childrenPromises.length === 0) {
					postUpdate();
				} else {
					Promise.all(childrenPromises).then(postUpdate);
					hostRef.$flags$ |= 4 /* isWaitingForChildren */;
					childrenPromises.length = 0;
				}
			}
		};
		var callRender = (hostRef, instance, elm, isInitialLoad) => {
			try {
				instance = instance.render();
				{
					hostRef.$flags$ &= -17 /* isQueuedForUpdate */;
				}
				{
					hostRef.$flags$ |= 2 /* hasRendered */;
				}
				{
					{
						{
							return Promise.resolve(instance).then((value) => renderVdom(hostRef, value, isInitialLoad));
						}
					}
				}
			} catch (e) {
				consoleError(e, hostRef.$hostElement$);
			}
			return null;
		};
		var postUpdateComponent = (hostRef) => {
			const tagName = hostRef.$cmpMeta$.$tagName$;
			const elm = hostRef.$hostElement$;
			const endPostUpdate = createTime('postUpdate', tagName);
			const instance = hostRef.$lazyInstance$;
			const ancestorComponent = hostRef.$ancestorComponent$;
			safeCall(instance, 'componentDidRender', void 0, elm);
			if (!((hostRef.$flags$ & 64) /* hasLoadedComponent */)) {
				hostRef.$flags$ |= 64 /* hasLoadedComponent */;
				{
					addHydratedFlag(elm);
				}
				safeCall(instance, 'componentDidLoad', void 0, elm);
				endPostUpdate();
				{
					hostRef.$onReadyResolve$(elm);
					if (!ancestorComponent) {
						appDidLoad();
					}
				}
			} else {
				safeCall(instance, 'componentDidUpdate', void 0, elm);
				endPostUpdate();
			}
			{
				hostRef.$onInstanceResolve$(elm);
			}
			{
				if (hostRef.$onRenderResolve$) {
					hostRef.$onRenderResolve$();
					hostRef.$onRenderResolve$ = void 0;
				}
				if (hostRef.$flags$ & 512 /* needsRerender */) {
					nextTick(() => scheduleUpdate(hostRef, false));
				}
				hostRef.$flags$ &= -517;
			}
		};
		var appDidLoad = (who) => {
			if (BUILD.asyncQueue) {
				plt.$flags$ |= 2 /* appLoaded */;
			}
			nextTick(() => emitEvent$1(win, 'appload', { detail: { namespace: NAMESPACE } }));
		};
		var safeCall = (instance, method, arg, elm) => {
			if (instance && instance[method]) {
				try {
					return instance[method](arg);
				} catch (e) {
					consoleError(e, elm);
				}
			}
			return void 0;
		};
		var addHydratedFlag = (elm) => {
			var _a;
			return elm.classList.add((_a = BUILD.hydratedSelectorName) != null ? _a : 'hydrated');
		};
		var serverSideConnected = (elm) => {
			const children = elm.children;
			if (children != null) {
				for (let i2 = 0, ii = children.length; i2 < ii; i2++) {
					const childElm = children[i2];
					if (typeof childElm.connectedCallback === 'function') {
						childElm.connectedCallback();
					}
					serverSideConnected(childElm);
				}
			}
		};

		// src/runtime/set-value.ts
		var getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);
		var setValue = (ref, propName, newVal, cmpMeta) => {
			const hostRef = getHostRef(ref);
			if (!hostRef) {
				throw new Error(
					`Couldn't find host element for "${cmpMeta.$tagName$}" as it is unknown to this Stencil runtime. This usually happens when integrating a 3rd party Stencil component with another Stencil component or application. Please reach out to the maintainers of the 3rd party Stencil component or report this on the Stencil Discord server (https://chat.stenciljs.com) or comment on this similar [GitHub issue](https://github.com/stenciljs/core/issues/5457).`,
				);
			}
			const elm = hostRef.$hostElement$;
			const oldVal = hostRef.$instanceValues$.get(propName);
			const flags = hostRef.$flags$;
			const instance = hostRef.$lazyInstance$;
			newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);
			const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);
			const didValueChange = newVal !== oldVal && !areBothNaN;
			if ((!((flags & 8) /* isConstructingInstance */) || oldVal === void 0) && didValueChange) {
				hostRef.$instanceValues$.set(propName, newVal);
				if (instance) {
					if (cmpMeta.$watchers$ && flags & 128 /* isWatchReady */) {
						const watchMethods = cmpMeta.$watchers$[propName];
						if (watchMethods) {
							watchMethods.map((watchMethodName) => {
								try {
									instance[watchMethodName](newVal, oldVal, propName);
								} catch (e) {
									consoleError(e, elm);
								}
							});
						}
					}
					if ((flags & (2 /* hasRendered */ | 16)) /* isQueuedForUpdate */ === 2 /* hasRendered */) {
						if (instance.componentShouldUpdate) {
							if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {
								return;
							}
						}
						scheduleUpdate(hostRef, false);
					}
				}
			}
		};

		// src/runtime/proxy-component.ts
		var proxyComponent = (Cstr, cmpMeta, flags) => {
			var _a;
			const prototype = Cstr.prototype;
			if (cmpMeta.$members$ || cmpMeta.$watchers$ || Cstr.watchers) {
				if (Cstr.watchers && !cmpMeta.$watchers$) {
					cmpMeta.$watchers$ = Cstr.watchers;
				}
				const members = Object.entries((_a = cmpMeta.$members$) != null ? _a : {});
				members.map(([memberName, [memberFlags]]) => {
					if (memberFlags & 31 /* Prop */ || memberFlags & 32 /* State */) {
						const { get: origGetter, set: origSetter } = Object.getOwnPropertyDescriptor(prototype, memberName) || {};
						if (origGetter) cmpMeta.$members$[memberName][0] |= 2048 /* Getter */;
						if (origSetter) cmpMeta.$members$[memberName][0] |= 4096 /* Setter */;
						if (!origGetter) {
							Object.defineProperty(prototype, memberName, {
								get() {
									{
										if ((cmpMeta.$members$[memberName][0] & 2048) /* Getter */ === 0) {
											return getValue(this, memberName);
										}
										const ref = getHostRef(this);
										const instance = ref ? ref.$lazyInstance$ : prototype;
										if (!instance) return;
										return instance[memberName];
									}
								},
								configurable: true,
								enumerable: true,
							});
						}
						Object.defineProperty(prototype, memberName, {
							set(newValue) {
								const ref = getHostRef(this);
								if (origSetter) {
									const currentValue = memberFlags & 32 /* State */ ? this[memberName] : ref.$hostElement$[memberName];
									if (typeof currentValue === 'undefined' && ref.$instanceValues$.get(memberName)) {
										newValue = ref.$instanceValues$.get(memberName);
									} else if (!ref.$instanceValues$.get(memberName) && currentValue) {
										ref.$instanceValues$.set(memberName, currentValue);
									}
									origSetter.apply(this, [parsePropertyValue(newValue, memberFlags)]);
									newValue = memberFlags & 32 /* State */ ? this[memberName] : ref.$hostElement$[memberName];
									setValue(this, memberName, newValue, cmpMeta);
									return;
								}
								{
									{
										setValue(this, memberName, newValue, cmpMeta);
										return;
									}
								}
							},
						});
					}
				});
			}
			return Cstr;
		};

		// src/runtime/initialize-component.ts
		var initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId) => {
			let Cstr;
			if ((hostRef.$flags$ & 32) /* hasInitializedComponent */ === 0) {
				hostRef.$flags$ |= 32 /* hasInitializedComponent */;
				const bundleId = cmpMeta.$lazyBundleId$;
				if (bundleId) {
					const CstrImport = loadModule(cmpMeta);
					if (CstrImport && 'then' in CstrImport) {
						const endLoad = uniqueTime();
						Cstr = await CstrImport;
						endLoad();
					} else {
						Cstr = CstrImport;
					}
					if (!Cstr) {
						throw new Error(`Constructor for "${cmpMeta.$tagName$}#${hostRef.$modeName$}" was not found`);
					}
					if (!Cstr.isProxied) {
						{
							cmpMeta.$watchers$ = Cstr.watchers;
						}
						proxyComponent(Cstr, cmpMeta);
						Cstr.isProxied = true;
					}
					const endNewInstance = createTime('createInstance', cmpMeta.$tagName$);
					{
						hostRef.$flags$ |= 8 /* isConstructingInstance */;
					}
					try {
						new Cstr(hostRef);
					} catch (e) {
						consoleError(e, elm);
					}
					{
						hostRef.$flags$ &= -9 /* isConstructingInstance */;
					}
					{
						hostRef.$flags$ |= 128 /* isWatchReady */;
					}
					endNewInstance();
					fireConnectedCallback(hostRef.$lazyInstance$, elm);
				} else {
					Cstr = elm.constructor;
					const cmpTag = elm.localName;
					customElements.whenDefined(cmpTag).then(() => (hostRef.$flags$ |= 128) /* isWatchReady */);
				}
				if (Cstr && Cstr.style) {
					let style;
					if (typeof Cstr.style === 'string') {
						style = Cstr.style;
					} else if (typeof Cstr.style !== 'string') {
						hostRef.$modeName$ = computeMode(elm);
						if (hostRef.$modeName$) {
							style = Cstr.style[hostRef.$modeName$];
						}
						if (hostRef.$modeName$) {
							elm.setAttribute('s-mode', hostRef.$modeName$);
						}
					}
					const scopeId2 = getScopeId(cmpMeta, hostRef.$modeName$);
					if (!styles.has(scopeId2)) {
						const endRegisterStyles = createTime('registerStyles', cmpMeta.$tagName$);
						if (cmpMeta.$flags$ & 128 /* shadowNeedsScopedCss */) {
							style = scopeCss(style, scopeId2);
						}
						registerStyle(scopeId2, style);
						endRegisterStyles();
					}
				}
			}
			const ancestorComponent = hostRef.$ancestorComponent$;
			const schedule = () => scheduleUpdate(hostRef, true);
			if (ancestorComponent && ancestorComponent['s-rc']) {
				ancestorComponent['s-rc'].push(schedule);
			} else {
				schedule();
			}
		};
		var fireConnectedCallback = (instance, elm) => {
			{
				safeCall(instance, 'connectedCallback', void 0, elm);
			}
		};

		// src/runtime/connected-callback.ts
		var connectedCallback = (elm) => {
			if ((plt.$flags$ & 1) /* isTmpDisconnected */ === 0) {
				const hostRef = getHostRef(elm);
				const cmpMeta = hostRef.$cmpMeta$;
				const endConnected = createTime('connectedCallback', cmpMeta.$tagName$);
				if (!((hostRef.$flags$ & 1) /* hasConnected */)) {
					hostRef.$flags$ |= 1 /* hasConnected */;
					let hostId;
					{
						hostId = elm.getAttribute(HYDRATE_ID);
						if (hostId) {
							if (cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {
								const scopeId2 = addStyle(elm.shadowRoot, cmpMeta, elm.getAttribute('s-mode'));
								elm.classList.remove(scopeId2 + '-h', scopeId2 + '-s');
							}
							initializeClientHydrate(elm, cmpMeta.$tagName$, hostId, hostRef);
						}
					}
					if (!hostId) {
						{
							setContentReference(elm);
						}
					}
					{
						let ancestorComponent = elm;
						while ((ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host)) {
							if (
								(ancestorComponent.nodeType === 1 /* ElementNode */ &&
									ancestorComponent.hasAttribute('s-id') &&
									ancestorComponent['s-p']) ||
								ancestorComponent['s-p']
							) {
								attachToAncestor(hostRef, (hostRef.$ancestorComponent$ = ancestorComponent));
								break;
							}
						}
					}
					if (BUILD.initializeNextTick) {
						nextTick(() => initializeComponent(elm, hostRef, cmpMeta));
					} else {
						initializeComponent(elm, hostRef, cmpMeta);
					}
				} else {
					addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);
					if (hostRef == null ? void 0 : hostRef.$lazyInstance$) {
						fireConnectedCallback(hostRef.$lazyInstance$, elm);
					} else if (hostRef == null ? void 0 : hostRef.$onReadyPromise$) {
						hostRef.$onReadyPromise$.then(() => fireConnectedCallback(hostRef.$lazyInstance$, elm));
					}
				}
				endConnected();
			}
		};
		var setContentReference = (elm) => {
			if (!win.document) {
				return;
			}
			const contentRefElm = (elm['s-cr'] = win.document.createComment(''));
			contentRefElm['s-cn'] = true;
			insertBefore(elm, contentRefElm, elm.firstChild);
		};

		// src/runtime/fragment.ts
		var Fragment = (_, children) => children;
		var addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {
			if (listeners && win.document) {
				listeners.map(([flags, name, method]) => {
					const target = getHostListenerTarget(win.document, elm, flags);
					const handler = hostListenerProxy(hostRef, method);
					const opts = hostListenerOpts(flags);
					plt.ael(target, name, handler, opts);
					(hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));
				});
			}
		};
		var hostListenerProxy = (hostRef, methodName) => (ev) => {
			var _a;
			try {
				{
					if (hostRef.$flags$ & 256 /* isListenReady */) {
						(_a = hostRef.$lazyInstance$) == null ? void 0 : _a[methodName](ev);
					} else {
						(hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);
					}
				}
			} catch (e) {
				consoleError(e, hostRef.$hostElement$);
			}
		};
		var getHostListenerTarget = (doc, elm, flags) => {
			if (flags & 8 /* TargetWindow */) {
				return win;
			}
			return elm;
		};
		var hostListenerOpts = (flags) => (flags & 2) /* Capture */ !== 0;

		// src/runtime/vdom/vdom-annotations.ts
		var insertVdomAnnotations = (doc, staticComponents) => {
			if (doc != null) {
				const docData = STENCIL_DOC_DATA in doc ? doc[STENCIL_DOC_DATA] : { ...DEFAULT_DOC_DATA };
				docData.staticComponents = new Set(staticComponents);
				const orgLocationNodes = [];
				parseVNodeAnnotations(doc, doc.body, docData, orgLocationNodes);
				orgLocationNodes.forEach((orgLocationNode) => {
					var _a;
					if (orgLocationNode != null && orgLocationNode['s-nr']) {
						const nodeRef = orgLocationNode['s-nr'];
						let hostId = nodeRef['s-host-id'];
						let nodeId = nodeRef['s-node-id'];
						let childId = `${hostId}.${nodeId}`;
						if (hostId == null) {
							hostId = 0;
							docData.rootLevelIds++;
							nodeId = docData.rootLevelIds;
							childId = `${hostId}.${nodeId}`;
							if (nodeRef.nodeType === 1 /* ElementNode */) {
								nodeRef.setAttribute(HYDRATE_CHILD_ID, childId);
								if (typeof nodeRef['s-sn'] === 'string' && !nodeRef.getAttribute('slot')) {
									nodeRef.setAttribute('s-sn', nodeRef['s-sn']);
								}
							} else if (nodeRef.nodeType === 3 /* TextNode */) {
								if (hostId === 0) {
									const textContent = (_a = nodeRef.nodeValue) == null ? void 0 : _a.trim();
									if (textContent === '') {
										orgLocationNode.remove();
										return;
									}
								}
								const commentBeforeTextNode = doc.createComment(childId);
								commentBeforeTextNode.nodeValue = `${TEXT_NODE_ID}.${childId}`;
								insertBefore(nodeRef.parentNode, commentBeforeTextNode, nodeRef);
							} else if (nodeRef.nodeType === 8 /* CommentNode */) {
								const commentBeforeTextNode = doc.createComment(childId);
								commentBeforeTextNode.nodeValue = `${COMMENT_NODE_ID}.${childId}`;
								nodeRef.parentNode.insertBefore(commentBeforeTextNode, nodeRef);
							}
						}
						let orgLocationNodeId = `${ORG_LOCATION_ID}.${childId}`;
						const orgLocationParentNode = orgLocationNode.parentElement;
						if (orgLocationParentNode) {
							if (orgLocationParentNode['s-en'] === '') {
								orgLocationNodeId += `.`;
							} else if (orgLocationParentNode['s-en'] === 'c') {
								orgLocationNodeId += `.c`;
							}
						}
						orgLocationNode.nodeValue = orgLocationNodeId;
					}
				});
			}
		};
		var parseVNodeAnnotations = (doc, node, docData, orgLocationNodes) => {
			var _a;
			if (node == null) {
				return;
			}
			if (node['s-nr'] != null) {
				orgLocationNodes.push(node);
			}
			if (node.nodeType === 1 /* ElementNode */) {
				const childNodes = [
					...Array.from(node.childNodes),
					...Array.from(((_a = node.shadowRoot) == null ? void 0 : _a.childNodes) || []),
				];
				childNodes.forEach((childNode) => {
					const hostRef = getHostRef(childNode);
					if (hostRef != null && !docData.staticComponents.has(childNode.nodeName.toLowerCase())) {
						const cmpData = {
							nodeIds: 0,
						};
						insertVNodeAnnotations(doc, childNode, hostRef.$vnode$, docData, cmpData);
					}
					parseVNodeAnnotations(doc, childNode, docData, orgLocationNodes);
				});
			}
		};
		var insertVNodeAnnotations = (doc, hostElm, vnode, docData, cmpData) => {
			if (vnode != null) {
				const hostId = ++docData.hostIds;
				hostElm.setAttribute(HYDRATE_ID, hostId);
				if (hostElm['s-cr'] != null) {
					hostElm['s-cr'].nodeValue = `${CONTENT_REF_ID}.${hostId}`;
				}
				if (vnode.$children$ != null) {
					const depth = 0;
					vnode.$children$.forEach((vnodeChild, index) => {
						insertChildVNodeAnnotations(doc, vnodeChild, cmpData, hostId, depth, index);
					});
				}
				if (hostElm && vnode && vnode.$elm$ && !hostElm.hasAttribute(HYDRATE_CHILD_ID)) {
					const parent = hostElm.parentElement;
					if (parent && parent.childNodes) {
						const parentChildNodes = Array.from(parent.childNodes);
						const comment = parentChildNodes.find((node) => node.nodeType === 8 /* CommentNode */ && node['s-sr']);
						if (comment) {
							const index = parentChildNodes.indexOf(hostElm) - 1;
							vnode.$elm$.setAttribute(HYDRATE_CHILD_ID, `${comment['s-host-id']}.${comment['s-node-id']}.0.${index}`);
						}
					}
				}
			}
		};
		var insertChildVNodeAnnotations = (doc, vnodeChild, cmpData, hostId, depth, index) => {
			const childElm = vnodeChild.$elm$;
			if (childElm == null) {
				return;
			}
			const nodeId = cmpData.nodeIds++;
			const childId = `${hostId}.${nodeId}.${depth}.${index}`;
			childElm['s-host-id'] = hostId;
			childElm['s-node-id'] = nodeId;
			if (childElm.nodeType === 1 /* ElementNode */) {
				childElm.setAttribute(HYDRATE_CHILD_ID, childId);
				if (typeof childElm['s-sn'] === 'string' && !childElm.getAttribute('slot')) {
					childElm.setAttribute('s-sn', childElm['s-sn']);
				}
			} else if (childElm.nodeType === 3 /* TextNode */) {
				const parentNode = childElm.parentNode;
				const nodeName = parentNode == null ? void 0 : parentNode.nodeName;
				if (nodeName !== 'STYLE' && nodeName !== 'SCRIPT') {
					const textNodeId = `${TEXT_NODE_ID}.${childId}`;
					const commentBeforeTextNode = doc.createComment(textNodeId);
					insertBefore(parentNode, commentBeforeTextNode, childElm);
				}
			} else if (childElm.nodeType === 8 /* CommentNode */) {
				if (childElm['s-sr']) {
					const slotName = childElm['s-sn'] || '';
					const slotNodeId = `${SLOT_NODE_ID}.${childId}.${slotName}`;
					childElm.nodeValue = slotNodeId;
				}
			}
			if (vnodeChild.$children$ != null) {
				const childDepth = depth + 1;
				vnodeChild.$children$.forEach((vnode, index2) => {
					insertChildVNodeAnnotations(doc, vnode, cmpData, hostId, childDepth, index2);
				});
			}
		};

		// src/hydrate/platform/h-async.ts
		var hAsync = (nodeName, vnodeData, ...children) => {
			if (Array.isArray(children) && children.length > 0) {
				const flatChildren = children.flat(Infinity);
				if (flatChildren.some((child) => child instanceof Promise)) {
					return Promise.all(flatChildren)
						.then((resolvedChildren) => {
							return h(nodeName, vnodeData, ...resolvedChildren);
						})
						.catch((err2) => {
							return h(nodeName, vnodeData);
						});
				}
				return h(nodeName, vnodeData, ...flatChildren);
			}
			return h(nodeName, vnodeData);
		};
		function proxyHostElement(elm, cstr) {
			const cmpMeta = cstr.cmpMeta;
			if (typeof elm.componentOnReady !== 'function') {
				elm.componentOnReady = componentOnReady;
			}
			if (typeof elm.forceUpdate !== 'function') {
				elm.forceUpdate = forceUpdate2;
			}
			if (
				!elm.shadowRoot &&
				!!((cmpMeta.$flags$ & 1) /* shadowDomEncapsulation */) &&
				!((cmpMeta.$flags$ & 128) /* shadowNeedsScopedCss */)
			) {
				{
					elm.attachShadow({ mode: 'open' });
				}
			}
			if (cmpMeta.$members$ != null) {
				const hostRef = getHostRef(elm);
				const members = Object.entries(cmpMeta.$members$);
				members.forEach(([memberName, [memberFlags, metaAttributeName]]) => {
					var _a;
					if (memberFlags & 31 /* Prop */) {
						const attributeName = metaAttributeName || memberName;
						const attrValue = elm.getAttribute(attributeName);
						const propValue = elm[memberName];
						let attrPropVal;
						const { get: origGetter, set: origSetter } =
							Object.getOwnPropertyDescriptor(cstr.prototype, memberName) || {};
						if (attrValue != null) {
							attrPropVal = parsePropertyValue(attrValue, memberFlags);
						}
						if (propValue !== void 0) {
							attrPropVal = propValue;
							delete elm[memberName];
						}
						if (attrPropVal !== void 0) {
							if (origSetter) {
								origSetter.apply(elm, [attrPropVal]);
								attrPropVal = origGetter ? origGetter.apply(elm) : attrPropVal;
							}
							(_a = hostRef == null ? void 0 : hostRef.$instanceValues$) == null
								? void 0
								: _a.set(memberName, attrPropVal);
						}
						const getterSetterDescriptor = {
							get: function () {
								return getValue(this, memberName);
							},
							set: function (newValue) {
								setValue(this, memberName, newValue, cmpMeta);
							},
							configurable: true,
							enumerable: true,
						};
						Object.defineProperty(elm, memberName, getterSetterDescriptor);
						Object.defineProperty(elm, metaAttributeName, getterSetterDescriptor);
						if (!cstr.prototype.__stencilAugmented) {
							Object.defineProperty(cstr.prototype, memberName, {
								get: function () {
									var _a2;
									const ref = getHostRef(this);
									const attrPropVal2 = (_a2 = ref.$instanceValues$) == null ? void 0 : _a2.get(memberName);
									if (origGetter && attrPropVal2 === void 0 && !getValue(this, memberName)) {
										setValue(this, memberName, origGetter.apply(this), cmpMeta);
									}
									return attrPropVal2 !== void 0
										? attrPropVal2
										: origGetter
											? origGetter.apply(this)
											: getValue(this, memberName);
								},
								configurable: true,
								enumerable: true,
							});
						}
					} else if (memberFlags & 64 /* Method */) {
						Object.defineProperty(elm, memberName, {
							value(...args) {
								var _a2;
								const ref = getHostRef(this);
								return (_a2 = ref == null ? void 0 : ref.$onInstancePromise$) == null
									? void 0
									: _a2
											.then(() => {
												var _a3;
												return (_a3 = ref == null ? void 0 : ref.$lazyInstance$) == null
													? void 0
													: _a3[memberName](...args);
											})
											.catch((e) => {
												consoleError(e, this);
											});
							},
						});
					}
				});
				cstr.prototype.__stencilAugmented = true;
			}
		}
		function componentOnReady() {
			var _a;
			return (_a = getHostRef(this)) == null ? void 0 : _a.$onReadyPromise$;
		}
		function forceUpdate2() {}

		// src/hydrate/platform/hydrate-app.ts
		function hydrateApp(win2, opts, results, afterHydrate, resolve) {
			const connectedElements = /* @__PURE__ */ new Set();
			const createdElements = /* @__PURE__ */ new Set();
			const waitingElements = /* @__PURE__ */ new Set();
			const orgDocumentCreateElement = win2.document.createElement;
			const orgDocumentCreateElementNS = win2.document.createElementNS;
			const resolved2 = Promise.resolve();
			let tmrId;
			let ranCompleted = false;
			function hydratedComplete() {
				globalThis.clearTimeout(tmrId);
				createdElements.clear();
				connectedElements.clear();
				if (!ranCompleted) {
					ranCompleted = true;
					try {
						if (opts.clientHydrateAnnotations) {
							insertVdomAnnotations(win2.document, opts.staticComponents);
						}
						win2.dispatchEvent(new win2.Event('DOMContentLoaded'));
						win2.document.createElement = orgDocumentCreateElement;
						win2.document.createElementNS = orgDocumentCreateElementNS;
					} catch (e) {
						renderCatchError(opts, results, e);
					}
				}
				afterHydrate(win2, opts, results, resolve);
			}
			function hydratedError(err2) {
				renderCatchError(opts, results, err2);
				hydratedComplete();
			}
			function timeoutExceeded() {
				hydratedError(`Hydrate exceeded timeout${waitingOnElementsMsg(waitingElements)}`);
			}
			try {
				let patchedConnectedCallback2 = function () {
						return connectElement2(this);
					},
					patchElement2 = function (elm) {
						if (isValidComponent(elm, opts)) {
							const hostRef = getHostRef(elm);
							if (!hostRef) {
								const Cstr = loadModule({
									$tagName$: elm.nodeName.toLowerCase(),
								});
								if (Cstr != null && Cstr.cmpMeta != null) {
									if (
										opts.serializeShadowRoot !== false &&
										!!((Cstr.cmpMeta.$flags$ & 1) /* shadowDomEncapsulation */) &&
										tagRequiresScoped(elm.tagName, opts.serializeShadowRoot)
									) {
										const cmpMeta = Cstr.cmpMeta;
										cmpMeta.$flags$ |= 128 /* shadowNeedsScopedCss */;
										Object.defineProperty(Cstr, 'cmpMeta', {
											get: function () {
												return cmpMeta;
											},
										});
									}
									createdElements.add(elm);
									elm.connectedCallback = patchedConnectedCallback2;
									registerHost(elm, Cstr.cmpMeta);
									proxyHostElement(elm, Cstr);
								}
							}
						}
					},
					patchChild2 = function (elm) {
						if (elm != null && elm.nodeType === 1) {
							patchElement2(elm);
							const children = elm.children;
							for (let i2 = 0, ii = children.length; i2 < ii; i2++) {
								patchChild2(children[i2]);
							}
						}
					},
					connectElement2 = function (elm) {
						createdElements.delete(elm);
						if (isValidComponent(elm, opts) && results.hydratedCount < opts.maxHydrateCount) {
							if (!connectedElements.has(elm) && shouldHydrate(elm)) {
								connectedElements.add(elm);
								return hydrateComponent.call(elm, win2, results, elm.nodeName, elm, waitingElements);
							}
						}
						return resolved2;
					},
					waitLoop2 = function () {
						const toConnect = Array.from(createdElements).filter((elm) => elm.parentElement);
						if (toConnect.length > 0) {
							return Promise.all(toConnect.map(connectElement2)).then(waitLoop2);
						}
						return resolved2;
					};
				win2.document.createElement = function patchedCreateElement(tagName) {
					const elm = orgDocumentCreateElement.call(win2.document, tagName);
					patchElement2(elm);
					return elm;
				};
				win2.document.createElementNS = function patchedCreateElement(namespaceURI, tagName) {
					const elm = orgDocumentCreateElementNS.call(win2.document, namespaceURI, tagName);
					patchElement2(elm);
					return elm;
				};
				tmrId = globalThis.setTimeout(timeoutExceeded, opts.timeout);
				plt.$resourcesUrl$ = new URL(opts.resourcesUrl || './', win2.document.baseURI).href;
				patchChild2(win2.document.body);
				waitLoop2().then(hydratedComplete).catch(hydratedError);
			} catch (e) {
				hydratedError(e);
			}
		}
		async function hydrateComponent(win2, results, tagName, elm, waitingElements) {
			tagName = tagName.toLowerCase();
			const Cstr = loadModule({
				$tagName$: tagName,
			});
			if (Cstr != null) {
				const cmpMeta = Cstr.cmpMeta;
				if (cmpMeta != null) {
					waitingElements.add(elm);
					const hostRef = getHostRef(this);
					addHostEventListeners(this, hostRef, cmpMeta.$listeners$);
					try {
						connectedCallback(elm);
						await elm.componentOnReady();
						results.hydratedCount++;
						const ref = getHostRef(elm);
						const modeName = !ref.$modeName$ ? '$' : ref.$modeName$;
						if (!results.components.some((c) => c.tag === tagName && c.mode === modeName)) {
							results.components.push({
								tag: tagName,
								mode: modeName,
								count: 0,
								depth: -1,
							});
						}
					} catch (e) {
						win2.console.error(e);
					}
					waitingElements.delete(elm);
				}
			}
		}
		function isValidComponent(elm, opts) {
			if (elm != null && elm.nodeType === 1) {
				const tagName = elm.nodeName;
				if (typeof tagName === 'string' && tagName.includes('-')) {
					if (opts.excludeComponents.includes(tagName.toLowerCase())) {
						return false;
					}
					return true;
				}
			}
			return false;
		}
		function shouldHydrate(elm) {
			if (elm.nodeType === 9) {
				return true;
			}
			if (NO_HYDRATE_TAGS.has(elm.nodeName)) {
				return false;
			}
			if (elm.hasAttribute('no-prerender')) {
				return false;
			}
			const parentNode = elm.parentNode;
			if (parentNode == null) {
				return true;
			}
			return shouldHydrate(parentNode);
		}
		var NO_HYDRATE_TAGS = /* @__PURE__ */ new Set([
			'CODE',
			'HEAD',
			'IFRAME',
			'INPUT',
			'OBJECT',
			'OUTPUT',
			'NOSCRIPT',
			'PRE',
			'SCRIPT',
			'SELECT',
			'STYLE',
			'TEMPLATE',
			'TEXTAREA',
		]);
		function renderCatchError(opts, results, err2) {
			const diagnostic = {
				level: 'error',
				type: 'build',
				header: 'Hydrate Error',
				messageText: '',
				relFilePath: void 0,
				absFilePath: void 0,
				lines: [],
			};
			if (opts.url) {
				try {
					const u = new URL(opts.url);
					if (u.pathname !== '/') {
						diagnostic.header += ': ' + u.pathname;
					}
				} catch (e) {}
			}
			if (err2 != null) {
				if (err2.stack != null) {
					diagnostic.messageText = err2.stack.toString();
				} else if (err2.message != null) {
					diagnostic.messageText = err2.message.toString();
				} else {
					diagnostic.messageText = err2.toString();
				}
			}
			results.diagnostics.push(diagnostic);
		}
		function printTag(elm) {
			let tag = `<${elm.nodeName.toLowerCase()}`;
			if (Array.isArray(elm.attributes)) {
				for (let i2 = 0; i2 < elm.attributes.length; i2++) {
					const attr = elm.attributes[i2];
					tag += ` ${attr.name}`;
					if (attr.value !== '') {
						tag += `="${attr.value}"`;
					}
				}
			}
			tag += `>`;
			return tag;
		}
		function waitingOnElementMsg(waitingElement) {
			let msg = '';
			if (waitingElement) {
				const lines = [];
				msg = ' - waiting on:';
				let elm = waitingElement;
				while (elm && elm.nodeType !== 9 && elm.nodeName !== 'BODY') {
					lines.unshift(printTag(elm));
					elm = elm.parentElement;
				}
				let indent = '';
				for (const ln of lines) {
					indent += '  ';
					msg += `
${indent}${ln}`;
				}
			}
			return msg;
		}
		function waitingOnElementsMsg(waitingElements) {
			return Array.from(waitingElements).map(waitingOnElementMsg);
		}
		function tagRequiresScoped(tagName, opts) {
			if (typeof opts === 'string') {
				return opts === 'scoped';
			}
			if (typeof opts === 'boolean') {
				return opts === true ? false : true;
			}
			if (typeof opts === 'object') {
				tagName = tagName.toLowerCase();
				if (Array.isArray(opts['declarative-shadow-dom']) && opts['declarative-shadow-dom'].includes(tagName)) {
					return false;
				} else if (
					(!Array.isArray(opts.scoped) || !opts.scoped.includes(tagName)) &&
					opts.default === 'declarative-shadow-dom'
				) {
					return false;
				} else {
					return true;
				}
			}
			return false;
		}
		var cmpModules = /* @__PURE__ */ new Map();
		var getModule = (tagName) => {
			if (typeof tagName === 'string') {
				tagName = tagName.toLowerCase();
				const cmpModule = cmpModules.get(tagName);
				if (cmpModule != null) {
					return cmpModule[tagName];
				}
			}
			return null;
		};
		var loadModule = (cmpMeta, _hostRef, _hmrVersionId) => {
			return getModule(cmpMeta.$tagName$);
		};
		var isMemberInElement = (elm, memberName) => {
			if (elm != null) {
				if (memberName in elm) {
					return true;
				}
				const cstr = getModule(elm.nodeName);
				if (cstr != null) {
					const hostRef = cstr;
					if (hostRef != null && hostRef.cmpMeta != null && hostRef.cmpMeta.$members$ != null) {
						return memberName in hostRef.cmpMeta.$members$;
					}
				}
			}
			return false;
		};
		var registerComponents = (Cstrs) => {
			for (const Cstr of Cstrs) {
				const exportName = Cstr.cmpMeta.$tagName$;
				cmpModules.set(exportName, {
					[exportName]: Cstr,
				});
			}
		};
		var win = window;
		var writeTask = (cb) => {
			nextTick(() => {
				try {
					cb();
				} catch (e) {
					consoleError(e);
				}
			});
		};
		var resolved = /* @__PURE__ */ Promise.resolve();
		var nextTick = (cb) => resolved.then(cb);
		var defaultConsoleError = (e) => {
			if (e != null) {
				console.error(e.stack || e.message || e);
			}
		};
		var consoleError = (e, el) => defaultConsoleError(e, el);
		var plt = {
			$flags$: 0,
			$resourcesUrl$: '',
			jmp: (h2) => h2(),
			raf: (h2) => requestAnimationFrame(h2),
			ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),
			rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),
			ce: (eventName, opts) => new win.CustomEvent(eventName, opts),
		};
		var getHostRef = (ref) => {
			if (ref.__stencil__getHostRef) {
				return ref.__stencil__getHostRef();
			}
			return void 0;
		};
		var registerInstance = (lazyInstance, hostRef) => {
			lazyInstance.__stencil__getHostRef = () => hostRef;
			hostRef.$lazyInstance$ = lazyInstance;
			{
				reWireGetterSetter(lazyInstance, hostRef);
			}
			return hostRef;
		};
		var registerHost = (elm, cmpMeta) => {
			const hostRef = {
				$flags$: 0,
				$cmpMeta$: cmpMeta,
				$hostElement$: elm,
				$instanceValues$: /* @__PURE__ */ new Map(),
				$renderCount$: 0,
			};
			hostRef.$onInstancePromise$ = new Promise((r) => (hostRef.$onInstanceResolve$ = r));
			hostRef.$onReadyPromise$ = new Promise((r) => (hostRef.$onReadyResolve$ = r));
			elm['s-p'] = [];
			elm['s-rc'] = [];
			elm.__stencil__getHostRef = () => hostRef;
			return hostRef;
		};
		var styles = /* @__PURE__ */ new Map();

		function validatePropExists(newValue) {
			// Check if new value that is passed in is a string and is not empty
			const isNewValueBlank = typeof newValue !== 'string' || newValue === '';
			// Return true if new value is both a string and is not empty
			return isNewValueBlank;
		}
		function validateObjectExists(newValue) {
			// Check if new value that is passed in is a string and is not empty
			const isNewValueBlank = typeof newValue !== 'object';
			// Return true if new value is both a string and is not empty
			return isNewValueBlank;
		}
		/**
		 * Validate value against keys
		 * @param value value to be compared against keys
		 * @param keys of values provided by caller
		 * @returns true if a match is found or false if no matches are found
		 */
		function validateValueAgainstArray(value, keys) {
			return keys.includes(value);
		}
		function validateLanguage(language) {
			if (language) {
				const toggledLanguage = typeof language !== 'string' ? language.detail : language;
				if (toggledLanguage && (toggledLanguage === 'en' || toggledLanguage === 'fr')) return toggledLanguage;
				else return 'en';
			}
			return 'en';
		}

		const accessibility = {
			checkboxHintExpander: {
				en: 'is available after the last checkbox item.',
				fr: 'suivront  la dernire case  cocher.',
			},
			moreInfo: {
				en: 'More information on',
				fr: 'Des renseignements supplmentaires sur',
			},
			singleHintExpander: {
				en: 'field is available in the next element.',
				fr: 'suivront au prochain lment.',
			},
		};
		const accessibilityLink = {
			link: {
				en: 'https://www.ontario.ca/page/accessibility',
				fr: 'https://www.ontario.ca/fr/page/accessibilite',
			},
			text: {
				en: 'Accessibility',
				fr: 'Accessibilit',
			},
		};
		const termsOfUse = {
			link: {
				en: 'https://www.ontario.ca/page/terms-use',
				fr: 'https://www.ontario.ca/fr/page/conditions-dutilisation',
			},
			text: {
				en: 'Terms of Use',
				fr: 'Conditions dutilisation',
			},
		};
		const accordion = {
			collapse: {
				en: 'Collapse all',
				fr: 'Rduire tout',
			},
			expand: {
				en: 'Expand all',
				fr: 'Agrandir tout',
			},
			expandCollapseAriaLabel: {
				en: 'Expand or collapse the accordion',
				fr: "Agrandissez ou rduisez l'accordon",
			},
		};
		const backToTop = {
			ariaLabel: {
				en: 'Scroll back to the top',
				fr: 'Retour en haut de la page',
			},
			top: {
				en: 'Top',
				fr: 'Haut',
			},
		};
		const contactUs = {
			en: 'Contact us',
			fr: 'Contactez-nous',
		};
		const dateInput = {
			caption: {
				en: 'Exact date',
				fr: 'Dates exactes',
			},
			day: {
				accessibility: {
					en: '4 digits',
					fr: '4 chiffres',
				},
				label: {
					en: 'Day',
					fr: 'Jour',
				},
			},
			error: {
				en: {
					emptyDay: 'Enter the day.',
					emptyDayAndMonth: 'Enter the month and day.',
					emptyDayAndYear: 'Enter the year and day.',
					emptyMonth: 'Enter the month.',
					emptyMonthAndYear: 'Enter the year and month.',
					emptyYear: 'Enter the year.',
					invalidDate: 'Enter a valid date.',
					invalidDay: 'Enter a valid day.',
					invalidMonth: 'Enter a valid month.',
					invalidYear: 'Enter a valid year.',
				},
				fr: {
					emptyDay: 'Saisissez le jour.',
					emptyDayAndMonth: 'Saisissez le mois et le jour.',
					emptyDayAndYear: 'Saisissez lanne et le jour.',
					emptyMonth: 'Saisissez le mois.',
					emptyMonthAndYear: 'Saisissez lanne et le mois.',
					emptyYear: 'Saisissez lanne.',
					invalidDate: 'Saisissez une date valide.',
					invalidDay: 'Saisissez un jour valide.',
					invalidMonth: 'Saisissez un mois valide.',
					invalidYear: 'Saisissez une anne valide.',
				},
			},
			month: {
				accessibility: {
					en: '1 or 2 digits',
					fr: '1 ou 2 chiffres',
				},
				label: {
					en: 'Month',
					fr: 'Mois',
				},
			},
			year: {
				accessibility: {
					en: '1 or 2 digits',
					fr: '1 ou 2 chiffres',
				},
				label: {
					en: 'Year',
					fr: 'Anne',
				},
			},
		};
		const dropdownList = {
			select: {
				en: 'Select',
				fr: 'Slectionner',
			},
		};
		const header = {
			clearSearchField: {
				en: 'Clear field',
				fr: 'Vider le champ',
			},
			close: {
				en: 'close',
				fr: 'fermer',
			},
			closeMenu: {
				en: 'Hide navigation menu',
				fr: 'Fermer le menu de navigation',
			},
			closeSearch: {
				en: 'Close search bar',
				fr: 'Fermer la barre de recherche',
			},
			logoAltText: {
				en: 'Ontario.ca homepage',
				fr: 'Page daccueil Ontario.ca',
			},
			logoLink: {
				en: 'https://www.ontario.ca/page/government-ontario',
				fr: 'https://www.ontario.ca/fr/page/gouvernement-de-lontario',
			},
			ontarioSearchURL: {
				en: 'https://www.ontario.ca/search/search-results?query=',
				fr: 'https://www.ontario.ca/fr/recherche/resultats-de-recherche/?query=',
			},
			openMenu: {
				en: 'Show navigation menu',
				fr: 'Ouvrir le menu de navigation',
			},
			search: {
				en: 'Search',
				fr: 'Rechercher',
			},
			serviceOntario: {
				en: 'ServiceOntario',
				fr: 'ServiceOntario',
			},
			submit: {
				en: 'Submit',
				fr: 'Soumission',
			},
		};
		const input = {
			requiredFieldError: {
				en: 'This is a required field.',
				fr: 'Ce champ est obligatoire.',
			},
		};
		const languageToggle = {
			ariaLabel: {
				en: 'Click to switch the language to English',
				fr: 'Cliquez pour changer la langue en franais',
			},
		};
		const loading = {
			en: 'Loading',
			fr: 'Chargement',
		};
		const optional = {
			en: 'optional',
			fr: 'facultative',
		};
		const printerLink = {
			link: {
				en: 'https://www.ontario.ca/page/copyright-information',
				fr: 'https://www.ontario.ca/fr/page/droits-dauteur',
			},
			text: {
				en: "King's Printer for Ontario,",
				fr: 'Imprimeur du Roi pour lOntario,',
			},
		};
		const privacyLink = {
			link: {
				en: 'https://www.ontario.ca/page/privacy-statement',
				fr: 'https://www.ontario.ca/fr/page/declaration-concernant-la-protection-de-la-vie-privee',
			},
			text: {
				en: 'Privacy',
				fr: 'Confidentialit',
			},
		};
		const stepIndicator = {
			back: {
				en: 'Back',
				fr: 'Retour',
			},
			complete: {
				en: 'complete',
				fr: 'complet',
			},
			of: {
				en: 'of',
				fr: 'sur',
			},
			step: {
				en: 'Step',
				fr: 'tape',
			},
		};
		const siteLanguage = {
			fullWord: {
				en: 'English',
				fr: 'Franais',
			},
			abbreviation: {
				en: 'en',
				fr: 'fr',
			},
		};
		const taskGroup = {
			completed: {
				en: 'You have completed',
				fr: 'Vous avez complt',
			},
			outOf: {
				en: 'out of',
				fr: 'sur',
			},
			tasks: {
				en: 'tasks.',
				fr: 'tches.',
			},
		};
		const taskStatus = {
			taskStatus: {
				en: 'Task Status:',
				fr: 'Statut de la tche:',
			},
			notStarted: {
				en: 'Not Started',
				fr: 'Pas commenc',
			},
			inProgress: {
				en: 'In Progress',
				fr: 'En cours',
			},
			completed: {
				en: 'Completed',
				fr: 'Termin',
			},
			cannotStartYet: {
				en: 'Cannot Start Yet',
				fr: 'Peux pas encore commencer',
			},
			error: {
				en: 'Error',
				fr: 'Erreur',
			},
			optional: {
				en: 'Optional',
				fr: 'Facultatif',
			},
		};
		const newWindow = {
			en: 'opens in a new window',
			fr: "s'ouvre dans une nouvelle fentre",
		};
		const required = {
			en: 'required',
			fr: 'obligatoire',
		};
		var translations = {
			accessibility: accessibility,
			accessibilityLink: accessibilityLink,
			termsOfUse: termsOfUse,
			accordion: accordion,
			backToTop: backToTop,
			contactUs: contactUs,
			dateInput: dateInput,
			dropdownList: dropdownList,
			header: header,
			input: input,
			languageToggle: languageToggle,
			loading: loading,
			optional: optional,
			printerLink: printerLink,
			privacyLink: privacyLink,
			stepIndicator: stepIndicator,
			siteLanguage: siteLanguage,
			taskGroup: taskGroup,
			taskStatus: taskStatus,
			newWindow: newWindow,
			required: required,
		};

		const ontarioAccordionCss =
			'.ontario-accordion__button--expand-all:focus,.ontario-accordion__button:focus{box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:box-shadow 0.1s ease-in-out}.ontario-accordion__button{font-style:normal;font-weight:700;text-rendering:optimizeLegibility;margin-bottom:1rem;font-feature-settings:normal;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif}.ontario-accordion__button{font-size:1.25rem;letter-spacing:0.03rem;line-height:1.5;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){.ontario-accordion__button{font-size:1.5rem;letter-spacing:0.0313rem;line-height:1.5}}.ontario-accordions__container{max-width:48rem;width:100%}.ontario-accordion{border-top:2px solid #cccccc}.ontario-accordion:last-of-type{border-bottom:2px solid #cccccc}.ontario-accordion__controls{display:flex;justify-content:flex-end}.ontario-accordion__button,.ontario-accordion__button--expand-all{background:none;border:0;box-sizing:border-box}.ontario-accordion__button--expand-all{font-size:1rem;margin-bottom:0.5rem;color:#0066CC;cursor:pointer}.ontario-accordion__button--expand-all:focus,.ontario-accordion__button--expand-all:hover{color:#00478F;text-decoration:underline}.ontario-accordion__button--expand-all:active{color:#002142;text-decoration:underline}.ontario-accordion--expand-close-all{display:none}.ontario-accordion__controls--active .ontario-accordion--expand-close-all{display:block}.ontario-accordion__controls--active .ontario-accordion--expand-open-all{display:none}.ontario-accordion__button{display:flex;align-items:flex-start;color:#0066CC;cursor:pointer;padding:0.75rem 0.5rem;text-align:left;width:100%;margin-bottom:0}.ontario-accordion__button .ontario-accordion__button-icon--close,.ontario-accordion__button .ontario-accordion__button-icon--open{margin-right:0.5rem}.ontario-accordion__button .ontario-icon{width:1.75rem;height:1.75rem}.ontario-accordion__button:focus,.ontario-accordion__button:hover{background-color:#f2f2f2;color:#00478F}.ontario-accordion__button:focus{box-shadow:0 0 0 4px #009ADB inset}.ontario-accordion__button:active{color:#002142}.ontario-accordion__content{display:none;padding:0.75rem 0.75rem 2rem 0.75rem;margin-left:0}@media screen and (min-width: 40em){.ontario-accordion__content{margin-left:2rem}}.ontario-accordion__content *{margin-top:0;max-width:48rem;width:100%}.ontario-accordion__content ul,.ontario-accordion__content ol{max-width:calc(100% - 3rem)}.ontario-accordion__content>:last-child{margin-bottom:0}.ontario-accordion__button-icon--close,.ontario-expander--active .ontario-accordion__button-icon--open{display:none}.ontario-expander--active~.ontario-accordion__content,.ontario-expander--active .ontario-accordion__button-icon--close{display:block}.ontario-accordions__container .ontario-h1,.ontario-accordions__container .ontario-h2,.ontario-accordions__container .ontario-h3,.ontario-accordions__container .ontario-h4,.ontario-accordions__container .ontario-h5,.ontario-accordions__container p,.ontario-accordions__container h1,.ontario-accordions__container h2,.ontario-accordions__container h3,.ontario-accordions__container h4,.ontario-accordions__container h5,.ontario-accordions__container h6{margin:0}';

		class OntarioAccordion {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			get host() {
				return getElement(this);
			}
			/**
			 * The name of the accordion component.
			 *
			 * This is not optional.
			 */
			name;
			/**
			 * Custom Expand/Collapse button text.
			 *
			 * @example
			 *  <ontario-accordion
			 *		name="My Accordion"
			 *		expand-collapse-button='{
			 *			"expandAllSectionsLabel": "Expand All",
			 *			"collapseAllSectionsLabel": "Collapse All"
			 *		}'
			 *		accordion-data='[
			 *			{"label": "Accordion 1", "content": ["Item 1", "Item 2", "Item 3"]},
			 *			{"label": "Accordion 2", "content": ["Item A", "Item B", "Item C"]}
			 *		]'
			 *	></ontario-accordion>
			 */
			expandCollapseButton;
			/**
			 * Used to include individual accordion data for the accordion component.
			 * This is passed in as an array of objects with key-value pairs.
			 *
			 * The `content` is expecting a string, that can either be written as HTML or a just a plain string, depending on the accordionContentType.
			 *
			 * @example
			 * 	<ontario-accordion
			 *		name="My Accordion"
			 *		accordion-data='[
			 *			{"label": "Accordion 1", "content": "This is a string"},
			 *			{"label": "Accordion 2", "accordionContentType": "html", "content": "<ul><li>List A</li><li>List B</li><li>List C</li></ul>"}
			 *		]'
			 *	></ontario-accordion>
			 */
			accordionData;
			/**
			 * Used to show whether the accordion is opened or closed.
			 */
			isOpen = false;
			/**
			 * The language of the component.
			 * This is used for translations, and is by default set through event listeners checking for a language property from the header. If none are passed, it will default to English.
			 */
			language;
			/**
			 * This listens for the `setAppLanguage` event sent from the test language toggler when it is is connected to the DOM. It is used for the initial language when the input component loads.
			 */
			handleSetAppLanguage(event) {
				if (!this.language) {
					this.language = validateLanguage(event);
				}
			}
			/**
			 * Handle the language being toggled from the `<ontario-header>`.
			 * @param event Event object passed when the event is fired.
			 */
			handleHeaderLanguageToggled(event) {
				this.language = validateLanguage(event);
			}
			/**
			 * Store the translation dictionary for use within the component.
			 */
			translations = translations;
			/**
			 * The label for the expand/collapse button.
			 * This is internal and udpdated dynamically.
			 */
			expandCollapseLabel;
			/**
			 * Internal state of the expand/collapse label information.
			 */
			internalExpandCollapseLabelDetails;
			/**
			 * Internal state containing the parsed Accordion Data
			 */
			internalAccordionData = [];
			/**
			 * This state tracks which accordions are open.
			 */
			openAccordionIndexes = [];
			/**
			 * Parse Accordion data, this is used to handle JSON strings from HTML.
			 */
			parseAccordionData() {
				if (typeof this.accordionData !== 'undefined') {
					this.internalAccordionData = Array.isArray(this.accordionData)
						? this.accordionData
						: JSON.parse(this.accordionData);
				}
				// Initialize the label based on the initial accordion state
				this.updateLabel();
			}
			/**
			 * Parse Expand/Collapse Button Details, this is used to handle JSON strings from HTML.
			 */
			parseExpandCollapseButtonDetails() {
				if (typeof this.expandCollapseButton !== 'undefined') {
					this.internalExpandCollapseLabelDetails =
						typeof this.expandCollapseButton === 'string'
							? JSON.parse(this.expandCollapseButton)
							: this.expandCollapseButton;
				}
			}
			// Toggle the accordion state when it's clicked
			toggleAccordion(index) {
				if (this.openAccordionIndexes.includes(index)) {
					// If the accordion is already open, close it
					this.openAccordionIndexes = this.openAccordionIndexes.filter((i) => i !== index);
				} else {
					// If the accordion is closed, open it
					this.openAccordionIndexes = [...this.openAccordionIndexes, index];
				}
				this.updateLabel();
			}
			/**
			 * Toggle all accordions open/close
			 */
			toggleAll() {
				if (this.openAccordionIndexes.length === this.internalAccordionData.length) {
					// All accordions are open, close all
					this.openAccordionIndexes = [];
				} else {
					// At least one accordion is closed, open all
					this.openAccordionIndexes = this.internalAccordionData.map((_, index) => index);
				}
				this.updateLabel();
			}
			/**
			 * Update the label based on the current accordion state
			 */
			updateLabel() {
				const allOpen = this.internalAccordionData.every((_, index) => this.openAccordionIndexes.includes(index));
				if (allOpen) {
					// All accordions are open, set label to "Collapse all"
					this.expandCollapseLabel = 'collapse';
				} else {
					// At least one accordion is closed, set label to "Expand all"
					this.expandCollapseLabel = 'expand';
				}
			}
			componentWillLoad() {
				this.parseAccordionData();
				this.parseExpandCollapseButtonDetails();
				this.language = validateLanguage(this.language);
			}
			render() {
				return hAsync(
					'div',
					{ key: '1ec9adce66ba9651eb72287a6268e041b8dc4fb3' },
					hAsync('h2', { key: 'b13104816ae4a4ae5292afbc94ffb526c020babe' }, this.name),
					hAsync(
						'div',
						{ key: '53e28363acaec45d55d0a021a68ebea3845b034d', class: 'ontario-accordions__container' },
						hAsync(
							'div',
							{ key: 'eb4ee3f92067cce8ff9b169026eb1df0801fa230', class: 'ontario-accordion__controls' },
							hAsync(
								'button',
								{
									'key': 'c018efcef59dcb152b3646e217df9b4ae09ed5c0',
									'class': 'ontario-accordion__button--expand-all',
									'onClick': () => this.toggleAll(),
									'aria-expanded':
										this.openAccordionIndexes.length === this.internalAccordionData.length ? 'true' : 'false',
									'aria-label': this.internalExpandCollapseLabelDetails?.ariaLabelText,
								},
								hAsync(
									'span',
									{ key: '9e0f9959fb6f83e14b02e9843652d7a66a3fae54', class: 'ontario-accordion--expand-open-all' },
									this.expandCollapseLabel === 'expand'
										? hAsync(
												'div',
												null,
												this.internalExpandCollapseLabelDetails?.expandAllSectionsLabel ??
													this.translations.accordion.expand[`${this.language}`],
											)
										: hAsync(
												'div',
												null,
												this.internalExpandCollapseLabelDetails?.collapseAllSectionsLabel ??
													this.translations.accordion.collapse[`${this.language}`],
											),
								),
							),
						),
						this.internalAccordionData?.map((accordion, index) =>
							hAsync(
								'div',
								{
									class: `ontario-accordion ${this.openAccordionIndexes.includes(index) ? 'open' : ''}`,
									key: `accordion-${index}`,
								},
								hAsync(
									'h3',
									{
										class: `ontario-accordion__heading ${this.openAccordionIndexes.includes(index) ? 'ontario-expander--active' : ''}`,
									},
									hAsync(
										'button',
										{
											'class': 'ontario-accordion__button',
											'aria-expanded': this.openAccordionIndexes.includes(index) ? 'true' : 'false',
											'data-toggle': 'ontario-collapse',
											'onClick': () => this.toggleAccordion(index),
											'aria-label': accordion.ariaLabelText,
										},
										hAsync(
											'span',
											{ class: 'ontario-accordion__button-icon--close' },
											hAsync('ontario-icon-chevron-up', { colour: 'blue' }),
										),
										hAsync(
											'span',
											{ class: 'ontario-accordion__button-icon--open' },
											hAsync('ontario-icon-chevron-down', { colour: 'blue' }),
										),
										accordion.label,
									),
								),
								hAsync(
									'section',
									{
										'class': `ontario-accordion__content ${
											this.openAccordionIndexes.includes(index)
												? 'ontario-accordion__content--opened'
												: 'ontario-accordion__content--closed'
										}`,
										'aria-hidden': !this.openAccordionIndexes.includes(index),
										'data-toggle': 'ontario-expander-content',
									},
									accordion.accordionContentType === 'html'
										? hAsync('div', { innerHTML: accordion.content }) // Render HTML content
										: hAsync('div', null, accordion.content),
								),
							),
						),
					),
				);
			}
			static get watchers() {
				return {
					accordionData: ['parseAccordionData'],
					expandCollapseButton: ['parseExpandCollapseButtonDetails'],
				};
			}
			static get style() {
				return ontarioAccordionCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-accordion',
					$members$: {
						name: [1],
						expandCollapseButton: [1, 'expand-collapse-button'],
						accordionData: [1, 'accordion-data'],
						isOpen: [4, 'is-open'],
						language: [1025],
						translations: [32],
						expandCollapseLabel: [32],
						internalExpandCollapseLabelDetails: [32],
						internalAccordionData: [32],
						openAccordionIndexes: [32],
					},
					$listeners$: [
						[8, 'setAppLanguage', 'handleSetAppLanguage'],
						[8, 'headerLanguageToggled', 'handleHeaderLanguageToggled'],
					],
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const HeadingLevel = ['h2', 'h3', 'h4', 'h5', 'h6'];
		const HighlightColours = ['teal', 'gold', 'yellow', 'taupe', 'green', 'lime', 'sky', 'blue', 'purple'];
		const HeadingContentTypes = ['string', 'html'];

		const isValidHighlightColour = (colour) => HighlightColours.includes(colour);
		const isValidHeadingLevel = (level) => HeadingLevel.includes(level);
		const generateClasses = (type, highlightColor) => {
			const componentType = type === 'callout' ? `ontario-callout` : `ontario-aside`;
			const borderColor = `ontario-border-highlight--${highlightColor}`;
			return highlightColor ? `${componentType} ${borderColor}` : `${componentType}`;
		};
		const generateHeading = (type, headingType, headingContentType, headingContent) => {
			const headingContentIsHTML = headingContentType === 'html';
			switch (headingType) {
				case 'h2':
					return headingContentIsHTML
						? hAsync('h2', { class: `ontario-${type}__title ontario-h5`, innerHTML: headingContent })
						: hAsync('h2', { class: `ontario-${type}__title ontario-h5` }, headingContent);
				case 'h3':
					return headingContentIsHTML
						? hAsync('h3', { class: `ontario-${type}__title ontario-h5`, innerHTML: headingContent })
						: hAsync('h3', { class: `ontario-${type}__title ontario-h5` }, headingContent);
				case 'h4':
					return headingContentIsHTML
						? hAsync('h4', { class: `ontario-${type}__title ontario-h5`, innerHTML: headingContent })
						: hAsync('h4', { class: `ontario-${type}__title ontario-h5` }, headingContent);
				case 'h5':
					return headingContentIsHTML
						? hAsync('h5', { class: `ontario-${type}__title ontario-h5`, innerHTML: headingContent })
						: hAsync('h5', { class: `ontario-${type}__title ontario-h5` }, headingContent);
				case 'h6':
					return headingContentIsHTML
						? hAsync('h6', { class: `ontario-${type}__title ontario-h5`, innerHTML: headingContent })
						: hAsync('h6', { class: `ontario-${type}__title ontario-h5` }, headingContent);
				default:
					return headingContentIsHTML
						? hAsync('h2', { class: `ontario-${type}__title ontario-h5`, innerHTML: headingContent })
						: hAsync('h2', { class: `ontario-${type}__title ontario-h5` }, headingContent);
			}
		};
		const generateCalloutAside = (type, headingContentType, headingType, headingContent, content, highlightColour) => {
			const contentIsString = typeof content === 'string';
			return type === 'callout'
				? hAsync(
						'div',
						{ class: generateClasses(type, highlightColour) },
						headingContent ? generateHeading(type, headingType, headingContentType, headingContent) : '',
						contentIsString ? hAsync('p', null, content) : hAsync('slot', null),
					)
				: hAsync(
						'aside',
						{ class: generateClasses(type, highlightColour) },
						headingContent ? generateHeading(type, headingType, headingContentType, headingContent) : '',
						contentIsString ? (content ? hAsync('p', null, content) : '') : hAsync('slot', null),
					);
		};

		var ConsoleType;
		(function (ConsoleType) {
			ConsoleType['Error'] = 'error';
			ConsoleType['Info'] = 'info';
			ConsoleType['Log'] = 'log';
			ConsoleType['Warning'] = 'warning';
		})(ConsoleType || (ConsoleType = {}));
		var MessageStyle;
		(function (MessageStyle) {
			MessageStyle['Regular'] = 'regular';
			MessageStyle['Code'] = 'code';
		})(MessageStyle || (MessageStyle = {}));

		// system tag with formatting specifier
		const designSystemTag = 'Ontario Design System';
		// default font size for console messages
		const fontSize = '12px';
		// styles for the system tag in a string format
		// the `background-color`, `color`, `padding` and `border-radius` values are hardcoded because
		// they are specific for console message use case
		const tagStyles = [
			'background-color: #367A76',
			'border: none',
			'color: white',
			'padding: 2px 5px',
			'text-align: center',
			'text-decoration: none',
			'display: inline-block',
			'cursor: pointer',
			'border-radius: 5px',
		].join(';');
		// styles for regular text in string format
		const regularTextStyles = ['font-family: sans-serif', `font-size: ${fontSize}`].join(';');
		// styles for code in string format
		const monospaceTextStyles = ['font-family: monospace', `font-size: ${fontSize}`].join(';');
		function addSpecifier(message) {
			const styleSpecifier = '%c';
			return styleSpecifier.concat(message);
		}
		// build and print console message with a fluent interface design
		class ConsoleMessageClass {
			message;
			styles;
			constructor() {
				this.message = '';
				this.styles = [];
			}
			// add the `Ontario Design System` tag to the beginning of the message
			// the first call in the chain if a tag is required
			addDesignSystemTag() {
				this.message = addSpecifier(designSystemTag);
				this.styles.push(tagStyles);
				return this;
			}
			// build console message as regular text
			addRegularText(text) {
				this.addText(text, regularTextStyles);
				return this;
			}
			// build console message as monospace text
			addMonospaceText(text) {
				this.addText(text, monospaceTextStyles);
				return this;
			}
			// print message to console depending on the `ConsoleType`
			// the last function call in the chain
			printMessage(consoleType = ConsoleType.Warning) {
				const messageArray = [this.message, ...this.styles];
				// pass array of arguments into the console function for printing depending on `consoleType`
				// the `function.apply()` function handles array of arguments which allows list of arguments to be set programmatically
				switch (consoleType) {
					case ConsoleType.Error:
						console.error.apply(null, messageArray);
						break;
					case ConsoleType.Info:
						console.info.apply(null, messageArray);
						break;
					case ConsoleType.Warning:
						console.warn.apply(null, messageArray);
						break;
					default:
						console.log.apply(null, messageArray);
				}
			}
			// add text to the `message` property and associated styles into the `styles` array
			addText(text, style) {
				if (text && text?.trim().length > 0) {
					this.message += addSpecifier(text);
					this.styles.push(style);
				}
			}
		}

		const ontarioAsideCss =
			'@charset "UTF-8";h6,.ontario-h6,h5,.ontario-h5,h4,.ontario-h4,h3,.ontario-h3,h2,.ontario-h2,h1,.ontario-h1{font-style:normal;font-weight:700;text-rendering:optimizeLegibility;margin-bottom:1rem;font-feature-settings:normal;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif}h1,.ontario-h1{font-size:2rem;letter-spacing:0.04rem;line-height:1.29;margin:2.5rem 0 1.5rem 0;max-width:70rem}@media screen and (min-width: 40em){h1,.ontario-h1{font-size:2.5rem;letter-spacing:0.04rem;line-height:1.2}}h2,.ontario-h2{font-size:1.6875rem;letter-spacing:0.03rem;line-height:1.37;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h2,.ontario-h2{font-size:2.0625rem;letter-spacing:0.02rem;line-height:1.33}}h3,.ontario-h3{font-size:1.4375rem;letter-spacing:0.02rem;line-height:1.39;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h3,.ontario-h3{font-size:1.75rem;letter-spacing:0.02rem;line-height:1.43}}h4,.ontario-h4{font-size:1.25rem;letter-spacing:0.03rem;line-height:1.5;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h4,.ontario-h4{font-size:1.5rem;letter-spacing:0.0313rem;line-height:1.5}}h5,.ontario-h5{font-size:1.125rem;letter-spacing:0.03rem;line-height:1.56;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h5,.ontario-h5{font-size:1.1875rem;letter-spacing:0.025rem;line-height:1.5}}h6,.ontario-h6{font-size:1rem;line-height:1.56;letter-spacing:0.03rem;max-width:48rem;margin:0 0 0.75rem 0}@media screen and (min-width: 40em){h6,.ontario-h6{font-size:1rem;letter-spacing:0.025rem;line-height:1.5}}.ontario-lead-statement{font-size:1.25rem;line-height:1.6;max-width:70rem}@media screen and (min-width: 40em){.ontario-lead-statement{font-size:1.375rem}}html{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem}body{font-size:1rem;line-height:1.6;background-color:#FFFFFF;color:#1a1a1a;margin:0}p{font-size:inherit;margin-bottom:1.25rem;text-rendering:optimizeLegibility;margin:0 0 1.5rem 0}cite{font-style:italic;line-height:inherit}strong{font-weight:700;line-height:inherit}*,*::before,*::after{box-sizing:inherit}main p,main p:not(.ontario-lead-statement),main dd,main li{max-width:48rem}hr{border:0;padding:0;margin:2.5rem 0;border-bottom:4px solid #cccccc}hr.ontario-hr--dark{border-bottom:4px solid #1a1a1a}a{color:#0066CC;text-decoration:underline}a:visited{color:#551A8B}a:hover{color:#00478F}a:active{color:#002142}a:focus{-moz-box-shadow:0 0 0 4px #009ADB;-webkit-box-shadow:0 0 0 4px #009ADB;box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:all 0.1s ease-in-out}p{margin:0 0 1.5rem 0}p+h1,p+h2,p+h3,p+h4,p+h5,p+h6,ul+h1,ul+h2,ul+h3,ul+h4,ul+h5,ul+h6,ol+h1,ol+h2,ol+h3,ol+h4,ol+h5,ol+h6,h1+h2,h2+h3,h3+h4,h4+h5,h5+h6{margin-top:2rem}p code,td code,li code{line-height:2.25rem}input[type=text],input[type=number],input[type=email],input[type=date],input[type=color],input[type=search],input[type=tel],textarea{background-origin:initial;height:auto;-webkit-appearance:none;-moz-appearance:none}input[type=checkbox]+label,input[type=radio]+label{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400;margin-left:0;margin-right:0}fieldset{border:0;margin:0;padding:0;page-break-inside:avoid}legend,label{display:block;margin:0}select{background-origin:initial;height:auto;-webkit-appearance:none;-moz-appearance:none}ul,ol{padding:0}ul{margin-left:2rem}ul li{padding:0 0 0.75rem 0}ol{margin-left:1.75rem}ol li{padding:0 0 0.75rem 0.25rem}ul li:last-child,ol li:last-child{padding-bottom:0}ul[class*=columns-] li:last-child,ol[class*=columns-] li:last-child{padding-bottom:0.75rem}ul ul,ol ul{margin:0.5rem 0 0.5rem 2rem}ul ol,ol ol{margin:0.5rem 0 0.5rem 1.75rem}p+ul,p+ol{margin-top:-0.75rem}@media screen and (min-width: 40em){ul{margin:0.5rem 0 1.5rem 3rem}ol{margin:0.5rem 0 1.5rem 2.75rem}ul ul,ol ul{margin:0.5rem 0 0.5rem 3rem}ul ol,ol ol{margin:0.5rem 0 0.5rem 2.75rem}}.ontario-aside{border-left:0.25rem solid #367A76;padding:1.5rem;margin:2rem 0 2.5rem 2rem}.ontario-aside *{max-width:48rem}.ontario-aside *:last-child{margin-bottom:0.5rem}@media screen and (max-width: 40em){.ontario-aside .ontario-aside{margin:2rem 0 2.5rem 1rem}}.ontario-aside__title{margin:0 0 1rem}.ontario-border-highlight--teal{border-color:#367A76 !important}.ontario-border-highlight--gold{border-color:#86743D !important}.ontario-border-highlight--yellow{border-color:#8A600D !important}.ontario-border-highlight--taupe{border-color:#7B725C !important}.ontario-border-highlight--green{border-color:#2B8737 !important}.ontario-border-highlight--lime{border-color:#5F8129 !important}.ontario-border-highlight--sky{border-color:#1080A6 !important}.ontario-border-highlight--blue{border-color:#0369ac !important}.ontario-border-highlight--purple{border-color:#92278F !important}';

		class OntarioAside {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The heading level of the aside heading.
			 */
			headingType;
			/**
			 * The type of the heading content. If no prop is passed, it will default to string.
			 */
			headingContentType = 'string';
			/**
			 * Text or HTML to be displayed as the heading of the aside. If the heading content should be displayed as HTML, the `headingContentType` needs to be set to `html`.
			 */
			headingContent;
			/**
			 * Optional text to be displayed as the content for the aside component. If a string is passed, it will automatically be nested in a paragraph tag.
			 *
			 * HTML content can also be passed as the child/children of the aside component if additional/different elements for the content are needed.
			 *
			 * @example
			 * <ontario-aside headingType='h3' headingContent='This is the aside heading'><p>This is the first sentence of the aside content.</p><p>This is the second sentence of the aside content.</p></ontario-aside>
			 */
			content;
			/**
			 * Optional prop to choose the border colour of the aside. If none is passed, the default colour will be teal.
			 */
			highlightColour = 'teal';
			/**
			 * Watch for changes to the `headingType` prop.
			 *
			 * This is for validation purposes to make sure the `headingType` matches one of the `HeadingLevelOptions`.
			 */
			validateHeadingType() {
				if (!!this.headingType) {
					if (isValidHeadingLevel(this.headingType)) return this.headingType;
					const message = new ConsoleMessageClass();
					return message
						.addDesignSystemTag()
						.addMonospaceText(` headingType ${this.headingType} `)
						.addRegularText('for')
						.addMonospaceText(' <ontario-aside> ')
						.addRegularText(
							'is not a valid type. Please ensure your heading type matches one of the headingType types.',
						)
						.printMessage();
				}
			}
			/**
			 * Watch for changes in the `headingContentType` prop for validation purposes.
			 *
			 * If the user input doesn't match one of the array values then `headingContentType` will be set to its default (`string`).
			 * If a match is found in one of the array values then `headingContentType` will be set to the matching array key value.
			 */
			validateHeadingContentType() {
				const isValid = validateValueAgainstArray(this.headingContentType, HeadingContentTypes);
				if (isValid) {
					return this.headingContentType;
				} else {
					return this.warnDefaultType();
				}
			}
			/**
			 * Watch for changes to the `highlightColour` prop.
			 *
			 * If no `highlightColour` is passed, or if the `highlightColour` does not match the `highlightColour` options, a default value of 'teal' will be applied.
			 */
			validateHighlightColour() {
				if (this.highlightColour) {
					if (isValidHighlightColour(this.highlightColour)) return this.highlightColour;
					else {
						const message = new ConsoleMessageClass();
						message
							.addDesignSystemTag()
							.addMonospaceText(` highlightColour ${this.highlightColour} `)
							.addRegularText('for')
							.addMonospaceText(' <ontario-aside> ')
							.addRegularText(
								'does not match one of the valid highlightColour types. A default colour of `teal` will be applied.',
							)
							.printMessage();
					}
				}
				// if no highlight colour is passed, return 'teal'
				return 'teal';
			}
			/**
			 * Print the invalid `type` warning message.
			 * @returns default type ('string')
			 */
			warnDefaultType() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' headingContentType ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-aside> ')
					.addRegularText('was set to an invalid type; only')
					.addMonospaceText(' string or html ')
					.addRegularText('are supported. The default type')
					.addMonospaceText(' string ')
					.addRegularText('is assumed.')
					.printMessage();
				return (this.headingContentType = 'string');
			}
			componentWillLoad() {
				this.validateHighlightColour();
				this.validateHeadingType();
				this.validateHeadingContentType();
			}
			render() {
				return generateCalloutAside(
					'aside',
					this.headingContentType,
					this.headingType,
					this.headingContent,
					this.content,
					this.highlightColour,
				);
			}
			static get watchers() {
				return {
					headingType: ['validateHeadingType'],
					headingContentType: ['validateHeadingContentType'],
					highlightColour: ['validateHighlightColour'],
				};
			}
			static get style() {
				return ontarioAsideCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-aside',
					$members$: {
						headingType: [1025, 'heading-type'],
						headingContentType: [1025, 'heading-content-type'],
						headingContent: [1, 'heading-content'],
						content: [1],
						highlightColour: [1025, 'highlight-colour'],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		var OntarioIconArrowUp$1 = `<svg class="ontario-icon" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#000000"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M4 12l1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z"/></svg>
`;

		const ontarioBackToTopCss =
			'.ontario-back-to-top,.ontario-back-to-top--default{position:fixed;bottom:5%;right:2%;visibility:hidden;opacity:0;transition:0.1s ease-in-out;display:flex;justify-content:center;align-items:center;height:3rem;padding:0.5rem 1rem 0.5rem 0.75rem;background:#e6e6e6;border:0.125rem solid #FFFFFF;border-radius:4px;box-shadow:0 0.125rem 0.25rem rgba(26, 26, 26, 0.6);box-sizing:border-box;color:#1a1a1a;line-height:1.25rem;font-size:1rem;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-weight:600;z-index:10000;cursor:pointer}.ontario-back-to-top .ontario-icon,.ontario-back-to-top--default .ontario-icon{margin:0.125rem 0.5rem 0 0;width:2rem;height:2rem}.ontario-back-to-top:hover,.ontario-back-to-top--default:hover{background-color:#cccccc}.ontario-back-to-top:focus,.ontario-back-to-top--default:focus{background-color:#e6e6e6;box-shadow:0 0 0 0.25rem #009ADB, 0 0.1875rem 0.3125rem 0.1875rem rgba(0, 0, 0, 0.6);outline:0.25rem solid transparent;transition:0.1s ease-in-out}.ontario-back-to-top:active,.ontario-back-to-top--default:active{background-color:#b2b2b2;box-shadow:0 0 0 0.25rem #009ADB, 0 0.3125rem 0.4375rem 0.1875rem rgba(0, 0, 0, 0.6);outline:0.25rem solid transparent;transition:background-color 0s, box-shadow 0.1s ease-in-out}@media screen and (max-width: 73em){.ontario-back-to-top,.ontario-back-to-top--default{flex-direction:column;height:4.75rem;padding:0.375rem 0.75rem 0.5625rem 0.75rem}.ontario-back-to-top .ontario-icon,.ontario-back-to-top--default .ontario-icon{margin:0.0625rem 0 0.25rem 0;width:2rem;height:2rem}}@media screen and (max-width: 40em){.ontario-back-to-top,.ontario-back-to-top--default{display:block;padding:0.25rem;font-size:0;width:3rem;height:3rem}.ontario-back-to-top .ontario-icon,.ontario-back-to-top--default .ontario-icon{margin:0.5rem 0 0 0}@-moz-document url-prefix(){.ontario-back-to-top .ontario-icon,.ontario-back-to-top--default .ontario-icon{margin-top:0.125rem}}}.ontario-back-to-top.active,.ontario-back-to-top--default.active{visibility:visible;opacity:1}';

		class OntarioBackToTop {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			get element() {
				return getElement(this);
			}
			/**
			 * The language of the component.
			 * This is used for translations, and is by default set through event listeners checking for a language property from the header. If no language prop is passed, it will default to English.
			 */
			language;
			translations = translations;
			displayBackToTop = false;
			scrollYValue = 200;
			/**
			 * This listens for the window Y scroll value to be above 200 pixels. Once it is, the Back to Top button will toggle the `displayBackToTop` state which will set an active class to control the components' visibility.
			 */
			showBackToTopButton() {
				this.displayBackToTop = window.scrollY > this.scrollYValue;
			}
			/**
			 * This listens for the `setAppLanguage` event sent from the test language toggler when it is is connected to the DOM. It is used for the initial language when the input component loads.
			 */
			handleSetAppLanguage(event) {
				if (!this.language) {
					this.language = validateLanguage(event);
				}
			}
			handleHeaderLanguageToggled(event) {
				this.language = validateLanguage(event);
			}
			/**
			 * Scroll to top functionality when the Back to Top button is clicked
			 */
			scrollToTop() {
				window.scrollTo({ top: 0, left: 0, behavior: 'smooth' });
			}
			componentWillLoad() {
				this.language = validateLanguage(this.language);
			}
			render() {
				return hAsync(
					'button',
					{
						'key': '6c95d5c593c21175250e36c2439351b9909260c3',
						'class': this.displayBackToTop ? `ontario-back-to-top active` : `ontario-back-to-top`,
						'onClick': this.scrollToTop,
						'aria-label': this.translations.backToTop.ariaLabel[`${this.language}`],
					},
					hAsync('span', {
						'key': 'e3914db3602ff24f7c92e8926bfd208cf7b57e8b',
						'aria-hidden': 'true',
						'innerHTML': OntarioIconArrowUp$1,
					}),
					this.translations.backToTop.top[`${this.language}`],
				);
			}
			static get style() {
				return ontarioBackToTopCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-back-to-top',
					$members$: {
						language: [1025],
						translations: [32],
						displayBackToTop: [32],
						scrollYValue: [32],
					},
					$listeners$: [
						[9, 'scroll', 'showBackToTopButton'],
						[8, 'setAppLanguage', 'handleSetAppLanguage'],
						[8, 'headerLanguageToggled', 'handleHeaderLanguageToggled'],
					],
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		function hasMultipleTrueValues(arr, key) {
			let count = 0;
			for (const obj of arr) {
				if (obj[key] === true || obj[key] === 'true') {
					count++;
					if (count > 1) {
						return true;
					}
				}
			}
			return false;
		}
		function extractValuesByKey(objects, key) {
			return objects.map((obj) => obj[key]);
		}
		function organizeObjectKeys(data, columns) {
			return data.map((item) => {
				const newData = {};
				const otherKeys = {};
				// Iterate through each key in the item
				Object.keys(item).forEach((key) => {
					if (key === 'data') {
						// Organize keys in the 'data' object
						columns.forEach((column) => {
							if (column in item.data) {
								newData[column] = item.data[column];
							}
						});
					} else {
						// Preserve other keys
						otherKeys[key] = item[key];
					}
				});
				return { data: newData, ...otherKeys };
			});
		}
		function removeObjectsBySpecificKey(objects, key, value) {
			const removedObjects = [];
			const filteredObjects = objects.filter((obj) => {
				if (obj[key] === value) {
					removedObjects.push(obj);
					return false;
				}
				return true;
			});
			return [filteredObjects, removedObjects];
		}
		/**
		 * Takes an input value and determines whether or not it is a number.
		 *
		 * @param {string | number} value - The value you would like to test against.
		 *
		 * @returns {boolean}
		 */
		function isNumber(value) {
			if (value === undefined || value === null) return false;
			return isNaN(Number(value)) === false;
		}
		function isEmpty(str) {
			return !str || str?.length <= 0;
		}
		/**
		 * Retrieves the keys from an enum and lists them in an array.
		 *
		 * @param {object} enumObject - The enum you wish to get the keys of.
		 *
		 * @returns {string[]}
		 */
		function retrieveEnumKeys(enumObject) {
			if (enumObject === undefined || enumObject === null) return new Array(0);
			return Object.keys(enumObject).filter((key) => !isNumber(key));
		}
		/**
		 * Prints an array as a comma delimited list, with the last element being preceded by a conjunction.
		 * As per ontario.ca content guidelines, there is no Oxford comma.
		 *
		 * @param {Array<any>} arr - The array that you wish to print.
		 * @param {Conjunction} conjunctionType - Whether you want the sentence to end with 'and value.' or 'or value.'
		 *
		 * @returns {string}
		 */
		function printArray(arr, conjunctionType = 'and') {
			return [...arr].reduce(
				(text, value, i, array) => text + (i < array.length - 1 ? ', ' : ` ${conjunctionType} `) + value,
			);
		}
		/**
		 * Grabs the HTML element of the page.
		 *
		 * More targetted than document.documentElement as the documentElement could
		 * in theory be any element that is the top level. e.g. <div> if the page is not
		 * set up to be semantically correct.
		 *
		 * @returns {HTMLElement}
		 */
		function getRootHTMLElement() {
			return document.getElementsByTagName('html')[0];
		}

		var BadgeColourToClass;
		(function (BadgeColourToClass) {
			BadgeColourToClass['teal'] = 'ontario-badge--default-heavy';
			BadgeColourToClass['lightTeal'] = 'ontario-badge--default-light';
			BadgeColourToClass['black'] = 'ontario-badge--neutral-heavy';
			BadgeColourToClass['grey'] = 'ontario-badge--neutral-light';
			BadgeColourToClass['red'] = 'ontario-badge--alert-heavy';
			BadgeColourToClass['yellow'] = 'ontario-badge--warning-heavy';
			BadgeColourToClass['green'] = 'ontario-badge--success-heavy';
			BadgeColourToClass['white'] = 'ontario-badge--white';
			BadgeColourToClass['darkGrey'] = 'ontario-badge--grey';
		})(BadgeColourToClass || (BadgeColourToClass = {}));
		const BadgeColours = retrieveEnumKeys(BadgeColourToClass);

		const ontarioBadgeCss =
			'.ontario-badge__container{display:flex;flex-direction:column;gap:2.5rem;align-items:flex-start;padding:1.5rem 1rem}.ontario-badge__label{display:block;text-align:left;font-weight:600;margin-bottom:0.75rem;font-size:0.875rem;color:#4d4d4d}.ontario-badge{display:inline-block;background-color:#E2F0F4;color:#4d4d4d;padding:0.25rem 0.5rem;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:700;line-height:1.5625rem;letter-spacing:0.03rem;text-transform:uppercase}.ontario-badge--default-light{background-color:#E2F0F4;color:#4d4d4d}.ontario-badge--default-heavy{background-color:#1080A6;color:#FFFFFF}.ontario-badge--neutral-light{background-color:#f2f2f2;color:#4d4d4d}.ontario-badge--neutral-heavy{background-color:#1a1a1a;color:#FFFFFF}.ontario-badge--alert-heavy{background-color:#CD0000;color:#FFFFFF}.ontario-badge--warning-heavy{background-color:#FFD440;color:#1a1a1a}.ontario-badge--success-heavy{background-color:#118847;color:#FFFFFF}.ontario-badge--white{background-color:#FFFFFF;color:#4d4d4d;border:0.0625rem solid #4d4d4d}.ontario-badge--grey{background-color:#cccccc;color:#1a1a1a}';

		class OntarioBadge {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			get host() {
				return getElement(this);
			}
			internals;
			/**
			 * The colour of the badge.
			 */
			colour = 'teal';
			/**
			 * The label for the badge.
			 *
			 * Offical guidance is to keep the label length within 15 characters.
			 */
			label;
			/**
			 * An aria label for screen readers.
			 *
			 * Used to provide more context to screen readers if necessary.
			 *
			 * This property is optional.
			 *
			 * @example
			 * <ontario-badge aria-label-text="This training is currently in progress.">In progress</ontario-badge>
			 */
			ariaLabelText;
			/**
			 * Watch for changes in the `label` prop for validation purposes.
			 *
			 * If no `label` value or host.textContent is provided, a warning message will be printed.
			 */
			validateLabel() {
				if (!this.getBadgeLabel()) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' a label ')
						.addRegularText('for')
						.addMonospaceText(' <ontario-badge> ')
						.addRegularText('was not provided.')
						.printMessage();
				}
			}
			/**
			 * Watch for changes to the `colour` prop.
			 *
			 * If no `colour` is passed, or if the `colour` does not match the `colour` options, a default value of 'teal' will be applied.
			 *
			 * @returns {BadgeColour}
			 */
			validateColour() {
				if (this.colour) {
					if (validateValueAgainstArray(this.colour, BadgeColours)) {
						return this.colour;
					} else {
						const message = new ConsoleMessageClass();
						message
							.addDesignSystemTag()
							.addMonospaceText(` colour ${this.colour} `)
							.addRegularText('for')
							.addMonospaceText(' <ontario-badge> ')
							.addRegularText(
								'does not match one of the valid colour types. A default colour of `teal` will be applied.',
							)
							.printMessage();
					}
				}
				return this.setBadgeColour('teal');
			}
			/**
			 * Programatically set and return the colour prop.
			 *
			 * @prop {BadgeColour} colour
			 *
			 * @returns {BadgeColour}
			 */
			setBadgeColour(colour) {
				this.colour = colour;
				return this.colour;
			}
			/**
			 * Returns badge label depending on if the label prop was set or
			 * if the host.textContent (text in-between the opening and closing tag) was set.
			 *
			 * The label prop takes priority.
			 *
			 * @returns {string | null}
			 */
			getBadgeLabel() {
				const badgeLabel = this.label ? this.label : this.host.textContent;
				return badgeLabel;
			}
			componentWillLoad() {
				this.validateColour();
				this.validateLabel();
			}
			render() {
				return hAsync(
					'span',
					{
						'key': '9fec2518bba42350d3bb2f744ae831d0bbc73265',
						'class': `ontario-badge ${BadgeColourToClass[this.colour]}`,
						'aria-label': this.ariaLabelText,
					},
					this.getBadgeLabel(),
				);
			}
			static get watchers() {
				return {
					label: ['validateLabel'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioBadgeCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-badge',
					$members$: {
						colour: [1025],
						label: [1],
						ariaLabelText: [1025, 'aria-label-text'],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioBlockquoteCss =
			'@charset "UTF-8";.ontario-blockquote{border-left:4px solid #4d4d4d;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1.1875rem;font-weight:400;letter-spacing:0.025rem;line-height:1.56;max-width:48rem;margin:2rem;padding:1.5rem 0 1.5rem 1.5rem;quotes:"" ""}@media screen and (max-width: 40em){.ontario-blockquote{font-size:1.125rem;letter-spacing:0.03rem;line-height:1.5;margin:1.5rem 0 2rem 0}}.ontario-blockquote p{margin:0 0 1.5rem 0}.ontario-blockquote p::before{content:open-quote}.ontario-blockquote p::after{content:close-quote}.ontario-blockquote--short{font-size:1.75rem;letter-spacing:0.02rem;line-height:1.5}@media screen and (max-width: 40em){.ontario-blockquote--short{font-size:1.4375rem;line-height:1.43}}.ontario-blockquote__attribution,.ontario-blockquote__byline{display:block;font-size:1rem;letter-spacing:0.025rem;line-height:1.56;text-align:right}@media screen and (max-width: 40em){.ontario-blockquote__attribution,.ontario-blockquote__byline{letter-spacing:0.03rem;line-height:1.5}}.ontario-blockquote__attribution{font-style:normal;font-weight:700}.ontario-blockquote__attribution::before{content:" "}html[lang=fr] blockquote{quotes:" " " "}';

		class OntarioBlockquote {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			get host() {
				return getElement(this);
			}
			/**
			 * Text to be displayed as the quote.
			 *
			 * Note that wrapping the quotes in quotations is not needed - this is handled through the component styles
			 */
			quote;
			/**
			 * Optional text to be displayed as the attribution (the author) of the quote.
			 */
			attribution;
			/**
			 * Optional text to be displayed for additional information about the attribution/author.
			 */
			byline;
			shortQuoteLength = 140;
			shortQuote = false;
			quoteState;
			/*
			 * Watch for changes in the `quote` prop for validation purposes.
			 *
			 * If the `quote` prop is not provided, set the `quote` prop to the host textContent (if it exists).
			 * If the `quote` prop length is 140 characters or less, set the `shortQuote` state to true - this will add additonal classes for the blockquote styles.
			 */
			validateQuote() {
				this.quoteState = this.quote ?? this.host.textContent ?? '';
				this.validateQuoteContent(this.quoteState);
				this.shortQuote = this.quoteState?.length <= this.shortQuoteLength ?? true;
			}
			/**
			 * Print the missing `quote` prop warning message
			 */
			validateQuoteContent(newValue) {
				if (validatePropExists(newValue)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' quote ')
						.addRegularText('for')
						.addMonospaceText(' <ontario-blockquote> ')
						.addRegularText('was not provided')
						.printMessage();
				}
			}
			componentWillLoad() {
				this.validateQuote();
			}
			/**
			 * This helper is used to help load translations for any slots + text content passed in by the user.
			 */
			componentDidLoad() {
				const observer = new MutationObserver((mutations) => {
					mutations.forEach((mutation) => {
						if (mutation.type === 'attributes') {
							this.validateQuote();
						}
					});
				});
				const options = { attributes: true };
				observer.observe(this.host, options);
			}
			render() {
				return hAsync(
					'blockquote',
					{
						key: '2ee572aa7d71ef844a7bb1fa544962339b19b5d0',
						class: this.shortQuote ? `ontario-blockquote ontario-blockquote--short` : `ontario-blockquote`,
					},
					hAsync('p', { key: 'edda8b3587f2eab9c8e06ee3fbc4162e980cc4a2' }, this.quoteState),
					this.attribution &&
						hAsync(
							'cite',
							{ key: '968f3739eae9fa5d5ae4a88462b8b23bc911e5c1', class: 'ontario-blockquote__attribution' },
							this.attribution,
						),
					this.byline &&
						hAsync(
							'cite',
							{ key: 'd6a8cd59764e78c64d0163f6a30f18ec215e32e9', class: 'ontario-blockquote__byline' },
							this.byline,
						),
				);
			}
			static get watchers() {
				return {
					quote: ['validateQuote'],
				};
			}
			static get style() {
				return ontarioBlockquoteCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-blockquote',
					$members$: {
						quote: [1025],
						attribution: [1],
						byline: [1],
						shortQuoteLength: [32],
						shortQuote: [32],
						quoteState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ButtonTypes = ['primary', 'secondary', 'tertiary', 'internalThemeDark'];
		const HtmlTypes = ['button', 'reset', 'submit'];

		const ontarioButtonCss =
			'.ontario-button:focus,.ontario-button:active{box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:box-shadow 0.1s ease-in-out}.ontario-button{border:none;border-radius:4px;box-sizing:border-box;box-shadow:none;display:inline-block;font-size:1.125rem;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-weight:600;line-height:1.5555555556;margin:0 1.75rem 1.5rem 0;min-width:10rem;padding:0.625rem 1.5rem;text-align:center;text-decoration:none;cursor:pointer}@media screen and (max-width: 40em){.ontario-button{margin-right:0;display:block;width:100%}}.ontario-button .ontario-icon{margin-right:4px}.ontario-button--primary{background-color:#0066CC;color:#FFFFFF}.ontario-button--primary:hover{background-color:#00478F;color:#FFFFFF}.ontario-button--primary:focus{background-color:#00478F;color:#FFFFFF;transition:background-color 0.2s ease-out, box-shadow 0.1s ease-in-out}.ontario-button--primary:active{background-color:#002142;color:#FFFFFF;transition:background-color 0s, box-shadow 0.1s ease-in-out}.ontario-button--primary:visited{color:#FFFFFF}.ontario-button--secondary{background-color:#FFFFFF;border:2px solid #0066CC;color:#0066CC;padding-top:0.5rem;padding-bottom:0.5rem}.ontario-button--secondary:hover{background-color:#e0f0ff;border-color:#00478F;color:#00478F}.ontario-button--secondary:focus{background-color:#e0f0ff;border-color:#00478F;color:#00478F;transition:background-color 0.2s ease-out, box-shadow 0.1s ease-in-out}.ontario-button--secondary:active{background-color:#c2e0ff;border-color:#002142;color:#002142;transition:background-color 0s, box-shadow 0.1s ease-in-out}.ontario-button--secondary:visited{color:#0066CC}.ontario-button--tertiary{background-color:transparent;color:#0066CC;text-decoration:underline}.ontario-button--tertiary:hover{background-color:#e8e8e8;color:#00478F;text-decoration:underline}.ontario-button--tertiary:focus{background-color:#e8e8e8;color:#00478F;text-decoration:underline;transition:background-color 0.2s ease-out, box-shadow 0.1s ease-in-out}.ontario-button--tertiary:active{background-color:#d1d1d1;color:#002142;text-decoration:underline;transition:background-color 0s, box-shadow 0.1s ease-in-out}.ontario-button--tertiary:visited{color:#0066CC}.ontario-button--internalThemeDark{background-color:#1a1a1a;border:2px solid #FFFFFF;color:#FFFFFF}.ontario-button--internalThemeDark:hover{background-color:#4d4d4d}.ontario-button--internalThemeDark:focus{background-color:#4d4d4d;transition:background-color 0.2s ease-out, box-shadow 0.1s ease-in-out}.ontario-button--internalThemeDark:active{background-color:#4d4d4d;transition:background-color 0s, box-shadow 0.1s ease-in-out}.ontario-button--internalThemeDark:visited{color:#0066CC}';

		class OntarioButton {
			constructor(hostRef) {
				registerInstance(this, hostRef);
				if (hostRef.$hostElement$['s-ei']) {
					this.internals = hostRef.$hostElement$['s-ei'];
				} else {
					this.internals = hostRef.$hostElement$.attachInternals();
					hostRef.$hostElement$['s-ei'] = this.internals;
				}
			}
			get host() {
				return getElement(this);
			}
			internals;
			/**
			 * The type of button to render.
			 *
			 * If no type is passed, it will default to 'secondary'.
			 */
			type = 'secondary';
			/**
			 * The native HTML button type the button should use.
			 *
			 * If no htmlType is passed, it will default to 'button'.
			 */
			htmlType = 'button';
			/**
			 * Text to be displayed within the button. This will override the text provided through the host element textContent.
			 *
			 * @example
			 * <ontario-button label="Label Text">Text</ontario-button>
			 *
			 * The resulting button will have the label `"Label Text"`.
			 */
			label;
			/**
			 * Provides more context as to what the button interaction is doing. This should only be used for accessibility purposes, if the button interaction requires more description than what the text provides.
			 *
			 *  This is optional.
			 *
			 * @example
			 * <ontario-button aria-label-text="Click button to open map">Open</ontario button>
			 */
			ariaLabelText;
			/**
			 * The unique identifier of the button. This is optional - if no ID is passed, one will be generated.
			 */
			elementId;
			/**
			 * Mutable variable, for internal use only.
			 * Set the button's type depending on validation result.
			 */
			typeState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the native HTML button type depending on validation result.
			 */
			htmlTypeState;
			labelState;
			/**
			 * A reference to the internal button element.
			 */
			buttonRef;
			/*
			 * Watch for changes to the `label` property for validation purposes.
			 *
			 * If  no `label` prop is provided, the `label` prop will be set to the host element textContent (if it exists).
			 */
			updateLabelContent() {
				this.labelState = this.label ?? this.host.textContent ?? '';
				this.validateLabelContent(this.labelState);
			}
			/**
			 * Watch for changes to the `type` property for validation purposes.
			 *
			 * If the user input doesn't match one of the array values then `type` will be set to its default (`secondary`).
			 * If a match is found in one of the array values then `type` will be set to the matching array key value.
			 */
			validateType() {
				const isValid = validateValueAgainstArray(this.type, ButtonTypes);
				this.typeState = isValid ? this.type : this.warnDefaultType();
			}
			/**
			 *  Watch for changes to the `htmlType` property for validation purposes.
			 *
			 * If the user input doesn't match one of the array values then `htmlType` will be set to its default (`submit`).
			 * If a match is found in one of the array values then `htmlType` will be set to the matching array key value.
			 */
			validateHtmlType() {
				const isValid = validateValueAgainstArray(this.htmlType, HtmlTypes);
				this.htmlTypeState = isValid ? this.htmlType : this.warnDefaultHtmlType();
			}
			/**
			 * Print the missing `label` prop warning message
			 */
			validateLabelContent(newValue) {
				if (validatePropExists(newValue)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' label ')
						.addRegularText('for')
						.addMonospaceText(' <ontario-button> ')
						.addRegularText('was not provided')
						.printMessage();
				}
			}
			/**
			 * Print the invalid `type` prop warning message
			 * @returns default type (secondary)
			 */
			warnDefaultType() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' type ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-button> ')
					.addRegularText('was set to an invalid type; only')
					.addMonospaceText(' primary, secondary, or tertiary ')
					.addRegularText('are supported. The default type')
					.addMonospaceText(' secondary ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'secondary';
			}
			/**
			 * Print the invalid `htmlType` warning message
			 * @returns default htmlType (button)
			 */
			warnDefaultHtmlType() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' htmlType ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-button> ')
					.addRegularText('was set to an invalid htmlType; only')
					.addMonospaceText(' button, reset, or submit ')
					.addRegularText('are supported. The default type')
					.addMonospaceText(' button ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'button';
			}
			/**
			 * @returns the classes of the button based of the button's `type`.
			 */
			getClass() {
				return `ontario-button ontario-button--${this.typeState}`;
			}
			getId() {
				return this.elementId ?? '';
			}
			/**
			 * Set `buttonId`, `label`, and `ariaLabel` using internal component logic.
			 */
			componentWillLoad() {
				this.updateLabelContent();
				this.validateHtmlType();
				this.validateType();
				this.ariaLabelText = this.ariaLabelText ?? this.labelState;
			}
			componentDidLoad() {
				// Used to help load translations for any slots + text content passed in by the user.
				const observer = new MutationObserver((mutations) => {
					mutations.forEach((mutation) => {
						if (mutation.type === 'attributes') {
							this.updateLabelContent();
						}
					});
				});
				const options = { attributes: true };
				observer.observe(this.host, options);
				// Add a click event listener to handle submitting a form
				if (this.htmlTypeState === 'submit') {
					this.buttonRef.addEventListener('click', () => {
						const { form } = this.internals;
						form?.requestSubmit();
					});
				}
			}
			render() {
				return hAsync(
					'button',
					{
						'key': '38158ea47d07a6da873acc3fba49ea3fecc534ce',
						'ref': (el) => (this.buttonRef = el),
						'type': this.htmlTypeState,
						'class': this.getClass(),
						'aria-label': this.ariaLabelText,
						'id': this.getId(),
					},
					this.labelState,
				);
			}
			static get formAssociated() {
				return true;
			}
			static get watchers() {
				return {
					label: ['updateLabelContent'],
					type: ['validateType'],
					htmlType: ['validateHtmlType'],
				};
			}
			static get style() {
				return ontarioButtonCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 73,
					$tagName$: 'ontario-button',
					$members$: {
						type: [1],
						htmlType: [1, 'html-type'],
						label: [1],
						ariaLabelText: [1025, 'aria-label-text'],
						elementId: [1025, 'element-id'],
						typeState: [32],
						htmlTypeState: [32],
						labelState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioCalloutCss =
			'@charset "UTF-8";h6,.ontario-h6,h5,.ontario-h5,h4,.ontario-h4,h3,.ontario-h3,h2,.ontario-h2,h1,.ontario-h1{font-style:normal;font-weight:700;text-rendering:optimizeLegibility;margin-bottom:1rem;font-feature-settings:normal;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif}h1,.ontario-h1{font-size:2rem;letter-spacing:0.04rem;line-height:1.29;margin:2.5rem 0 1.5rem 0;max-width:70rem}@media screen and (min-width: 40em){h1,.ontario-h1{font-size:2.5rem;letter-spacing:0.04rem;line-height:1.2}}h2,.ontario-h2{font-size:1.6875rem;letter-spacing:0.03rem;line-height:1.37;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h2,.ontario-h2{font-size:2.0625rem;letter-spacing:0.02rem;line-height:1.33}}h3,.ontario-h3{font-size:1.4375rem;letter-spacing:0.02rem;line-height:1.39;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h3,.ontario-h3{font-size:1.75rem;letter-spacing:0.02rem;line-height:1.43}}h4,.ontario-h4{font-size:1.25rem;letter-spacing:0.03rem;line-height:1.5;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h4,.ontario-h4{font-size:1.5rem;letter-spacing:0.0313rem;line-height:1.5}}h5,.ontario-h5{font-size:1.125rem;letter-spacing:0.03rem;line-height:1.56;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h5,.ontario-h5{font-size:1.1875rem;letter-spacing:0.025rem;line-height:1.5}}h6,.ontario-h6{font-size:1rem;line-height:1.56;letter-spacing:0.03rem;max-width:48rem;margin:0 0 0.75rem 0}@media screen and (min-width: 40em){h6,.ontario-h6{font-size:1rem;letter-spacing:0.025rem;line-height:1.5}}.ontario-lead-statement{font-size:1.25rem;line-height:1.6;max-width:70rem}@media screen and (min-width: 40em){.ontario-lead-statement{font-size:1.375rem}}html{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem}body{font-size:1rem;line-height:1.6;background-color:#FFFFFF;color:#1a1a1a;margin:0}p{font-size:inherit;margin-bottom:1.25rem;text-rendering:optimizeLegibility;margin:0 0 1.5rem 0}cite{font-style:italic;line-height:inherit}strong{font-weight:700;line-height:inherit}*,*::before,*::after{box-sizing:inherit}main p,main p:not(.ontario-lead-statement),main dd,main li{max-width:48rem}hr{border:0;padding:0;margin:2.5rem 0;border-bottom:4px solid #cccccc}hr.ontario-hr--dark{border-bottom:4px solid #1a1a1a}a{color:#0066CC;text-decoration:underline}a:visited{color:#551A8B}a:hover{color:#00478F}a:active{color:#002142}a:focus{-moz-box-shadow:0 0 0 4px #009ADB;-webkit-box-shadow:0 0 0 4px #009ADB;box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:all 0.1s ease-in-out}p{margin:0 0 1.5rem 0}p+h1,p+h2,p+h3,p+h4,p+h5,p+h6,ul+h1,ul+h2,ul+h3,ul+h4,ul+h5,ul+h6,ol+h1,ol+h2,ol+h3,ol+h4,ol+h5,ol+h6,h1+h2,h2+h3,h3+h4,h4+h5,h5+h6{margin-top:2rem}p code,td code,li code{line-height:2.25rem}input[type=text],input[type=number],input[type=email],input[type=date],input[type=color],input[type=search],input[type=tel],textarea{background-origin:initial;height:auto;-webkit-appearance:none;-moz-appearance:none}input[type=checkbox]+label,input[type=radio]+label{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400;margin-left:0;margin-right:0}fieldset{border:0;margin:0;padding:0;page-break-inside:avoid}legend,label{display:block;margin:0}select{background-origin:initial;height:auto;-webkit-appearance:none;-moz-appearance:none}ul,ol{padding:0}ul{margin-left:2rem}ul li{padding:0 0 0.75rem 0}ol{margin-left:1.75rem}ol li{padding:0 0 0.75rem 0.25rem}ul li:last-child,ol li:last-child{padding-bottom:0}ul[class*=columns-] li:last-child,ol[class*=columns-] li:last-child{padding-bottom:0.75rem}ul ul,ol ul{margin:0.5rem 0 0.5rem 2rem}ul ol,ol ol{margin:0.5rem 0 0.5rem 1.75rem}p+ul,p+ol{margin-top:-0.75rem}@media screen and (min-width: 40em){ul{margin:0.5rem 0 1.5rem 3rem}ol{margin:0.5rem 0 1.5rem 2.75rem}ul ul,ol ul{margin:0.5rem 0 0.5rem 3rem}ul ol,ol ol{margin:0.5rem 0 0.5rem 2.75rem}}.ontario-callout{border-left:0.25rem solid #367A76;padding:1.5rem;margin:2rem 0 2.5rem 0;background-color:#f2f2f2}.ontario-callout *{max-width:48rem}.ontario-callout *:last-child{margin-bottom:0.5rem}.ontario-callout__title{margin:0 0 1rem}.ontario-border-highlight--teal{border-color:#367A76 !important}.ontario-border-highlight--gold{border-color:#86743D !important}.ontario-border-highlight--yellow{border-color:#8A600D !important}.ontario-border-highlight--taupe{border-color:#7B725C !important}.ontario-border-highlight--green{border-color:#2B8737 !important}.ontario-border-highlight--lime{border-color:#5F8129 !important}.ontario-border-highlight--sky{border-color:#1080A6 !important}.ontario-border-highlight--blue{border-color:#0369ac !important}.ontario-border-highlight--purple{border-color:#92278F !important}';

		class OntarioCallout {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The heading level of the callout heading.
			 */
			headingType;
			/**
			 * The type of the heading content. If no prop is passed, it will default to `string`.
			 */
			headingContentType = 'string';
			/**
			 * Text or HTML to be displayed as the heading of the callout. If the heading content should be displayed as HTML, the `headingContentType` needs to be set to `html`.
			 */
			headingContent;
			/**
			 * Optional text to be displayed as the content for the callout component. If a string is passed, it will automatically be nested in a paragraph tag.
			 *
			 * HTML content can also be passed as the child/children of the callout component if additional/different elements for the content are needed.
			 *
			 * @example
			 * <ontario-callout headingType='h3' headingContent='This is the callout heading'><p>This is the first sentence of the callout content.</p><p>This is the second sentence of the callout content.</p></ontario-callout>
			 */
			content;
			/**
			 * Optional prop to choose the border colour of the callout. If none is passed, the default colour will be teal.
			 */
			highlightColour = 'teal';
			/**
			 * Watch for changes to the `headingType` prop.
			 * This is for validation purposes to make sure the `headingType` matches one of the `HeadingLevelOptions`.
			 */
			validateHeadingType() {
				if (!!this.headingType) {
					if (isValidHeadingLevel(this.headingType)) return this.headingType;
					const message = new ConsoleMessageClass();
					return message
						.addDesignSystemTag()
						.addMonospaceText(` headingType ${this.headingType} `)
						.addRegularText('for')
						.addMonospaceText(' <ontario-callout> ')
						.addRegularText(
							'is not a valid type. Please ensure your heading type matches one of the headingType types.',
						)
						.printMessage();
				}
			}
			/**
			 * Watch for changes in the `headingContentType` variable for validation purposes.
			 *
			 * If the user input doesn't match one of the array values then `headingContentType` will be set to its default (`string`).
			 * If a match is found in one of the array values then `headingContentType` will be set to the matching array key value.
			 */
			validateHeadingContentType() {
				const isValid = validateValueAgainstArray(this.headingContentType, HeadingContentTypes);
				if (isValid) {
					return this.headingContentType;
				} else {
					return this.warnDefaultType();
				}
			}
			/**
			 * Watch for changes to the `highlightColour` prop.
			 *
			 * If no `highlightColour` is passed, or if the `highlightColour` does not match the `highlightColour` options, a default value of 'teal' will be applied.
			 */
			validateHighlightColour() {
				if (this.highlightColour) {
					if (isValidHighlightColour(this.highlightColour)) return this.highlightColour;
					else {
						const message = new ConsoleMessageClass();
						message
							.addDesignSystemTag()
							.addMonospaceText(` highlightColour ${this.highlightColour} `)
							.addRegularText('for')
							.addMonospaceText(' <ontario-callout> ')
							.addRegularText(
								'does not match one of the valid highlightColour types. A default colour of `teal` will be applied.',
							)
							.printMessage();
					}
				}
				// if no highlight colour is passed, return 'teal'
				return 'teal';
			}
			/**
			 * Print the invalid `type` warning message.
			 * @returns default type ('string')
			 */
			warnDefaultType() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' headingContentType ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-callout> ')
					.addRegularText('was set to an invalid type; only')
					.addMonospaceText(' string or html ')
					.addRegularText('are supported. The default type')
					.addMonospaceText(' string ')
					.addRegularText('is assumed.')
					.printMessage();
				return (this.headingContentType = 'string');
			}
			componentWillLoad() {
				this.validateHighlightColour();
				this.validateHeadingType();
				this.validateHeadingContentType();
			}
			render() {
				return generateCalloutAside(
					'callout',
					this.headingContentType,
					this.headingType,
					this.headingContent,
					this.content,
					this.highlightColour,
				);
			}
			static get watchers() {
				return {
					headingType: ['validateHeadingType'],
					headingContentType: ['validateHeadingContentType'],
					highlightColour: ['validateHighlightColour'],
				};
			}
			static get style() {
				return ontarioCalloutCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-callout',
					$members$: {
						headingType: [1025, 'heading-type'],
						headingContentType: [1025, 'heading-content-type'],
						headingContent: [1, 'heading-content'],
						content: [1],
						highlightColour: [1025, 'highlight-colour'],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const layoutDirectionDefinitions = ['vertical', 'horizontal'];
		const headerColourDefinitions = [
			'dark-accent',
			'light-accent',
			'light-gold',
			'light-yellow',
			'light-taupe',
			'light-green',
			'light-lime',
			'light-teal',
			'light-sky',
			'light-blue',
			'light-purple',
			'light-orange',
			'light-red',
			'light-magenta',
			'gold',
			'yellow',
			'taupe',
			'green',
			'lime',
			'teal',
			'sky',
			'blue',
			'purple',
			'orange',
			'red',
			'magenta',
		];

		const headingLevelDefinitions = ['h2', 'h3', 'h4', 'h5', 'h6'];

		const ontarioCardCss =
			'.ontario-card__heading{font-style:normal;font-weight:700;text-rendering:optimizeLegibility;margin-bottom:1rem;font-feature-settings:normal;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif}.ontario-card__heading{font-size:1.25rem;letter-spacing:0.03rem;line-height:1.5;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){.ontario-card__heading{font-size:1.5rem;letter-spacing:0.0313rem;line-height:1.5}}.ontario-card{box-shadow:0rem 0.1875rem 0.5rem 0.0625rem rgba(0, 0, 0, 0.4);border-radius:4px;margin-bottom:2.5rem;padding:0;height:calc(100% - 2.5rem);list-style-type:none;transition:all 0.3s ease-in-out;position:relative;cursor:pointer;background:#FFFFFF}.ontario-card:hover{box-shadow:0rem 0.375rem 0.75rem 0.125rem rgba(0, 0, 0, 0.35)}.ontario-card:focus-within{box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:box-shadow 0.1s ease-in-out}.ontario-card:active{box-shadow:0 0 0 4px #009ADB;background-color:#f2f2f2}@media screen and (max-width: 40em){.ontario-card{margin-bottom:3rem;width:100% !important;max-width:100%}}.ontario-card--image-true{margin-top:-0.5rem}.ontario-card__card-type--horizontal .ontario-card--image-true{margin-top:0}.ontario-card__card-type--horizontal{display:flex}@media screen and (max-width: 40em){.ontario-card__card-type--horizontal{width:100%;max-width:100%}}.ontario-card__card-type--horizontal .ontario-card__image-container,.ontario-card__card-type--horizontal .ontario-card__text-container{position:relative}.ontario-card__card-type--horizontal .ontario-card__heading{border-radius:0}.ontario-card__card-type--horizontal a:focus-within{box-shadow:none;outline:none}.ontario-card__card-type--horizontal a:active{box-shadow:none}.ontario-card__card-type--horizontal img{height:100%;position:absolute}.ontario-card__image-right{flex-direction:row-reverse}.ontario-card__heading{margin:0;border-radius:4px 4px 0 0;padding:1.25rem 1.5rem 0.5rem 1.5rem;transition:text-decoration 0.3s ease-in-out;background-color:#FFFFFF;max-width:none}.ontario-card:hover .ontario-card__heading{text-decoration-line:underline;text-decoration-color:#1a1a1a}.ontario-card--image-true .ontario-card__heading{border-radius:0}.ontario-card__image-right .ontario-card--image-true .ontario-card__heading{border-radius:4px 0 0 0}.ontario-card__image-left .ontario-card--image-true .ontario-card__heading{border-radius:0 4px 0 0}.ontario-card__heading a{color:#1a1a1a;text-decoration:none;outline:none}.ontario-card__heading a::after{content:"";position:absolute;left:0;top:0;right:0;bottom:0}.ontario-card__heading a:focus{box-shadow:none}.ontario-card__heading a:active{outline:none}@media screen and (max-width: 73em){.ontario-card__heading{font-size:1.25rem;padding-left:1rem;padding-right:1rem}}.ontario-card__background--light-accent{background-color:#f2f2f2}.ontario-card__heading--light-accent{background-color:#f2f2f2;padding-top:1rem;padding-bottom:1rem}.ontario-card__background--dark-accent{background-color:#1a1a1a}.ontario-card__heading--dark-accent{background-color:#1a1a1a;padding-top:1rem;padding-bottom:1rem}.ontario-card__background--light-gold{background-color:#F0E7CC}.ontario-card__heading--light-gold{background-color:#F0E7CC;padding-top:1rem;padding-bottom:1rem}.ontario-card__background--light-yellow{background-color:#F8E5C3}.ontario-card__heading--light-yellow{background-color:#F8E5C3;padding-top:1rem;padding-bottom:1rem}.ontario-card__background--light-taupe{background-color:#EBE7DB}.ontario-card__heading--light-taupe{background-color:#EBE7DB;padding-top:1rem;padding-bottom:1rem}.ontario-card__background--light-green{background-color:#D1EFD4}.ontario-card__heading--light-green{background-color:#D1EFD4;padding-top:1rem;padding-bottom:1rem}.ontario-card__background--light-lime{background-color:#DDEDC7}.ontario-card__heading--light-lime{background-color:#DDEDC7;padding-top:1rem;padding-bottom:1rem}.ontario-card__background--light-teal{background-color:#CFEDED}.ontario-card__heading--light-teal{background-color:#CFEDED;padding-top:1rem;padding-bottom:1rem}.ontario-card__background--light-sky{background-color:#C5EEFA}.ontario-card__heading--light-sky{background-color:#C5EEFA;padding-top:1rem;padding-bottom:1rem}.ontario-card__background--light-purple{background-color:#F1E3F2}.ontario-card__heading--light-purple{background-color:#F1E3F2;padding-top:1rem;padding-bottom:1rem}.ontario-card__background--light-orange{background-color:#FEE1D9}.ontario-card__heading--light-orange{background-color:#FEE1D9;padding-top:1rem;padding-bottom:1rem}.ontario-card__background--light-red{background-color:#FFE0E2}.ontario-card__heading--light-red{background-color:#FFE0E2;padding-top:1rem;padding-bottom:1rem}.ontario-card__background--light-magenta{background-color:#FEDFF0}.ontario-card__heading--light-magenta{background-color:#FEDFF0;padding-top:1rem;padding-bottom:1rem}.ontario-card__background--gold{background-color:#CBA52E}.ontario-card__heading--gold{background-color:#CBA52E;padding-top:1rem;padding-bottom:1rem}.ontario-card__background--yellow{background-color:#FCAF17}.ontario-card__heading--yellow{background-color:#FCAF17;padding-top:1rem;padding-bottom:1rem}.ontario-card__background--taupe{background-color:#C1B28F}.ontario-card__heading--taupe{background-color:#C1B28F;padding-top:1rem;padding-bottom:1rem}.ontario-card__background--green{background-color:#39B54A}.ontario-card__heading--green{background-color:#39B54A;padding-top:1rem;padding-bottom:1rem}.ontario-card__background--lime{background-color:#8DC63F}.ontario-card__heading--lime{background-color:#8DC63F;padding-top:1rem;padding-bottom:1rem}.ontario-card__background--teal{background-color:#49A7A2}.ontario-card__heading--teal{background-color:#49A7A2;padding-top:1rem;padding-bottom:1rem}.ontario-card__background--sky{background-color:#00B2E3}.ontario-card__heading--sky{background-color:#00B2E3;padding-top:1rem;padding-bottom:1rem}.ontario-card__background--purple{background-color:#B975B7}.ontario-card__heading--purple{background-color:#B975B7;padding-top:1rem;padding-bottom:1rem}.ontario-card__background--orange{background-color:#F15A22}.ontario-card__heading--orange{background-color:#F15A22;padding-top:1rem;padding-bottom:1rem}.ontario-card__background--red{background-color:#F0454B}.ontario-card__heading--red{background-color:#F0454B;padding-top:1rem;padding-bottom:1rem}.ontario-card__background--magenta{background-color:#F03093}.ontario-card__heading--magenta{background-color:#F03093;padding-top:1rem;padding-bottom:1rem}.ontario-card__card-type--horizontal .ontario-card__text-container{width:66.6666666667%}.ontario-card__image-size-one-fourth .ontario-card__text-container{width:75%}.ontario-card--no-image .ontario-card__text-container{width:100%}.ontario-card__description{margin:0;padding:0.5rem 1.5rem 1.5rem 1.5rem;background-color:#FFFFFF;border-bottom-left-radius:4px;border-bottom-right-radius:4px}.ontario-card__description p{margin-top:0}.ontario-card__description p:last-of-type{margin-bottom:0}@media screen and (max-width: 73em){.ontario-card__description{padding:0.5rem 1rem 1.5rem 1rem}}.ontario-card--position-vertical .ontario-card__image-container{margin-bottom:-0.5rem}.ontario-card__card-type--horizontal .ontario-card__image-container{width:33.3%}.ontario-card__image-size-one-fourth .ontario-card__image-container{width:25%}.ontario-card__image{width:100%;height:100%;object-fit:cover;background-size:100% 100%}.ontario-card--position-vertical .ontario-card__image{border-top-left-radius:4px;border-top-right-radius:4px}.ontario-card__image-right .ontario-card__image{border-top-right-radius:4px;border-bottom-right-radius:4px}.ontario-card__image-left .ontario-card__image{border-top-left-radius:4px;border-bottom-left-radius:4px}';

		class OntarioCard {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			get host() {
				return getElement(this);
			}
			/**
			 * Text to be displayed within the header.
			 *
			 * @example
			 *	<ontario-card
			 *		header-type="dark"
			 *		card-type="horizontal"
			 *		label="Card Title 1"
			 *		description="Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum"
			 *	>
			 */
			label;
			/**
			 * The heading level that the label will be rendered as.
			 *
			 * @example
			 *	<ontario-card
			 *		heading-level="h4"
			 *		label="Card Title 1"
			 *	>
			 */
			headingLevel = 'h2';
			/**
			 * Image to be displayed within the card image container.
			 *
			 * This is optional.
			 */
			image;
			/**
			 * Alt text for the card's image.
			 *
			 * This is optional prop, but may be required for an
			 * image due to accessibility requirements.
			 *
			 * You can find guidance on when to add alt text to an image
			 * on the Ontario.ca web content editing guide.
			 *
			 * https://www.ontario.ca/page/ontario-ca-web-content-editing-guide#alt-text-image-accessibility
			 *
			 * Note: This should default to an empty string ('') to ensure the alt attribute appears in the markup
			 * for decorative images. If left as undefined, the alt attribute will not render in markup.
			 */
			imageAltText = '';
			/**
			 * Text to be displayed within the card description container.
			 *
			 * This is optional.
			 */
			description;
			/**
			 * Action link for when the card is clicked.
			 *
			 * This is optional.
			 */
			cardLink;
			/**
			 * The layout direction/orientation of the card.
			 *
			 * If no type is passed, it will default to 'vertical'.
			 *
			 */
			layoutDirection = 'vertical';
			/**
			 * Set the card's header colour.
			 *
			 * This is optional.
			 */
			headerColour;
			/**
			 * The position of the image when the card-type is set to 'horizontal'.
			 *
			 * This prop is only necessry when the card-type is set to 'horizontal'.
			 *
			 * @example
			 * 	<ontario-card
			 *		card-type="horizontal"
			 *		label="Card Title 1"
			 *		image="https://picsum.photos/200/300"
			 *		horizontal-image-position-type="left"
			 *		horizontal-image-size-type="one-fourth"
			 *	  description="Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum"
			 *	>
			 *	</ontario-card>
			 */
			horizontalImagePositionType = 'left';
			/**
			 * The size of the image when the card-type is set to 'horizontal'.
			 *
			 * This prop is only necessry when the card-type is set to 'horizontal'.
			 *
			 * @example
			 * 	<ontario-card
			 *		card-type="horizontal"
			 *		label="Card Title 1"
			 *		image="https://picsum.photos/200/300"
			 *		horizontal-image-position-type="left"
			 *		horizontal-image-size-type="one-fourth"
			 *	  description="Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum"
			 *	>
			 *	</ontario-card>
			 */
			horizontalImageSizeType = 'one-third';
			/**
			 * Provides more context as to what the card interaction is doing. This should only be used for accessibility purposes, if the card interaction requires more * * description than what the text provides.
			 *
			 * This is optional.
			 *
			 */
			ariaLabelText;
			cardState = {
				headerColour: undefined,
				headingLevel: undefined,
				layoutDirection: undefined,
			};
			/**
			 * Watch for changes to the `layoutDirection` property for validation purposes.
			 *
			 * If the user input doesn't match one of the array values then `layoutDirection` will be set to its default (`vertical`).
			 * If a match is found in one of the array values then `cardState.layoutDirection` will be set to the matching array key value.
			 */
			validateLayoutDirection() {
				const isValid =
					this.layoutDirection && validateValueAgainstArray(this.layoutDirection, layoutDirectionDefinitions);
				if (!isValid) {
					this.printPropWarning(
						'layout-direction',
						'<ontario-card>',
						this.layoutDirection,
						layoutDirectionDefinitions,
						'vertical',
					);
					this.updateCardState('layoutDirection', 'vertical');
					return;
				}
				this.updateCardState('layoutDirection', this.layoutDirection);
			}
			/**
			 * Watch for changes to the `headingLevel` property for validation purposes.
			 *
			 * If the user input doesn't match one of the array values then `headingLevel` will be set to its default (`h2`).
			 *
			 * If a match is found in one of the array values then `headingLevel` will be set to the matching array key value.
			 */
			validateHeadingLevel() {
				const isValid = this.headingLevel && validateValueAgainstArray(this.headingLevel, headingLevelDefinitions);
				if (!isValid) {
					this.printPropWarning('heading-level', '<ontario-card>', this.headingLevel, headingLevelDefinitions, 'h2');
					this.updateCardState('headingLevel', 'h2');
					return;
				}
				this.updateCardState('headingLevel', this.headingLevel);
			}
			/**
			 * Watch for changes to the `headerColour` property for validation purposes.
			 *
			 * If the user input doesn't match one of the array values then `headerColour` will be kept empty (undefined).
			 * If a match is found in one of the array values then `headerColour` will be set to the matching array key value.
			 */
			validateHeaderColour() {
				const isValid = this.headerColour && validateValueAgainstArray(this.headerColour, headerColourDefinitions);
				if (!isValid && this.headerColour !== undefined) {
					this.printPropWarning(
						'header-colour',
						'<ontario-card>',
						this.headerColour,
						headerColourDefinitions,
						'undefined',
					);
					this.updateCardState('headerColour', undefined);
					return;
				}
				this.updateCardState('headerColour', this.headerColour);
			}
			/**
			 * Print an invalid prop warning message.
			 *
			 * @param {string} propName - Name of the prop
			 * @param {string} component - Component the error is on e.g. <ontario-card>
			 * @param {any} propValue - Value of the prop
			 * @param {readonly any[]} acceptableValues  - readonly array of acceptable prop values
			 * @param {string} defaultValue - Stringified representation of the value that the corresponding State Object value will default to
			 */
			printPropWarning(propName, component, propValue, acceptableValues, defaultValue) {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(` ${propName} `)
					.addRegularText('on')
					.addMonospaceText(` ${component} `)
					.addRegularText('was set to an invalid value of ')
					.addMonospaceText(` ${propValue} `)
					.addRegularText('. Only ')
					.addMonospaceText(printArray([...acceptableValues]))
					.addRegularText(' are supported values. The default value of')
					.addMonospaceText(` ${defaultValue} `)
					.addRegularText('is assumed.')
					.printMessage();
			}
			/**
			 * Update a key within the State Object with a value.
			 *
			 * Note: When state is represented as an object, and values are changed, the entire object needs to be rebuilt.
			 * If only the corresponding object key/value is updated, corresponding render changes may not happen.
			 *
			 * @param {keyof CardState} key - Should match a key found within `CardState`.
			 * @param {any} value - Should match the value type associated to the key within `CardState`.
			 */
			updateCardState(key, value) {
				const cardStateCopy = { ...this.cardState };
				cardStateCopy[key] = value;
				this.cardState = cardStateCopy;
			}
			/**
			 * Returns the top level classes of the card.
			 *
			 * @returns {string}
			 */
			getCardClasses() {
				const baseClass =
					this.cardState.layoutDirection === 'horizontal'
						? `ontario-card ontario-card__card-type--${this.cardState.layoutDirection} ontario-card__image-${this.horizontalImagePositionType} ontario-card__image-size-${this.horizontalImageSizeType}`
						: `ontario-card ontario-card__card-type--basic ontario-card--position-${this.cardState.layoutDirection}`;
				const descriptionClass = this.description ? '' : ' ontario-card__description-false';
				const backgroundClass =
					this.headerColour && !this.description ? `ontario-card__background--${this.headerColour}` : '';
				return `${baseClass} ${descriptionClass} ${backgroundClass}`.trim();
			}
			/**
			 * Returns the heading classes of the card.
			 *
			 * @returns {string}
			 */
			getCardHeadingClasses() {
				const baseClass = 'ontario-card__heading';
				const backgroundClass = this.cardState.headerColour
					? `ontario-card__heading--${this.cardState.headerColour}`
					: '';
				return `${baseClass} ${backgroundClass}`.trim();
			}
			/**
			 * Returns the url that the card links to.
			 *
			 * @returns {string}
			 */
			getHref() {
				return this.cardLink ? this.cardLink : '#';
			}
			/**
			 * Component life cycle hook.
			 *
			 * https://stenciljs.com/docs/component-lifecycle#connectedcallback
			 */
			componentWillLoad() {
				this.validateLayoutDirection();
				this.validateHeadingLevel();
				this.validateHeaderColour();
			}
			render() {
				return hAsync(
					'li',
					{ key: '2491546d5c8cd802237264110f6af2635c9fd2f3', class: this.getCardClasses() },
					this.image &&
						hAsync(
							'div',
							{ key: 'e2c66a5844d5dc92422bb40e7df02dec8951c574', class: 'ontario-card__image-container' },
							hAsync(
								'a',
								{
									'key': '14146da6cc4600e8ab54bd246e0655d3828cdae0',
									'href': this.getHref(),
									'aria-label': this.ariaLabelText,
								},
								hAsync('img', {
									key: '7b80dc691d2a323b5d0078c9c7ef93e96b073367',
									class: 'ontario-card__image',
									alt: this.imageAltText,
									src: this.image,
								}),
							),
						),
					hAsync(
						'div',
						{
							key: '78dd72f3673fc4528660fc24361df6509ed8e4b9',
							class: `ontario-card__text-container ${this.image ? 'ontario-card--image-true' : ''}`,
						},
						hAsync(
							this.cardState.headingLevel, //tag
							{ className: this.getCardHeadingClasses() }, //attributes
							hAsync('a', { 'href': this.getHref(), 'aria-label': this.ariaLabelText }, this.label),
						),
						this.description &&
							hAsync(
								'div',
								{ key: 'f7dad07c4e39806379e3cdbd63d4edcc913859f9', class: 'ontario-card__description' },
								hAsync('p', { key: 'ae429b791a870a174ad39610fd12d426fdb382cd' }, this.description),
							),
					),
				);
			}
			static get watchers() {
				return {
					layoutDirection: ['validateLayoutDirection'],
					headingLevel: ['validateHeadingLevel'],
					headerColour: ['validateHeaderColour'],
				};
			}
			static get style() {
				return ontarioCardCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-card',
					$members$: {
						label: [1],
						headingLevel: [1, 'heading-level'],
						image: [1],
						imageAltText: [1, 'image-alt-text'],
						description: [1],
						cardLink: [1, 'card-link'],
						layoutDirection: [1, 'layout-direction'],
						headerColour: [1, 'header-colour'],
						horizontalImagePositionType: [1, 'horizontal-image-position-type'],
						horizontalImageSizeType: [1, 'horizontal-image-size-type'],
						ariaLabelText: [1, 'aria-label-text'],
						cardState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioCardCollectionCss =
			'.ontario-card-collection__container{display:flex;flex-wrap:wrap;gap:2rem;margin:0;padding:0}.ontario-card-collecton--cards-per-row-4 ::slotted(ontario-card){width:calc(25% - 1.5rem)}@media screen and (max-width: 73em){.ontario-card-collecton--cards-per-row-4 ::slotted(ontario-card){width:calc(50% - 1rem)}}@media screen and (max-width: 40em){.ontario-card-collecton--cards-per-row-4 ::slotted(ontario-card){width:100%}}.ontario-card-collecton--cards-per-row-3 ::slotted(ontario-card){width:calc(33.3% - 1.33rem)}@media screen and (max-width: 40em){.ontario-card-collecton--cards-per-row-3 ::slotted(ontario-card){width:100%}}.ontario-card-collecton--cards-per-row-2 ::slotted(ontario-card){width:calc(50% - 1rem)}@media screen and (max-width: 40em){.ontario-card-collecton--cards-per-row-2 ::slotted(ontario-card){width:100%}}';

		class OntarioCardCollection {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			get host() {
				return getElement(this);
			}
			/**
			 * The number of cards to display per row.
			 *
			 * If no number is passed, it will default to 3.
			 */
			cardsPerRow = 3;
			/**
			 * Mutable variable, for internal use only.
			 *
			 * Set number of cards per row depending on validation result.
			 */
			cardsPerRowState;
			/**
			 * Watch for changes to the `cardsPerRow` property for validation purposes.
			 *
			 * If the user input is not a number or is a negative number then `cardsPerRow` will be set to its default (3).
			 */
			validateCardsPerRow() {
				if (isNaN(this.cardsPerRow) || (!isNaN(this.cardsPerRow) && this.cardsPerRow <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' cards-per-row ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-card> ')
						.addRegularText(
							`${isNaN(this.cardsPerRow) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default number of cards per row: `,
						)
						.addMonospaceText(' 3 ')
						.addRegularText('was assumed.')
						.printMessage();
					this.cardsPerRowState = 3;
				} else {
					this.cardsPerRowState = this.cardsPerRow;
				}
			}
			/**
			 * @returns the classes of the ontario cards based off the `cardType` and number of cards per row.
			 */
			getClass() {
				return `
      ontario-card-collection__container
      ontario-card-collecton--cards-per-row-${this.cardsPerRowState}
    `.trim();
			}
			componentWillLoad() {
				this.validateCardsPerRow();
			}
			render() {
				return hAsync(
					'ul',
					{ key: '8991908dd16580e556964b37009bb25ad547232a', class: this.getClass() },
					hAsync('slot', { key: 'f75f012338edd1a94ed1c5b3d197a9b909b36250' }),
				);
			}
			static get watchers() {
				return {
					cardsPerRow: ['validateCardsPerRow'],
				};
			}
			static get style() {
				return ontarioCardCollectionCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-card-collection',
					$members$: {
						cardsPerRow: [2, 'cards-per-row'],
						cardsPerRowState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const Input$1 = ({
			autoComplete,
			className,
			id,
			name,
			placeholder,
			type,
			value,
			checked,
			required,
			onKeyDown,
			onInput,
			onChange,
			onBlur,
			onFocus,
			onClick,
			ariaInvalid,
			ariaDescribedBy,
			ref,
			inputMode,
			...props
		}) => {
			return hAsync('input', {
				'autoComplete': autoComplete,
				'class': className,
				'id': id,
				'name': name,
				'type': type,
				'value': value,
				'checked': checked,
				'placeholder': placeholder,
				'required': !!required,
				'onKeyDown': onKeyDown,
				'onInput': onInput,
				'onChange': onChange,
				'onBlur': onBlur,
				'onFocus': onFocus,
				'onClick': onClick,
				'inputMode': inputMode,
				'ref': ref,
				'aria-invalid': ariaInvalid,
				'aria-describedby': ariaDescribedBy,
				...props,
			});
		};

		const CaptionTypes = ['default', 'large', 'heading'];

		var MessageContentType;
		(function (MessageContentType) {
			MessageContentType['UndefinedCaptionObject'] = 'undefinedCaptionObject';
			MessageContentType['UndefinedCaptionText'] = 'undefinedCaption';
			MessageContentType['EmptyCaptionText'] = 'emptyCaption';
			MessageContentType['UndefinedCaptionType'] = 'undefinedCaptionType';
			MessageContentType['IncorrectCaptionType'] = 'incorrectCaptionType';
		})(MessageContentType || (MessageContentType = {}));

		class InputCaption {
			/**
			 * The text to display as caption.
			 */
			captionText;
			/**
			 * The type of caption to render.
			 */
			captionType = 'default';
			/**
			 * Determine whether the input field is required.
			 */
			required = false;
			/**
			 * Determine whether the rendered element is a `<label>` or `<legend>`.
			 */
			isLegend = false;
			/**
			 * Name of the component instantiating the class.
			 * This is used for validation warning message.
			 */
			componentTagName;
			language = 'en';
			translations;
			/**
			 * Set the class members
			 * Output a console warning message if the provided `label` type is incorrect
			 * @param caption object containing the essential data to configure the input label
			 */
			constructor(componentTagName, caption, translations, language, isLegend = false, required = false) {
				let captionObject;
				if (typeof caption === 'string') {
					try {
						captionObject = JSON.parse(caption);
					} catch {
						captionObject = { captionText: caption, captionType: 'default' };
					}
				} else {
					captionObject = caption;
				}
				this.componentTagName = componentTagName.toLocaleLowerCase();
				this.captionText = captionObject?.captionText;
				this.captionType =
					(captionObject?.captionType &&
						CaptionTypes.find((type) => type === captionObject.captionType?.toLowerCase())) ||
					'default';
				this.required = required;
				this.isLegend = isLegend;
				this.translations = translations;
				this.language = language;
				this.validateCaption(this);
			}
			/**
			 * Return the `<label>` element for text inputs
			 * @param captionFor Set the `htmlFor` attribute
			 * @param hasHintExpander Indicate whether the component the label is for has a hint expander or not
			 * @param disableRequiredFlag Disable the required/optional label text _(only use in highly special cases)_
			 * @returns element containing the caption for the input
			 */
			getCaption = (captionFor, hasHintExpander = false, disableRequiredFlag = false) => {
				const captionText = this.captionText && this.captionText.toLowerCase();
				const captionContent = this.isLegend
					? hAsync(
							'legend',
							{ class: this.getClass() },
							this.captionType === 'heading' ? hAsync('h1', null, this.captionText) : this.captionText,
							!disableRequiredFlag && this.getRequiredFlagElement(),
							hasHintExpander && this.getHintExpanderAccessibilityText(captionText, false),
						)
					: hAsync(
							'label',
							{ htmlFor: captionFor, class: this.getClass() },
							this.captionText,
							!disableRequiredFlag && this.getRequiredFlagElement(),
							hasHintExpander && this.getHintExpanderAccessibilityText(captionText, false),
						);
				// with `this.captionType` already set to one of the enum values, the comparison no longer needs the `toLowerCase()` transform
				return this.captionType === 'heading' && !this.isLegend ? hAsync('h1', null, captionContent) : captionContent;
			};
			getHintExpanderAccessibilityText(captionText, hasHintExpanderOnOption = false) {
				const multipleOptionsMessage = hAsync(
					'span',
					{ class: 'ontario-show-for-sr' },
					this.translations.accessibility.moreInfo[this.language],
					' "',
					captionText.toLowerCase(),
					'"',
					' ',
					this.translations.accessibility.checkboxHintExpander[this.language],
				);
				const singleOptionMessage = hAsync(
					'span',
					{ class: 'ontario-show-for-sr' },
					this.translations.accessibility.moreInfo[this.language],
					' "',
					captionText.toLowerCase(),
					'"',
					' ',
					this.translations.accessibility.singleHintExpander[this.language],
				);
				return this.componentTagName === 'ontario-checkboxes'
					? !hasHintExpanderOnOption
						? multipleOptionsMessage
						: singleOptionMessage
					: singleOptionMessage;
			}
			/**
			 * Determines which flag text to use between `required` and `optional`
			 * @returns `required` or `optional` flag text
			 */
			getRequiredFlagText() {
				return this.required
					? this.translations && `(${this.translations.required[this.language]})`
					: this.translations && `(${this.translations.optional[this.language]})`;
			}
			/**
			 * Get the HTML for the required/optional flag.
			 * @returns CSS class for the label/legend.
			 */
			getRequiredFlagElement() {
				return hAsync('span', { class: 'ontario-label__flag' }, this.getRequiredFlagText());
			}
			/**
			 * Get the CSS class for the `label` element.
			 * @returns CSS class for the `label` element.
			 */
			getClass() {
				return this.captionType === 'large' || this.captionType === 'heading'
					? this.isLegend
						? `ontario-fieldset__legend ontario-fieldset__legend--${this.captionType}`
						: `ontario-label ontario-label--${this.captionType}`
					: this.isLegend
						? 'ontario-fieldset__legend'
						: 'ontario-label';
			}
			/**
			 * Validate caption input by user and output warning message to the console if:
			 * 1. the `caption` object is not provided
			 * 2. the `captionText` property of the `caption` object is not provided
			 * 3. the `captionText` property of the `caption` object is empty or contain only spaces
			 * 4. the `captionType` property of the `caption` object is not provided
			 * 5. the `captionType` property of the `caption` object is incorrect
			 */
			validateCaption(caption) {
				let messageType;
				// undefined `caption` object
				if (!caption || Object.keys(caption).length <= 0) {
					messageType = MessageContentType.UndefinedCaptionObject;
				} else {
					// undefined `captionText` property
					if (!caption.captionText) {
						messageType = MessageContentType.UndefinedCaptionText;
					} else {
						// `captionText` that is empty or contains only spaces
						if (/^\s*$/.test(caption.captionText)) {
							messageType = MessageContentType.EmptyCaptionText;
						}
					}
					// undefined `captionType`
					if (!caption.captionType) {
						messageType = MessageContentType.UndefinedCaptionType;
					} else {
						// incorrect `captionType`
						if (!CaptionTypes.includes(caption?.captionType?.toLowerCase())) {
							messageType = MessageContentType.IncorrectCaptionType;
						}
					}
				}
				if (messageType) {
					const message = new ConsoleMessageClass().addDesignSystemTag();
					if (messageType !== MessageContentType.UndefinedCaptionObject) {
						message
							.addMonospaceText(
								` ${
									messageType === MessageContentType.EmptyCaptionText ||
									messageType === MessageContentType.UndefinedCaptionText
										? 'caption or captionText'
										: 'captionType'
								} `,
							)
							.addRegularText('object or property of');
					}
					message
						.addMonospaceText(' caption ')
						.addRegularText('object on')
						.addMonospaceText(` ${this.componentTagName} `);
					this.printConsoleMessage(messageType, message, this.getRequiredFlagText());
				}
			}
			/**
			 * Generate the content of warning message to be printed to the console
			 * @param messageType determine the content of warning message to output
			 * @param componentTagName the tag name of the component that's emitting the warning message
			 * @param requiredFlagText accepts a string value to be used as the required flag text and defaults to `(optional)` if not set
			 * @returns an array of `ConsoleMessage` objects containing the message and associated styles to be printed to the console
			 */
			printConsoleMessage(messageType, message, requiredFlagText = '(optional)') {
				switch (messageType) {
					// undefinedCaptionObject example: caption object on <ontario-input> is required but not defined. A blank followed by a (optional) flag is assumed.
					// undefinedCaptionText example: captionText property of caption object on <ontario-input> is required but not defined. A blank followed by a (optional) flag is assumed.
					// EmptyCaptionText example: captionText property of caption object on <ontario-input> is empty or contains only spaces. A blank followed by a (optional) flag is assumed.
					case MessageContentType.UndefinedCaptionObject:
					case MessageContentType.UndefinedCaptionText:
					case MessageContentType.EmptyCaptionText:
						message
							.addRegularText(
								`${
									messageType === MessageContentType.EmptyCaptionText
										? 'is empty or contains only spaces'
										: 'is required but not defined'
								}. A blank followed by a`,
							)
							.addMonospaceText(` ${requiredFlagText} `)
							.addRegularText('flag is assumed.');
						break;
					// UndefinedCaptionType example: captionType property of caption object on <ontario-input> is not defined. The default type is assumed.
					case MessageContentType.UndefinedCaptionType:
						message
							.addRegularText('is not defined. The')
							.addMonospaceText(' default ')
							.addRegularText('type is assumed.');
						break;
					// IncorrectCaptionType example: captionType property of caption object on <ontario-input> was set to an incorrect type; only default, heading or large type is allowed. The default type is assumed.
					case MessageContentType.IncorrectCaptionType:
						message
							.addRegularText('was set to an incorrect type; only')
							.addMonospaceText(' default, heading, ')
							.addRegularText('or')
							.addMonospaceText(' large ')
							.addRegularText('type is allowed. The')
							.addMonospaceText(' default ')
							.addRegularText('type is assumed.');
						break;
				}
				message.printMessage();
			}
		}

		const constructHintTextObject = (hintText) => {
			let hintTextObject = { hint: '', hintContentType: 'string' };
			if (hintText) {
				if (typeof hintText === 'string') {
					try {
						hintTextObject = JSON.parse(hintText);
					} catch {
						hintTextObject = { hint: hintText, hintContentType: 'string' };
					}
				} else {
					hintTextObject = hintText;
				}
			}
			return hintTextObject;
		};

		var EventType;
		(function (EventType) {
			EventType['Change'] = 'change';
			EventType['Blur'] = 'blur';
			EventType['Focus'] = 'focus';
			EventType['Input'] = 'input';
		})(EventType || (EventType = {}));

		const handleInputEvent = (
			event,
			eventType,
			input,
			inputChangeEvent,
			inputFocusEvent,
			inputBlurEvent,
			inputInputEvent,
			type,
			customChangeFunction,
			customFocusFunction,
			customBlurFunction,
			customInputFunction,
			hostElement,
		) => {
			if (eventType === EventType.Input) {
				inputInputEvent?.emit({
					id: input?.id,
					value: event.data ?? undefined,
					inputType: event.inputType,
				});
				customInputFunction && customInputFunction(event);
			}
			if (eventType === EventType.Change) {
				if (type === 'radio' || type === 'checkbox') {
					if (input instanceof HTMLInputElement) {
						inputChangeEvent.emit({
							checked: input?.checked,
							id: input?.id,
							value: input?.value,
						});
					}
				} else {
					inputChangeEvent.emit({
						id: input?.id,
						value: input?.value,
					});
				}
				customChangeFunction && customChangeFunction(event);
				// Note: Change events don't have composable set to true and don't cross the ShadowDOM boundary.
				// This will emit an event so the normal `onChange` event pattern is maintained.
				hostElement && emitEvent(hostElement, eventType, event);
			}
			if (eventType === EventType.Focus) {
				inputFocusEvent.emit({
					id: input?.id,
					focused: true,
					value: input?.value,
				});
				customFocusFunction && customFocusFunction(event);
			}
			if (eventType === EventType.Blur) {
				inputBlurEvent.emit({
					id: input?.id,
					focused: false,
					value: input?.value,
				});
				customBlurFunction && customBlurFunction(event);
			}
		};
		/**
		 * Emit a custom event that can be subscribed to by an event listener.
		 *
		 * @param element Component host element, see https://stenciljs.com/docs/host-element
		 * @param name name of the event
		 * @param detail any relevant details, like the original event
		 */
		const emitEvent = (element, name, detail) => {
			element.dispatchEvent(new CustomEvent(name, { composed: true, bubbles: true, detail }));
		};

		const ErrorMessage = ({ message, error = false }) => {
			const hideError = !error || isEmpty(message);
			return hAsync(
				'div',
				{ role: 'alert', class: `ontario-error-messaging ${hideError ? 'ontario-error__hidden' : ''}` },
				hAsync('ontario-icon-alert-error', null),
				hAsync('div', { class: 'ontario-error-messaging__content' }, message),
			);
		};

		const ontarioCheckboxesCss =
			'@charset "UTF-8";h6,.ontario-h6,h5,.ontario-h5,h4,.ontario-h4,h3,.ontario-h3,h2,.ontario-h2,.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1,h1,.ontario-h1{font-style:normal;font-weight:700;text-rendering:optimizeLegibility;margin-bottom:1rem;font-feature-settings:normal;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif}.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1,h1,.ontario-h1{font-size:2rem;letter-spacing:0.04rem;line-height:1.29;margin:2.5rem 0 1.5rem 0;max-width:70rem}@media screen and (min-width: 40em){.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1,h1,.ontario-h1{font-size:2.5rem;letter-spacing:0.04rem;line-height:1.2}}h2,.ontario-h2{font-size:1.6875rem;letter-spacing:0.03rem;line-height:1.37;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h2,.ontario-h2{font-size:2.0625rem;letter-spacing:0.02rem;line-height:1.33}}h3,.ontario-h3{font-size:1.4375rem;letter-spacing:0.02rem;line-height:1.39;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h3,.ontario-h3{font-size:1.75rem;letter-spacing:0.02rem;line-height:1.43}}h4,.ontario-h4{font-size:1.25rem;letter-spacing:0.03rem;line-height:1.5;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h4,.ontario-h4{font-size:1.5rem;letter-spacing:0.0313rem;line-height:1.5}}h5,.ontario-h5{font-size:1.125rem;letter-spacing:0.03rem;line-height:1.56;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h5,.ontario-h5{font-size:1.1875rem;letter-spacing:0.025rem;line-height:1.5}}h6,.ontario-h6{font-size:1rem;line-height:1.56;letter-spacing:0.03rem;max-width:48rem;margin:0 0 0.75rem 0}@media screen and (min-width: 40em){h6,.ontario-h6{font-size:1rem;letter-spacing:0.025rem;line-height:1.5}}.ontario-lead-statement{font-size:1.25rem;line-height:1.6;max-width:70rem}@media screen and (min-width: 40em){.ontario-lead-statement{font-size:1.375rem}}html{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem}body{font-size:1rem;line-height:1.6;background-color:#FFFFFF;color:#1a1a1a;margin:0}p{font-size:inherit;margin-bottom:1.25rem;text-rendering:optimizeLegibility;margin:0 0 1.5rem 0}cite{font-style:italic;line-height:inherit}strong{font-weight:700;line-height:inherit}*,*::before,*::after{box-sizing:inherit}main p,main p:not(.ontario-lead-statement),main dd,main li{max-width:48rem}hr{border:0;padding:0;margin:2.5rem 0;border-bottom:4px solid #cccccc}hr.ontario-hr--dark{border-bottom:4px solid #1a1a1a}a{color:#0066CC;text-decoration:underline}a:visited{color:#551A8B}a:hover{color:#00478F}a:active{color:#002142}a:focus{-moz-box-shadow:0 0 0 4px #009ADB;-webkit-box-shadow:0 0 0 4px #009ADB;box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:all 0.1s ease-in-out}p{margin:0 0 1.5rem 0}p+h1,p+h2,p+h3,p+h4,p+h5,p+h6,ul+h1,ul+h2,ul+h3,ul+h4,ul+h5,ul+h6,ol+h1,ol+h2,ol+h3,ol+h4,ol+h5,ol+h6,h1+h2,h2+h3,h3+h4,h4+h5,h5+h6{margin-top:2rem}p code,td code,li code{line-height:2.25rem}input[type=text],input[type=number],input[type=email],input[type=date],input[type=color],input[type=search],input[type=tel],textarea{background-origin:initial;height:auto;-webkit-appearance:none;-moz-appearance:none}input[type=checkbox]+label,input[type=radio]+label{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400;margin-left:0;margin-right:0}fieldset{border:0;margin:0;padding:0;page-break-inside:avoid}legend,label{display:block;margin:0}select{background-origin:initial;height:auto;-webkit-appearance:none;-moz-appearance:none}ul,ol{padding:0}ul{margin-left:2rem}ul li{padding:0 0 0.75rem 0}ol{margin-left:1.75rem}ol li{padding:0 0 0.75rem 0.25rem}ul li:last-child,ol li:last-child{padding-bottom:0}ul[class*=columns-] li:last-child,ol[class*=columns-] li:last-child{padding-bottom:0.75rem}ul ul,ol ul{margin:0.5rem 0 0.5rem 2rem}ul ol,ol ol{margin:0.5rem 0 0.5rem 1.75rem}p+ul,p+ol{margin-top:-0.75rem}@media screen and (min-width: 40em){ul{margin:0.5rem 0 1.5rem 3rem}ol{margin:0.5rem 0 1.5rem 2.75rem}ul ul,ol ul{margin:0.5rem 0 0.5rem 3rem}ul ol,ol ol{margin:0.5rem 0 0.5rem 2.75rem}}.ontario-form-group:last-of-type{margin-bottom:2.5rem}.ontario-form-group:last-of-type{margin-bottom:3rem}.ontario-fieldset__legend{color:#1a1a1a;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1.1875rem;font-weight:700;margin:0 0 1rem 0;line-height:1.5;max-width:38.75em;white-space:normal;width:100%;hyphens:auto}@media screen and (max-width: 40em){.ontario-fieldset__legend{font-size:1.125rem;line-height:1.56}}.ontario-fieldset__legend--large,.ontario-fieldset__legend--heading{letter-spacing:0.02rem;line-height:1.2}.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1{display:inline-block;margin:0}@media screen and (max-width: 40em){.ontario-fieldset__legend--large,.ontario-fieldset__legend--heading{font-size:1.4375rem;line-height:1.39}}.ontario-fieldset__legend--large{font-size:1.75rem}.ontario-fieldset__legend-required-flag,.ontario-fieldset__legend-optional-flag{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400}.ontario-fieldset__legend-required-flag:before,.ontario-fieldset__legend-optional-flag:before{content:""}.ontario-label__flag{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400}.ontario-label__flag:before{content:""}.ontario-hide{display:none !important}.ontario-invisible{visibility:hidden !important}@media screen and (max-width: 39.99875em){.ontario-hide-for-small-only{display:none !important}}@media screen and (max-width: 0em), screen and (min-width: 40em){.ontario-show-for-small-only{display:none !important}}@media print, screen and (min-width: 40em){.ontario-hide-for-medium{display:none !important}}@media screen and (max-width: 39.99875em){.ontario-show-for-medium{display:none !important}}@media screen and (min-width: 40em) and (max-width: 72.99875em){.ontario-hide-for-medium-only{display:none !important}}@media screen and (max-width: 39.99875em), screen and (min-width: 73em){.ontario-show-for-medium-only{display:none !important}}@media print, screen and (min-width: 73em){.ontario-hide-for-large{display:none !important}}@media screen and (max-width: 72.99875em){.ontario-show-for-large{display:none !important}}@media screen and (min-width: 73em) and (max-width: 95.99875em){.ontario-hide-for-large-only{display:none !important}}@media screen and (max-width: 72.99875em), screen and (min-width: 96em){.ontario-show-for-large-only{display:none !important}}.ontario-show-for-sr,.ontario-show-on-focus{position:absolute;width:1px;height:1px;overflow:hidden;clip:rect(0, 0, 0, 0)}.ontario-show-on-focus:active,.ontario-show-on-focus:focus{position:static;width:auto;height:auto;overflow:visible;clip:auto}.ontario-show-for-landscape,.ontario-hide-for-portrait{display:block !important}@media screen and (orientation: landscape){.ontario-show-for-landscape,.ontario-hide-for-portrait{display:block !important}}@media screen and (orientation: portrait){.ontario-show-for-landscape,.ontario-hide-for-portrait{display:none !important}}.ontario-hide-for-landscape,.ontario-show-for-portrait{display:none !important}@media screen and (orientation: landscape){.ontario-hide-for-landscape,.ontario-show-for-portrait{display:none !important}}@media screen and (orientation: portrait){.ontario-hide-for-landscape,.ontario-show-for-portrait{display:block !important}}.ontario-input:focus,.ontario-input:active{box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:box-shadow 0.1s ease-in-out}.ontario-input{border:2px solid #1a1a1a;border-radius:4px;box-sizing:border-box;color:#1a1a1a;display:block;font-size:1rem;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;line-height:1.5;margin:0 0 2.5rem;max-width:48rem;width:100%;padding:0.625rem 1rem;transition:box-shadow 0.1s ease-in-out}.ontario-input--2-char-width{max-width:8ex}.ontario-input--3-char-width{max-width:10ex}.ontario-input--4-char-width{max-width:12ex}.ontario-input--5-char-width{max-width:14ex}.ontario-input--7-char-width{max-width:17ex}.ontario-input--10-char-width{max-width:23ex}.ontario-input--20-char-width{max-width:41ex}.ontario-form-group:last-of-type{margin-bottom:2.5rem}.ontario-error-messaging{display:flex;align-items:flex-start;margin:-0.25rem 0 0.5rem 0;color:#D81A21;max-width:48rem}.ontario-error-messaging__content{margin-left:0.5rem}.ontario-input__error{border-color:#D81A21 !important}.ontario-error__hidden{display:none}:host{--checkbox-bg:url("data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\'%3E%3Cpath d=\'M0 2.667C0 1.194 1.194 0 2.667 0h18.667C22.806 0 24 1.194 24 2.667v18.667C24 22.806 22.806 24 21.333 24H2.667C1.194 24 0 22.806 0 21.333V2.667z\' fill=\'%231a1a1a\'/%3E%3Cpath d=\'M2.667 12.616l6.667 6.718 12-12.092-1.88-1.908L9.333 15.53l-4.787-4.8-1.88 1.894z\' fill=\'%23fff\'/%3E%3C/svg%3E")}.ontario-checkboxes{margin-bottom:2.5rem;max-width:48rem}.ontario-checkboxes__item{position:relative;margin:0 0 1rem;padding:0 0 0 2rem;min-height:1.75rem;box-sizing:content-box}.ontario-checkboxes__item:last-of-type{margin:0}@media screen and (max-width: 40em){.ontario-checkboxes__item{padding:0 0 0 2.5rem;min-height:2rem}}.ontario-checkboxes__input{cursor:pointer;margin:0;position:absolute;top:-0.125rem;left:-0.125rem;opacity:0;width:36px;height:36px;z-index:0;-webkit-tap-highlight-color:transparent}@media screen and (max-width: 40em){.ontario-checkboxes__input{width:40px;height:40px}}.ontario-checkboxes__label{display:inline-block;cursor:pointer;line-height:1.5;margin:0.25rem 0;padding:0 1rem;width:auto;white-space:normal}@media screen and (max-width: 40em){.ontario-checkboxes__label{margin:0.33rem 0}}.ontario-checkboxes__label:before{content:"";border:0.125rem solid #1a1a1a;border-radius:4px;position:absolute;top:0;left:0;width:2rem;height:2rem;transition:border 0.1s ease-in-out;display:block}@media screen and (min-width: 40em){.ontario-checkboxes__label:before{width:1.75rem;height:1.75rem}}.ontario-checkboxes__label:after{content:"";background-image:var(--checkbox-bg);background-repeat:no-repeat;height:1.875rem;width:1.875rem;position:absolute;top:0.0625rem;left:0.0625rem;right:0;bottom:0;opacity:0;display:block}@media screen and (max-width: 40em){.ontario-checkboxes__label:after{height:2.125rem;width:2.125rem}}.ontario-checkboxes__input:focus+.ontario-checkboxes__label:before{-moz-box-shadow:0 0 0 0.25rem #009ADB;-webkit-box-shadow:0 0 0 0.25rem #009ADB;box-shadow:0 0 0 0.25rem #009ADB;outline:0.25rem solid transparent;transition:all 0.1s ease-in-out}.ontario-checkboxes__input:checked+.ontario-checkboxes__label:after{opacity:1}.ontario-checkboxes__input:checked+.ontario-checkboxes__label:before{background-color:#1a1a1a}.ontario-checkboxes__hint-expander{margin:0.75rem 0 0 0.5rem}@media screen and (max-width: 40em){.ontario-checkboxes__hint-expander{margin-top:1rem}}';

		class OntarioCheckboxes {
			constructor(hostRef) {
				registerInstance(this, hostRef);
				this.checkboxOnChange = createEvent(this, 'checkboxOnChange');
				this.checkboxOnBlur = createEvent(this, 'checkboxOnBlur');
				this.checkboxOnFocus = createEvent(this, 'checkboxOnFocus');
				this.inputErrorOccurred = createEvent(this, 'inputErrorOccurred');
				if (hostRef.$hostElement$['s-ei']) {
					this.internals = hostRef.$hostElement$['s-ei'];
				} else {
					this.internals = hostRef.$hostElement$.attachInternals();
					hostRef.$hostElement$['s-ei'] = this.internals;
				}
			}
			get element() {
				return getElement(this);
			}
			internals;
			hintTextRef;
			/**
			 * The text to display for the checkbox legend.
			 *
			 * @example
			 * <ontario-checkboxes
			 *   caption='{
			 *     "captionText": "Checkbox legend",
			 *     "captionType": "heading",
			 *   }
			 *   ...>
			 * </ontario-checkboxes>
			 */
			caption;
			/**
			 * The language of the component.
			 * This is used for translations, and is by default set through event listeners checking for a language property from the header. If no language is passed, it will default to English.
			 */
			language;
			/**
			 * The name for the checkboxes. The name value is used to reference form data after a form is submitted.
			 */
			name;
			/**
			 * Used to include the ontario-hint-text component for the checkbox group.
			 * This is optional.
			 */
			hintText;
			/**
			 * Used to include the ontario-hint-expander component for the checkbox group.
			 * This is passed in as an object with key-value pairs.
			 *
			 * This is optional.
			 *
			 * @example
			 * <ontario-checkboxes
			 *   caption='{
			 *     "captionText": "Checkbox legend",
			 *     "captionType": "heading",
			 *   }
			 *   name='ontario-checkboxes'
			 *   options='[
			 *		{
			 *			"value": "checkbox-option-1",
			 *			"label": "Checkbox option 1 label",
			 *			"elementId": "checkbox-1"
			 *		}
			 *   }]'
			 *   hint-expander='{
			 *    "hint": "Hint expander for the checkbox group",
			 *    "content": "Example hint expander content for the checkbox group"
			 *   }'
			 *   required="true"
			 * >
			 * </ontario-checkboxes>
			 */
			hintExpander;
			/**
			 * The options for the checkbox group.
			 *
			 * Each property will be passed in through an object in the options array.
			 * This can either be passed in as an object directly (if using react), or as a string in HTML.
			 * If there are multiple checkboxes in a fieldset, each checkbox will be displayed as an option.
			 *
			 * In the example below, the options are being passed in as a string and there are two checkboxes to be displayed in the fieldset.
			 *
			 * @example
			 * <ontario-checkboxes
			 *   caption='{
			 *		"captionText": "Checkbox legend",
			 *		"captionType": "heading",
			 *   }
			 *   name="ontario-checkboxes",
			 *   hint-text="Hint text for the checkbox group."
			 *   options='[
			 *		{
			 *			"value": "checkbox-option-1",
			 *			"label": "Checkbox option 1 label"
			 *			"elementId": "checkbox-1"
			 *     },
			 *     {
			 *        "value": "checkbox-option-2",
			 *        "label": "Checkbox option 2 label",
			 * 		  "elementId": "checkbox-2",
			 *	      "hintExpander": {
			 *				"hint": "Hint expander for checkbox option 2",
			 *              "content": "Example hint expander content for checkbox option 2"
			 *        }
			 *      }
			 *   ]'
			 *   required="true"
			 * >
			 * </ontario-checkboxes>
			 */
			options;
			/**
			 * This is used to determine whether the checkbox is required or not.
			 * This prop also gets passed to the InputCaption utility to display either an optional or required flag in the label.
			 * If no prop is set, it will default to false (optional).
			 */
			required = false;
			/**
			 * Set this to display an error message
			 */
			errorMessage;
			/**
			 * Used to add a custom function to the checkbox onChange event.
			 */
			customOnChange;
			/**
			 * Used to add a custom function to the checkbox onBlur event.
			 */
			customOnBlur;
			/**
			 * Used to add a custom function to the checkbox onFocus event.
			 */
			customOnFocus;
			/**
			 * Used for the `aria-describedby` value of the checkbox fieldset. This will match with the id of the hint text.
			 */
			hintTextId;
			/**
			 * Instantiate an InputCaption object for internal logic use
			 */
			captionState;
			/**
			 * The hint text options are re-assigned to the internalHintText array.
			 */
			internalHintText;
			/**
			 * The hint expander options are re-assigned to the internalHintExpander array.
			 */
			internalHintExpander;
			/**
			 * The options are re-assigned to the internalOptions array.
			 */
			internalOptions;
			/**
			 * Emitted when a keyboard input or mouse event occurs when a checkbox option has been changed.
			 */
			checkboxOnChange;
			/**
			 * Emitted when a keyboard input event occurs when a checkbox option has lost focus.
			 */
			checkboxOnBlur;
			/**
			 * Emitted when a keyboard input event occurs when a checkbox option has gained focus.
			 */
			checkboxOnFocus;
			/**
			 * Emitted when an error message is reported to the component.
			 */
			inputErrorOccurred;
			/**
			 * This listens for the `setAppLanguage` event sent from the test language toggler when it is is connected to the DOM. It is used for the initial language when the input component loads.
			 */
			handleSetAppLanguage(event) {
				if (!this.language) {
					this.language = validateLanguage(event);
				}
			}
			handleHeaderLanguageToggled(event) {
				this.language = validateLanguage(event);
			}
			/**
			 * Watch for changes to the `hintText` prop.
			 *
			 * If a `hintText` prop is passed, the `constructHintTextObject` function will convert it to the correct format, and set the result to the `internalHintText` state.
			 */
			parseHintText() {
				if (this.hintText) {
					const hintTextObject = constructHintTextObject(this.hintText);
					this.internalHintText = hintTextObject;
				}
			}
			/**
			 * Watch for changes to the `hintExpander` prop.
			 *
			 * If a `hintExpander` prop is passed, it will be parsed (if it is a string), and the result will be set to the `internalHintExpander` state.
			 */
			parseHintExpander() {
				const hintExpander = this.hintExpander;
				if (hintExpander) {
					if (typeof hintExpander === 'string') this.internalHintExpander = JSON.parse(hintExpander);
					else this.internalHintExpander = hintExpander;
				}
			}
			/**
			 * Watch for changes to the `options` prop.
			 *
			 * If an `options` prop is passed, it will be parsed (if it is a string), and the result will be set to the `internalOptions` state. The result will be run through a validation function.
			 */
			parseOptions() {
				if (typeof this.options !== 'undefined') {
					if (!Array.isArray(this.options)) {
						this.internalOptions = JSON.parse(this.options);
					} else {
						this.internalOptions = this.options;
					}
				}
				this.validateOptions(this.internalOptions);
			}
			/**
			 * Validate the `options` and make sure the `options` prop has a value.
			 * Log a warning if user doesn't input a value for the `options`.
			 *
			 * @param newValue object to be validated
			 */
			validateOptions(newValue) {
				if (validateObjectExists(newValue)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' options ')
						.addRegularText('for')
						.addMonospaceText(' <ontario-checkboxes> ')
						.addRegularText('was not provided')
						.printMessage();
				}
			}
			/*
			 * Watch for changes in the `name` prop for validation purposes.
			 *
			 * Validate the `name` and make sure the `name` prop has a value.
			 * Log a warning if user doesn't input a value for the `name`.
			 */
			validateName(newValue) {
				if (validatePropExists(newValue)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' name ')
						.addRegularText('for')
						.addMonospaceText(' <ontario-checkboxes> ')
						.addRegularText('was not provided')
						.printMessage();
				}
			}
			/**
			 * Watch for changes to the `caption` prop.
			 *
			 * The caption will be run through the InputCaption constructor to convert it to the correct format, and set the result to the `captionState` state.
			 * @param newValue: Caption | string
			 */
			updateCaptionState(newValue) {
				this.captionState = new InputCaption(
					this.element.tagName,
					newValue,
					translations,
					this.language,
					true,
					this.required,
				);
			}
			/**
			 * Watch for changes to the `language` prop to render either the English or French translations
			 */
			updateLanguage() {
				this.updateCaptionState(this.caption);
			}
			broadcastInputErrorOccurredEvent() {
				// Emit event to notify anyone who wants to listen for errors occurring
				this.inputErrorOccurred.emit({ errorMessage: this.errorMessage ?? '' });
			}
			/**
			 * Function to handle checkbox events and the information pertaining to the checkbox to emit.
			 */
			handleEvent(event, eventType) {
				const input = event.target;
				if (input) {
					input.checked = input.checked ?? '';
				}
				// Update internalOptions checked state
				const changedOption = this.internalOptions.find((x) => x.value === input?.value);
				if (changedOption) changedOption.checked = !changedOption?.checked;
				// Set the value within the form
				this.internals?.setFormValue?.(
					this.internalOptions
						.filter((x) => !!x.checked)
						.reduce((formData, currentValue) => {
							formData.append(this.name, currentValue.value);
							return formData;
						}, new FormData()),
				);
				handleInputEvent(
					event,
					eventType,
					input,
					this.checkboxOnChange,
					this.checkboxOnFocus,
					this.checkboxOnBlur,
					undefined,
					'checkbox',
					this.customOnChange,
					this.customOnFocus,
					this.customOnBlur,
					undefined,
					this.element,
				);
			}
			/**
			 * If a `hintText` prop is passed, the id generated from it will be set to the internal `hintTextId` state to match with the fieldset `aria-describedBy` attribute.
			 */
			async componentDidLoad() {
				this.hintTextId = await this.hintTextRef?.getHintTextId();
			}
			componentWillLoad() {
				this.updateCaptionState(this.caption);
				this.parseOptions();
				this.parseHintExpander();
				this.parseHintText();
				this.validateName(this.name);
				this.language = validateLanguage(this.language);
			}
			render() {
				const error = !!this.errorMessage;
				return hAsync(
					'div',
					{
						key: '5436155c32e692dee15fbf93fc4a80cec4ef6325',
						class: `ontario-form-group ${error ? 'ontario-input--error' : ''}`,
					},
					hAsync(
						'fieldset',
						{
							'key': '13830e1c232fd935c8085a0a443b1a0c6f7655a9',
							'class': 'ontario-fieldset',
							'aria-describedby': this.hintTextId,
						},
						this.captionState.getCaption(undefined, !!this.internalHintExpander),
						this.internalHintText &&
							hAsync('ontario-hint-text', {
								key: 'd176e8693779d38e3508b89c24320b9e4f9c0b6c',
								hint: this.internalHintText.hint,
								hintContentType: this.internalHintText.hintContentType,
								ref: (el) => (this.hintTextRef = el),
							}),
						hAsync(ErrorMessage, {
							key: 'c775a4a1ec00311fcb831473e9b6a51add3cb569',
							message: this.errorMessage,
							error: error,
						}),
						hAsync(
							'div',
							{ key: '491cd03960d0e69d1ad5fc8c2827409af2721609', class: 'ontario-checkboxes' },
							this.internalOptions?.map((checkbox) =>
								hAsync(
									'div',
									{ class: 'ontario-checkboxes__item' },
									hAsync(Input$1, {
										className: 'ontario-checkboxes__input',
										id: checkbox.elementId,
										name: this.name,
										type: 'checkbox',
										value: checkbox.value,
										required: !!this.required,
										checked: !!checkbox.checked,
										onChange: (e) => this.handleEvent(e, EventType.Change),
										onBlur: (e) => this.handleEvent(e, EventType.Blur),
										onFocus: (e) => this.handleEvent(e, EventType.Focus),
									}),
									hAsync(
										'label',
										{ class: 'ontario-checkboxes__label', htmlFor: checkbox.elementId },
										checkbox.label,
										checkbox.hintExpander && this.captionState.getHintExpanderAccessibilityText(checkbox.label, true),
									),
									checkbox.hintExpander &&
										hAsync(
											'div',
											{ class: 'ontario-checkboxes__hint-expander' },
											hAsync('ontario-hint-expander', {
												'hint': checkbox.hintExpander.hint,
												'content': checkbox.hintExpander.content,
												'hintContentType': checkbox.hintExpander.hintContentType,
												'input-exists': true,
											}),
										),
								),
							),
							this.internalHintExpander &&
								hAsync(
									'div',
									{ key: '982eb7debd2038a33166c0e3b4db9887c632a2f2', class: 'ontario-checkboxes__hint-expander' },
									hAsync('ontario-hint-expander', {
										'key': '624fa6eb7ec9dd1840651f4a536792655b8aa0fc',
										'hint': this.internalHintExpander.hint,
										'content': this.internalHintExpander.content,
										'hintContentType': this.internalHintExpander.hintContentType,
										'input-exists': true,
									}),
								),
						),
					),
				);
			}
			static get formAssociated() {
				return true;
			}
			static get watchers() {
				return {
					hintText: ['parseHintText'],
					hintExpander: ['parseHintExpander'],
					options: ['parseOptions'],
					name: ['validateName'],
					caption: ['updateCaptionState'],
					language: ['updateLanguage'],
					errorMessage: ['broadcastInputErrorOccurredEvent'],
				};
			}
			static get style() {
				return ontarioCheckboxesCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 73,
					$tagName$: 'ontario-checkboxes',
					$members$: {
						caption: [1],
						language: [1025],
						name: [1],
						hintText: [1025, 'hint-text'],
						hintExpander: [1, 'hint-expander'],
						options: [1],
						required: [4],
						errorMessage: [1025, 'error-message'],
						customOnChange: [16, 'custom-on-change'],
						customOnBlur: [16, 'custom-on-blur'],
						customOnFocus: [16, 'custom-on-focus'],
						hintTextId: [32],
						captionState: [32],
						internalHintText: [32],
						internalHintExpander: [32],
						internalOptions: [32],
					},
					$listeners$: [
						[8, 'setAppLanguage', 'handleSetAppLanguage'],
						[8, 'headerLanguageToggled', 'handleHeaderLanguageToggled'],
					],
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		var OntarioIconCriticalAlertWarning$1 = `<svg class="svg-icon" role="img" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
	<path d="M1 21H23L12 2L1 21ZM13 18H11V16H13V18ZM13 14H11V10H13V14Z" fill="white" />
	<rect x="11" y="10" width="2" height="4" fill="black" />
	<rect x="11" y="16" width="2" height="2" fill="black" />
</svg>
`;

		const ontarioCriticalAlertCss =
			'.ontario-row{margin:0 auto;max-width:72rem;width:100%}.ontario-row:before,.ontario-row:after{content:"";display:table}.ontario-row:after{clear:both}.ontario-row.ontario-row--collapse>.ontario-column,.ontario-row.ontario-row--collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-row--collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row .ontario-row{margin:0 -1rem;max-width:none;width:auto}.ontario-row .ontario-row:before,.ontario-row .ontario-row:after{content:"";display:table}.ontario-row .ontario-row:after{clear:both}.ontario-row .ontario-row.ontario-row--collapse{margin:0;max-width:none;width:auto}.ontario-row .ontario-row.ontario-row--collapse:before,.ontario-row .ontario-row.ontario-row--collapse:after{content:"";display:table}.ontario-row .ontario-row.ontario-row--collapse:after{clear:both}.ontario-column,.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;width:100%;float:left}.ontario-column+.ontario-column:last-child,.ontario-column+.ontario-columns:last-child,.ontario-columns+.ontario-column:last-child,.ontario-columns+.ontario-columns:last-child{float:right}.ontario-column+.ontario-column.ontario-end,.ontario-column+.ontario-columns.ontario-end,.ontario-columns+.ontario-column.ontario-end,.ontario-columns+.ontario-columns.ontario-end{float:left}@media only screen{.ontario-small-push-0{position:relative;left:0;right:auto}.ontario-small-pull-0{position:relative;right:0;left:auto}.ontario-small-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-small-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-small-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-small-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-small-push-3{position:relative;left:25%;right:auto}.ontario-small-pull-3{position:relative;right:25%;left:auto}.ontario-small-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-small-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-small-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-small-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-small-push-6{position:relative;left:50%;right:auto}.ontario-small-pull-6{position:relative;right:50%;left:auto}.ontario-small-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-small-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-small-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-small-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-small-push-9{position:relative;left:75%;right:auto}.ontario-small-pull-9{position:relative;right:75%;left:auto}.ontario-small-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-small-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-small-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-small-pull-11{position:relative;right:91.6666666667%;left:auto}.ontario-column,.ontario-columns{position:relative;padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-small-1{width:8.3333333333%}.ontario-small-2{width:16.6666666667%}.ontario-small-3{width:25%}.ontario-small-4{width:33.3333333333%}.ontario-small-5{width:41.6666666667%}.ontario-small-6{width:50%}.ontario-small-7{width:58.3333333333%}.ontario-small-8{width:66.6666666667%}.ontario-small-9{width:75%}.ontario-small-10{width:83.3333333333%}.ontario-small-11{width:91.6666666667%}.ontario-small-12{width:100%}.ontario-small-offset-0{margin-left:0 !important}.ontario-small-offset-1{margin-left:8.3333333333% !important}.ontario-small-offset-2{margin-left:16.6666666667% !important}.ontario-small-offset-3{margin-left:25% !important}.ontario-small-offset-4{margin-left:33.3333333333% !important}.ontario-small-offset-5{margin-left:41.6666666667% !important}.ontario-small-offset-6{margin-left:50% !important}.ontario-small-offset-7{margin-left:58.3333333333% !important}.ontario-small-offset-8{margin-left:66.6666666667% !important}.ontario-small-offset-9{margin-left:75% !important}.ontario-small-offset-10{margin-left:83.3333333333% !important}.ontario-small-offset-11{margin-left:91.6666666667% !important}.ontario-small-reset-order{float:left;left:auto;margin-left:0;margin-right:0;right:auto}.ontario-column.ontario-small-centered,.ontario-columns.ontario-small-centered{margin-left:auto;margin-right:auto;float:none}.ontario-column.ontario-small-uncentered,.ontario-columns.ontario-small-uncentered{float:left;margin-left:0;margin-right:0}.ontario-column.ontario-small-centered:last-child,.ontario-columns.ontario-small-centered:last-child{float:none}.ontario-column.ontario-small-uncentered:last-child,.ontario-columns.ontario-small-uncentered:last-child{float:left}.ontario-column.ontario-small-uncentered.ontario-opposite,.ontario-columns.ontario-small-uncentered.ontario-opposite{float:right}.ontario-row.ontario-small-collapse>.ontario-column,.ontario-row.ontario-small-collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-small-collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row.ontario-small-uncollapse>.ontario-column,.ontario-row.ontario-small-uncollapse>.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}}@media only screen and (min-width:40.063em){.ontario-medium-push-0{position:relative;left:0;right:auto}.ontario-medium-pull-0{position:relative;right:0;left:auto}.ontario-medium-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-medium-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-medium-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-medium-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-medium-push-3{position:relative;left:25%;right:auto}.ontario-medium-pull-3{position:relative;right:25%;left:auto}.ontario-medium-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-medium-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-medium-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-medium-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-medium-push-6{position:relative;left:50%;right:auto}.ontario-medium-pull-6{position:relative;right:50%;left:auto}.ontario-medium-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-medium-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-medium-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-medium-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-medium-push-9{position:relative;left:75%;right:auto}.ontario-medium-pull-9{position:relative;right:75%;left:auto}.ontario-medium-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-medium-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-medium-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-medium-pull-11{position:relative;right:91.6666666667%;left:auto}.ontario-column,.ontario-columns{position:relative;padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-medium-1{width:8.3333333333%}.ontario-medium-2{width:16.6666666667%}.ontario-medium-3{width:25%}.ontario-medium-4{width:33.3333333333%}.ontario-medium-5{width:41.6666666667%}.ontario-medium-6{width:50%}.ontario-medium-7{width:58.3333333333%}.ontario-medium-8{width:66.6666666667%}.ontario-medium-9{width:75%}.ontario-medium-10{width:83.3333333333%}.ontario-medium-11{width:91.6666666667%}.ontario-medium-12{width:100%}.ontario-medium-offset-0{margin-left:0 !important}.ontario-medium-offset-1{margin-left:8.3333333333% !important}.ontario-medium-offset-2{margin-left:16.6666666667% !important}.ontario-medium-offset-3{margin-left:25% !important}.ontario-medium-offset-4{margin-left:33.3333333333% !important}.ontario-medium-offset-5{margin-left:41.6666666667% !important}.ontario-medium-offset-6{margin-left:50% !important}.ontario-medium-offset-7{margin-left:58.3333333333% !important}.ontario-medium-offset-8{margin-left:66.6666666667% !important}.ontario-medium-offset-9{margin-left:75% !important}.ontario-medium-offset-10{margin-left:83.3333333333% !important}.ontario-medium-offset-11{margin-left:91.6666666667% !important}.ontario-medium-reset-order{float:left;left:auto;margin-left:0;margin-right:0;right:auto}.ontario-column.ontario-medium-centered,.ontario-columns.ontario-medium-centered{margin-left:auto;margin-right:auto;float:none}.ontario-column.ontario-medium-uncentered,.ontario-columns.ontario-medium-uncentered{float:left;margin-left:0;margin-right:0}.ontario-column.ontario-medium-centered:last-child,.ontario-columns.ontario-medium-centered:last-child{float:none}.ontario-column.ontario-medium-uncentered:last-child,.ontario-columns.ontario-medium-uncentered:last-child{float:left}.ontario-column.ontario-medium-uncentered.ontario-opposite,.ontario-columns.ontario-medium-uncentered.ontario-opposite{float:right}.ontario-row.ontario-medium-collapse>.ontario-column,.ontario-row.ontario-medium-collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-medium-collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row.ontario-medium-uncollapse>.ontario-column,.ontario-row.ontario-medium-uncollapse>.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}}@media only screen and (min-width:73.063em){.ontario-large-push-0{position:relative;left:0;right:auto}.ontario-large-pull-0{position:relative;right:0;left:auto}.ontario-large-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-large-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-large-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-large-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-large-push-3{position:relative;left:25%;right:auto}.ontario-large-pull-3{position:relative;right:25%;left:auto}.ontario-large-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-large-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-large-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-large-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-large-push-6{position:relative;left:50%;right:auto}.ontario-large-pull-6{position:relative;right:50%;left:auto}.ontario-large-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-large-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-large-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-large-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-large-push-9{position:relative;left:75%;right:auto}.ontario-large-pull-9{position:relative;right:75%;left:auto}.ontario-large-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-large-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-large-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-large-pull-11{position:relative;right:91.6666666667%;left:auto}.ontario-column,.ontario-columns{position:relative;padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-large-1{width:8.3333333333%}.ontario-large-2{width:16.6666666667%}.ontario-large-3{width:25%}.ontario-large-4{width:33.3333333333%}.ontario-large-5{width:41.6666666667%}.ontario-large-6{width:50%}.ontario-large-7{width:58.3333333333%}.ontario-large-8{width:66.6666666667%}.ontario-large-9{width:75%}.ontario-large-10{width:83.3333333333%}.ontario-large-11{width:91.6666666667%}.ontario-large-12{width:100%}.ontario-large-offset-0{margin-left:0 !important}.ontario-large-offset-1{margin-left:8.3333333333% !important}.ontario-large-offset-2{margin-left:16.6666666667% !important}.ontario-large-offset-3{margin-left:25% !important}.ontario-large-offset-4{margin-left:33.3333333333% !important}.ontario-large-offset-5{margin-left:41.6666666667% !important}.ontario-large-offset-6{margin-left:50% !important}.ontario-large-offset-7{margin-left:58.3333333333% !important}.ontario-large-offset-8{margin-left:66.6666666667% !important}.ontario-large-offset-9{margin-left:75% !important}.ontario-large-offset-10{margin-left:83.3333333333% !important}.ontario-large-offset-11{margin-left:91.6666666667% !important}.ontario-large-reset-order{float:left;left:auto;margin-left:0;margin-right:0;right:auto}.ontario-column.ontario-large-centered,.ontario-columns.ontario-large-centered{margin-left:auto;margin-right:auto;float:none}.ontario-column.ontario-large-uncentered,.ontario-columns.ontario-large-uncentered{float:left;margin-left:0;margin-right:0}.ontario-column.ontario-large-centered:last-child,.ontario-columns.ontario-large-centered:last-child{float:none}.ontario-column.ontario-large-uncentered:last-child,.ontario-columns.ontario-large-uncentered:last-child{float:left}.ontario-column.ontario-large-uncentered.ontario-opposite,.ontario-columns.ontario-large-uncentered.ontario-opposite{float:right}.ontario-row.ontario-large-collapse>.ontario-column,.ontario-row.ontario-large-collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-large-collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row.ontario-large-uncollapse>.ontario-column,.ontario-row.ontario-large-uncollapse>.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-push-0{position:relative;left:0;right:auto}.ontario-pull-0{position:relative;right:0;left:auto}.ontario-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-push-3{position:relative;left:25%;right:auto}.ontario-pull-3{position:relative;right:25%;left:auto}.ontario-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-push-6{position:relative;left:50%;right:auto}.ontario-pull-6{position:relative;right:50%;left:auto}.ontario-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-push-9{position:relative;left:75%;right:auto}.ontario-pull-9{position:relative;right:75%;left:auto}.ontario-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-pull-11{position:relative;right:91.6666666667%;left:auto}}@media only screen and (min-width:96.063em){.ontario-xlarge-push-0{position:relative;left:0;right:auto}.ontario-xlarge-pull-0{position:relative;right:0;left:auto}.ontario-xlarge-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-xlarge-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-xlarge-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-xlarge-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-xlarge-push-3{position:relative;left:25%;right:auto}.ontario-xlarge-pull-3{position:relative;right:25%;left:auto}.ontario-xlarge-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-xlarge-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-xlarge-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-xlarge-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-xlarge-push-6{position:relative;left:50%;right:auto}.ontario-xlarge-pull-6{position:relative;right:50%;left:auto}.ontario-xlarge-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-xlarge-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-xlarge-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-xlarge-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-xlarge-push-9{position:relative;left:75%;right:auto}.ontario-xlarge-pull-9{position:relative;right:75%;left:auto}.ontario-xlarge-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-xlarge-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-xlarge-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-xlarge-pull-11{position:relative;right:91.6666666667%;left:auto}.ontario-column,.ontario-columns{position:relative;padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-xlarge-1{width:8.3333333333%}.ontario-xlarge-2{width:16.6666666667%}.ontario-xlarge-3{width:25%}.ontario-xlarge-4{width:33.3333333333%}.ontario-xlarge-5{width:41.6666666667%}.ontario-xlarge-6{width:50%}.ontario-xlarge-7{width:58.3333333333%}.ontario-xlarge-8{width:66.6666666667%}.ontario-xlarge-9{width:75%}.ontario-xlarge-10{width:83.3333333333%}.ontario-xlarge-11{width:91.6666666667%}.ontario-xlarge-12{width:100%}.ontario-xlarge-offset-0{margin-left:0 !important}.ontario-xlarge-offset-1{margin-left:8.3333333333% !important}.ontario-xlarge-offset-2{margin-left:16.6666666667% !important}.ontario-xlarge-offset-3{margin-left:25% !important}.ontario-xlarge-offset-4{margin-left:33.3333333333% !important}.ontario-xlarge-offset-5{margin-left:41.6666666667% !important}.ontario-xlarge-offset-6{margin-left:50% !important}.ontario-xlarge-offset-7{margin-left:58.3333333333% !important}.ontario-xlarge-offset-8{margin-left:66.6666666667% !important}.ontario-xlarge-offset-9{margin-left:75% !important}.ontario-xlarge-offset-10{margin-left:83.3333333333% !important}.ontario-xlarge-offset-11{margin-left:91.6666666667% !important}.ontario-xlarge-reset-order{float:left;left:auto;margin-left:0;margin-right:0;right:auto}.ontario-column.ontario-xlarge-centered,.ontario-columns.ontario-xlarge-centered{margin-left:auto;margin-right:auto;float:none}.ontario-column.ontario-xlarge-uncentered,.ontario-columns.ontario-xlarge-uncentered{float:left;margin-left:0;margin-right:0}.ontario-column.ontario-xlarge-centered:last-child,.ontario-columns.ontario-xlarge-centered:last-child{float:none}.ontario-column.ontario-xlarge-uncentered:last-child,.ontario-columns.ontario-xlarge-uncentered:last-child{float:left}.ontario-column.ontario-xlarge-uncentered.ontario-opposite,.ontario-columns.ontario-xlarge-uncentered.ontario-opposite{float:right}.ontario-row.ontario-xlarge-collapse>.ontario-column,.ontario-row.ontario-xlarge-collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-xlarge-collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row.ontario-xlarge-uncollapse>.ontario-column,.ontario-row.ontario-xlarge-uncollapse>.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}}@media only screen and (min-width:120.063em){.ontario-xxlarge-push-0{position:relative;left:0;right:auto}.ontario-xxlarge-pull-0{position:relative;right:0;left:auto}.ontario-xxlarge-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-xxlarge-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-xxlarge-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-xxlarge-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-xxlarge-push-3{position:relative;left:25%;right:auto}.ontario-xxlarge-pull-3{position:relative;right:25%;left:auto}.ontario-xxlarge-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-xxlarge-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-xxlarge-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-xxlarge-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-xxlarge-push-6{position:relative;left:50%;right:auto}.ontario-xxlarge-pull-6{position:relative;right:50%;left:auto}.ontario-xxlarge-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-xxlarge-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-xxlarge-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-xxlarge-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-xxlarge-push-9{position:relative;left:75%;right:auto}.ontario-xxlarge-pull-9{position:relative;right:75%;left:auto}.ontario-xxlarge-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-xxlarge-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-xxlarge-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-xxlarge-pull-11{position:relative;right:91.6666666667%;left:auto}.ontario-column,.ontario-columns{position:relative;padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-xxlarge-1{width:8.3333333333%}.ontario-xxlarge-2{width:16.6666666667%}.ontario-xxlarge-3{width:25%}.ontario-xxlarge-4{width:33.3333333333%}.ontario-xxlarge-5{width:41.6666666667%}.ontario-xxlarge-6{width:50%}.ontario-xxlarge-7{width:58.3333333333%}.ontario-xxlarge-8{width:66.6666666667%}.ontario-xxlarge-9{width:75%}.ontario-xxlarge-10{width:83.3333333333%}.ontario-xxlarge-11{width:91.6666666667%}.ontario-xxlarge-12{width:100%}.ontario-xxlarge-offset-0{margin-left:0 !important}.ontario-xxlarge-offset-1{margin-left:8.3333333333% !important}.ontario-xxlarge-offset-2{margin-left:16.6666666667% !important}.ontario-xxlarge-offset-3{margin-left:25% !important}.ontario-xxlarge-offset-4{margin-left:33.3333333333% !important}.ontario-xxlarge-offset-5{margin-left:41.6666666667% !important}.ontario-xxlarge-offset-6{margin-left:50% !important}.ontario-xxlarge-offset-7{margin-left:58.3333333333% !important}.ontario-xxlarge-offset-8{margin-left:66.6666666667% !important}.ontario-xxlarge-offset-9{margin-left:75% !important}.ontario-xxlarge-offset-10{margin-left:83.3333333333% !important}.ontario-xxlarge-offset-11{margin-left:91.6666666667% !important}.ontario-xxlarge-reset-order{float:left;left:auto;margin-left:0;margin-right:0;right:auto}.ontario-column.ontario-xxlarge-centered,.ontario-columns.ontario-xxlarge-centered{margin-left:auto;margin-right:auto;float:none}.ontario-column.ontario-xxlarge-uncentered,.ontario-columns.ontario-xxlarge-uncentered{float:left;margin-left:0;margin-right:0}.ontario-column.ontario-xxlarge-centered:last-child,.ontario-columns.ontario-xxlarge-centered:last-child{float:none}.ontario-column.ontario-xxlarge-uncentered:last-child,.ontario-columns.ontario-xxlarge-uncentered:last-child{float:left}.ontario-column.ontario-xxlarge-uncentered.ontario-opposite,.ontario-columns.ontario-xxlarge-uncentered.ontario-opposite{float:right}.ontario-row.ontario-xxlarge-collapse>.ontario-column,.ontario-row.ontario-xxlarge-collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-xxlarge-collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row.ontario-xxlarge-uncollapse>.ontario-column,.ontario-row.ontario-xxlarge-uncollapse>.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}}.ontario-critical-alert{background-color:#FFD440;font-weight:400;margin:0;padding:1rem 0;position:relative;z-index:10}.ontario-critical-alert__body{display:flex;flex-wrap:nowrap}.ontario-critical-alert__icon{display:flex}.ontario-critical-alert__icon svg{width:28px;height:28px;margin:0 0.85rem 0 0}.ontario-critical-alert p{margin:0;padding:0;line-height:1.8}.ontario-critical-alert a{color:#1a1a1a;font-weight:700}.ontario-critical-alert a:hover,.ontario-critical-alert a:focus{text-decoration:none}.ontario-critical-alert a:visited{color:#1a1a1a}.ontario-critical-alert ::slotted(a){color:#1a1a1a !important;font-weight:700}.ontario-critical-alert ::slotted(a:hover),.ontario-critical-alert ::slotted(a:focus){text-decoration:none !important}.ontario-critical-alert ::slotted(a:visited){color:#1a1a1a}';

		class OntarioCriticalAlert {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			get host() {
				return getElement(this);
			}
			/**
			 * Content for critical alert message. It can be either string or HTML content. The content is already wrapped in a paragraph tag, so if using HTML content, the paragraph tag can be ommitted.
			 *
			 * @example
			 * <ontario-critical-alert content="COVID-19 State of emergency extended until May 12, 2020."></ontario-critical-alert>
			 *
			 * or
			 *
			 * <ontario-critical-alert>
			 *  <a href="#">COVID-19 State of emergency</a> extended until May 12, 2020.
			 * </ontario-critical-alert>
			 */
			content;
			/**
			 * Watch for changes to the `content` prop value.
			 *
			 * If no `content` prop was passed, or no host element textContent exists, a warning message will be printed.
			 *
			 * @param newValue string | HTMLElement
			 */
			validateCriticalAlertContent(newValue) {
				// if no slot is passed, run the `validatePropExists` function
				if (!this.host.textContent) {
					if (validatePropExists(newValue)) {
						/**
						 * Print the quote warning message
						 */
						const message = new ConsoleMessageClass();
						message
							.addDesignSystemTag()
							.addMonospaceText(' content ')
							.addRegularText('for')
							.addMonospaceText(' <ontario-critical-alert> ')
							.addRegularText('was not provided.')
							.printMessage();
					}
				}
			}
			renderContent() {
				const content = this.content;
				if (typeof content === 'string') {
					return content;
				}
				return hAsync('slot', null);
			}
			componentWillLoad() {
				this.validateCriticalAlertContent(this.content);
			}
			render() {
				return hAsync(
					'div',
					{ key: 'cf4c3e5c390270f7d877ad7c4b7d754f741626fd', class: 'ontario-critical-alert' },
					hAsync(
						'div',
						{ key: 'a4964983fa2b5bc9929678d3bd7b0cf7de2ddba0', class: 'ontario-row' },
						hAsync(
							'div',
							{ key: 'dedd449315f760e1a35ddb466d60af1e1af7cdbd', class: 'ontario-column ontario-small-12' },
							hAsync(
								'div',
								{ key: '048aa5fb48f716f46140c6af6390e67ef7151631', class: 'ontario-critical-alert__body' },
								hAsync('div', {
									key: '19b130c21073dd7e88c90381eeece2c2889f4ec9',
									class: 'ontario-critical-alert__icon',
									innerHTML: OntarioIconCriticalAlertWarning$1,
								}),
								hAsync('p', { key: '52ac104930699c9a5ae80bd982312048426455b4' }, this.renderContent()),
							),
						),
					),
				);
			}
			static get watchers() {
				return {
					content: ['validateCriticalAlertContent'],
				};
			}
			static get style() {
				return ontarioCriticalAlertCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-critical-alert',
					$members$: {
						content: [1],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const byteToHex = [];
		for (let i = 0; i < 256; ++i) {
			byteToHex.push((i + 0x100).toString(16).slice(1));
		}
		function unsafeStringify(arr, offset = 0) {
			return (
				byteToHex[arr[offset + 0]] +
				byteToHex[arr[offset + 1]] +
				byteToHex[arr[offset + 2]] +
				byteToHex[arr[offset + 3]] +
				'-' +
				byteToHex[arr[offset + 4]] +
				byteToHex[arr[offset + 5]] +
				'-' +
				byteToHex[arr[offset + 6]] +
				byteToHex[arr[offset + 7]] +
				'-' +
				byteToHex[arr[offset + 8]] +
				byteToHex[arr[offset + 9]] +
				'-' +
				byteToHex[arr[offset + 10]] +
				byteToHex[arr[offset + 11]] +
				byteToHex[arr[offset + 12]] +
				byteToHex[arr[offset + 13]] +
				byteToHex[arr[offset + 14]] +
				byteToHex[arr[offset + 15]]
			).toLowerCase();
		}

		let getRandomValues;
		const rnds8 = new Uint8Array(16);
		function rng() {
			if (!getRandomValues) {
				if (typeof crypto === 'undefined' || !crypto.getRandomValues) {
					throw new Error(
						'crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported',
					);
				}
				getRandomValues = crypto.getRandomValues.bind(crypto);
			}
			return getRandomValues(rnds8);
		}

		const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
		var native = { randomUUID };

		function v4(options, buf, offset) {
			if (native.randomUUID && true && !options) {
				return native.randomUUID();
			}
			options = options || {};
			const rnds = options.random ?? options.rng?.() ?? rng();
			if (rnds.length < 16) {
				throw new Error('Random bytes length must be >= 16');
			}
			rnds[6] = (rnds[6] & 0x0f) | 0x40;
			rnds[8] = (rnds[8] & 0x3f) | 0x80;
			return unsafeStringify(rnds);
		}

		const Input = ({
			id,
			type,
			label,
			accessibilityLabel,
			placeholder,
			onInput,
			onChange,
			onFocus,
			onBlur,
			ariaDescribedBy,
			error = false,
			required = false,
		}) => {
			const handleInputInput = (event) => {
				const newValue = event.target?.value ?? '';
				onInput(newValue, type);
			};
			const handleInputChange = (event) => {
				const newValue = event.target?.value ?? '';
				onChange(newValue, type);
			};
			const handleInputFocus = () => {
				onFocus(type);
			};
			const handleInputBlur = () => {
				onBlur(type);
			};
			return hAsync(
				'div',
				{ class: `ontario-date__group-input ${error ? 'ontario-date--error' : ''}` },
				hAsync(
					'label',
					{ htmlFor: id },
					label,
					hAsync('span', { class: 'ontario-show-for-sr' }, '(', accessibilityLabel, ')'),
				),
				hAsync(Input$1, {
					className: 'ontario-input ontario-input--4-char-width',
					type: 'text',
					inputMode: 'numeric',
					id: id,
					required: !!required,
					placeholder: placeholder,
					onInput: handleInputInput,
					onChange: handleInputChange,
					onFocus: handleInputFocus,
					onBlur: handleInputBlur,
					ariaInvalid: error,
					ariaDescribedBy: ariaDescribedBy,
				}),
			);
		};

		const DAY_MIN_VALUE = 1;
		const DAY_MAX_VALUE = 31;
		const MONTH_MIN_VALUE = 1;
		const MONTH_MAX_VALUE = 12;
		const YEAR_MIN_VALUE = 999;
		const YEAR_MAX_VALUE = 9999;

		/*
		 * Day field should be a number, not negative, no greater than 31
		 */
		const isInvalidDay = (value) => {
			if (!isNumber(value)) {
				return true;
			}
			const day = Number(value);
			return day < DAY_MIN_VALUE || day > DAY_MAX_VALUE;
		};
		/*
		 * Month field should be a number, not negative, no greater than 12
		 */
		const isInvalidMonth = (value) => {
			if (!isNumber(value)) {
				return true;
			}
			const month = Number(value);
			return month < MONTH_MIN_VALUE || month > MONTH_MAX_VALUE;
		};
		/**
		 * Valid value year against minimum and maximum year range (defaulted if not provided.)
		 *
		 * Year field should be a number and not written out; it has no concept of positive and negative.
		 *
		 * Suggestion:
		 * - `< 0` B.C.E.
		 * - `>= 0` A.C.E.
		 *
		 * @param value value to check for validity
		 * @param minYear minimum valid year to validate against
		 * @param maxYear maximum valid year to validate against
		 */
		const isInvalidYear = (value, minYear = YEAR_MIN_VALUE, maxYear = YEAR_MAX_VALUE) => {
			if (!isNumber(value)) {
				return true;
			}
			const year = Number(value);
			return year < minYear || year > maxYear;
		};
		/**
		 * Helper function to get error message for birthdate validation
		 */
		const getDateErrorMessage = ({
			dayValue,
			monthValue,
			yearValue,
			errorMessages,
			minYear,
			maxYear,
			dayVisible,
			monthVisible,
			yearVisible,
		}) => {
			const {
				emptyDay,
				emptyMonth,
				emptyYear,
				emptyDayAndMonth,
				emptyDayAndYear,
				emptyMonthAndYear,
				invalidDate,
				invalidDay,
				invalidMonth,
				invalidYear,
			} = errorMessages;
			let error = '';
			let dayInvalid = false;
			let monthInvalid = false;
			let yearInvalid = false;
			const isDayEmpty = dayVisible && isEmpty(dayValue);
			const isMonthEmpty = monthVisible && isEmpty(monthValue);
			const isYearEmpty = yearVisible && isEmpty(yearValue);
			/*
			 *  If one ore more fields are valid but others are empty:
			 *  1 field empty:
			 *  Day as empty - Enter the day.
			 *  Month as empty - Enter the month.
			 *  Year as empty - Enter the year.
			 *  2 fields empty:
			 *  Month and day empty - Enter the month and day.
			 *  Year and day empty - Enter the year and day.
			 *  Year and month empty - Enter the year and month.
			 */
			if (isDayEmpty && isMonthEmpty && isYearEmpty) {
				error = invalidDate;
				dayInvalid = true;
				monthInvalid = true;
				yearInvalid = true;
			} else if (isDayEmpty && isMonthEmpty) {
				error = emptyDayAndMonth;
				dayInvalid = true;
				monthInvalid = true;
			} else if (isDayEmpty && isYearEmpty) {
				error = emptyDayAndYear;
				dayInvalid = true;
				yearInvalid = true;
			} else if (isMonthEmpty && isYearEmpty) {
				error = emptyMonthAndYear;
				yearInvalid = true;
				monthInvalid = true;
			} else if (isDayEmpty) {
				error = emptyDay;
				dayInvalid = true;
			} else if (isMonthEmpty) {
				error = emptyMonth;
				monthInvalid = true;
			} else if (isYearEmpty) {
				error = emptyYear;
				yearInvalid = true;
			}
			const isDayInvalid = dayVisible && isInvalidDay(dayValue);
			const isMonthInvalid = monthVisible && isInvalidMonth(monthValue);
			const isYearInvalid = yearVisible && isInvalidYear(yearValue, minYear, maxYear);
			/*
			 *  If only one error, specify where the error occurs
			 *  E.g. Enter a valid day., Enter a valid month. Or Enter a valid year.
			 *  If 2 or more fields have error (or all 3), say Enter a valid date.
			 *  If one or more fields are invalid but the others are empty say: Enter a valid date.
			 */
			if (isEmpty(error)) {
				if (isDayInvalid && isMonthInvalid && isYearInvalid) {
					error = invalidDate;
					dayInvalid = true;
					monthInvalid = true;
					yearInvalid = true;
				} else if (isDayInvalid && isMonthInvalid) {
					error = invalidDate;
					dayInvalid = true;
					monthInvalid = true;
				} else if (isDayInvalid && isYearInvalid) {
					error = invalidDate;
					dayInvalid = true;
					yearInvalid = true;
				} else if (isMonthInvalid && isYearInvalid) {
					error = invalidDate;
					monthInvalid = true;
					yearInvalid = true;
				} else if (isYearInvalid) {
					error = invalidYear;
					yearInvalid = true;
				} else if (isMonthInvalid) {
					error = invalidMonth;
					monthInvalid = true;
				} else if (isDayInvalid) {
					error = invalidDay;
					dayInvalid = true;
				}
			}
			return { errorMessage: error, dayInvalid, monthInvalid, yearInvalid };
		};

		const getVisibleDateFields = (dateOptions) => {
			const dayVisible = dateOptions.includes('day');
			const monthVisible = dateOptions.includes('month');
			const yearVisible = dateOptions.includes('year');
			return { dayVisible, monthVisible, yearVisible };
		};

		const ontarioDateInputCss =
			'@charset "UTF-8";h6,.ontario-h6,h5,.ontario-h5,h4,.ontario-h4,h3,.ontario-h3,h2,.ontario-h2,h1>.ontario-label--heading,.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1,h1,.ontario-h1{font-style:normal;font-weight:700;text-rendering:optimizeLegibility;margin-bottom:1rem;font-feature-settings:normal;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif}h1>.ontario-label--heading,.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1,h1,.ontario-h1{font-size:2rem;letter-spacing:0.04rem;line-height:1.29;margin:2.5rem 0 1.5rem 0;max-width:70rem}@media screen and (min-width: 40em){h1>.ontario-label--heading,.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1,h1,.ontario-h1{font-size:2.5rem;letter-spacing:0.04rem;line-height:1.2}}h2,.ontario-h2{font-size:1.6875rem;letter-spacing:0.03rem;line-height:1.37;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h2,.ontario-h2{font-size:2.0625rem;letter-spacing:0.02rem;line-height:1.33}}h3,.ontario-h3{font-size:1.4375rem;letter-spacing:0.02rem;line-height:1.39;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h3,.ontario-h3{font-size:1.75rem;letter-spacing:0.02rem;line-height:1.43}}h4,.ontario-h4{font-size:1.25rem;letter-spacing:0.03rem;line-height:1.5;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h4,.ontario-h4{font-size:1.5rem;letter-spacing:0.0313rem;line-height:1.5}}h5,.ontario-h5{font-size:1.125rem;letter-spacing:0.03rem;line-height:1.56;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h5,.ontario-h5{font-size:1.1875rem;letter-spacing:0.025rem;line-height:1.5}}h6,.ontario-h6{font-size:1rem;line-height:1.56;letter-spacing:0.03rem;max-width:48rem;margin:0 0 0.75rem 0}@media screen and (min-width: 40em){h6,.ontario-h6{font-size:1rem;letter-spacing:0.025rem;line-height:1.5}}.ontario-lead-statement{font-size:1.25rem;line-height:1.6;max-width:70rem}@media screen and (min-width: 40em){.ontario-lead-statement{font-size:1.375rem}}html{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem}body{font-size:1rem;line-height:1.6;background-color:#FFFFFF;color:#1a1a1a;margin:0}p{font-size:inherit;margin-bottom:1.25rem;text-rendering:optimizeLegibility;margin:0 0 1.5rem 0}cite{font-style:italic;line-height:inherit}strong{font-weight:700;line-height:inherit}*,*::before,*::after{box-sizing:inherit}main p,main p:not(.ontario-lead-statement),main dd,main li{max-width:48rem}hr{border:0;padding:0;margin:2.5rem 0;border-bottom:4px solid #cccccc}hr.ontario-hr--dark{border-bottom:4px solid #1a1a1a}a{color:#0066CC;text-decoration:underline}a:visited{color:#551A8B}a:hover{color:#00478F}a:active{color:#002142}a:focus{-moz-box-shadow:0 0 0 4px #009ADB;-webkit-box-shadow:0 0 0 4px #009ADB;box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:all 0.1s ease-in-out}p{margin:0 0 1.5rem 0}p+h1,p+h2,p+h3,p+h4,p+h5,p+h6,ul+h1,ul+h2,ul+h3,ul+h4,ul+h5,ul+h6,ol+h1,ol+h2,ol+h3,ol+h4,ol+h5,ol+h6,h1+h2,h2+h3,h3+h4,h4+h5,h5+h6{margin-top:2rem}p code,td code,li code{line-height:2.25rem}input[type=text],input[type=number],input[type=email],input[type=date],input[type=color],input[type=search],input[type=tel],textarea{background-origin:initial;height:auto;-webkit-appearance:none;-moz-appearance:none}input[type=checkbox]+label,input[type=radio]+label{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400;margin-left:0;margin-right:0}fieldset{border:0;margin:0;padding:0;page-break-inside:avoid}legend,label{display:block;margin:0}select{background-origin:initial;height:auto;-webkit-appearance:none;-moz-appearance:none}ul,ol{padding:0}ul{margin-left:2rem}ul li{padding:0 0 0.75rem 0}ol{margin-left:1.75rem}ol li{padding:0 0 0.75rem 0.25rem}ul li:last-child,ol li:last-child{padding-bottom:0}ul[class*=columns-] li:last-child,ol[class*=columns-] li:last-child{padding-bottom:0.75rem}ul ul,ol ul{margin:0.5rem 0 0.5rem 2rem}ul ol,ol ol{margin:0.5rem 0 0.5rem 1.75rem}p+ul,p+ol{margin-top:-0.75rem}@media screen and (min-width: 40em){ul{margin:0.5rem 0 1.5rem 3rem}ol{margin:0.5rem 0 1.5rem 2.75rem}ul ul,ol ul{margin:0.5rem 0 0.5rem 3rem}ul ol,ol ol{margin:0.5rem 0 0.5rem 2.75rem}}.ontario-form-group:last-of-type{margin-bottom:2.5rem}.ontario-form-group:last-of-type{margin-bottom:3rem}.ontario-fieldset__legend{color:#1a1a1a;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1.1875rem;font-weight:700;margin:0 0 1rem 0;line-height:1.5;max-width:38.75em;white-space:normal;width:100%;hyphens:auto}@media screen and (max-width: 40em){.ontario-fieldset__legend{font-size:1.125rem;line-height:1.56}}.ontario-fieldset__legend--large,.ontario-fieldset__legend--heading{letter-spacing:0.02rem;line-height:1.2}.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1{display:inline-block;margin:0}@media screen and (max-width: 40em){.ontario-fieldset__legend--large,.ontario-fieldset__legend--heading{font-size:1.4375rem;line-height:1.39}}.ontario-fieldset__legend--large{font-size:1.75rem}.ontario-fieldset__legend-required-flag,.ontario-fieldset__legend-optional-flag{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400}.ontario-fieldset__legend-required-flag:before,.ontario-fieldset__legend-optional-flag:before{content:""}.ontario-label__flag{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400}.ontario-label__flag:before{content:""}.ontario-label{cursor:pointer;color:#1a1a1a;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1.1875rem;font-weight:700;line-height:1.5;margin:0 0 1rem 0;max-width:38.75em;white-space:normal;width:100%;hyphens:auto}@media screen and (max-width: 40em){.ontario-label{font-size:1.125rem;line-height:1.56}}.ontario-label--large{font-size:1.75rem;letter-spacing:0.02rem;line-height:1.2;max-width:26.25em}@media screen and (max-width: 40em){.ontario-label--large{font-size:1.4375rem;line-height:1.39}}h1>.ontario-label--heading{display:inline-block;margin:0}.ontario-label__flag{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400}.ontario-label__flag:before{content:""}.ontario-input:focus,.ontario-input:active{box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:box-shadow 0.1s ease-in-out}.ontario-input{border:2px solid #1a1a1a;border-radius:4px;box-sizing:border-box;color:#1a1a1a;display:block;font-size:1rem;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;line-height:1.5;margin:0 0 2.5rem;max-width:48rem;width:100%;padding:0.625rem 1rem;transition:box-shadow 0.1s ease-in-out}.ontario-input--2-char-width{max-width:8ex}.ontario-input--3-char-width{max-width:10ex}.ontario-input--4-char-width{max-width:12ex}.ontario-input--5-char-width{max-width:14ex}.ontario-input--7-char-width{max-width:17ex}.ontario-input--10-char-width{max-width:23ex}.ontario-input--20-char-width{max-width:41ex}.ontario-form-group:last-of-type{margin-bottom:2.5rem}.ontario-hide{display:none !important}.ontario-invisible{visibility:hidden !important}@media screen and (max-width: 39.99875em){.ontario-hide-for-small-only{display:none !important}}@media screen and (max-width: 0em), screen and (min-width: 40em){.ontario-show-for-small-only{display:none !important}}@media print, screen and (min-width: 40em){.ontario-hide-for-medium{display:none !important}}@media screen and (max-width: 39.99875em){.ontario-show-for-medium{display:none !important}}@media screen and (min-width: 40em) and (max-width: 72.99875em){.ontario-hide-for-medium-only{display:none !important}}@media screen and (max-width: 39.99875em), screen and (min-width: 73em){.ontario-show-for-medium-only{display:none !important}}@media print, screen and (min-width: 73em){.ontario-hide-for-large{display:none !important}}@media screen and (max-width: 72.99875em){.ontario-show-for-large{display:none !important}}@media screen and (min-width: 73em) and (max-width: 95.99875em){.ontario-hide-for-large-only{display:none !important}}@media screen and (max-width: 72.99875em), screen and (min-width: 96em){.ontario-show-for-large-only{display:none !important}}.ontario-show-for-sr,.ontario-show-on-focus{position:absolute;width:1px;height:1px;overflow:hidden;clip:rect(0, 0, 0, 0)}.ontario-show-on-focus:active,.ontario-show-on-focus:focus{position:static;width:auto;height:auto;overflow:visible;clip:auto}.ontario-show-for-landscape,.ontario-hide-for-portrait{display:block !important}@media screen and (orientation: landscape){.ontario-show-for-landscape,.ontario-hide-for-portrait{display:block !important}}@media screen and (orientation: portrait){.ontario-show-for-landscape,.ontario-hide-for-portrait{display:none !important}}.ontario-hide-for-landscape,.ontario-show-for-portrait{display:none !important}@media screen and (orientation: landscape){.ontario-hide-for-landscape,.ontario-show-for-portrait{display:none !important}}@media screen and (orientation: portrait){.ontario-hide-for-landscape,.ontario-show-for-portrait{display:block !important}}.ontario-error-messaging{display:flex;align-items:flex-start;margin:-0.25rem 0 0.5rem 0;color:#D81A21;max-width:48rem}.ontario-error-messaging__content{margin-left:0.5rem}.ontario-input__error{border-color:#D81A21 !important}.ontario-error__hidden{display:none}.ontario-date__group{display:flex}.ontario-date__group label{font-weight:600}.ontario-date__group input{margin-top:1rem}.ontario-date__group-input{display:flex;flex-direction:column;margin-right:1.5rem}.ontario-date--error input{border:0.125rem solid #CD0000}';

		class OntarioDateInput {
			constructor(hostRef) {
				registerInstance(this, hostRef);
				this.inputOnInput = createEvent(this, 'inputOnInput');
				this.inputOnChange = createEvent(this, 'inputOnChange');
				this.inputOnBlur = createEvent(this, 'inputOnBlur');
				this.inputOnFocus = createEvent(this, 'inputOnFocus');
				this.inputErrorOccurred = createEvent(this, 'inputErrorOccurred');
				if (hostRef.$hostElement$['s-ei']) {
					this.internals = hostRef.$hostElement$['s-ei'];
				} else {
					this.internals = hostRef.$hostElement$.attachInternals();
					hostRef.$hostElement$['s-ei'] = this.internals;
				}
			}
			get element() {
				return getElement(this);
			}
			internals;
			/**
			 * The language of the component.
			 * This is used for translations, and is by default set through event listeners checking for a language property from the header. If none are passed, it will default to English.
			 */
			language;
			/**
			 * A boolean value to determine whether or not the date input is required.
			 *
			 * This is optional. If no prop is passed, it will default to `false`.
			 */
			required = false;
			/**
			 * An object value used to set the placeholder text for the day, month and year input fields. Any combination of the three input fields (i.e day, month, year)
			 * of the date component can be overridden.
			 *
			 * This is optional. If no prop is passed, it will not display any placeholder text.
			 */
			placeholder;
			/**
			 * The text to display as the input label
			 *
			 * @example
			 * <ontario-date-input
			 *   caption='{
			 *     "captionText": "Exact Date",
			 *     "captionType": "heading",
			 *   }
			 *   required="true"
			 *   ...>
			 * </ontario-date-input>
			 */
			caption;
			/**
			 * The unique identifier of the input. This is optional - if no ID is passed, one will be generated.
			 */
			elementId;
			/**
			 * A number value indicating minimum value allowed for year input field of the date component.
			 *
			 * This is optional. If no prop is passed, it will default to `999`.
			 */
			minYear;
			/**
			 * A number value indicating maximum value allowed for year input field of the date component.
			 *
			 * This is optional. If no prop is passed, it will default to `9999`.
			 */
			maxYear;
			/**
			 * Used to include the ontario-hint-text component for the date input group.
			 *
			 * This is optional.
			 */
			hintText;
			/**
			 * An array value used to display date options. For example, only the day and month fields can be displayed by
			 * specifying the dateOptions as `["day", "month"]`, etc.
			 *
			 * This is optional. If no prop for `dateOptions` is passed, it will default to `["day", "month", "year"]`.
			 */
			dateOptions = ['day', 'month', 'year'];
			/**
			 * A function used to override internal date validation logic, which takes three arguments (i.e day, month and year) and returns
			 * an object of type `DateValidatorReturnType`
			 *
			 * This is optional. If no prop for `dateValidator` is passed, it will default to internal validation function to validate
			 * the date input.
			 */
			dateValidator;
			/**
			 * Emitted when an `input` event occurs within the component.
			 */
			inputOnInput;
			/**
			 * Emitted when a `change` event occurs within the component.
			 */
			inputOnChange;
			/**
			 * Emitted when a keyboard input event occurs when an input has lost focus.
			 */
			inputOnBlur;
			/**
			 * Emitted when a keyboard input event occurs when an input has gained focus.
			 */
			inputOnFocus;
			/**
			 * Emitted when an error message is reported to the component.
			 */
			inputErrorOccurred;
			broadcastInputErrorOccurredEvent() {
				// Emit event to notify anyone who wants to listen for errors occurring
				this.inputErrorOccurred.emit({ inputId: this.getId(), errorMessage: this.errorMessage ?? '' });
			}
			/**
			 * This listens for the `setAppLanguage` event sent from the test language toggler when it is is connected to the DOM. It is used for the initial language when the input component loads.
			 */
			handleSetAppLanguage(event) {
				if (!this.language) {
					this.language = validateLanguage(event);
				}
			}
			handleHeaderLanguageToggled(event) {
				this.language = validateLanguage(event);
			}
			handleComponentBlur() {
				const { day, month, year, minYear, maxYear, dateValidator, dateOptionsState } = this;
				const { dayVisible, monthVisible, yearVisible } = getVisibleDateFields(dateOptionsState);
				// if user has not interacted with the component, skip validation
				if (!this.isDateTyped) {
					return;
				}
				const errorMessages = translations.dateInput.error[this.getLanguage()];
				const { dayInvalid, monthInvalid, yearInvalid, errorMessage } = dateValidator
					? dateValidator(day, month, year)
					: getDateErrorMessage({
							dayValue: day,
							monthValue: month,
							yearValue: year,
							errorMessages,
							minYear,
							maxYear,
							dayVisible,
							monthVisible,
							yearVisible,
						});
				this.dayInvalid = dayInvalid;
				this.monthInvalid = monthInvalid;
				this.yearInvalid = yearInvalid;
				this.errorMessage = errorMessage;
			}
			translations = translations;
			captionState;
			isDateTyped = false;
			dayInvalid = false;
			monthInvalid = false;
			yearInvalid = false;
			errorMessage;
			day = '';
			month = '';
			year = '';
			placeholderState;
			dateOptionsState;
			/**
			 * Watch for changes to the `caption` prop.
			 *
			 * The caption will be run through the InputCaption constructor to convert it to the correct format, and set the result to the `captionState` state.
			 * @param newValue: Caption | string
			 */
			updateCaptionState(newValue) {
				this.captionState = new InputCaption(
					this.element.tagName,
					newValue,
					translations,
					this.language,
					true,
					this.required,
				);
			}
			/**
			 * Watch for changes in the `language` prop to render either the English or French translations
			 */
			updateLanguage() {
				this.updateCaptionState(this.caption);
			}
			processPlaceholder() {
				this.parseOptions(this.placeholder);
			}
			processDateOptions() {
				this.parseOptions(this.dateOptions);
			}
			parseOptions(options) {
				const isString = typeof options === 'string';
				if (!options) {
					return;
				}
				try {
					if (options === this.placeholder) {
						this.placeholderState = isString ? JSON.parse(options) : options;
					} else if (options === this.dateOptions) {
						this.dateOptionsState = isString ? JSON.parse(options) : options;
					}
				} catch (error) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addRegularText(' failed to parse props for ')
						.addMonospaceText('<ontario-date-input>')
						.addRegularText(' in ')
						.addMonospaceText('parseOptions()')
						.addRegularText(' method \n ')
						.addMonospaceText(error.stack)
						.printMessage(ConsoleType.Error);
				}
			}
			isInvalidDate = () => {
				return this.dayInvalid || this.monthInvalid || this.yearInvalid;
			};
			resetErrorState = () => {
				if (!this.isInvalidDate()) {
					return;
				}
				this.dayInvalid = false;
				this.monthInvalid = false;
				this.yearInvalid = false;
				this.errorMessage = '';
			};
			updateDateState = (value, inputFieldType) => {
				switch (inputFieldType) {
					case 'day':
						this.day = value;
						break;
					case 'month':
						this.month = value;
						break;
					case 'year':
						this.year = value;
						break;
				}
			};
			handleDateUpdates = (value, fieldType) => {
				// set boolean indicating user interaction with the component for validation
				if (!this.isDateTyped) {
					this.isDateTyped = true;
				}
				// reset error state when user starts typing
				this.resetErrorState();
				// update date state
				this.updateDateState(value, fieldType);
				// TODO: verify are all the values numbers?
				if (this.year && this.month && this.day) {
					const desiredDate = new Date(
						Date.UTC(parseInt(this.year), parseInt(this.month) - 1, parseInt(this.day), 0, 0, 0, 0),
					);
					this.internals?.setFormValue?.(desiredDate.toISOString());
				}
			};
			handleDateInput = (value, fieldType) => {
				this.handleDateUpdates(value, fieldType);
				// emit date change event
				this.inputOnInput.emit({ value, fieldType });
			};
			handleDateChanged = (value, fieldType) => {
				this.handleDateUpdates(value, fieldType);
				// emit date change event
				this.inputOnChange.emit({ value, fieldType });
				// emit change event
				emitEvent(this.element, 'change', { value, fieldType });
			};
			handleDateFocus = (fieldType) => {
				// emit date field focus event
				this.inputOnFocus.emit(fieldType);
			};
			handleDateBlur = (fieldType) => {
				// emit date field focus event
				this.inputOnBlur.emit(fieldType);
			};
			getLanguage() {
				return this.language ?? 'en';
			}
			getCaption() {
				const language = this.getLanguage();
				const captionText = translations.dateInput.caption[language];
				return this.caption ?? { captionText, captionType: 'default' };
			}
			getId() {
				return this.elementId ?? '';
			}
			getHintTextId() {
				return `date-input-hint-${this.getId()}`;
			}
			getInputIds() {
				const id = this.getId();
				const dayId = `day-${id}`;
				const monthId = `month-${id}`;
				const yearId = `year-${id}`;
				return { dayId, monthId, yearId };
			}
			componentWillLoad() {
				this.processPlaceholder();
				this.processDateOptions();
				this.updateCaptionState(this.getCaption());
				this.elementId = this.elementId ?? v4();
				this.language = validateLanguage(this.language);
			}
			render() {
				const { dateOptionsState, required, translations, hintText, placeholderState } = this;
				const language = this.getLanguage();
				const dateStrings = translations.dateInput;
				const placeholderText = placeholderState ?? {};
				const { dayVisible, monthVisible, yearVisible } = getVisibleDateFields(dateOptionsState);
				const { dayId, monthId, yearId } = this.getInputIds();
				const hintTextId = this.getHintTextId();
				return hAsync(
					'div',
					{ key: 'fb2e35ac185c5b7e907dc7d7e5a9f19efec5da60', class: 'ontario-form-group' },
					hAsync(
						'fieldset',
						{ key: '75825fe50854e77ca693a1e4d70ae7081b6abca7', role: 'group', class: 'ontario-fieldset' },
						this.captionState.getCaption(),
						!!hintText &&
							hAsync(
								'p',
								{ key: '9bfa87affb330cbecb03b8126fd11d1168841e7c', id: hintTextId, class: 'ontario-hint' },
								hintText,
							),
						hAsync(ErrorMessage, {
							key: 'ad38e55cd91bcc4c9f1b5e62970d89d389c33b48',
							message: this.errorMessage,
							error: this.isInvalidDate(),
						}),
						hAsync(
							'div',
							{ key: '221265608ce2ebbfbbc9e5aa39088b456403cc9a', class: 'ontario-date__group' },
							yearVisible &&
								hAsync(Input, {
									key: '105e1af34520b7b81442ac48e1d6ac77ce8c6a5d',
									id: yearId,
									type: 'year',
									label: dateStrings.year.label[language],
									accessibilityLabel: dateStrings.year.accessibility[language],
									required: !!required,
									error: this.yearInvalid,
									placeholder: placeholderText.year,
									onInput: this.handleDateInput,
									onChange: this.handleDateChanged,
									onBlur: this.handleDateBlur,
									onFocus: this.handleDateFocus,
									ariaDescribedBy: hintTextId,
								}),
							monthVisible &&
								hAsync(Input, {
									key: 'f7c69b3c2d21815d8f66ec2cb7b2ae6ff826de41',
									id: monthId,
									type: 'month',
									label: dateStrings.month.label[language],
									accessibilityLabel: dateStrings.month.accessibility[language],
									required: !!required,
									error: this.monthInvalid,
									placeholder: placeholderText.month,
									onInput: this.handleDateInput,
									onChange: this.handleDateChanged,
									onBlur: this.handleDateBlur,
									onFocus: this.handleDateFocus,
									ariaDescribedBy: hintTextId,
								}),
							dayVisible &&
								hAsync(Input, {
									key: '41ba2e13537d61dc4c73e23dc5e30887a0d60cdd',
									id: dayId,
									type: 'day',
									label: dateStrings.day.label[language],
									accessibilityLabel: dateStrings.day.accessibility[language],
									required: !!required,
									error: this.dayInvalid,
									placeholder: placeholderText.day,
									onInput: this.handleDateInput,
									onChange: this.handleDateChanged,
									onBlur: this.handleDateBlur,
									onFocus: this.handleDateFocus,
									ariaDescribedBy: hintTextId,
								}),
						),
					),
				);
			}
			static get formAssociated() {
				return true;
			}
			static get watchers() {
				return {
					errorMessage: ['broadcastInputErrorOccurredEvent'],
					caption: ['updateCaptionState'],
					language: ['updateLanguage'],
				};
			}
			static get style() {
				return ontarioDateInputCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 73,
					$tagName$: 'ontario-date-input',
					$members$: {
						language: [1025],
						required: [4],
						placeholder: [1],
						caption: [1],
						elementId: [1025, 'element-id'],
						minYear: [2, 'min-year'],
						maxYear: [2, 'max-year'],
						hintText: [1, 'hint-text'],
						dateOptions: [1, 'date-options'],
						dateValidator: [16, 'date-validator'],
						translations: [32],
						captionState: [32],
						isDateTyped: [32],
						dayInvalid: [32],
						monthInvalid: [32],
						yearInvalid: [32],
						errorMessage: [32],
						day: [32],
						month: [32],
						year: [32],
						placeholderState: [32],
						dateOptionsState: [32],
					},
					$listeners$: [
						[8, 'setAppLanguage', 'handleSetAppLanguage'],
						[8, 'headerLanguageToggled', 'handleHeaderLanguageToggled'],
						[2, 'blur', 'handleComponentBlur'],
					],
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioDropdownListCss =
			'@charset "UTF-8";h6,.ontario-h6,h5,.ontario-h5,h4,.ontario-h4,h3,.ontario-h3,h2,.ontario-h2,h1>.ontario-label--heading,.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1,h1,.ontario-h1{font-style:normal;font-weight:700;text-rendering:optimizeLegibility;margin-bottom:1rem;font-feature-settings:normal;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif}h1>.ontario-label--heading,.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1,h1,.ontario-h1{font-size:2rem;letter-spacing:0.04rem;line-height:1.29;margin:2.5rem 0 1.5rem 0;max-width:70rem}@media screen and (min-width: 40em){h1>.ontario-label--heading,.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1,h1,.ontario-h1{font-size:2.5rem;letter-spacing:0.04rem;line-height:1.2}}h2,.ontario-h2{font-size:1.6875rem;letter-spacing:0.03rem;line-height:1.37;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h2,.ontario-h2{font-size:2.0625rem;letter-spacing:0.02rem;line-height:1.33}}h3,.ontario-h3{font-size:1.4375rem;letter-spacing:0.02rem;line-height:1.39;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h3,.ontario-h3{font-size:1.75rem;letter-spacing:0.02rem;line-height:1.43}}h4,.ontario-h4{font-size:1.25rem;letter-spacing:0.03rem;line-height:1.5;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h4,.ontario-h4{font-size:1.5rem;letter-spacing:0.0313rem;line-height:1.5}}h5,.ontario-h5{font-size:1.125rem;letter-spacing:0.03rem;line-height:1.56;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h5,.ontario-h5{font-size:1.1875rem;letter-spacing:0.025rem;line-height:1.5}}h6,.ontario-h6{font-size:1rem;line-height:1.56;letter-spacing:0.03rem;max-width:48rem;margin:0 0 0.75rem 0}@media screen and (min-width: 40em){h6,.ontario-h6{font-size:1rem;letter-spacing:0.025rem;line-height:1.5}}.ontario-lead-statement{font-size:1.25rem;line-height:1.6;max-width:70rem}@media screen and (min-width: 40em){.ontario-lead-statement{font-size:1.375rem}}html{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem}body{font-size:1rem;line-height:1.6;background-color:#FFFFFF;color:#1a1a1a;margin:0}p{font-size:inherit;margin-bottom:1.25rem;text-rendering:optimizeLegibility;margin:0 0 1.5rem 0}cite{font-style:italic;line-height:inherit}strong{font-weight:700;line-height:inherit}*,*::before,*::after{box-sizing:inherit}main p,main p:not(.ontario-lead-statement),main dd,main li{max-width:48rem}hr{border:0;padding:0;margin:2.5rem 0;border-bottom:4px solid #cccccc}hr.ontario-hr--dark{border-bottom:4px solid #1a1a1a}a{color:#0066CC;text-decoration:underline}a:visited{color:#551A8B}a:hover{color:#00478F}a:active{color:#002142}a:focus{-moz-box-shadow:0 0 0 4px #009ADB;-webkit-box-shadow:0 0 0 4px #009ADB;box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:all 0.1s ease-in-out}p{margin:0 0 1.5rem 0}p+h1,p+h2,p+h3,p+h4,p+h5,p+h6,ul+h1,ul+h2,ul+h3,ul+h4,ul+h5,ul+h6,ol+h1,ol+h2,ol+h3,ol+h4,ol+h5,ol+h6,h1+h2,h2+h3,h3+h4,h4+h5,h5+h6{margin-top:2rem}p code,td code,li code{line-height:2.25rem}input[type=text],input[type=number],input[type=email],input[type=date],input[type=color],input[type=search],input[type=tel],textarea{background-origin:initial;height:auto;-webkit-appearance:none;-moz-appearance:none}input[type=checkbox]+label,input[type=radio]+label{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400;margin-left:0;margin-right:0}fieldset{border:0;margin:0;padding:0;page-break-inside:avoid}legend,label{display:block;margin:0}select{background-origin:initial;height:auto;-webkit-appearance:none;-moz-appearance:none}ul,ol{padding:0}ul{margin-left:2rem}ul li{padding:0 0 0.75rem 0}ol{margin-left:1.75rem}ol li{padding:0 0 0.75rem 0.25rem}ul li:last-child,ol li:last-child{padding-bottom:0}ul[class*=columns-] li:last-child,ol[class*=columns-] li:last-child{padding-bottom:0.75rem}ul ul,ol ul{margin:0.5rem 0 0.5rem 2rem}ul ol,ol ol{margin:0.5rem 0 0.5rem 1.75rem}p+ul,p+ol{margin-top:-0.75rem}@media screen and (min-width: 40em){ul{margin:0.5rem 0 1.5rem 3rem}ol{margin:0.5rem 0 1.5rem 2.75rem}ul ul,ol ul{margin:0.5rem 0 0.5rem 3rem}ul ol,ol ol{margin:0.5rem 0 0.5rem 2.75rem}}.ontario-form-group:last-of-type{margin-bottom:2.5rem}.ontario-form-group:last-of-type{margin-bottom:3rem}.ontario-fieldset__legend{color:#1a1a1a;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1.1875rem;font-weight:700;margin:0 0 1rem 0;line-height:1.5;max-width:38.75em;white-space:normal;width:100%;hyphens:auto}@media screen and (max-width: 40em){.ontario-fieldset__legend{font-size:1.125rem;line-height:1.56}}.ontario-fieldset__legend--large,.ontario-fieldset__legend--heading{letter-spacing:0.02rem;line-height:1.2}.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1{display:inline-block;margin:0}@media screen and (max-width: 40em){.ontario-fieldset__legend--large,.ontario-fieldset__legend--heading{font-size:1.4375rem;line-height:1.39}}.ontario-fieldset__legend--large{font-size:1.75rem}.ontario-fieldset__legend-required-flag,.ontario-fieldset__legend-optional-flag{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400}.ontario-fieldset__legend-required-flag:before,.ontario-fieldset__legend-optional-flag:before{content:""}.ontario-label__flag{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400}.ontario-label__flag:before{content:""}.ontario-label{cursor:pointer;color:#1a1a1a;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1.1875rem;font-weight:700;line-height:1.5;margin:0 0 1rem 0;max-width:38.75em;white-space:normal;width:100%;hyphens:auto}@media screen and (max-width: 40em){.ontario-label{font-size:1.125rem;line-height:1.56}}.ontario-label--large{font-size:1.75rem;letter-spacing:0.02rem;line-height:1.2;max-width:26.25em}@media screen and (max-width: 40em){.ontario-label--large{font-size:1.4375rem;line-height:1.39}}h1>.ontario-label--heading{display:inline-block;margin:0}.ontario-label__flag{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400}.ontario-label__flag:before{content:""}.ontario-input:focus,.ontario-input:active{box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:box-shadow 0.1s ease-in-out}.ontario-input{border:2px solid #1a1a1a;border-radius:4px;box-sizing:border-box;color:#1a1a1a;display:block;font-size:1rem;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;line-height:1.5;margin:0 0 2.5rem;max-width:48rem;width:100%;padding:0.625rem 1rem;transition:box-shadow 0.1s ease-in-out}.ontario-input--2-char-width{max-width:8ex}.ontario-input--3-char-width{max-width:10ex}.ontario-input--4-char-width{max-width:12ex}.ontario-input--5-char-width{max-width:14ex}.ontario-input--7-char-width{max-width:17ex}.ontario-input--10-char-width{max-width:23ex}.ontario-input--20-char-width{max-width:41ex}.ontario-form-group:last-of-type{margin-bottom:2.5rem}.ontario-hide{display:none !important}.ontario-invisible{visibility:hidden !important}@media screen and (max-width: 39.99875em){.ontario-hide-for-small-only{display:none !important}}@media screen and (max-width: 0em), screen and (min-width: 40em){.ontario-show-for-small-only{display:none !important}}@media print, screen and (min-width: 40em){.ontario-hide-for-medium{display:none !important}}@media screen and (max-width: 39.99875em){.ontario-show-for-medium{display:none !important}}@media screen and (min-width: 40em) and (max-width: 72.99875em){.ontario-hide-for-medium-only{display:none !important}}@media screen and (max-width: 39.99875em), screen and (min-width: 73em){.ontario-show-for-medium-only{display:none !important}}@media print, screen and (min-width: 73em){.ontario-hide-for-large{display:none !important}}@media screen and (max-width: 72.99875em){.ontario-show-for-large{display:none !important}}@media screen and (min-width: 73em) and (max-width: 95.99875em){.ontario-hide-for-large-only{display:none !important}}@media screen and (max-width: 72.99875em), screen and (min-width: 96em){.ontario-show-for-large-only{display:none !important}}.ontario-show-for-sr,.ontario-show-on-focus{position:absolute;width:1px;height:1px;overflow:hidden;clip:rect(0, 0, 0, 0)}.ontario-show-on-focus:active,.ontario-show-on-focus:focus{position:static;width:auto;height:auto;overflow:visible;clip:auto}.ontario-show-for-landscape,.ontario-hide-for-portrait{display:block !important}@media screen and (orientation: landscape){.ontario-show-for-landscape,.ontario-hide-for-portrait{display:block !important}}@media screen and (orientation: portrait){.ontario-show-for-landscape,.ontario-hide-for-portrait{display:none !important}}.ontario-hide-for-landscape,.ontario-show-for-portrait{display:none !important}@media screen and (orientation: landscape){.ontario-hide-for-landscape,.ontario-show-for-portrait{display:none !important}}@media screen and (orientation: portrait){.ontario-hide-for-landscape,.ontario-show-for-portrait{display:block !important}}.ontario-error-messaging{display:flex;align-items:flex-start;margin:-0.25rem 0 0.5rem 0;color:#D81A21;max-width:48rem}.ontario-error-messaging__content{margin-left:0.5rem}.ontario-input__error{border-color:#D81A21 !important}.ontario-error__hidden{display:none}.ontario-dropdown{background-color:#FFFFFF;background-position:right 0.5rem center;background-repeat:no-repeat;background-size:2rem;padding-right:2.25rem;cursor:pointer}.ontario-dropdown.ontario-dropdown-hint-expander--true{margin-bottom:1rem}.ontario-dropdown::-ms-expand{display:none}.ontario-dropdown option{font-weight:normal}.ontario-dropdown--error select{border:0.125rem solid #CD0000}';

		class OntarioDropdownList {
			constructor(hostRef) {
				registerInstance(this, hostRef);
				this.dropdownOnChange = createEvent(this, 'dropdownOnChange');
				this.dropdownOnBlur = createEvent(this, 'dropdownOnBlur');
				this.dropdownOnFocus = createEvent(this, 'dropdownOnFocus');
				this.inputErrorOccurred = createEvent(this, 'inputErrorOccurred');
				if (hostRef.$hostElement$['s-ei']) {
					this.internals = hostRef.$hostElement$['s-ei'];
				} else {
					this.internals = hostRef.$hostElement$.attachInternals();
					hostRef.$hostElement$['s-ei'] = this.internals;
				}
			}
			get element() {
				return getElement(this);
			}
			internals;
			hintTextRef;
			/**
			 * The text to display for the dropdown list label.
			 *
			 * @example
			 * <ontario-dropdown-list
			 *   name="ontario-dropdown-list"
			 *   caption='{
			 *     "captionText": "Label",
			 *     "captionType": "heading",
			 *   }'
			 *   ...>
			 * </ontario-dropdown-list>
			 */
			caption;
			/**
			 * The language of the component.
			 * This is used for translations, and is by default set through event listeners checking for a language property from the header. If no language is passed, it will default to English.
			 */
			language;
			/**
			 * The name for the dropdown list. The name value is used to reference form data after a form is submitted.
			 */
			name;
			/**
			 * The ID for the dropdown list.
			 * If no ID is provided, one will be generated.
			 */
			elementId;
			/**
			 * The options for dropdown list.
			 *
			 * Each option will be passed in through an object in the options array.
			 * This can either be passed in as an object directly (if using react), or as a string in HTML.
			 *
			 * In the example below, the options are being passed in as a string and there are three dropdown options displayed.
			 *
			 * @example
			 * <ontario-dropdown-list
			 *   caption='{
			 *     "captionText": "Label",
			 *     "captionType": "heading",
			 *   }'
			 *   name="ontario-dropdown-list"
			 *   options='[
			 *     {
			 *       "value": "dropdown-option-1",
			 *       "label": "Option 1",
			 *       "selected": "true"
			 *     },
			 *     {
			 *       "value": "dropdown-option-2",
			 *       "label": "Option 2"
			 *     },
			 *     {
			 *       "value": "dropdown-option-3",
			 *       "label": "Option 3"
			 *     }
			 *   ]'
			 * >
			 * </ontario-dropdown-list>
			 */
			options;
			/**
			 * This is used to determine whether the dropdown list is required or not.
			 * This prop also gets passed to the InputCaption utility to display either an optional or required flag in the label.
			 * If no prop is set, it will default to false (optional).
			 */
			required = false;
			/**
			 * This prop is used to determine whether or not the initial option displayed is empty.
			 * If set to `true`, it will render the default select text.
			 * If set to a string, it will render the string value.
			 *
			 * @example
			 * <ontario-dropdown-list is-empty-start-option="true"></ontario-dropdown-list>
			 *
			 * or
			 *
			 * <ontario-dropdown-list is-empty-start-option="Please select"></ontario-dropdown-list>
			 */
			isEmptyStartOption = false;
			/**
			 * Used to include the ontario-hint-text component for the dropdown list.
			 * This is optional.
			 */
			hintText;
			/**
			 * Used to include the ontario-hint-expander component for the dropdown list component.
			 * This is passed in as an object with key-value pairs.
			 *
			 * This is optional.
			 *
			 * @example
			 * <ontario-dropdown-list
			 *   caption='{
			 *     "caption": "What province do you live in?",
			 *     "captionType": "heading",
			 *   }
			 *   name="ontario-dropdown-list"
			 *   options='[
			 *     {
			 *       "value": "dropdown-option-1",
			 *       "label": "Option 1",
			 *       "selected": "true"
			 *     },
			 *     {
			 *       "value": "dropdown-option-2",
			 *       "label": "Option 2"
			 *     },
			 *     {
			 *       "value": "dropdown-option-3",
			 *       "label": "Option 3"
			 *     }
			 *   ]'
			 *   hint-expander='{
			 *    "hint": "Hint expander for the dropdown list",
			 *    "content": "Example hint expander content for the dropdown list."
			 *   }'
			 * >
			 * </ontario-dropdown-list>
			 */
			hintExpander;
			/**
			 * Set this to display an error message
			 */
			errorMessage;
			/**
			 * Used to add a custom function to the dropdown onChange event.
			 */
			customOnChange;
			/**
			 * Used to add a custom function to the dropdown onBlur event.
			 */
			customOnBlur;
			/**
			 * Used to add a custom function to the dropdown onFocus event.
			 */
			customOnFocus;
			/**
			 * Used for the `aria-describedby` value of the dropdown list. This will match with the id of the hint text.
			 */
			hintTextId;
			/**
			 * Instantiate an InputCaption object for internal logic use
			 */
			captionState;
			/**
			 * The options are re-assigned to the internalOptions array.
			 */
			internalOptions;
			/**
			 * The hint text options are re-assigned to the internalHintText array.
			 */
			internalHintText;
			/**
			 * The hint expander options are re-assigned to the internalHintExpander array.
			 */
			internalHintExpander;
			translations = translations;
			/**
			 * Emitted when a keyboard input or mouse event occurs when a dropdown list has been changed.
			 */
			dropdownOnChange;
			/**
			 * Emitted when a keyboard input event occurs when a dropdown list has lost focus.
			 */
			dropdownOnBlur;
			/**
			 * Emitted when a keyboard input event occurs when a dropdown list has gained focus.
			 */
			dropdownOnFocus;
			/**
			 * Emitted when an error message is reported to the component.
			 */
			inputErrorOccurred;
			/**
			 * This listens for the `setAppLanguage` event sent from the test language toggler when it is is connected to the DOM. It is used for the initial language when the input component loads.
			 */
			handleSetAppLanguage(event) {
				if (!this.language) {
					this.language = validateLanguage(event);
				}
			}
			handleHeaderLanguageToggled(event) {
				this.language = validateLanguage(event);
			}
			/*
			 * Watch for changes in the `name` prop for validation purposes.
			 *
			 * Validate the `name` and make sure the `name` prop has a value.
			 * Log a warning if user doesn't input a value for the `name`.
			 */
			validateName(newValue) {
				if (validatePropExists(newValue)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' name ')
						.addRegularText('for')
						.addMonospaceText(' <ontario-dropdown-list> ')
						.addRegularText('was not provided')
						.printMessage();
				}
			}
			/*
			 * Watch for changes in the `options` prop for validation purposes.
			 *
			 * Validate the `options` and make sure the `options` prop has a value.
			 * Log a warning if user doesn't input a value for the `options`.
			 */
			validateOptions(newValue) {
				if (validateObjectExists(newValue)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' options ')
						.addRegularText('for')
						.addMonospaceText(' <ontario-dropdown-list> ')
						.addRegularText('was not provided')
						.printMessage();
				}
			}
			/**
			 * Watch for changes to the `options` prop.
			 *
			 * If an `options` prop is passed, it will be parsed (if it is a string), and the result will be set to the `internalOptions` state. The result will be run through a validation function.
			 */
			parseOptions() {
				if (typeof this.options !== 'undefined') {
					if (!Array.isArray(this.options)) {
						this.internalOptions = JSON.parse(this.options);
					} else {
						this.internalOptions = this.options;
					}
				}
				// Check selected status of options and set the selectedValue
				this.validateSelectedOption(this.internalOptions);
			}
			/**
			 * Watch for changes to the `caption` prop.
			 *
			 * The caption will be run through the InputCaption constructor to convert it to the correct format, and set the result to the `captionState` state.
			 * @param newValue: Caption | string
			 */
			updateCaptionState(newValue) {
				this.captionState = new InputCaption(
					this.element.tagName,
					newValue,
					translations,
					this.language,
					false,
					this.required,
				);
			}
			/**
			 * Watch for changes to the `hintText` prop.
			 *
			 * If a `hintText` prop is passed, the `constructHintTextObject` function will convert it to the correct format, and set the result to the `internalHintText` state.
			 */
			parseHintText() {
				if (this.hintText) {
					const hintTextObject = constructHintTextObject(this.hintText);
					this.internalHintText = hintTextObject;
				}
			}
			/**
			 * Watch for changes to the `language` prop to render either the English or French translations
			 */
			updateLanguage() {
				this.updateCaptionState(this.caption);
			}
			/**
			 * Watch for changes to the `hintExpander` prop.
			 *
			 * If a `hintExpander` prop is passed, it will be parsed (if it is a string), and the result will be set to the `internalHintExpander` state.
			 */
			parseHintExpander() {
				const hintExpander = this.hintExpander;
				if (hintExpander) {
					if (typeof hintExpander === 'string') this.internalHintExpander = JSON.parse(hintExpander);
					else this.internalHintExpander = hintExpander;
				}
			}
			broadcastInputErrorOccurredEvent() {
				// Emit event to notify anyone who wants to listen for errors occurring
				this.inputErrorOccurred.emit({ errorMessage: this.errorMessage ?? '' });
			}
			/**
			 * Function to handle dropdown list events and the information pertaining to the dropdown list to emit.
			 */
			handleEvent(event, eventType) {
				const input = event.target;
				this.internals?.setFormValue?.(input?.value ?? '');
				handleInputEvent(
					event,
					eventType,
					input,
					this.dropdownOnChange,
					this.dropdownOnFocus,
					this.dropdownOnBlur,
					undefined,
					'dropdown',
					this.customOnChange,
					this.customOnFocus,
					this.customOnBlur,
					undefined,
					this.element,
				);
			}
			getId() {
				return this.elementId ?? '';
			}
			/**
			 * This function will set a selected key to `false` for each dropdown if no selected value is passed.
			 *
			 * It will also pass a warning to the user if multiple `true` selected values are passed.
			 *
			 * @param options
			 * @returns options
			 */
			validateSelectedOption(options) {
				const selected = 'selected';
				options.forEach((singleOption) => {
					// if no selected key is passed, set a default key to false
					if (!singleOption.hasOwnProperty(selected)) {
						singleOption.selected = false;
					}
				});
				if (hasMultipleTrueValues(options, selected)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' There are duplicate truthy `selected` values ')
						.addRegularText('for')
						.addMonospaceText(' <ontario-dropdown-list> ')
						.addRegularText('options. Please update options so only one truthy `selected` value exists.')
						.printMessage();
				}
				return options;
			}
			getDropdownArrow() {
				return {
					backgroundImage: `url(${getAssetPath('./assets/ontario-material-dropdown-arrow-48px.svg')})`,
				};
			}
			getClass() {
				return this.hintExpander
					? `ontario-input ontario-dropdown ontario-dropdown-hint-expander--true`
					: `ontario-input ontario-dropdown`;
			}
			/**
			 * If a `hintText` prop is passed, the id generated from it will be set to the internal `hintTextId` state to match with the select `aria-describedBy` attribute.
			 */
			async componentDidLoad() {
				this.hintTextId = await this.hintTextRef?.getHintTextId();
			}
			componentWillLoad() {
				this.updateCaptionState(this.caption);
				this.parseOptions();
				this.validateName(this.name);
				this.validateOptions(this.internalOptions);
				this.elementId = this.elementId ?? v4();
				this.parseHintText();
				this.parseHintExpander();
				this.language = validateLanguage(this.language);
			}
			render() {
				const error = !!this.errorMessage;
				return hAsync(
					'div',
					{
						key: '7f81bd420d6ce32dde1b1a53d7c8c7cac5b65ca4',
						class: `ontario-form-group ${error ? 'ontario-dropdown--error' : ''}`,
					},
					this.captionState.getCaption(this.getId(), !!this.internalHintExpander),
					this.internalHintText &&
						hAsync('ontario-hint-text', {
							key: '0962a69c3b1ffcf9ca99d100fb716634721484d9',
							hint: this.internalHintText.hint,
							hintContentType: this.internalHintText.hintContentType,
							ref: (el) => (this.hintTextRef = el),
						}),
					hAsync(ErrorMessage, {
						key: '1775d30239aaf84ca28a5c87bde7877c3dc77d9a',
						message: this.errorMessage,
						error: error,
					}),
					hAsync(
						'select',
						{
							'key': 'b8be2aa917016b7f900843b7dce84edbbb152c72',
							'class': this.getClass(),
							'aria-describedby': this.hintTextId,
							'id': this.getId(),
							'name': this.name,
							'style': this.getDropdownArrow(),
							'onChange': (e) => this.handleEvent(e, EventType.Change),
							'onBlur': (e) => this.handleEvent(e, EventType.Blur),
							'onFocus': (e) => this.handleEvent(e, EventType.Focus),
							'required': !!this.required,
						},
						this.isEmptyStartOption &&
							(this.isEmptyStartOption === true || this.isEmptyStartOption === 'true'
								? hAsync('option', null, this.translations.dropdownList.select[`${this.language}`])
								: hAsync('option', null, this.isEmptyStartOption)),
						this.internalOptions?.map((dropdown) =>
							hAsync('option', { value: dropdown.value, selected: dropdown.selected }, dropdown.label),
						) ?? '',
					),
					this.internalHintExpander &&
						hAsync('ontario-hint-expander', {
							key: '1c21ec8303eb6e868b01b66ee56842565b2c2efd',
							hint: this.internalHintExpander.hint,
							content: this.internalHintExpander.content,
							hintContentType: this.internalHintExpander.hintContentType,
						}),
				);
			}
			static get formAssociated() {
				return true;
			}
			static get assetsDirs() {
				return ['./assets'];
			}
			static get watchers() {
				return {
					name: ['validateName'],
					options: ['validateOptions', 'parseOptions'],
					caption: ['updateCaptionState'],
					hintText: ['parseHintText'],
					language: ['updateLanguage'],
					hintExpander: ['parseHintExpander'],
					errorMessage: ['broadcastInputErrorOccurredEvent'],
				};
			}
			static get style() {
				return ontarioDropdownListCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 73,
					$tagName$: 'ontario-dropdown-list',
					$members$: {
						caption: [1],
						language: [1025],
						name: [1],
						elementId: [1025, 'element-id'],
						options: [1],
						required: [4],
						isEmptyStartOption: [8, 'is-empty-start-option'],
						hintText: [1, 'hint-text'],
						hintExpander: [1, 'hint-expander'],
						errorMessage: [1025, 'error-message'],
						customOnChange: [16, 'custom-on-change'],
						customOnBlur: [16, 'custom-on-blur'],
						customOnFocus: [16, 'custom-on-focus'],
						hintTextId: [32],
						captionState: [32],
						internalOptions: [32],
						internalHintText: [32],
						internalHintExpander: [32],
						translations: [32],
					},
					$listeners$: [
						[8, 'setAppLanguage', 'handleSetAppLanguage'],
						[8, 'headerLanguageToggled', 'handleHeaderLanguageToggled'],
					],
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioFieldsetCss =
			'@charset "UTF-8";h6,.ontario-h6,h5,.ontario-h5,h4,.ontario-h4,h3,.ontario-h3,h2,.ontario-h2,.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1,h1,.ontario-h1{font-style:normal;font-weight:700;text-rendering:optimizeLegibility;margin-bottom:1rem;font-feature-settings:normal;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif}.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1,h1,.ontario-h1{font-size:2rem;letter-spacing:0.04rem;line-height:1.29;margin:2.5rem 0 1.5rem 0;max-width:70rem}@media screen and (min-width: 40em){.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1,h1,.ontario-h1{font-size:2.5rem;letter-spacing:0.04rem;line-height:1.2}}h2,.ontario-h2{font-size:1.6875rem;letter-spacing:0.03rem;line-height:1.37;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h2,.ontario-h2{font-size:2.0625rem;letter-spacing:0.02rem;line-height:1.33}}h3,.ontario-h3{font-size:1.4375rem;letter-spacing:0.02rem;line-height:1.39;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h3,.ontario-h3{font-size:1.75rem;letter-spacing:0.02rem;line-height:1.43}}h4,.ontario-h4{font-size:1.25rem;letter-spacing:0.03rem;line-height:1.5;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h4,.ontario-h4{font-size:1.5rem;letter-spacing:0.0313rem;line-height:1.5}}h5,.ontario-h5{font-size:1.125rem;letter-spacing:0.03rem;line-height:1.56;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h5,.ontario-h5{font-size:1.1875rem;letter-spacing:0.025rem;line-height:1.5}}h6,.ontario-h6{font-size:1rem;line-height:1.56;letter-spacing:0.03rem;max-width:48rem;margin:0 0 0.75rem 0}@media screen and (min-width: 40em){h6,.ontario-h6{font-size:1rem;letter-spacing:0.025rem;line-height:1.5}}.ontario-lead-statement{font-size:1.25rem;line-height:1.6;max-width:70rem}@media screen and (min-width: 40em){.ontario-lead-statement{font-size:1.375rem}}html{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem}body{font-size:1rem;line-height:1.6;background-color:#FFFFFF;color:#1a1a1a;margin:0}p{font-size:inherit;margin-bottom:1.25rem;text-rendering:optimizeLegibility;margin:0 0 1.5rem 0}cite{font-style:italic;line-height:inherit}strong{font-weight:700;line-height:inherit}*,*::before,*::after{box-sizing:inherit}main p,main p:not(.ontario-lead-statement),main dd,main li{max-width:48rem}hr{border:0;padding:0;margin:2.5rem 0;border-bottom:4px solid #cccccc}hr.ontario-hr--dark{border-bottom:4px solid #1a1a1a}a{color:#0066CC;text-decoration:underline}a:visited{color:#551A8B}a:hover{color:#00478F}a:active{color:#002142}a:focus{-moz-box-shadow:0 0 0 4px #009ADB;-webkit-box-shadow:0 0 0 4px #009ADB;box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:all 0.1s ease-in-out}p{margin:0 0 1.5rem 0}p+h1,p+h2,p+h3,p+h4,p+h5,p+h6,ul+h1,ul+h2,ul+h3,ul+h4,ul+h5,ul+h6,ol+h1,ol+h2,ol+h3,ol+h4,ol+h5,ol+h6,h1+h2,h2+h3,h3+h4,h4+h5,h5+h6{margin-top:2rem}p code,td code,li code{line-height:2.25rem}input[type=text],input[type=number],input[type=email],input[type=date],input[type=color],input[type=search],input[type=tel],textarea{background-origin:initial;height:auto;-webkit-appearance:none;-moz-appearance:none}input[type=checkbox]+label,input[type=radio]+label{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400;margin-left:0;margin-right:0}fieldset{border:0;margin:0;padding:0;page-break-inside:avoid}legend,label{display:block;margin:0}select{background-origin:initial;height:auto;-webkit-appearance:none;-moz-appearance:none}ul,ol{padding:0}ul{margin-left:2rem}ul li{padding:0 0 0.75rem 0}ol{margin-left:1.75rem}ol li{padding:0 0 0.75rem 0.25rem}ul li:last-child,ol li:last-child{padding-bottom:0}ul[class*=columns-] li:last-child,ol[class*=columns-] li:last-child{padding-bottom:0.75rem}ul ul,ol ul{margin:0.5rem 0 0.5rem 2rem}ul ol,ol ol{margin:0.5rem 0 0.5rem 1.75rem}p+ul,p+ol{margin-top:-0.75rem}@media screen and (min-width: 40em){ul{margin:0.5rem 0 1.5rem 3rem}ol{margin:0.5rem 0 1.5rem 2.75rem}ul ul,ol ul{margin:0.5rem 0 0.5rem 3rem}ul ol,ol ol{margin:0.5rem 0 0.5rem 2.75rem}}.ontario-form-group:last-of-type{margin-bottom:2.5rem}.ontario-form-group:last-of-type{margin-bottom:3rem}.ontario-fieldset__legend{color:#1a1a1a;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1.1875rem;font-weight:700;margin:0 0 1rem 0;line-height:1.5;max-width:38.75em;white-space:normal;width:100%;hyphens:auto}@media screen and (max-width: 40em){.ontario-fieldset__legend{font-size:1.125rem;line-height:1.56}}.ontario-fieldset__legend--large,.ontario-fieldset__legend--heading{letter-spacing:0.02rem;line-height:1.2}.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1{display:inline-block;margin:0}@media screen and (max-width: 40em){.ontario-fieldset__legend--large,.ontario-fieldset__legend--heading{font-size:1.4375rem;line-height:1.39}}.ontario-fieldset__legend--large{font-size:1.75rem}.ontario-fieldset__legend-required-flag,.ontario-fieldset__legend-optional-flag{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400}.ontario-fieldset__legend-required-flag:before,.ontario-fieldset__legend-optional-flag:before{content:""}.ontario-label__flag{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400}.ontario-label__flag:before{content:""}';

		class OntarioFieldset {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The text value used for the legend of the fieldset.
			 */
			legend;
			/**
			 * The size of the fieldset legend. If no prop is passed, it will be `default`.
			 */
			legendSize = 'default';
			/**
			 * Watch for changes to the legendSize prop.
			 * This is for validation purposes to make sure the legendSize matches one of the CaptionTypes.
			 */
			validateLegendSize() {
				const isValid = validateValueAgainstArray(this.legendSize, CaptionTypes);
				if (isValid) {
					return this.legendSize;
				} else {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(` legendSize ${this.legendSize} `)
						.addRegularText('for')
						.addMonospaceText(' <ontario-fieldset> ')
						.addRegularText('is not a valid type. A default size will be applied.')
						.printMessage();
					return 'default';
				}
			}
			/*
			 * Watch for changes in the `legend` prop for validation purposes.
			 */
			validateLegend() {
				this.validateLegendText(this.legend);
			}
			/**
			 * Print the legend warning message
			 */
			validateLegendText(newValue) {
				if (validatePropExists(newValue)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' legend ')
						.addRegularText('for')
						.addMonospaceText(' <ontario-fieldset> ')
						.addRegularText('was not provided')
						.printMessage();
				}
			}
			componentWillLoad() {
				this.validateLegend();
				this.validateLegendSize();
			}
			getClass() {
				switch (this.legendSize) {
					case 'large':
						return `ontario-fieldset__legend ontario-fieldset__legend--large`;
					case 'heading':
						return `ontario-fieldset__legend ontario-fieldset__legend--heading`;
					case 'default':
					default:
						return `ontario-fieldset__legend`;
				}
			}
			render() {
				return hAsync(
					'div',
					{ key: '43597f1eb7279ccb96e8ef27b0a2bdab57e45a10', class: 'ontario-form-group' },
					hAsync(
						'fieldset',
						{ key: '68737bd9cae2ce8871e07458adc97e878d668d0b', class: 'ontario-fieldset' },
						hAsync(
							'legend',
							{ key: '6a831b206e46ba7531ed9ba47f145bc3279bf166', class: this.getClass() },
							this.legendSize === 'heading' ? hAsync('h1', null, this.legend) : this.legend,
						),
						hAsync('slot', { key: 'e6835d747a0a988fe1d890875af812ed66f86434' }),
					),
				);
			}
			static get watchers() {
				return {
					legendSize: ['validateLegendSize'],
					legend: ['validateLegend'],
				};
			}
			static get style() {
				return ontarioFieldsetCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-fieldset',
					$members$: {
						legend: [1025],
						legendSize: [1025, 'legend-size'],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ICON_WIDTH = 32;
		const FooterSocialLinks = ({ facebook, twitter, instagram, youtube }) => {
			return hAsync(
				'ul',
				{ class: 'ontario-footer__links-container ontario-footer__links-container--social' },
				facebook &&
					hAsync(
						'li',
						null,
						hAsync(
							'a',
							{ 'class': 'ontario-footer__link', 'href': facebook, 'aria-label': 'Facebook' },
							hAsync('ontario-icon-facebook', { 'colour': 'white', 'icon-width': ICON_WIDTH }),
						),
					),
				twitter &&
					hAsync(
						'li',
						null,
						hAsync(
							'a',
							{ 'class': 'ontario-footer__link', 'href': twitter, 'aria-label': 'Twitter' },
							hAsync('ontario-icon-twitter', { 'colour': 'white', 'icon-width': ICON_WIDTH }),
						),
					),
				instagram &&
					hAsync(
						'li',
						null,
						hAsync(
							'a',
							{ 'class': 'ontario-footer__link', 'href': instagram, 'aria-label': 'Instagram' },
							hAsync('ontario-icon-instagram', { 'colour': 'white', 'icon-width': ICON_WIDTH }),
						),
					),
				youtube &&
					hAsync(
						'li',
						null,
						hAsync(
							'a',
							{ 'class': 'ontario-footer__link', 'href': youtube, 'aria-label': 'Youtube' },
							hAsync('ontario-icon-youtube', { 'colour': 'white', 'icon-width': ICON_WIDTH }),
						),
					),
			);
		};

		const enDash = '\u2013';
		const SimpleFooter = ({ accessibilityLink, privacyLink, contactLink, printerLink, className, termsOfUseLink }) => {
			return hAsync(
				'div',
				{ class: `ontario-row ${className ?? ''}` },
				hAsync(
					'div',
					{ class: 'ontario-columns ontario-small-12' },
					hAsync(
						'ul',
						{ class: 'ontario-footer__links-container ontario-footer__links-container--inline' },
						hAsync(
							'li',
							null,
							hAsync('a', { class: 'ontario-footer__link', href: accessibilityLink.href }, accessibilityLink.text),
						),
						hAsync(
							'li',
							null,
							hAsync('a', { class: 'ontario-footer__link', href: privacyLink.href }, privacyLink.text),
						),
						contactLink &&
							hAsync(
								'li',
								null,
								hAsync('a', { class: 'ontario-footer__link', href: contactLink?.href }, contactLink?.text),
							),
						termsOfUseLink &&
							hAsync(
								'li',
								null,
								hAsync('a', { class: 'ontario-footer__link', href: termsOfUseLink?.href }, termsOfUseLink?.text),
							),
					),
					hAsync(
						'div',
						{ class: 'ontario-footer__copyright' },
						hAsync(
							'a',
							{ class: 'ontario-footer__link', href: printerLink?.href },
							'\u00A9 ',
							printerLink?.text,
							' ',
							hAsync('span', { class: 'ontario-nbsp' }, '2012', enDash, String(new Date().getFullYear()).slice(-2)),
						),
					),
				),
			);
		};

		const ColumnContent = ({ content }) => {
			const { heading, headingLevel: Heading = 'h3', text, html, list, type = 'text' } = content;
			return hAsync(
				Fragment,
				null,
				heading && hAsync(Heading, { class: 'ontario-h5' }, heading),
				type === 'text' && hAsync('p', null, text),
				type === 'html' && hAsync('div', { class: 'ontario-footer__paragraph', innerHTML: html }),
				type === 'list' &&
					!!list?.length &&
					hAsync(
						'ul',
						null,
						list.map((item) => hAsync('li', { class: 'ontario-footer__list_item', innerHTML: item })),
					),
			);
		};

		const FooterColumn = ({ data, socialLinks, isThreeColLayout = false, isFullWidthInMediumLayout = false }) => {
			const { title, content, button, headingLevel: Heading = 'h2' } = data;
			const threeColumnLayoutClasses = isThreeColLayout
				? 'ontario-large-4 ontario-expanded-footer__one-third-block'
				: '';
			const mediumLayoutClasses = isFullWidthInMediumLayout ? 'ontario-medium-12' : 'ontario-medium-6';
			return hAsync(
				'div',
				{ class: `ontario-columns ontario-small-12 ${mediumLayoutClasses} ${threeColumnLayoutClasses}` },
				hAsync(Heading, { class: 'ontario-h4' }, title),
				content.map((item) => hAsync(ColumnContent, { content: item })),
				button &&
					hAsync(
						'a',
						{ class: 'ontario-footer__button ontario-button ontario-margin-bottom-0-!', href: button.link },
						button.text,
					),
				socialLinks && hAsync(FooterSocialLinks, { ...socialLinks }),
			);
		};

		const ExpandedFooterWrapper = (props, children) => {
			const { topMargin, footerLinks, backgroundImagePath } = props;
			const style = { '--imagePath': backgroundImagePath };
			const marginClass = !topMargin ? 'ontario-margin-top-0-!' : '';
			return hAsync(
				'footer',
				{ class: `ontario-footer ontario-footer--expanded ${marginClass}`, style: style },
				hAsync(
					'div',
					{ class: 'ontario-footer__expanded-top-section' },
					hAsync('div', { class: 'ontario-row' }, children),
				),
				hAsync(SimpleFooter, { ...footerLinks, className: 'ontario-footer__expanded-bottom-section' }),
			);
		};

		const isInvalidTwoColumnOptions = (options) => {
			return (
				!options ||
				!options.column1?.title ||
				!options.column1?.content ||
				!options.column2?.title ||
				!options.column2?.content
			);
		};
		const isInvalidThreeColumnOptions = (options) => {
			return (
				!options ||
				!options.column1?.title ||
				!options.column1?.content ||
				!options.column2?.title ||
				!options.column2?.content ||
				!options.column3?.title ||
				!options.column3?.content
			);
		};

		const ontarioFooterCss =
			'@charset "UTF-8";.ontario-row{margin:0 auto;max-width:72rem;width:100%}.ontario-row:before,.ontario-row:after{content:"";display:table}.ontario-row:after{clear:both}.ontario-row.ontario-row--collapse>.ontario-column,.ontario-row.ontario-row--collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-row--collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row .ontario-row{margin:0 -1rem;max-width:none;width:auto}.ontario-row .ontario-row:before,.ontario-row .ontario-row:after{content:"";display:table}.ontario-row .ontario-row:after{clear:both}.ontario-row .ontario-row.ontario-row--collapse{margin:0;max-width:none;width:auto}.ontario-row .ontario-row.ontario-row--collapse:before,.ontario-row .ontario-row.ontario-row--collapse:after{content:"";display:table}.ontario-row .ontario-row.ontario-row--collapse:after{clear:both}.ontario-column,.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;width:100%;float:left}.ontario-column+.ontario-column:last-child,.ontario-column+.ontario-columns:last-child,.ontario-columns+.ontario-column:last-child,.ontario-columns+.ontario-columns:last-child{float:right}.ontario-column+.ontario-column.ontario-end,.ontario-column+.ontario-columns.ontario-end,.ontario-columns+.ontario-column.ontario-end,.ontario-columns+.ontario-columns.ontario-end{float:left}@media only screen{.ontario-small-push-0{position:relative;left:0;right:auto}.ontario-small-pull-0{position:relative;right:0;left:auto}.ontario-small-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-small-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-small-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-small-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-small-push-3{position:relative;left:25%;right:auto}.ontario-small-pull-3{position:relative;right:25%;left:auto}.ontario-small-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-small-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-small-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-small-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-small-push-6{position:relative;left:50%;right:auto}.ontario-small-pull-6{position:relative;right:50%;left:auto}.ontario-small-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-small-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-small-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-small-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-small-push-9{position:relative;left:75%;right:auto}.ontario-small-pull-9{position:relative;right:75%;left:auto}.ontario-small-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-small-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-small-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-small-pull-11{position:relative;right:91.6666666667%;left:auto}.ontario-column,.ontario-columns{position:relative;padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-small-1{width:8.3333333333%}.ontario-small-2{width:16.6666666667%}.ontario-small-3{width:25%}.ontario-small-4{width:33.3333333333%}.ontario-small-5{width:41.6666666667%}.ontario-small-6{width:50%}.ontario-small-7{width:58.3333333333%}.ontario-small-8{width:66.6666666667%}.ontario-small-9{width:75%}.ontario-small-10{width:83.3333333333%}.ontario-small-11{width:91.6666666667%}.ontario-small-12{width:100%}.ontario-small-offset-0{margin-left:0 !important}.ontario-small-offset-1{margin-left:8.3333333333% !important}.ontario-small-offset-2{margin-left:16.6666666667% !important}.ontario-small-offset-3{margin-left:25% !important}.ontario-small-offset-4{margin-left:33.3333333333% !important}.ontario-small-offset-5{margin-left:41.6666666667% !important}.ontario-small-offset-6{margin-left:50% !important}.ontario-small-offset-7{margin-left:58.3333333333% !important}.ontario-small-offset-8{margin-left:66.6666666667% !important}.ontario-small-offset-9{margin-left:75% !important}.ontario-small-offset-10{margin-left:83.3333333333% !important}.ontario-small-offset-11{margin-left:91.6666666667% !important}.ontario-small-reset-order{float:left;left:auto;margin-left:0;margin-right:0;right:auto}.ontario-column.ontario-small-centered,.ontario-columns.ontario-small-centered{margin-left:auto;margin-right:auto;float:none}.ontario-column.ontario-small-uncentered,.ontario-columns.ontario-small-uncentered{float:left;margin-left:0;margin-right:0}.ontario-column.ontario-small-centered:last-child,.ontario-columns.ontario-small-centered:last-child{float:none}.ontario-column.ontario-small-uncentered:last-child,.ontario-columns.ontario-small-uncentered:last-child{float:left}.ontario-column.ontario-small-uncentered.ontario-opposite,.ontario-columns.ontario-small-uncentered.ontario-opposite{float:right}.ontario-row.ontario-small-collapse>.ontario-column,.ontario-row.ontario-small-collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-small-collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row.ontario-small-uncollapse>.ontario-column,.ontario-row.ontario-small-uncollapse>.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}}@media only screen and (min-width:40.063em){.ontario-medium-push-0{position:relative;left:0;right:auto}.ontario-medium-pull-0{position:relative;right:0;left:auto}.ontario-medium-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-medium-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-medium-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-medium-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-medium-push-3{position:relative;left:25%;right:auto}.ontario-medium-pull-3{position:relative;right:25%;left:auto}.ontario-medium-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-medium-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-medium-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-medium-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-medium-push-6{position:relative;left:50%;right:auto}.ontario-medium-pull-6{position:relative;right:50%;left:auto}.ontario-medium-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-medium-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-medium-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-medium-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-medium-push-9{position:relative;left:75%;right:auto}.ontario-medium-pull-9{position:relative;right:75%;left:auto}.ontario-medium-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-medium-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-medium-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-medium-pull-11{position:relative;right:91.6666666667%;left:auto}.ontario-column,.ontario-columns{position:relative;padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-medium-1{width:8.3333333333%}.ontario-medium-2{width:16.6666666667%}.ontario-medium-3{width:25%}.ontario-medium-4{width:33.3333333333%}.ontario-medium-5{width:41.6666666667%}.ontario-medium-6{width:50%}.ontario-medium-7{width:58.3333333333%}.ontario-medium-8{width:66.6666666667%}.ontario-medium-9{width:75%}.ontario-medium-10{width:83.3333333333%}.ontario-medium-11{width:91.6666666667%}.ontario-medium-12{width:100%}.ontario-medium-offset-0{margin-left:0 !important}.ontario-medium-offset-1{margin-left:8.3333333333% !important}.ontario-medium-offset-2{margin-left:16.6666666667% !important}.ontario-medium-offset-3{margin-left:25% !important}.ontario-medium-offset-4{margin-left:33.3333333333% !important}.ontario-medium-offset-5{margin-left:41.6666666667% !important}.ontario-medium-offset-6{margin-left:50% !important}.ontario-medium-offset-7{margin-left:58.3333333333% !important}.ontario-medium-offset-8{margin-left:66.6666666667% !important}.ontario-medium-offset-9{margin-left:75% !important}.ontario-medium-offset-10{margin-left:83.3333333333% !important}.ontario-medium-offset-11{margin-left:91.6666666667% !important}.ontario-medium-reset-order{float:left;left:auto;margin-left:0;margin-right:0;right:auto}.ontario-column.ontario-medium-centered,.ontario-columns.ontario-medium-centered{margin-left:auto;margin-right:auto;float:none}.ontario-column.ontario-medium-uncentered,.ontario-columns.ontario-medium-uncentered{float:left;margin-left:0;margin-right:0}.ontario-column.ontario-medium-centered:last-child,.ontario-columns.ontario-medium-centered:last-child{float:none}.ontario-column.ontario-medium-uncentered:last-child,.ontario-columns.ontario-medium-uncentered:last-child{float:left}.ontario-column.ontario-medium-uncentered.ontario-opposite,.ontario-columns.ontario-medium-uncentered.ontario-opposite{float:right}.ontario-row.ontario-medium-collapse>.ontario-column,.ontario-row.ontario-medium-collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-medium-collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row.ontario-medium-uncollapse>.ontario-column,.ontario-row.ontario-medium-uncollapse>.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}}@media only screen and (min-width:73.063em){.ontario-large-push-0{position:relative;left:0;right:auto}.ontario-large-pull-0{position:relative;right:0;left:auto}.ontario-large-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-large-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-large-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-large-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-large-push-3{position:relative;left:25%;right:auto}.ontario-large-pull-3{position:relative;right:25%;left:auto}.ontario-large-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-large-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-large-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-large-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-large-push-6{position:relative;left:50%;right:auto}.ontario-large-pull-6{position:relative;right:50%;left:auto}.ontario-large-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-large-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-large-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-large-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-large-push-9{position:relative;left:75%;right:auto}.ontario-large-pull-9{position:relative;right:75%;left:auto}.ontario-large-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-large-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-large-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-large-pull-11{position:relative;right:91.6666666667%;left:auto}.ontario-column,.ontario-columns{position:relative;padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-large-1{width:8.3333333333%}.ontario-large-2{width:16.6666666667%}.ontario-large-3{width:25%}.ontario-large-4{width:33.3333333333%}.ontario-large-5{width:41.6666666667%}.ontario-large-6{width:50%}.ontario-large-7{width:58.3333333333%}.ontario-large-8{width:66.6666666667%}.ontario-large-9{width:75%}.ontario-large-10{width:83.3333333333%}.ontario-large-11{width:91.6666666667%}.ontario-large-12{width:100%}.ontario-large-offset-0{margin-left:0 !important}.ontario-large-offset-1{margin-left:8.3333333333% !important}.ontario-large-offset-2{margin-left:16.6666666667% !important}.ontario-large-offset-3{margin-left:25% !important}.ontario-large-offset-4{margin-left:33.3333333333% !important}.ontario-large-offset-5{margin-left:41.6666666667% !important}.ontario-large-offset-6{margin-left:50% !important}.ontario-large-offset-7{margin-left:58.3333333333% !important}.ontario-large-offset-8{margin-left:66.6666666667% !important}.ontario-large-offset-9{margin-left:75% !important}.ontario-large-offset-10{margin-left:83.3333333333% !important}.ontario-large-offset-11{margin-left:91.6666666667% !important}.ontario-large-reset-order{float:left;left:auto;margin-left:0;margin-right:0;right:auto}.ontario-column.ontario-large-centered,.ontario-columns.ontario-large-centered{margin-left:auto;margin-right:auto;float:none}.ontario-column.ontario-large-uncentered,.ontario-columns.ontario-large-uncentered{float:left;margin-left:0;margin-right:0}.ontario-column.ontario-large-centered:last-child,.ontario-columns.ontario-large-centered:last-child{float:none}.ontario-column.ontario-large-uncentered:last-child,.ontario-columns.ontario-large-uncentered:last-child{float:left}.ontario-column.ontario-large-uncentered.ontario-opposite,.ontario-columns.ontario-large-uncentered.ontario-opposite{float:right}.ontario-row.ontario-large-collapse>.ontario-column,.ontario-row.ontario-large-collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-large-collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row.ontario-large-uncollapse>.ontario-column,.ontario-row.ontario-large-uncollapse>.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-push-0{position:relative;left:0;right:auto}.ontario-pull-0{position:relative;right:0;left:auto}.ontario-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-push-3{position:relative;left:25%;right:auto}.ontario-pull-3{position:relative;right:25%;left:auto}.ontario-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-push-6{position:relative;left:50%;right:auto}.ontario-pull-6{position:relative;right:50%;left:auto}.ontario-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-push-9{position:relative;left:75%;right:auto}.ontario-pull-9{position:relative;right:75%;left:auto}.ontario-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-pull-11{position:relative;right:91.6666666667%;left:auto}}@media only screen and (min-width:96.063em){.ontario-xlarge-push-0{position:relative;left:0;right:auto}.ontario-xlarge-pull-0{position:relative;right:0;left:auto}.ontario-xlarge-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-xlarge-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-xlarge-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-xlarge-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-xlarge-push-3{position:relative;left:25%;right:auto}.ontario-xlarge-pull-3{position:relative;right:25%;left:auto}.ontario-xlarge-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-xlarge-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-xlarge-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-xlarge-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-xlarge-push-6{position:relative;left:50%;right:auto}.ontario-xlarge-pull-6{position:relative;right:50%;left:auto}.ontario-xlarge-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-xlarge-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-xlarge-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-xlarge-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-xlarge-push-9{position:relative;left:75%;right:auto}.ontario-xlarge-pull-9{position:relative;right:75%;left:auto}.ontario-xlarge-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-xlarge-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-xlarge-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-xlarge-pull-11{position:relative;right:91.6666666667%;left:auto}.ontario-column,.ontario-columns{position:relative;padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-xlarge-1{width:8.3333333333%}.ontario-xlarge-2{width:16.6666666667%}.ontario-xlarge-3{width:25%}.ontario-xlarge-4{width:33.3333333333%}.ontario-xlarge-5{width:41.6666666667%}.ontario-xlarge-6{width:50%}.ontario-xlarge-7{width:58.3333333333%}.ontario-xlarge-8{width:66.6666666667%}.ontario-xlarge-9{width:75%}.ontario-xlarge-10{width:83.3333333333%}.ontario-xlarge-11{width:91.6666666667%}.ontario-xlarge-12{width:100%}.ontario-xlarge-offset-0{margin-left:0 !important}.ontario-xlarge-offset-1{margin-left:8.3333333333% !important}.ontario-xlarge-offset-2{margin-left:16.6666666667% !important}.ontario-xlarge-offset-3{margin-left:25% !important}.ontario-xlarge-offset-4{margin-left:33.3333333333% !important}.ontario-xlarge-offset-5{margin-left:41.6666666667% !important}.ontario-xlarge-offset-6{margin-left:50% !important}.ontario-xlarge-offset-7{margin-left:58.3333333333% !important}.ontario-xlarge-offset-8{margin-left:66.6666666667% !important}.ontario-xlarge-offset-9{margin-left:75% !important}.ontario-xlarge-offset-10{margin-left:83.3333333333% !important}.ontario-xlarge-offset-11{margin-left:91.6666666667% !important}.ontario-xlarge-reset-order{float:left;left:auto;margin-left:0;margin-right:0;right:auto}.ontario-column.ontario-xlarge-centered,.ontario-columns.ontario-xlarge-centered{margin-left:auto;margin-right:auto;float:none}.ontario-column.ontario-xlarge-uncentered,.ontario-columns.ontario-xlarge-uncentered{float:left;margin-left:0;margin-right:0}.ontario-column.ontario-xlarge-centered:last-child,.ontario-columns.ontario-xlarge-centered:last-child{float:none}.ontario-column.ontario-xlarge-uncentered:last-child,.ontario-columns.ontario-xlarge-uncentered:last-child{float:left}.ontario-column.ontario-xlarge-uncentered.ontario-opposite,.ontario-columns.ontario-xlarge-uncentered.ontario-opposite{float:right}.ontario-row.ontario-xlarge-collapse>.ontario-column,.ontario-row.ontario-xlarge-collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-xlarge-collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row.ontario-xlarge-uncollapse>.ontario-column,.ontario-row.ontario-xlarge-uncollapse>.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}}@media only screen and (min-width:120.063em){.ontario-xxlarge-push-0{position:relative;left:0;right:auto}.ontario-xxlarge-pull-0{position:relative;right:0;left:auto}.ontario-xxlarge-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-xxlarge-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-xxlarge-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-xxlarge-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-xxlarge-push-3{position:relative;left:25%;right:auto}.ontario-xxlarge-pull-3{position:relative;right:25%;left:auto}.ontario-xxlarge-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-xxlarge-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-xxlarge-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-xxlarge-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-xxlarge-push-6{position:relative;left:50%;right:auto}.ontario-xxlarge-pull-6{position:relative;right:50%;left:auto}.ontario-xxlarge-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-xxlarge-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-xxlarge-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-xxlarge-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-xxlarge-push-9{position:relative;left:75%;right:auto}.ontario-xxlarge-pull-9{position:relative;right:75%;left:auto}.ontario-xxlarge-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-xxlarge-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-xxlarge-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-xxlarge-pull-11{position:relative;right:91.6666666667%;left:auto}.ontario-column,.ontario-columns{position:relative;padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-xxlarge-1{width:8.3333333333%}.ontario-xxlarge-2{width:16.6666666667%}.ontario-xxlarge-3{width:25%}.ontario-xxlarge-4{width:33.3333333333%}.ontario-xxlarge-5{width:41.6666666667%}.ontario-xxlarge-6{width:50%}.ontario-xxlarge-7{width:58.3333333333%}.ontario-xxlarge-8{width:66.6666666667%}.ontario-xxlarge-9{width:75%}.ontario-xxlarge-10{width:83.3333333333%}.ontario-xxlarge-11{width:91.6666666667%}.ontario-xxlarge-12{width:100%}.ontario-xxlarge-offset-0{margin-left:0 !important}.ontario-xxlarge-offset-1{margin-left:8.3333333333% !important}.ontario-xxlarge-offset-2{margin-left:16.6666666667% !important}.ontario-xxlarge-offset-3{margin-left:25% !important}.ontario-xxlarge-offset-4{margin-left:33.3333333333% !important}.ontario-xxlarge-offset-5{margin-left:41.6666666667% !important}.ontario-xxlarge-offset-6{margin-left:50% !important}.ontario-xxlarge-offset-7{margin-left:58.3333333333% !important}.ontario-xxlarge-offset-8{margin-left:66.6666666667% !important}.ontario-xxlarge-offset-9{margin-left:75% !important}.ontario-xxlarge-offset-10{margin-left:83.3333333333% !important}.ontario-xxlarge-offset-11{margin-left:91.6666666667% !important}.ontario-xxlarge-reset-order{float:left;left:auto;margin-left:0;margin-right:0;right:auto}.ontario-column.ontario-xxlarge-centered,.ontario-columns.ontario-xxlarge-centered{margin-left:auto;margin-right:auto;float:none}.ontario-column.ontario-xxlarge-uncentered,.ontario-columns.ontario-xxlarge-uncentered{float:left;margin-left:0;margin-right:0}.ontario-column.ontario-xxlarge-centered:last-child,.ontario-columns.ontario-xxlarge-centered:last-child{float:none}.ontario-column.ontario-xxlarge-uncentered:last-child,.ontario-columns.ontario-xxlarge-uncentered:last-child{float:left}.ontario-column.ontario-xxlarge-uncentered.ontario-opposite,.ontario-columns.ontario-xxlarge-uncentered.ontario-opposite{float:right}.ontario-row.ontario-xxlarge-collapse>.ontario-column,.ontario-row.ontario-xxlarge-collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-xxlarge-collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row.ontario-xxlarge-uncollapse>.ontario-column,.ontario-row.ontario-xxlarge-uncollapse>.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}}h6,.ontario-h6,h5,.ontario-h5,h4,.ontario-h4,h3,.ontario-h3,h2,.ontario-h2,h1,.ontario-h1{font-style:normal;font-weight:700;text-rendering:optimizeLegibility;margin-bottom:1rem;font-feature-settings:normal;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif}h1,.ontario-h1{font-size:2rem;letter-spacing:0.04rem;line-height:1.29;margin:2.5rem 0 1.5rem 0;max-width:70rem}@media screen and (min-width: 40em){h1,.ontario-h1{font-size:2.5rem;letter-spacing:0.04rem;line-height:1.2}}h2,.ontario-h2{font-size:1.6875rem;letter-spacing:0.03rem;line-height:1.37;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h2,.ontario-h2{font-size:2.0625rem;letter-spacing:0.02rem;line-height:1.33}}h3,.ontario-h3{font-size:1.4375rem;letter-spacing:0.02rem;line-height:1.39;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h3,.ontario-h3{font-size:1.75rem;letter-spacing:0.02rem;line-height:1.43}}h4,.ontario-h4{font-size:1.25rem;letter-spacing:0.03rem;line-height:1.5;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h4,.ontario-h4{font-size:1.5rem;letter-spacing:0.0313rem;line-height:1.5}}h5,.ontario-h5{font-size:1.125rem;letter-spacing:0.03rem;line-height:1.56;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h5,.ontario-h5{font-size:1.1875rem;letter-spacing:0.025rem;line-height:1.5}}h6,.ontario-h6{font-size:1rem;line-height:1.56;letter-spacing:0.03rem;max-width:48rem;margin:0 0 0.75rem 0}@media screen and (min-width: 40em){h6,.ontario-h6{font-size:1rem;letter-spacing:0.025rem;line-height:1.5}}.ontario-lead-statement{font-size:1.25rem;line-height:1.6;max-width:70rem}@media screen and (min-width: 40em){.ontario-lead-statement{font-size:1.375rem}}html{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem}body{font-size:1rem;line-height:1.6;background-color:#FFFFFF;color:#1a1a1a;margin:0}p{font-size:inherit;margin-bottom:1.25rem;text-rendering:optimizeLegibility;margin:0 0 1.5rem 0}cite{font-style:italic;line-height:inherit}strong{font-weight:700;line-height:inherit}*,*::before,*::after{box-sizing:inherit}main p,main p:not(.ontario-lead-statement),main dd,main li{max-width:48rem}hr{border:0;padding:0;margin:2.5rem 0;border-bottom:4px solid #cccccc}hr.ontario-hr--dark{border-bottom:4px solid #1a1a1a}a{color:#0066CC;text-decoration:underline}a:visited{color:#551A8B}a:hover{color:#00478F}a:active{color:#002142}a:focus{-moz-box-shadow:0 0 0 4px #009ADB;-webkit-box-shadow:0 0 0 4px #009ADB;box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:all 0.1s ease-in-out}p{margin:0 0 1.5rem 0}p+h1,p+h2,p+h3,p+h4,p+h5,p+h6,ul+h1,ul+h2,ul+h3,ul+h4,ul+h5,ul+h6,ol+h1,ol+h2,ol+h3,ol+h4,ol+h5,ol+h6,h1+h2,h2+h3,h3+h4,h4+h5,h5+h6{margin-top:2rem}p code,td code,li code{line-height:2.25rem}input[type=text],input[type=number],input[type=email],input[type=date],input[type=color],input[type=search],input[type=tel],textarea{background-origin:initial;height:auto;-webkit-appearance:none;-moz-appearance:none}input[type=checkbox]+label,input[type=radio]+label{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400;margin-left:0;margin-right:0}fieldset{border:0;margin:0;padding:0;page-break-inside:avoid}legend,label{display:block;margin:0}select{background-origin:initial;height:auto;-webkit-appearance:none;-moz-appearance:none}ul,ol{padding:0}ul{margin-left:2rem}ul li{padding:0 0 0.75rem 0}ol{margin-left:1.75rem}ol li{padding:0 0 0.75rem 0.25rem}ul li:last-child,ol li:last-child{padding-bottom:0}ul[class*=columns-] li:last-child,ol[class*=columns-] li:last-child{padding-bottom:0.75rem}ul ul,ol ul{margin:0.5rem 0 0.5rem 2rem}ul ol,ol ol{margin:0.5rem 0 0.5rem 1.75rem}p+ul,p+ol{margin-top:-0.75rem}@media screen and (min-width: 40em){ul{margin:0.5rem 0 1.5rem 3rem}ol{margin:0.5rem 0 1.5rem 2.75rem}ul ul,ol ul{margin:0.5rem 0 0.5rem 3rem}ul ol,ol ol{margin:0.5rem 0 0.5rem 2.75rem}}.ontario-margin-top-0-\\!{margin-top:0}.ontario-padding-top-0-\\!{padding-top:0}.ontario-margin-bottom-0-\\!{margin-bottom:0}.ontario-padding-bottom-0-\\!{padding-bottom:0}.ontario-margin-left-0-\\!{margin-left:0}.ontario-padding-left-0-\\!{padding-left:0}.ontario-margin-right-0-\\!{margin-right:0}.ontario-padding-right-0-\\!{padding-right:0}.ontario-margin-top-4-\\!{margin-top:0.25rem}.ontario-padding-top-4-\\!{padding-top:0.25rem}.ontario-margin-bottom-4-\\!{margin-bottom:0.25rem}.ontario-padding-bottom-4-\\!{padding-bottom:0.25rem}.ontario-margin-left-4-\\!{margin-left:0.25rem}.ontario-padding-left-4-\\!{padding-left:0.25rem}.ontario-margin-right-4-\\!{margin-right:0.25rem}.ontario-padding-right-4-\\!{padding-right:0.25rem}.ontario-margin-top-8-\\!{margin-top:0.5rem}.ontario-padding-top-8-\\!{padding-top:0.5rem}.ontario-margin-bottom-8-\\!{margin-bottom:0.5rem}.ontario-padding-bottom-8-\\!{padding-bottom:0.5rem}.ontario-margin-left-8-\\!{margin-left:0.5rem}.ontario-padding-left-8-\\!{padding-left:0.5rem}.ontario-margin-right-8-\\!{margin-right:0.5rem}.ontario-padding-right-8-\\!{padding-right:0.5rem}.ontario-margin-top-12-\\!{margin-top:0.75rem}.ontario-padding-top-12-\\!{padding-top:0.75rem}.ontario-margin-bottom-12-\\!{margin-bottom:0.75rem}.ontario-padding-bottom-12-\\!{padding-bottom:0.75rem}.ontario-margin-left-12-\\!{margin-left:0.75rem}.ontario-padding-left-12-\\!{padding-left:0.75rem}.ontario-margin-right-12-\\!{margin-right:0.75rem}.ontario-padding-right-12-\\!{padding-right:0.75rem}.ontario-margin-top-16-\\!{margin-top:1rem}.ontario-padding-top-16-\\!{padding-top:1rem}.ontario-margin-bottom-16-\\!{margin-bottom:1rem}.ontario-padding-bottom-16-\\!{padding-bottom:1rem}.ontario-margin-left-16-\\!{margin-left:1rem}.ontario-padding-left-16-\\!{padding-left:1rem}.ontario-margin-right-16-\\!{margin-right:1rem}.ontario-padding-right-16-\\!{padding-right:1rem}.ontario-margin-top-24-\\!{margin-top:1.5rem}.ontario-padding-top-24-\\!{padding-top:1.5rem}.ontario-margin-bottom-24-\\!{margin-bottom:1.5rem}.ontario-padding-bottom-24-\\!{padding-bottom:1.5rem}.ontario-margin-left-24-\\!{margin-left:1.5rem}.ontario-padding-left-24-\\!{padding-left:1.5rem}.ontario-margin-right-24-\\!{margin-right:1.5rem}.ontario-padding-right-24-\\!{padding-right:1.5rem}.ontario-margin-top-32-\\!{margin-top:2rem}.ontario-padding-top-32-\\!{padding-top:2rem}.ontario-margin-bottom-32-\\!{margin-bottom:2rem}.ontario-padding-bottom-32-\\!{padding-bottom:2rem}.ontario-margin-left-32-\\!{margin-left:2rem}.ontario-padding-left-32-\\!{padding-left:2rem}.ontario-margin-right-32-\\!{margin-right:2rem}.ontario-padding-right-32-\\!{padding-right:2rem}.ontario-margin-top-40-\\!{margin-top:2.5rem}.ontario-padding-top-40-\\!{padding-top:2.5rem}.ontario-margin-bottom-40-\\!{margin-bottom:2.5rem}.ontario-padding-bottom-40-\\!{padding-bottom:2.5rem}.ontario-margin-left-40-\\!{margin-left:2.5rem}.ontario-padding-left-40-\\!{padding-left:2.5rem}.ontario-margin-right-40-\\!{margin-right:2.5rem}.ontario-padding-right-40-\\!{padding-right:2.5rem}.ontario-margin-top-48-\\!{margin-top:3rem}.ontario-padding-top-48-\\!{padding-top:3rem}.ontario-margin-bottom-48-\\!{margin-bottom:3rem}.ontario-padding-bottom-48-\\!{padding-bottom:3rem}.ontario-margin-left-48-\\!{margin-left:3rem}.ontario-padding-left-48-\\!{padding-left:3rem}.ontario-margin-right-48-\\!{margin-right:3rem}.ontario-padding-right-48-\\!{padding-right:3rem}.ontario-margin-top-64-\\!{margin-top:4rem}.ontario-padding-top-64-\\!{padding-top:4rem}.ontario-margin-bottom-64-\\!{margin-bottom:4rem}.ontario-padding-bottom-64-\\!{padding-bottom:4rem}.ontario-margin-left-64-\\!{margin-left:4rem}.ontario-padding-left-64-\\!{padding-left:4rem}.ontario-margin-right-64-\\!{margin-right:4rem}.ontario-padding-right-64-\\!{padding-right:4rem}.ontario-padding-top-0-\\!{padding-top:0 !important}.ontario-padding-bottom-0-\\!{padding-bottom:0 !important}.ontario-padding-right-0-\\!{padding-right:0 !important}.ontario-padding-left-0-\\!{padding-left:0 !important}.ontario-padding-top-4-\\!{padding-top:0.25rem !important}.ontario-padding-bottom-4-\\!{padding-bottom:0.25rem !important}.ontario-padding-right-4-\\!{padding-right:0.25rem !important}.ontario-padding-left-4-\\!{padding-left:0.25rem !important}.ontario-padding-top-8-\\!{padding-top:0.5rem !important}.ontario-padding-bottom-8-\\!{padding-bottom:0.5rem !important}.ontario-padding-right-8-\\!{padding-right:0.5rem !important}.ontario-padding-left-8-\\!{padding-left:0.5rem !important}.ontario-padding-top-12-\\!{padding-top:0.75rem !important}.ontario-padding-bottom-12-\\!{padding-bottom:0.75rem !important}.ontario-padding-right-12-\\!{padding-right:0.75rem !important}.ontario-padding-left-12-\\!{padding-left:0.75rem !important}.ontario-padding-top-16-\\!{padding-top:1rem !important}.ontario-padding-bottom-16-\\!{padding-bottom:1rem !important}.ontario-padding-right-16-\\!{padding-right:1rem !important}.ontario-padding-left-16-\\!{padding-left:1rem !important}.ontario-padding-top-24-\\!{padding-top:1.5rem !important}.ontario-padding-bottom-24-\\!{padding-bottom:1.5rem !important}.ontario-padding-right-24-\\!{padding-right:1.5rem !important}.ontario-padding-left-24-\\!{padding-left:1.5rem !important}.ontario-padding-top-32-\\!{padding-top:2rem !important}.ontario-padding-bottom-32-\\!{padding-bottom:2rem !important}.ontario-padding-right-32-\\!{padding-right:2rem !important}.ontario-padding-left-32-\\!{padding-left:2rem !important}.ontario-padding-top-40-\\!{padding-top:2.5rem !important}.ontario-padding-bottom-40-\\!{padding-bottom:2.5rem !important}.ontario-padding-right-40-\\!{padding-right:2.5rem !important}.ontario-padding-left-40-\\!{padding-left:2.5rem !important}.ontario-padding-top-48-\\!{padding-top:3rem !important}.ontario-padding-bottom-48-\\!{padding-bottom:3rem !important}.ontario-padding-right-48-\\!{padding-right:3rem !important}.ontario-padding-left-48-\\!{padding-left:3rem !important}.ontario-padding-top-64-\\!{padding-top:4rem !important}.ontario-padding-bottom-64-\\!{padding-bottom:4rem !important}.ontario-padding-right-64-\\!{padding-right:4rem !important}.ontario-padding-left-64-\\!{padding-left:4rem !important}.ontario-padding-top-80-\\!{padding-top:5rem !important}.ontario-padding-bottom-80-\\!{padding-bottom:5rem !important}.ontario-padding-right-80-\\!{padding-right:5rem !important}.ontario-padding-left-80-\\!{padding-left:5rem !important}.ontario-margin-top-0-\\!{margin-top:0 !important}.ontario-margin-bottom-0-\\!{margin-bottom:0 !important}.ontario-margin-right-0-\\!{margin-right:0 !important}.ontario-margin-left-0-\\!{margin-left:0 !important}.ontario-margin-top-4-\\!{margin-top:0.25rem !important}.ontario-margin-bottom-4-\\!{margin-bottom:0.25rem !important}.ontario-margin-right-4-\\!{margin-right:0.25rem !important}.ontario-margin-left-4-\\!{margin-left:0.25rem !important}.ontario-margin-top-8-\\!{margin-top:0.5rem !important}.ontario-margin-bottom-8-\\!{margin-bottom:0.5rem !important}.ontario-margin-right-8-\\!{margin-right:0.5rem !important}.ontario-margin-left-8-\\!{margin-left:0.5rem !important}.ontario-margin-top-12-\\!{margin-top:0.75rem !important}.ontario-margin-bottom-12-\\!{margin-bottom:0.75rem !important}.ontario-margin-right-12-\\!{margin-right:0.75rem !important}.ontario-margin-left-12-\\!{margin-left:0.75rem !important}.ontario-margin-top-16-\\!{margin-top:1rem !important}.ontario-margin-bottom-16-\\!{margin-bottom:1rem !important}.ontario-margin-right-16-\\!{margin-right:1rem !important}.ontario-margin-left-16-\\!{margin-left:1rem !important}.ontario-margin-top-24-\\!{margin-top:1.5rem !important}.ontario-margin-bottom-24-\\!{margin-bottom:1.5rem !important}.ontario-margin-right-24-\\!{margin-right:1.5rem !important}.ontario-margin-left-24-\\!{margin-left:1.5rem !important}.ontario-margin-top-32-\\!{margin-top:2rem !important}.ontario-margin-bottom-32-\\!{margin-bottom:2rem !important}.ontario-margin-right-32-\\!{margin-right:2rem !important}.ontario-margin-left-32-\\!{margin-left:2rem !important}.ontario-margin-top-40-\\!{margin-top:2.5rem !important}.ontario-margin-bottom-40-\\!{margin-bottom:2.5rem !important}.ontario-margin-right-40-\\!{margin-right:2.5rem !important}.ontario-margin-left-40-\\!{margin-left:2.5rem !important}.ontario-margin-top-48-\\!{margin-top:3rem !important}.ontario-margin-bottom-48-\\!{margin-bottom:3rem !important}.ontario-margin-right-48-\\!{margin-right:3rem !important}.ontario-margin-left-48-\\!{margin-left:3rem !important}.ontario-margin-top-64-\\!{margin-top:4rem !important}.ontario-margin-bottom-64-\\!{margin-bottom:4rem !important}.ontario-margin-right-64-\\!{margin-right:4rem !important}.ontario-margin-left-64-\\!{margin-left:4rem !important}.ontario-margin-top-80-\\!{margin-top:5rem !important}.ontario-margin-bottom-80-\\!{margin-bottom:5rem !important}.ontario-margin-right-80-\\!{margin-right:5rem !important}.ontario-margin-left-80-\\!{margin-left:5rem !important}.ontario-footer{color:#FFFFFF;margin-top:5rem;padding:4rem 0}.ontario-footer .ontario-columns *:last-child{margin-bottom:0}@media screen and (max-width: 73em){.ontario-footer .ontario-columns{margin-bottom:3rem}.ontario-footer .ontario-columns:last-of-type{margin-bottom:0}}.ontario-footer__links-container{list-style:none;margin:0 0 1rem 0}@media screen and (min-width: 73em){.ontario-footer__links-container{margin-bottom:0.5rem}}.ontario-footer__links-container--inline{display:flex;flex-direction:column;flex-wrap:wrap}@media screen and (min-width: 40em){.ontario-footer__links-container--inline{flex-direction:row}}.ontario-footer__links-container--two-column-list{column-count:1;display:block;margin:0}@media screen and (min-width: 40em){.ontario-footer__links-container--two-column-list{column-count:2}.ontario-footer__links-container--two-column-list .ontario-footer__link{padding:0;margin:0 1rem 1rem 0}}.ontario-footer__links-container li{padding:0.25rem 0}.ontario-footer__link{color:#FFFFFF;display:inline-block;padding:0.5rem 0;margin:0;text-decoration:underline}.ontario-footer__link:hover,.ontario-footer__link:focus{text-decoration:none}.ontario-footer__link:visited,.ontario-footer__link:active,.ontario-footer__link:hover{color:#FFFFFF}@media screen and (min-width: 40em){.ontario-footer__link{padding:0;margin:0 3rem 1rem 0}}.ontario-footer__copyright a{margin:0}.ontario-footer__links-container--social{display:flex;flex-direction:row;flex-wrap:wrap}.ontario-footer__links-container--social .ontario-footer__link{background:transparent;border-radius:45%;margin:0 1rem 0.75rem 0;padding:0;outline:none;height:3.5rem;width:3.5rem;display:flex;justify-content:center;align-items:center}.ontario-footer__links-container--social .ontario-footer__link:hover,.ontario-footer__links-container--social .ontario-footer__link:focus{background-color:black}.ontario-footer__links-container--social .ontario-footer__link:hover .ontario-icon,.ontario-footer__links-container--social .ontario-footer__link:focus .ontario-icon{fill:#FFFFFF}@media screen and (min-width: 40em){.ontario-footer__links-container--social .ontario-footer__link{height:3rem;width:3rem}}.ontario-footer__links-container--social .ontario-footer__link .ontario-icon{fill:#FFFFFF;width:36px;height:36px}@media screen and (min-width: 40em){.ontario-footer__links-container--social .ontario-footer__link .ontario-icon{width:32px;height:32px}}.ontario-footer__paragraph{max-width:48rem;width:100%;margin-bottom:1.5rem}.ontario-footer p a,.ontario-footer__paragraph a,.ontario-footer__list_item a{color:#FFFFFF;font-weight:600}.ontario-footer p a:visited,.ontario-footer__paragraph a:visited,.ontario-footer__list_item a:visited{color:#FFFFFF}.ontario-footer p a:active,.ontario-footer__paragraph a:active,.ontario-footer__list_item a:active{color:#e6e6e6}.ontario-footer p a:focus,.ontario-footer p a:hover,.ontario-footer__paragraph a:focus,.ontario-footer__paragraph a:hover,.ontario-footer__list_item a:focus,.ontario-footer__list_item a:hover{text-decoration:none}.ontario-button.ontario-footer__button{background-color:#1a1a1a;border:2px solid #FFFFFF;border-color:#FFFFFF;color:#FFFFFF;margin-bottom:2rem;border-radius:0.25rem;box-sizing:border-box;box-shadow:none;display:inline-block;font-size:1.125rem;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-weight:600;line-height:1.5555555556;margin:0 1.75rem 1.5rem 0;min-width:10rem;padding:0.625rem 1.5rem;text-align:center;text-decoration:none;cursor:pointer}.ontario-button.ontario-footer__button:hover{background-color:#4d4d4d}.ontario-button.ontario-footer__button:focus,.ontario-button.ontario-footer__button:active{background-color:#666666;box-shadow:0 0 0 0.25rem #009ADB;outline:0.25rem solid transparent;transition:all 0.1s ease-in-out}.ontario-footer__button+.ontario-footer__links-container{margin-top:1.5rem}.ontario-footer--default,.ontario-footer__expanded-top-section{position:relative}.ontario-footer--default:before,.ontario-footer__expanded-top-section:before{background-color:#333333;background-repeat:no-repeat;content:"";position:absolute;top:0;left:0;width:100%;height:100%}.ontario-footer--default:before{background-image:var(--imagePath, url(""))}.ontario-footer__expanded-top-section:before{background-image:var(--imagePath, url(""))}.ontario-footer--default{background-color:#1a1a1a;border-bottom:0.25rem solid #4d4d4d}.ontario-footer--default:before{background-size:112.5rem;background-position:calc(50vw - 73.5rem) -64rem}@media screen and (min-width: 40em){.ontario-footer--default:before{background-size:180rem;background-position:calc(50vw - 120rem) -106rem}}@media screen and (min-width: 73em){.ontario-footer--default:before{background-size:275rem;background-position:calc(50vw - 187rem) -160rem}}.ontario-footer--expanded{padding-top:0;background-color:#1a1a1a;border-bottom:0.25rem solid #4d4d4d}.ontario-footer__expanded-top-section{background-color:#262626;padding:4rem 0}.ontario-footer__expanded-top-section:before{background-size:165rem;background-position:calc(50vw - 125rem) -64rem}@media screen and (min-width: 40em){.ontario-footer__expanded-top-section:before{background-size:250rem;background-position:calc(50vw - 195rem) -106rem}}@media screen and (min-width: 73em){.ontario-footer__expanded-top-section:before{background-size:305rem;background-position:calc(50vw - 222rem) -160rem}}.ontario-footer__expanded-top-section .ontario-footer__link{text-decoration:underline}.ontario-footer__expanded-top-section .ontario-footer__link:hover,.ontario-footer__expanded-top-section .ontario-footer__link:focus{text-decoration:none}.ontario-footer__expanded-top-section .ontario-footer__link:active{color:#e6e6e6}.ontario-footer__expanded-top-section ul{margin-bottom:0}.ontario-expanded-footer__one-third-block{margin-bottom:0}.ontario-expanded-footer__one-third-block:first-of-type,.ontario-expanded-footer__one-third-block:nth-child(2){margin-bottom:3rem}@media screen and (min-width: 40em){.ontario-expanded-footer__one-third-block{margin-bottom:0}.ontario-expanded-footer__one-third-block:first-of-type{margin-bottom:3rem}.ontario-expanded-footer__one-third-block:nth-child(2){margin-bottom:0}}@media screen and (min-width: 73em){.ontario-expanded-footer__one-third-block{margin-bottom:0}.ontario-expanded-footer__one-third-block:first-of-type{margin-bottom:0}}.ontario-footer__expanded-bottom-section{background-color:#1a1a1a;padding-top:4rem}';

		class OntarioFooter {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The language of the component.
			 * This is used for translations, and is by default set through event listeners checking for a language property from the header. If no language is passed, it will default to English.
			 */
			language;
			/**
			 * The type of footer to be rendered. If no prop is provided, it will default to the 'default' type.
			 */
			type = 'default';
			/**
			 * A prop that stores the required links for all footers.
			 * Available options are 'accessibilityLink', 'privacyLink', 'contactLink','termsOfUseLink' and 'printerLink'
			 */
			footerLinks;
			/**
			 * Social media links to render in the footer.
			 * Available options are 'facebook', 'twitter', 'instagram' and 'youtube'
			 */
			socialLinks;
			/**
			 * Stores the titles and content for the expanded two column footer.
			 */
			twoColumnOptions;
			/**
			 * Stores the titles and content for the expanded three column footer.
			 */
			threeColumnOptions;
			/**
			 * Top margin for the footer. By default, this prop is set to `true`, which adds a margin top value of `5rem`.
			 * If set to `false`, the top margin value will be set to zero.
			 */
			topMargin = true;
			/**
			 * The base path to an assets folder containing the Design System assets
			 */
			assetBasePath;
			translations = translations;
			footerLinksState;
			socialLinksState;
			twoColumnState;
			threeColumnState;
			/**
			 * This listens for the `setAppLanguage` event sent from the test language toggler when it is
			 * connected to the DOM. It is used for the initial language when the input component loads.
			 */
			handleSetAppLanguage(event) {
				if (!this.language) {
					this.language = validateLanguage(event);
				}
			}
			handleHeaderLanguageToggled(event) {
				this.language = validateLanguage(event);
			}
			processFooterLinks() {
				this.parseOptions(this.footerLinks);
			}
			processSocialLinks() {
				this.parseOptions(this.socialLinks);
			}
			processTwoColumnOptions() {
				this.twoColumnOptions && this.parseOptions(this.twoColumnOptions);
				this.verifyTwoColumnOptions();
			}
			processThreeColumnOptions() {
				this.threeColumnOptions && this.parseOptions(this.threeColumnOptions);
				this.verifyThreeColumnOptions();
			}
			isTwoColumnLayout = () => this.type === 'twoColumn';
			isThreeColumnLayout = () => this.type === 'threeColumn';
			isExpandedLayout = () => this.isTwoColumnLayout() || this.isThreeColumnLayout();
			verifyTwoColumnOptions() {
				if (this.isTwoColumnLayout() && isInvalidTwoColumnOptions(this.twoColumnState)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' twoColumnOptions ')
						.addRegularText('for')
						.addMonospaceText(' <ontario-footer> ')
						.addRegularText('were not fully set. Please review your values and ensure all options are set.')
						.printMessage();
				}
			}
			verifyThreeColumnOptions() {
				if (this.isThreeColumnLayout() && isInvalidThreeColumnOptions(this.threeColumnState)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' threeColumnOptions ')
						.addRegularText('for')
						.addMonospaceText(' <ontario-footer> ')
						.addRegularText('were not fully set. Please review your values and ensure all options are set.')
						.printMessage();
				}
			}
			parseOptions(optionType) {
				const options = optionType;
				const isString = typeof options === 'string';
				if (!options) {
					return;
				}
				try {
					if (options === this.footerLinks) {
						this.footerLinksState = isString ? JSON.parse(options) : options;
					} else if (options === this.socialLinks) {
						this.socialLinksState = isString ? JSON.parse(options) : options;
					} else if (options === this.twoColumnOptions) {
						this.twoColumnState = isString ? JSON.parse(options) : options;
					} else {
						this.threeColumnState = isString ? JSON.parse(options) : options;
					}
				} catch (error) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addRegularText(' failed to parse props for ')
						.addMonospaceText('<ontario-footer>')
						.addRegularText(' in ')
						.addMonospaceText('parseOptions()')
						.addRegularText(' method \n ')
						.addMonospaceText(error.stack)
						.printMessage(ConsoleType.Error);
				}
			}
			/**
			 * Generate a link to the given image based on the base asset path.
			 * @param imageName Name of the image to build the path to
			 * @returns Path to image with asset path
			 */
			getImageAssetSrcPath(imageName) {
				return `${this.assetBasePath ? this.assetBasePath : getAssetPath('./assets')}/${imageName}`;
			}
			/**
			 * Generate CSS url to the background image
			 * @returns path to the background image
			 */
			getBackgroundImagePath() {
				const supergraphicLogoFile = this.isExpandedLayout()
					? 'footer-expanded-supergraphic-logo.svg'
					: 'footer-default-supergraphic-logo.svg';
				return `url(${this.getImageAssetSrcPath(supergraphicLogoFile)})`;
			}
			getFooterClasses() {
				let classes = 'ontario-footer ontario-footer--default';
				if (!this.topMargin) {
					classes = `${classes}  ontario-margin-top-0-!`;
				}
				return classes;
			}
			getFooterLinks() {
				const { language, translations, footerLinksState } = this;
				const { accessibilityLink, privacyLink, contactLink, termsOfUseLink, printerLink } = footerLinksState ?? {};
				const links = {
					accessibilityLink: {
						href: accessibilityLink?.href ?? translations.accessibilityLink.link[language],
						text: accessibilityLink?.text ?? translations.accessibilityLink.text[language],
					},
					privacyLink: {
						href: privacyLink?.href ?? translations.privacyLink.link[language],
						text: privacyLink?.text ?? translations.privacyLink.text[language],
					},
					printerLink: {
						href: printerLink?.href ?? translations.printerLink.link[language],
						text: printerLink?.text ?? translations.printerLink.text[language],
					},
				};
				if (contactLink) {
					links.contactLink = {
						href: contactLink.href,
						text: contactLink.text ?? translations.contactUs[language],
					};
				}
				if (termsOfUseLink) {
					links.termsOfUseLink = {
						href: termsOfUseLink.href,
						text: termsOfUseLink.text ?? translations.termsOfUse[language],
					};
				}
				return links;
			}
			componentWillLoad() {
				this.processFooterLinks();
				this.processSocialLinks();
				this.processTwoColumnOptions();
				this.processThreeColumnOptions();
				this.language = validateLanguage(this.language);
			}
			render() {
				const { socialLinksState, twoColumnState, threeColumnState, topMargin } = this;
				const footerLinks = this.getFooterLinks();
				if (this.isTwoColumnLayout()) {
					return hAsync(
						ExpandedFooterWrapper,
						{ footerLinks: footerLinks, topMargin: topMargin, backgroundImagePath: this.getBackgroundImagePath() },
						hAsync(FooterColumn, { data: twoColumnState.column1 }),
						hAsync(FooterColumn, { data: twoColumnState.column2, socialLinks: socialLinksState }),
					);
				}
				if (this.isThreeColumnLayout()) {
					return hAsync(
						ExpandedFooterWrapper,
						{ footerLinks: footerLinks, topMargin: topMargin, backgroundImagePath: this.getBackgroundImagePath() },
						hAsync(FooterColumn, {
							data: threeColumnState.column1,
							isThreeColLayout: true,
							isFullWidthInMediumLayout: true,
						}),
						hAsync(FooterColumn, { data: threeColumnState.column2, isThreeColLayout: true }),
						hAsync(FooterColumn, {
							data: threeColumnState.column3,
							socialLinks: socialLinksState,
							isThreeColLayout: true,
						}),
					);
				}
				return hAsync(
					'footer',
					{ class: this.getFooterClasses(), style: { '--imagePath': this.getBackgroundImagePath() } },
					hAsync(SimpleFooter, { ...footerLinks }),
				);
			}
			static get assetsDirs() {
				return ['assets'];
			}
			static get watchers() {
				return {
					footerLinks: ['processFooterLinks'],
					socialLinks: ['processSocialLinks'],
					twoColumnOptions: ['processTwoColumnOptions'],
					threeColumnOptions: ['processThreeColumnOptions'],
				};
			}
			static get style() {
				return ontarioFooterCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-footer',
					$members$: {
						language: [1025],
						type: [1],
						footerLinks: [1, 'footer-links'],
						socialLinks: [1, 'social-links'],
						twoColumnOptions: [1, 'two-column-options'],
						threeColumnOptions: [1, 'three-column-options'],
						topMargin: [4, 'top-margin'],
						assetBasePath: [1, 'asset-base-path'],
						translations: [32],
						footerLinksState: [32],
						socialLinksState: [32],
						twoColumnState: [32],
						threeColumnState: [32],
					},
					$listeners$: [
						[8, 'setAppLanguage', 'handleSetAppLanguage'],
						[8, 'headerLanguageToggled', 'handleHeaderLanguageToggled'],
					],
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		var OntarioIconClose$1 = `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="#000000" viewBox="0 0 24 24"><path d="M19 6.4L17.6 5 12 10.6 6.4 5 5 6.4l5.6 5.6L5 17.6 6.4 19l5.6-5.6 5.6 5.6 1.4-1.4-5.6-5.6L19 6.4z" fill="#ffffff"/></svg>
`;

		var OntarioIconMenu$1 = `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="#ffffff" viewBox="0 0 24 24"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z" fill="#ffffff"/></svg>`;

		var OntarioIconSearch$1 = `<svg class="svg-icon" role="img" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" fill="none"><path d="M15.5 14h-.8l-.28-.27A6.47 6.47 0 0 0 16 9.5a6.5 6.5 0 1 0-13 0A6.5 6.5 0 0 0 9.5 16a6.47 6.47 0 0 0 4.23-1.57l.27.28v.8l5 5 1.5-1.5-5-5zm-6 0C7 14 5 12 5 9.5S7 5 9.5 5 14 7 14 9.5 12 14 9.5 14z"/></svg>
`;

		var OntarioIconSearchWhite$1 = `<svg class="svg-icon" role="img" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="#ffffff"><path d="M15.5 14h-.8l-.28-.27A6.47 6.47 0 0 0 16 9.5a6.5 6.5 0 1 0-13 0A6.5 6.5 0 0 0 9.5 16a6.47 6.47 0 0 0 4.23-1.57l.27.28v.8l5 5 1.5-1.5-5-5zm-6 0C7 14 5 12 5 9.5S7 5 9.5 5 14 7 14 9.5 12 14 9.5 14z"/></svg>
`;

		const en = [
			{
				title: 'Arts and Culture',
				href: 'https://www.ontario.ca/page/arts-and-culture',
			},
			{
				title: 'Business and economy',
				href: 'https://www.ontario.ca/page/business-and-economy',
			},
			{
				title: 'COVID-19',
				href: 'https://www.ontario.ca/page/covid-19-coronavirus',
			},
			{
				title: 'Driving and Roads',
				href: 'https://www.ontario.ca/page/driving-and-roads',
			},
			{
				title: 'Education and training',
				href: 'https://www.ontario.ca/page/education-and-training',
			},
			{
				title: 'Environment and energy',
				href: 'https://www.ontario.ca/page/environment-and-energy',
			},
			{
				title: 'Government',
				href: 'https://www.ontario.ca/page/government',
			},
			{
				title: 'Health and wellness',
				href: 'https://www.ontario.ca/page/health-care-ontario',
			},
			{
				title: 'Home and community',
				href: 'https://www.ontario.ca/page/home-and-community',
			},
			{
				title: 'Jobs and employment',
				href: 'https://www.ontario.ca/page/jobs-and-employment',
			},
			{
				title: 'Law and safety',
				href: 'https://www.ontario.ca/page/law-and-safety',
			},
			{
				title: 'Rural and north',
				href: 'https://www.ontario.ca/page/rural-and-north',
			},
			{
				title: 'Taxes and benefits',
				href: 'https://www.ontario.ca/page/taxes-and-benefits',
			},
			{
				title: 'Travel and recreation',
				href: 'https://www.ontario.ca/page/travel-and-recreation',
			},
		];
		const fr = [
			{
				title: 'Affaires et conomie',
				href: 'https://www.ontario.ca/fr/page/affaires-et-economie',
			},
			{
				title: 'Arts et culture',
				href: 'https://www.ontario.ca/fr/page/arts-et-culture',
			},
			{
				title: 'Conduite et routes',
				href: 'https://www.ontario.ca/fr/page/conduite-et-routes',
			},
			{
				title: 'COVID-19',
				href: 'https://www.ontario.ca/fr/page/covid-19-le-coronavirus',
			},
			{
				title: 'Domicile et communaut',
				href: 'https://www.ontario.ca/fr/page/domicile-et-communaute',
			},
			{
				title: 'ducation et formation',
				href: 'https://www.ontario.ca/fr/page/education-et-formation',
			},
			{
				title: 'Environnement et nergie',
				href: 'https://www.ontario.ca/fr/page/environnement-et-energie',
			},
			{
				title: 'Gouvernement',
				href: 'https://www.ontario.ca/fr/page/gouvernement',
			},
			{
				title: 'Impts et avantages fiscaux',
				href: 'https://www.ontario.ca/fr/page/impots-et-avantages-fiscaux',
			},
			{
				title: 'Lois et scurit',
				href: 'https://www.ontario.ca/fr/page/lois-et-securite',
			},
			{
				title: 'Rgions rurales et du Nord',
				href: 'https://www.ontario.ca/fr/page/regions-rurales-et-du-nord',
			},
			{
				title: 'Sant et bien-tre',
				href: 'https://www.ontario.ca/fr/page/les-soins-de-sante-en-ontario',
			},
			{
				title: 'Travail et emploi',
				href: 'https://www.ontario.ca/fr/page/travail-et-emploi',
			},
			{
				title: 'Voyage et loisirs',
				href: 'https://www.ontario.ca/fr/page/voyage-et-loisirs',
			},
		];
		var OntarioHeaderDefaultData = {
			en: en,
			fr: fr,
		};

		const ONTARIO_HEADER_API_URL_EN = '';
		const ONTARIO_HEADER_API_URL_FR = '';
		var config = {
			ONTARIO_HEADER_API_URL_EN: ONTARIO_HEADER_API_URL_EN,
			ONTARIO_HEADER_API_URL_FR: ONTARIO_HEADER_API_URL_FR,
		};

		const ontarioApplicationHeaderCss =
			'.ontario-application-navigation a:focus,.ontario-application-navigation a:active,.ontario-header-button:focus,.ontario-input:focus,.ontario-input:active{box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:box-shadow 0.1s ease-in-out}.ontario-application-subheader__heading{font-style:normal;font-weight:700;text-rendering:optimizeLegibility;margin-bottom:1rem;font-feature-settings:normal;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif}.ontario-application-subheader__heading{font-size:1.25rem;letter-spacing:0.03rem;line-height:1.5;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){.ontario-application-subheader__heading{font-size:1.5rem;letter-spacing:0.0313rem;line-height:1.5}}.ontario-row{margin:0 auto;max-width:72rem;width:100%}.ontario-row:before,.ontario-row:after{content:"";display:table}.ontario-row:after{clear:both}.ontario-row.ontario-row--collapse>.ontario-column,.ontario-row.ontario-row--collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-row--collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row .ontario-row{margin:0 -1rem;max-width:none;width:auto}.ontario-row .ontario-row:before,.ontario-row .ontario-row:after{content:"";display:table}.ontario-row .ontario-row:after{clear:both}.ontario-row .ontario-row.ontario-row--collapse{margin:0;max-width:none;width:auto}.ontario-row .ontario-row.ontario-row--collapse:before,.ontario-row .ontario-row.ontario-row--collapse:after{content:"";display:table}.ontario-row .ontario-row.ontario-row--collapse:after{clear:both}.ontario-column,.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;width:100%;float:left}.ontario-column+.ontario-column:last-child,.ontario-column+.ontario-columns:last-child,.ontario-columns+.ontario-column:last-child,.ontario-columns+.ontario-columns:last-child{float:right}.ontario-column+.ontario-column.ontario-end,.ontario-column+.ontario-columns.ontario-end,.ontario-columns+.ontario-column.ontario-end,.ontario-columns+.ontario-columns.ontario-end{float:left}@media only screen{.ontario-small-push-0{position:relative;left:0;right:auto}.ontario-small-pull-0{position:relative;right:0;left:auto}.ontario-small-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-small-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-small-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-small-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-small-push-3{position:relative;left:25%;right:auto}.ontario-small-pull-3{position:relative;right:25%;left:auto}.ontario-small-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-small-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-small-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-small-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-small-push-6{position:relative;left:50%;right:auto}.ontario-small-pull-6{position:relative;right:50%;left:auto}.ontario-small-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-small-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-small-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-small-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-small-push-9{position:relative;left:75%;right:auto}.ontario-small-pull-9{position:relative;right:75%;left:auto}.ontario-small-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-small-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-small-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-small-pull-11{position:relative;right:91.6666666667%;left:auto}.ontario-column,.ontario-columns{position:relative;padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-small-1{width:8.3333333333%}.ontario-small-2{width:16.6666666667%}.ontario-small-3{width:25%}.ontario-small-4{width:33.3333333333%}.ontario-small-5{width:41.6666666667%}.ontario-small-6{width:50%}.ontario-small-7{width:58.3333333333%}.ontario-small-8{width:66.6666666667%}.ontario-small-9{width:75%}.ontario-small-10{width:83.3333333333%}.ontario-small-11{width:91.6666666667%}.ontario-small-12{width:100%}.ontario-small-offset-0{margin-left:0 !important}.ontario-small-offset-1{margin-left:8.3333333333% !important}.ontario-small-offset-2{margin-left:16.6666666667% !important}.ontario-small-offset-3{margin-left:25% !important}.ontario-small-offset-4{margin-left:33.3333333333% !important}.ontario-small-offset-5{margin-left:41.6666666667% !important}.ontario-small-offset-6{margin-left:50% !important}.ontario-small-offset-7{margin-left:58.3333333333% !important}.ontario-small-offset-8{margin-left:66.6666666667% !important}.ontario-small-offset-9{margin-left:75% !important}.ontario-small-offset-10{margin-left:83.3333333333% !important}.ontario-small-offset-11{margin-left:91.6666666667% !important}.ontario-small-reset-order{float:left;left:auto;margin-left:0;margin-right:0;right:auto}.ontario-column.ontario-small-centered,.ontario-columns.ontario-small-centered{margin-left:auto;margin-right:auto;float:none}.ontario-column.ontario-small-uncentered,.ontario-columns.ontario-small-uncentered{float:left;margin-left:0;margin-right:0}.ontario-column.ontario-small-centered:last-child,.ontario-columns.ontario-small-centered:last-child{float:none}.ontario-column.ontario-small-uncentered:last-child,.ontario-columns.ontario-small-uncentered:last-child{float:left}.ontario-column.ontario-small-uncentered.ontario-opposite,.ontario-columns.ontario-small-uncentered.ontario-opposite{float:right}.ontario-row.ontario-small-collapse>.ontario-column,.ontario-row.ontario-small-collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-small-collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row.ontario-small-uncollapse>.ontario-column,.ontario-row.ontario-small-uncollapse>.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}}@media only screen and (min-width:40.063em){.ontario-medium-push-0{position:relative;left:0;right:auto}.ontario-medium-pull-0{position:relative;right:0;left:auto}.ontario-medium-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-medium-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-medium-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-medium-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-medium-push-3{position:relative;left:25%;right:auto}.ontario-medium-pull-3{position:relative;right:25%;left:auto}.ontario-medium-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-medium-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-medium-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-medium-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-medium-push-6{position:relative;left:50%;right:auto}.ontario-medium-pull-6{position:relative;right:50%;left:auto}.ontario-medium-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-medium-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-medium-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-medium-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-medium-push-9{position:relative;left:75%;right:auto}.ontario-medium-pull-9{position:relative;right:75%;left:auto}.ontario-medium-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-medium-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-medium-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-medium-pull-11{position:relative;right:91.6666666667%;left:auto}.ontario-column,.ontario-columns{position:relative;padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-medium-1{width:8.3333333333%}.ontario-medium-2{width:16.6666666667%}.ontario-medium-3{width:25%}.ontario-medium-4{width:33.3333333333%}.ontario-medium-5{width:41.6666666667%}.ontario-medium-6{width:50%}.ontario-medium-7{width:58.3333333333%}.ontario-medium-8{width:66.6666666667%}.ontario-medium-9{width:75%}.ontario-medium-10{width:83.3333333333%}.ontario-medium-11{width:91.6666666667%}.ontario-medium-12{width:100%}.ontario-medium-offset-0{margin-left:0 !important}.ontario-medium-offset-1{margin-left:8.3333333333% !important}.ontario-medium-offset-2{margin-left:16.6666666667% !important}.ontario-medium-offset-3{margin-left:25% !important}.ontario-medium-offset-4{margin-left:33.3333333333% !important}.ontario-medium-offset-5{margin-left:41.6666666667% !important}.ontario-medium-offset-6{margin-left:50% !important}.ontario-medium-offset-7{margin-left:58.3333333333% !important}.ontario-medium-offset-8{margin-left:66.6666666667% !important}.ontario-medium-offset-9{margin-left:75% !important}.ontario-medium-offset-10{margin-left:83.3333333333% !important}.ontario-medium-offset-11{margin-left:91.6666666667% !important}.ontario-medium-reset-order{float:left;left:auto;margin-left:0;margin-right:0;right:auto}.ontario-column.ontario-medium-centered,.ontario-columns.ontario-medium-centered{margin-left:auto;margin-right:auto;float:none}.ontario-column.ontario-medium-uncentered,.ontario-columns.ontario-medium-uncentered{float:left;margin-left:0;margin-right:0}.ontario-column.ontario-medium-centered:last-child,.ontario-columns.ontario-medium-centered:last-child{float:none}.ontario-column.ontario-medium-uncentered:last-child,.ontario-columns.ontario-medium-uncentered:last-child{float:left}.ontario-column.ontario-medium-uncentered.ontario-opposite,.ontario-columns.ontario-medium-uncentered.ontario-opposite{float:right}.ontario-row.ontario-medium-collapse>.ontario-column,.ontario-row.ontario-medium-collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-medium-collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row.ontario-medium-uncollapse>.ontario-column,.ontario-row.ontario-medium-uncollapse>.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}}@media only screen and (min-width:73.063em){.ontario-large-push-0{position:relative;left:0;right:auto}.ontario-large-pull-0{position:relative;right:0;left:auto}.ontario-large-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-large-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-large-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-large-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-large-push-3{position:relative;left:25%;right:auto}.ontario-large-pull-3{position:relative;right:25%;left:auto}.ontario-large-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-large-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-large-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-large-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-large-push-6{position:relative;left:50%;right:auto}.ontario-large-pull-6{position:relative;right:50%;left:auto}.ontario-large-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-large-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-large-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-large-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-large-push-9{position:relative;left:75%;right:auto}.ontario-large-pull-9{position:relative;right:75%;left:auto}.ontario-large-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-large-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-large-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-large-pull-11{position:relative;right:91.6666666667%;left:auto}.ontario-column,.ontario-columns{position:relative;padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-large-1{width:8.3333333333%}.ontario-large-2{width:16.6666666667%}.ontario-large-3{width:25%}.ontario-large-4{width:33.3333333333%}.ontario-large-5{width:41.6666666667%}.ontario-large-6{width:50%}.ontario-large-7{width:58.3333333333%}.ontario-large-8{width:66.6666666667%}.ontario-large-9{width:75%}.ontario-large-10{width:83.3333333333%}.ontario-large-11{width:91.6666666667%}.ontario-large-12{width:100%}.ontario-large-offset-0{margin-left:0 !important}.ontario-large-offset-1{margin-left:8.3333333333% !important}.ontario-large-offset-2{margin-left:16.6666666667% !important}.ontario-large-offset-3{margin-left:25% !important}.ontario-large-offset-4{margin-left:33.3333333333% !important}.ontario-large-offset-5{margin-left:41.6666666667% !important}.ontario-large-offset-6{margin-left:50% !important}.ontario-large-offset-7{margin-left:58.3333333333% !important}.ontario-large-offset-8{margin-left:66.6666666667% !important}.ontario-large-offset-9{margin-left:75% !important}.ontario-large-offset-10{margin-left:83.3333333333% !important}.ontario-large-offset-11{margin-left:91.6666666667% !important}.ontario-large-reset-order{float:left;left:auto;margin-left:0;margin-right:0;right:auto}.ontario-column.ontario-large-centered,.ontario-columns.ontario-large-centered{margin-left:auto;margin-right:auto;float:none}.ontario-column.ontario-large-uncentered,.ontario-columns.ontario-large-uncentered{float:left;margin-left:0;margin-right:0}.ontario-column.ontario-large-centered:last-child,.ontario-columns.ontario-large-centered:last-child{float:none}.ontario-column.ontario-large-uncentered:last-child,.ontario-columns.ontario-large-uncentered:last-child{float:left}.ontario-column.ontario-large-uncentered.ontario-opposite,.ontario-columns.ontario-large-uncentered.ontario-opposite{float:right}.ontario-row.ontario-large-collapse>.ontario-column,.ontario-row.ontario-large-collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-large-collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row.ontario-large-uncollapse>.ontario-column,.ontario-row.ontario-large-uncollapse>.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-push-0{position:relative;left:0;right:auto}.ontario-pull-0{position:relative;right:0;left:auto}.ontario-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-push-3{position:relative;left:25%;right:auto}.ontario-pull-3{position:relative;right:25%;left:auto}.ontario-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-push-6{position:relative;left:50%;right:auto}.ontario-pull-6{position:relative;right:50%;left:auto}.ontario-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-push-9{position:relative;left:75%;right:auto}.ontario-pull-9{position:relative;right:75%;left:auto}.ontario-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-pull-11{position:relative;right:91.6666666667%;left:auto}}@media only screen and (min-width:96.063em){.ontario-xlarge-push-0{position:relative;left:0;right:auto}.ontario-xlarge-pull-0{position:relative;right:0;left:auto}.ontario-xlarge-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-xlarge-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-xlarge-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-xlarge-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-xlarge-push-3{position:relative;left:25%;right:auto}.ontario-xlarge-pull-3{position:relative;right:25%;left:auto}.ontario-xlarge-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-xlarge-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-xlarge-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-xlarge-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-xlarge-push-6{position:relative;left:50%;right:auto}.ontario-xlarge-pull-6{position:relative;right:50%;left:auto}.ontario-xlarge-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-xlarge-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-xlarge-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-xlarge-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-xlarge-push-9{position:relative;left:75%;right:auto}.ontario-xlarge-pull-9{position:relative;right:75%;left:auto}.ontario-xlarge-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-xlarge-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-xlarge-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-xlarge-pull-11{position:relative;right:91.6666666667%;left:auto}.ontario-column,.ontario-columns{position:relative;padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-xlarge-1{width:8.3333333333%}.ontario-xlarge-2{width:16.6666666667%}.ontario-xlarge-3{width:25%}.ontario-xlarge-4{width:33.3333333333%}.ontario-xlarge-5{width:41.6666666667%}.ontario-xlarge-6{width:50%}.ontario-xlarge-7{width:58.3333333333%}.ontario-xlarge-8{width:66.6666666667%}.ontario-xlarge-9{width:75%}.ontario-xlarge-10{width:83.3333333333%}.ontario-xlarge-11{width:91.6666666667%}.ontario-xlarge-12{width:100%}.ontario-xlarge-offset-0{margin-left:0 !important}.ontario-xlarge-offset-1{margin-left:8.3333333333% !important}.ontario-xlarge-offset-2{margin-left:16.6666666667% !important}.ontario-xlarge-offset-3{margin-left:25% !important}.ontario-xlarge-offset-4{margin-left:33.3333333333% !important}.ontario-xlarge-offset-5{margin-left:41.6666666667% !important}.ontario-xlarge-offset-6{margin-left:50% !important}.ontario-xlarge-offset-7{margin-left:58.3333333333% !important}.ontario-xlarge-offset-8{margin-left:66.6666666667% !important}.ontario-xlarge-offset-9{margin-left:75% !important}.ontario-xlarge-offset-10{margin-left:83.3333333333% !important}.ontario-xlarge-offset-11{margin-left:91.6666666667% !important}.ontario-xlarge-reset-order{float:left;left:auto;margin-left:0;margin-right:0;right:auto}.ontario-column.ontario-xlarge-centered,.ontario-columns.ontario-xlarge-centered{margin-left:auto;margin-right:auto;float:none}.ontario-column.ontario-xlarge-uncentered,.ontario-columns.ontario-xlarge-uncentered{float:left;margin-left:0;margin-right:0}.ontario-column.ontario-xlarge-centered:last-child,.ontario-columns.ontario-xlarge-centered:last-child{float:none}.ontario-column.ontario-xlarge-uncentered:last-child,.ontario-columns.ontario-xlarge-uncentered:last-child{float:left}.ontario-column.ontario-xlarge-uncentered.ontario-opposite,.ontario-columns.ontario-xlarge-uncentered.ontario-opposite{float:right}.ontario-row.ontario-xlarge-collapse>.ontario-column,.ontario-row.ontario-xlarge-collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-xlarge-collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row.ontario-xlarge-uncollapse>.ontario-column,.ontario-row.ontario-xlarge-uncollapse>.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}}@media only screen and (min-width:120.063em){.ontario-xxlarge-push-0{position:relative;left:0;right:auto}.ontario-xxlarge-pull-0{position:relative;right:0;left:auto}.ontario-xxlarge-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-xxlarge-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-xxlarge-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-xxlarge-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-xxlarge-push-3{position:relative;left:25%;right:auto}.ontario-xxlarge-pull-3{position:relative;right:25%;left:auto}.ontario-xxlarge-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-xxlarge-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-xxlarge-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-xxlarge-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-xxlarge-push-6{position:relative;left:50%;right:auto}.ontario-xxlarge-pull-6{position:relative;right:50%;left:auto}.ontario-xxlarge-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-xxlarge-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-xxlarge-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-xxlarge-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-xxlarge-push-9{position:relative;left:75%;right:auto}.ontario-xxlarge-pull-9{position:relative;right:75%;left:auto}.ontario-xxlarge-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-xxlarge-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-xxlarge-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-xxlarge-pull-11{position:relative;right:91.6666666667%;left:auto}.ontario-column,.ontario-columns{position:relative;padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-xxlarge-1{width:8.3333333333%}.ontario-xxlarge-2{width:16.6666666667%}.ontario-xxlarge-3{width:25%}.ontario-xxlarge-4{width:33.3333333333%}.ontario-xxlarge-5{width:41.6666666667%}.ontario-xxlarge-6{width:50%}.ontario-xxlarge-7{width:58.3333333333%}.ontario-xxlarge-8{width:66.6666666667%}.ontario-xxlarge-9{width:75%}.ontario-xxlarge-10{width:83.3333333333%}.ontario-xxlarge-11{width:91.6666666667%}.ontario-xxlarge-12{width:100%}.ontario-xxlarge-offset-0{margin-left:0 !important}.ontario-xxlarge-offset-1{margin-left:8.3333333333% !important}.ontario-xxlarge-offset-2{margin-left:16.6666666667% !important}.ontario-xxlarge-offset-3{margin-left:25% !important}.ontario-xxlarge-offset-4{margin-left:33.3333333333% !important}.ontario-xxlarge-offset-5{margin-left:41.6666666667% !important}.ontario-xxlarge-offset-6{margin-left:50% !important}.ontario-xxlarge-offset-7{margin-left:58.3333333333% !important}.ontario-xxlarge-offset-8{margin-left:66.6666666667% !important}.ontario-xxlarge-offset-9{margin-left:75% !important}.ontario-xxlarge-offset-10{margin-left:83.3333333333% !important}.ontario-xxlarge-offset-11{margin-left:91.6666666667% !important}.ontario-xxlarge-reset-order{float:left;left:auto;margin-left:0;margin-right:0;right:auto}.ontario-column.ontario-xxlarge-centered,.ontario-columns.ontario-xxlarge-centered{margin-left:auto;margin-right:auto;float:none}.ontario-column.ontario-xxlarge-uncentered,.ontario-columns.ontario-xxlarge-uncentered{float:left;margin-left:0;margin-right:0}.ontario-column.ontario-xxlarge-centered:last-child,.ontario-columns.ontario-xxlarge-centered:last-child{float:none}.ontario-column.ontario-xxlarge-uncentered:last-child,.ontario-columns.ontario-xxlarge-uncentered:last-child{float:left}.ontario-column.ontario-xxlarge-uncentered.ontario-opposite,.ontario-columns.ontario-xxlarge-uncentered.ontario-opposite{float:right}.ontario-row.ontario-xxlarge-collapse>.ontario-column,.ontario-row.ontario-xxlarge-collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-xxlarge-collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row.ontario-xxlarge-uncollapse>.ontario-column,.ontario-row.ontario-xxlarge-uncollapse>.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}}.ontario-input{border:2px solid #1a1a1a;border-radius:4px;box-sizing:border-box;color:#1a1a1a;display:block;font-size:1rem;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;line-height:1.5;margin:0 0 2.5rem;max-width:48rem;width:100%;padding:0.625rem 1rem;transition:box-shadow 0.1s ease-in-out}.ontario-input--2-char-width{max-width:8ex}.ontario-input--3-char-width{max-width:10ex}.ontario-input--4-char-width{max-width:12ex}.ontario-input--5-char-width{max-width:14ex}.ontario-input--7-char-width{max-width:17ex}.ontario-input--10-char-width{max-width:23ex}.ontario-input--20-char-width{max-width:41ex}.ontario-form-group:last-of-type{margin-bottom:2.5rem}.ontario-hide{display:none !important}.ontario-invisible{visibility:hidden !important}@media screen and (max-width: 39.99875em){.ontario-hide-for-small-only{display:none !important}}@media screen and (max-width: 0em), screen and (min-width: 40em){.ontario-show-for-small-only{display:none !important}}@media print, screen and (min-width: 40em){.ontario-hide-for-medium{display:none !important}}@media screen and (max-width: 39.99875em){.ontario-show-for-medium{display:none !important}}@media screen and (min-width: 40em) and (max-width: 72.99875em){.ontario-hide-for-medium-only{display:none !important}}@media screen and (max-width: 39.99875em), screen and (min-width: 73em){.ontario-show-for-medium-only{display:none !important}}@media print, screen and (min-width: 73em){.ontario-hide-for-large{display:none !important}}@media screen and (max-width: 72.99875em){.ontario-show-for-large{display:none !important}}@media screen and (min-width: 73em) and (max-width: 95.99875em){.ontario-hide-for-large-only{display:none !important}}@media screen and (max-width: 72.99875em), screen and (min-width: 96em){.ontario-show-for-large-only{display:none !important}}.ontario-show-for-sr,.ontario-show-on-focus{position:absolute;width:1px;height:1px;overflow:hidden;clip:rect(0, 0, 0, 0)}.ontario-show-on-focus:active,.ontario-show-on-focus:focus{position:static;width:auto;height:auto;overflow:visible;clip:auto}.ontario-show-for-landscape,.ontario-hide-for-portrait{display:block !important}@media screen and (orientation: landscape){.ontario-show-for-landscape,.ontario-hide-for-portrait{display:block !important}}@media screen and (orientation: portrait){.ontario-show-for-landscape,.ontario-hide-for-portrait{display:none !important}}.ontario-hide-for-landscape,.ontario-show-for-portrait{display:none !important}@media screen and (orientation: landscape){.ontario-hide-for-landscape,.ontario-show-for-portrait{display:none !important}}@media screen and (orientation: portrait){.ontario-hide-for-landscape,.ontario-show-for-portrait{display:block !important}}.ontario-application-header{display:flex;align-items:center;background-color:#1a1a1a;color:#FFFFFF;height:3.125rem !important;position:relative;z-index:5}.ontario-application-header>.ontario-row{display:flex;align-items:center}.ontario-application-header-container{position:relative;width:100%}.ontario-header-button.ontario-application-navigation--open:hover{background-color:#666666}.ontario-header-button.ontario-application-navigation--closed:active{background-color:#1a1a1a}.ontario-header-button--with-outline{border:2px solid #FFFFFF;margin:0 0 0 1rem;padding:0.375rem 1rem}.ontario-application-subheader .ontario-header-button,.ontario-application-navigation .ontario-header-button{background-color:#4d4d4d}.ontario-header-button--closed:focus{box-shadow:none;outline:none;transition:none}.ontario-application-header__logo,.ontario-application-header__logo a,.ontario-application-header__lang-toggle,.ontario-application-subheader__container,.ontario-application-subheader__menu-container,.ontario-application-subheader__menu{display:flex;align-items:center;outline:none}.ontario-application-header__logo a:focus{box-shadow:0 0 0 4px #009ADB;transition:all 0.1s ease-in-out}.ontario-application-header__logo svg,.ontario-application-header__logo img{width:100px;height:25px}.ontario-application-header__lang-toggle{justify-content:flex-end}.ontario-application-header__lang-toggle a{font-size:1rem;line-height:1.375rem;height:auto;outline:none;padding:0.5rem 0.75rem}.ontario-application-subheader{padding:1.25rem 0;background-color:#404040;overflow:visible;position:relative;z-index:5}@media screen and (min-width: 73em){.ontario-application-subheader{z-index:0}}.ontario-application-subheader>.ontario-row{position:relative}.ontario-application-header-container{position:relative;z-index:5}.ontario-application-header>.ontario-row{display:flex;align-items:center}.ontario-application-subheader .ontario-header-button{visibility:visible}.ontario-application-subheader .ontario-header-button,.ontario-application-navigation .ontario-header-button{background-color:#4d4d4d}.ontario-application-subheader .ontario-header-button:hover,.ontario-application-navigation .ontario-header-button:hover{background-color:#666666}.ontario-application-subheader .ontario-header-button:active,.ontario-application-navigation .ontario-header-button:active{background-color:#1a1a1a}.ontario-header-button--without-outline:hover{background-color:#4d4d4d}.ontario-header-button--without-outline:focus{box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:all 0.1s ease-in-out}.ontario-application-subheader__heading{padding:0.375rem 0;margin-bottom:0;max-width:65%}.ontario-application-subheader__heading a{color:#FFFFFF;font-weight:600;text-decoration:none}.ontario-application-subheader__heading a:focus{box-shadow:0 0 0 4px #009ADB;transition:all 0.1s ease-in-out}.ontario-application-subheader__heading a:hover,.ontario-application-subheader__heading a:active,.ontario-application-subheader__heading a:visited{color:#FFFFFF;text-decoration:underline}.ontario-application-subheader .ontario-header-button{visibility:visible;background-color:#4d4d4d}.ontario-application-subheader .ontario-header-button:hover{background-color:#666666}.ontario-application-subheader .ontario-header-button:active{background-color:#1a1a1a}.ontario-header__menu-toggler span{display:flex}@media screen and (max-width: 20em){.ontario-header__menu-toggler span:last-of-type{display:none}}.ontario-header__menu-toggler svg{margin-right:6px}@media screen and (max-width: 20em){.ontario-header__menu-toggler svg{margin-right:0}}.ontario-application-subheader__container{align-items:center;justify-content:space-between}.ontario-application-subheader__menu{display:flex;align-items:center;list-style:none;margin:0;padding-left:0}.ontario-application-subheader__menu li{border-radius:4px;padding:0;margin:0 0 0 0.75rem;text-align:center}.ontario-application-subheader__menu-container a{box-sizing:border-box;border-radius:4px;color:#FFFFFF;display:inline-block;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1.125rem;font-weight:600;height:48px;line-height:1.4375rem;outline:none;padding:0.75rem;text-align:left;text-decoration:none;white-space:nowrap}.ontario-application-subheader__menu-container a.ontario-link--active{border-radius:4px 4px 0 0;border-bottom:4px solid #FFFFFF}.ontario-application-subheader__menu-container a:hover{background-color:#666666;color:#FFFFFF}.ontario-application-subheader__menu-container a:active{background-color:#1a1a1a}.ontario-application-subheader__menu-container a:focus{box-shadow:0 0 0 4px #009ADB;transition:all 0.1s ease-in-out}.ontario-application-navigation{position:absolute;width:100%}@media screen and (min-width: 73em){.ontario-application-navigation{position:relative;max-width:72rem;width:auto;margin:0 auto}}.ontario-application-navigation .ontario-header-button{visibility:hidden;position:absolute;top:-4.25rem;right:1rem;z-index:6}.ontario-application-navigation__container{background:#FFFFFF;position:absolute;top:0;width:100%;z-index:4}@media screen and (min-width: 40em){.ontario-application-navigation__container{background:#FFFFFF;position:absolute;z-index:4}}@media screen and (min-width: 73em){.ontario-application-navigation__container{box-shadow:0 4px 12px rgba(0, 0, 0, 0.3);border-radius:4px;position:absolute;right:0.75rem;top:-0.6rem;min-width:290px;max-width:30%;z-index:3;transition:none !important}}.ontario-application-navigation ul{list-style:none;padding:0.5rem 0;margin:0;border-bottom:1px solid #cccccc}@media screen and (min-width: 73em){.ontario-application-navigation ul{border-bottom:none}}.ontario-application-navigation li{border-top:1px solid #cccccc;padding:0;margin-bottom:0}.ontario-application-navigation li:last-of-type{border-bottom:1px solid #cccccc}.ontario-application-navigation a{color:#1a1a1a;display:block;font-size:1.125rem;font-weight:600;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;text-decoration:none;padding:0.6730769231rem 1.5rem}.ontario-application-navigation a:hover{text-decoration:underline;background-color:#e5e5e5}.ontario-application-navigation a:active{text-decoration:underline;background-color:#cccccc}.ontario-application-navigation a:focus,.ontario-application-navigation a:active{box-shadow:0 0 0 4px #009ADB inset}.ontario-application-navigation a.ontario-link--active{border-left:6px solid #1a1a1a;background-color:#f2f2f2}.ontario-navigation--open{visibility:visible;transform:translateY(0);transition:transform 0.4s ease-in-out}@media screen and (min-width: 73em){.ontario-navigation--open{z-index:5}}.ontario-navigation--closed{background:#FFFFFF;position:absolute;transform:translateY(-100%);transition:transform 0.3s ease-in-out, visibility 0.1s ease;width:100%;visibility:hidden;z-index:4}.ontario-application-navigation.ontario-navigation--open .ontario-application-navigation__container{visibility:visible;transform:translateY(0);transition:transform 0.4s ease-in-out}@media screen and (min-width: 73em){.ontario-application-navigation.ontario-navigation--open .ontario-application-navigation__container{transition:none;display:block}}.ontario-overlay{position:fixed;top:0;left:0;background:rgba(0, 0, 0, 0.6);width:100%;height:100%;z-index:2}.ontario-header-button.ontario-navigation--open:hover{background-color:#666666}.ontario-header-button.ontario-navigation--open:active{background-color:#1a1a1a}.ontario-header-button.ontario-navigation--closed:active{background-color:#1a1a1a}.ontario-header-button{background-color:#1a1a1a;border:none;border-radius:4px;box-sizing:border-box;box-shadow:none;color:#FFFFFF;cursor:pointer;display:flex;align-items:center;font-size:1.125rem;font-weight:600;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;height:48px;line-height:1.5555555556;text-align:center;text-decoration:none}.ontario-header-button:hover,.ontario-header-button:focus,.ontario-header-button:visited{color:#FFFFFF}.ontario-header-button--with-outline,.ontario-header-button--without-outline{background-color:#1a1a1a;color:#FFFFFF}.ontario-header-button--with-outline:hover,.ontario-header-button--without-outline:hover{background-color:#4d4d4d}.ontario-header-button--with-outline:active,.ontario-header-button--without-outline:active{background-color:#666666}.ontario-header-button--with-outline:focus,.ontario-header-button--without-outline:focus{background-color:#4d4d4d}.ontario-header-button--with-outline{border:2px solid #FFFFFF;margin:0 0 0 1rem;padding:0.375rem 1rem}.ontario-header-button--with-outline:hover{border:2px solid #FFFFFF;color:#FFFFFF}.ontario-header-button--with-outline:focus{background-color:#4d4d4d}@media screen and (max-width: 20em){.ontario-header-button--with-outline{padding:0.375rem}}.ontario-header__menu-toggler{padding:0.375rem 1rem}@media screen and (max-width: 20em){.ontario-header__menu-toggler{padding-left:0.5rem;padding-right:0.5rem}}.ontario-header__menu-toggler span{display:flex}@media screen and (max-width: 20em){.ontario-header__menu-toggler span{display:none}}.ontario-header__menu-toggler svg{margin-right:6px}@media screen and (max-width: 20em){.ontario-header__menu-toggler svg{margin-right:0}}.ontario-application-navigation__container{background:#FFFFFF;position:absolute;transform:translateY(-100%);transition:transform 0.3s ease-in-out, visibility 0.1s ease;width:100%;visibility:hidden;z-index:4}@media screen and (min-width: 73em){.ontario-application-navigation__container{box-shadow:0 4px 12px rgba(0, 0, 0, 0.3);border-radius:4px;display:none;position:absolute;right:1rem;top:calc(100% - 0.5rem);min-width:290px;max-width:30%;z-index:5}}.ontario-application-navigation.ontario-navigation--open .ontario-application-navigation__container{background:#FFFFFF;visibility:visible;transform:translateY(0);transition:transform 0.4s ease-in-out}@media screen and (min-width: 73em){.ontario-application-navigation.ontario-navigation--open .ontario-application-navigation__container{transition:none;display:block}}.ontario-application-navigation.ontario-navigation--open{background:#FFFFFF;z-index:4}.ontario-application-navigation ul{list-style:none;padding:0.5rem 0;margin:0;border-bottom:1px solid #cccccc}@media screen and (min-width: 73em){.ontario-application-navigation ul{border-bottom:none}}.ontario-application-navigation li{border-top:1px solid #cccccc;padding:0;margin-bottom:0}.ontario-application-navigation li:last-of-type{border-bottom:1px solid #cccccc}.ontario-application-navigation a{color:#1a1a1a;display:block;font-size:1.125rem;font-weight:600;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;text-decoration:none;padding:0.6730769231rem 1.5rem}.ontario-application-navigation a:hover{text-decoration:underline;background-color:#e5e5e5}.ontario-application-navigation a:active{text-decoration:underline;background-color:#cccccc}.ontario-application-navigation a:focus,.ontario-application-navigation a:active{box-shadow:0 0 0 4px #009ADB inset}.ontario-application-navigation a.ontario-link--active{border-left:6px solid #1a1a1a;background-color:#f2f2f2}.ontario-overlay{position:fixed;top:0;left:0;background:rgba(0, 0, 0, 0.6);width:100%;height:100%;z-index:2}.ontario-header__icon-container{display:flex;align-items:center}';

		const ontarioHeaderCss =
			'.ontario-navigation a:focus,.ontario-navigation a:active,.ontario-header-button:focus,.ontario-input:focus,.ontario-input:active{box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:box-shadow 0.1s ease-in-out}.ontario-row{margin:0 auto;max-width:72rem;width:100%}.ontario-row:before,.ontario-row:after{content:"";display:table}.ontario-row:after{clear:both}.ontario-row.ontario-row--collapse>.ontario-column,.ontario-row.ontario-row--collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-row--collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row .ontario-row{margin:0 -1rem;max-width:none;width:auto}.ontario-row .ontario-row:before,.ontario-row .ontario-row:after{content:"";display:table}.ontario-row .ontario-row:after{clear:both}.ontario-row .ontario-row.ontario-row--collapse{margin:0;max-width:none;width:auto}.ontario-row .ontario-row.ontario-row--collapse:before,.ontario-row .ontario-row.ontario-row--collapse:after{content:"";display:table}.ontario-row .ontario-row.ontario-row--collapse:after{clear:both}.ontario-column,.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;width:100%;float:left}.ontario-column+.ontario-column:last-child,.ontario-column+.ontario-columns:last-child,.ontario-columns+.ontario-column:last-child,.ontario-columns+.ontario-columns:last-child{float:right}.ontario-column+.ontario-column.ontario-end,.ontario-column+.ontario-columns.ontario-end,.ontario-columns+.ontario-column.ontario-end,.ontario-columns+.ontario-columns.ontario-end{float:left}@media only screen{.ontario-small-push-0{position:relative;left:0;right:auto}.ontario-small-pull-0{position:relative;right:0;left:auto}.ontario-small-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-small-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-small-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-small-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-small-push-3{position:relative;left:25%;right:auto}.ontario-small-pull-3{position:relative;right:25%;left:auto}.ontario-small-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-small-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-small-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-small-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-small-push-6{position:relative;left:50%;right:auto}.ontario-small-pull-6{position:relative;right:50%;left:auto}.ontario-small-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-small-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-small-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-small-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-small-push-9{position:relative;left:75%;right:auto}.ontario-small-pull-9{position:relative;right:75%;left:auto}.ontario-small-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-small-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-small-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-small-pull-11{position:relative;right:91.6666666667%;left:auto}.ontario-column,.ontario-columns{position:relative;padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-small-1{width:8.3333333333%}.ontario-small-2{width:16.6666666667%}.ontario-small-3{width:25%}.ontario-small-4{width:33.3333333333%}.ontario-small-5{width:41.6666666667%}.ontario-small-6{width:50%}.ontario-small-7{width:58.3333333333%}.ontario-small-8{width:66.6666666667%}.ontario-small-9{width:75%}.ontario-small-10{width:83.3333333333%}.ontario-small-11{width:91.6666666667%}.ontario-small-12{width:100%}.ontario-small-offset-0{margin-left:0 !important}.ontario-small-offset-1{margin-left:8.3333333333% !important}.ontario-small-offset-2{margin-left:16.6666666667% !important}.ontario-small-offset-3{margin-left:25% !important}.ontario-small-offset-4{margin-left:33.3333333333% !important}.ontario-small-offset-5{margin-left:41.6666666667% !important}.ontario-small-offset-6{margin-left:50% !important}.ontario-small-offset-7{margin-left:58.3333333333% !important}.ontario-small-offset-8{margin-left:66.6666666667% !important}.ontario-small-offset-9{margin-left:75% !important}.ontario-small-offset-10{margin-left:83.3333333333% !important}.ontario-small-offset-11{margin-left:91.6666666667% !important}.ontario-small-reset-order{float:left;left:auto;margin-left:0;margin-right:0;right:auto}.ontario-column.ontario-small-centered,.ontario-columns.ontario-small-centered{margin-left:auto;margin-right:auto;float:none}.ontario-column.ontario-small-uncentered,.ontario-columns.ontario-small-uncentered{float:left;margin-left:0;margin-right:0}.ontario-column.ontario-small-centered:last-child,.ontario-columns.ontario-small-centered:last-child{float:none}.ontario-column.ontario-small-uncentered:last-child,.ontario-columns.ontario-small-uncentered:last-child{float:left}.ontario-column.ontario-small-uncentered.ontario-opposite,.ontario-columns.ontario-small-uncentered.ontario-opposite{float:right}.ontario-row.ontario-small-collapse>.ontario-column,.ontario-row.ontario-small-collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-small-collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row.ontario-small-uncollapse>.ontario-column,.ontario-row.ontario-small-uncollapse>.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}}@media only screen and (min-width:40.063em){.ontario-medium-push-0{position:relative;left:0;right:auto}.ontario-medium-pull-0{position:relative;right:0;left:auto}.ontario-medium-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-medium-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-medium-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-medium-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-medium-push-3{position:relative;left:25%;right:auto}.ontario-medium-pull-3{position:relative;right:25%;left:auto}.ontario-medium-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-medium-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-medium-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-medium-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-medium-push-6{position:relative;left:50%;right:auto}.ontario-medium-pull-6{position:relative;right:50%;left:auto}.ontario-medium-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-medium-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-medium-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-medium-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-medium-push-9{position:relative;left:75%;right:auto}.ontario-medium-pull-9{position:relative;right:75%;left:auto}.ontario-medium-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-medium-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-medium-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-medium-pull-11{position:relative;right:91.6666666667%;left:auto}.ontario-column,.ontario-columns{position:relative;padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-medium-1{width:8.3333333333%}.ontario-medium-2{width:16.6666666667%}.ontario-medium-3{width:25%}.ontario-medium-4{width:33.3333333333%}.ontario-medium-5{width:41.6666666667%}.ontario-medium-6{width:50%}.ontario-medium-7{width:58.3333333333%}.ontario-medium-8{width:66.6666666667%}.ontario-medium-9{width:75%}.ontario-medium-10{width:83.3333333333%}.ontario-medium-11{width:91.6666666667%}.ontario-medium-12{width:100%}.ontario-medium-offset-0{margin-left:0 !important}.ontario-medium-offset-1{margin-left:8.3333333333% !important}.ontario-medium-offset-2{margin-left:16.6666666667% !important}.ontario-medium-offset-3{margin-left:25% !important}.ontario-medium-offset-4{margin-left:33.3333333333% !important}.ontario-medium-offset-5{margin-left:41.6666666667% !important}.ontario-medium-offset-6{margin-left:50% !important}.ontario-medium-offset-7{margin-left:58.3333333333% !important}.ontario-medium-offset-8{margin-left:66.6666666667% !important}.ontario-medium-offset-9{margin-left:75% !important}.ontario-medium-offset-10{margin-left:83.3333333333% !important}.ontario-medium-offset-11{margin-left:91.6666666667% !important}.ontario-medium-reset-order{float:left;left:auto;margin-left:0;margin-right:0;right:auto}.ontario-column.ontario-medium-centered,.ontario-columns.ontario-medium-centered{margin-left:auto;margin-right:auto;float:none}.ontario-column.ontario-medium-uncentered,.ontario-columns.ontario-medium-uncentered{float:left;margin-left:0;margin-right:0}.ontario-column.ontario-medium-centered:last-child,.ontario-columns.ontario-medium-centered:last-child{float:none}.ontario-column.ontario-medium-uncentered:last-child,.ontario-columns.ontario-medium-uncentered:last-child{float:left}.ontario-column.ontario-medium-uncentered.ontario-opposite,.ontario-columns.ontario-medium-uncentered.ontario-opposite{float:right}.ontario-row.ontario-medium-collapse>.ontario-column,.ontario-row.ontario-medium-collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-medium-collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row.ontario-medium-uncollapse>.ontario-column,.ontario-row.ontario-medium-uncollapse>.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}}@media only screen and (min-width:73.063em){.ontario-large-push-0{position:relative;left:0;right:auto}.ontario-large-pull-0{position:relative;right:0;left:auto}.ontario-large-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-large-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-large-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-large-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-large-push-3{position:relative;left:25%;right:auto}.ontario-large-pull-3{position:relative;right:25%;left:auto}.ontario-large-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-large-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-large-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-large-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-large-push-6{position:relative;left:50%;right:auto}.ontario-large-pull-6{position:relative;right:50%;left:auto}.ontario-large-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-large-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-large-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-large-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-large-push-9{position:relative;left:75%;right:auto}.ontario-large-pull-9{position:relative;right:75%;left:auto}.ontario-large-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-large-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-large-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-large-pull-11{position:relative;right:91.6666666667%;left:auto}.ontario-column,.ontario-columns{position:relative;padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-large-1{width:8.3333333333%}.ontario-large-2{width:16.6666666667%}.ontario-large-3{width:25%}.ontario-large-4{width:33.3333333333%}.ontario-large-5{width:41.6666666667%}.ontario-large-6{width:50%}.ontario-large-7{width:58.3333333333%}.ontario-large-8{width:66.6666666667%}.ontario-large-9{width:75%}.ontario-large-10{width:83.3333333333%}.ontario-large-11{width:91.6666666667%}.ontario-large-12{width:100%}.ontario-large-offset-0{margin-left:0 !important}.ontario-large-offset-1{margin-left:8.3333333333% !important}.ontario-large-offset-2{margin-left:16.6666666667% !important}.ontario-large-offset-3{margin-left:25% !important}.ontario-large-offset-4{margin-left:33.3333333333% !important}.ontario-large-offset-5{margin-left:41.6666666667% !important}.ontario-large-offset-6{margin-left:50% !important}.ontario-large-offset-7{margin-left:58.3333333333% !important}.ontario-large-offset-8{margin-left:66.6666666667% !important}.ontario-large-offset-9{margin-left:75% !important}.ontario-large-offset-10{margin-left:83.3333333333% !important}.ontario-large-offset-11{margin-left:91.6666666667% !important}.ontario-large-reset-order{float:left;left:auto;margin-left:0;margin-right:0;right:auto}.ontario-column.ontario-large-centered,.ontario-columns.ontario-large-centered{margin-left:auto;margin-right:auto;float:none}.ontario-column.ontario-large-uncentered,.ontario-columns.ontario-large-uncentered{float:left;margin-left:0;margin-right:0}.ontario-column.ontario-large-centered:last-child,.ontario-columns.ontario-large-centered:last-child{float:none}.ontario-column.ontario-large-uncentered:last-child,.ontario-columns.ontario-large-uncentered:last-child{float:left}.ontario-column.ontario-large-uncentered.ontario-opposite,.ontario-columns.ontario-large-uncentered.ontario-opposite{float:right}.ontario-row.ontario-large-collapse>.ontario-column,.ontario-row.ontario-large-collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-large-collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row.ontario-large-uncollapse>.ontario-column,.ontario-row.ontario-large-uncollapse>.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-push-0{position:relative;left:0;right:auto}.ontario-pull-0{position:relative;right:0;left:auto}.ontario-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-push-3{position:relative;left:25%;right:auto}.ontario-pull-3{position:relative;right:25%;left:auto}.ontario-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-push-6{position:relative;left:50%;right:auto}.ontario-pull-6{position:relative;right:50%;left:auto}.ontario-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-push-9{position:relative;left:75%;right:auto}.ontario-pull-9{position:relative;right:75%;left:auto}.ontario-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-pull-11{position:relative;right:91.6666666667%;left:auto}}@media only screen and (min-width:96.063em){.ontario-xlarge-push-0{position:relative;left:0;right:auto}.ontario-xlarge-pull-0{position:relative;right:0;left:auto}.ontario-xlarge-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-xlarge-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-xlarge-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-xlarge-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-xlarge-push-3{position:relative;left:25%;right:auto}.ontario-xlarge-pull-3{position:relative;right:25%;left:auto}.ontario-xlarge-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-xlarge-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-xlarge-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-xlarge-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-xlarge-push-6{position:relative;left:50%;right:auto}.ontario-xlarge-pull-6{position:relative;right:50%;left:auto}.ontario-xlarge-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-xlarge-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-xlarge-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-xlarge-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-xlarge-push-9{position:relative;left:75%;right:auto}.ontario-xlarge-pull-9{position:relative;right:75%;left:auto}.ontario-xlarge-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-xlarge-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-xlarge-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-xlarge-pull-11{position:relative;right:91.6666666667%;left:auto}.ontario-column,.ontario-columns{position:relative;padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-xlarge-1{width:8.3333333333%}.ontario-xlarge-2{width:16.6666666667%}.ontario-xlarge-3{width:25%}.ontario-xlarge-4{width:33.3333333333%}.ontario-xlarge-5{width:41.6666666667%}.ontario-xlarge-6{width:50%}.ontario-xlarge-7{width:58.3333333333%}.ontario-xlarge-8{width:66.6666666667%}.ontario-xlarge-9{width:75%}.ontario-xlarge-10{width:83.3333333333%}.ontario-xlarge-11{width:91.6666666667%}.ontario-xlarge-12{width:100%}.ontario-xlarge-offset-0{margin-left:0 !important}.ontario-xlarge-offset-1{margin-left:8.3333333333% !important}.ontario-xlarge-offset-2{margin-left:16.6666666667% !important}.ontario-xlarge-offset-3{margin-left:25% !important}.ontario-xlarge-offset-4{margin-left:33.3333333333% !important}.ontario-xlarge-offset-5{margin-left:41.6666666667% !important}.ontario-xlarge-offset-6{margin-left:50% !important}.ontario-xlarge-offset-7{margin-left:58.3333333333% !important}.ontario-xlarge-offset-8{margin-left:66.6666666667% !important}.ontario-xlarge-offset-9{margin-left:75% !important}.ontario-xlarge-offset-10{margin-left:83.3333333333% !important}.ontario-xlarge-offset-11{margin-left:91.6666666667% !important}.ontario-xlarge-reset-order{float:left;left:auto;margin-left:0;margin-right:0;right:auto}.ontario-column.ontario-xlarge-centered,.ontario-columns.ontario-xlarge-centered{margin-left:auto;margin-right:auto;float:none}.ontario-column.ontario-xlarge-uncentered,.ontario-columns.ontario-xlarge-uncentered{float:left;margin-left:0;margin-right:0}.ontario-column.ontario-xlarge-centered:last-child,.ontario-columns.ontario-xlarge-centered:last-child{float:none}.ontario-column.ontario-xlarge-uncentered:last-child,.ontario-columns.ontario-xlarge-uncentered:last-child{float:left}.ontario-column.ontario-xlarge-uncentered.ontario-opposite,.ontario-columns.ontario-xlarge-uncentered.ontario-opposite{float:right}.ontario-row.ontario-xlarge-collapse>.ontario-column,.ontario-row.ontario-xlarge-collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-xlarge-collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row.ontario-xlarge-uncollapse>.ontario-column,.ontario-row.ontario-xlarge-uncollapse>.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}}@media only screen and (min-width:120.063em){.ontario-xxlarge-push-0{position:relative;left:0;right:auto}.ontario-xxlarge-pull-0{position:relative;right:0;left:auto}.ontario-xxlarge-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-xxlarge-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-xxlarge-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-xxlarge-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-xxlarge-push-3{position:relative;left:25%;right:auto}.ontario-xxlarge-pull-3{position:relative;right:25%;left:auto}.ontario-xxlarge-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-xxlarge-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-xxlarge-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-xxlarge-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-xxlarge-push-6{position:relative;left:50%;right:auto}.ontario-xxlarge-pull-6{position:relative;right:50%;left:auto}.ontario-xxlarge-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-xxlarge-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-xxlarge-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-xxlarge-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-xxlarge-push-9{position:relative;left:75%;right:auto}.ontario-xxlarge-pull-9{position:relative;right:75%;left:auto}.ontario-xxlarge-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-xxlarge-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-xxlarge-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-xxlarge-pull-11{position:relative;right:91.6666666667%;left:auto}.ontario-column,.ontario-columns{position:relative;padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-xxlarge-1{width:8.3333333333%}.ontario-xxlarge-2{width:16.6666666667%}.ontario-xxlarge-3{width:25%}.ontario-xxlarge-4{width:33.3333333333%}.ontario-xxlarge-5{width:41.6666666667%}.ontario-xxlarge-6{width:50%}.ontario-xxlarge-7{width:58.3333333333%}.ontario-xxlarge-8{width:66.6666666667%}.ontario-xxlarge-9{width:75%}.ontario-xxlarge-10{width:83.3333333333%}.ontario-xxlarge-11{width:91.6666666667%}.ontario-xxlarge-12{width:100%}.ontario-xxlarge-offset-0{margin-left:0 !important}.ontario-xxlarge-offset-1{margin-left:8.3333333333% !important}.ontario-xxlarge-offset-2{margin-left:16.6666666667% !important}.ontario-xxlarge-offset-3{margin-left:25% !important}.ontario-xxlarge-offset-4{margin-left:33.3333333333% !important}.ontario-xxlarge-offset-5{margin-left:41.6666666667% !important}.ontario-xxlarge-offset-6{margin-left:50% !important}.ontario-xxlarge-offset-7{margin-left:58.3333333333% !important}.ontario-xxlarge-offset-8{margin-left:66.6666666667% !important}.ontario-xxlarge-offset-9{margin-left:75% !important}.ontario-xxlarge-offset-10{margin-left:83.3333333333% !important}.ontario-xxlarge-offset-11{margin-left:91.6666666667% !important}.ontario-xxlarge-reset-order{float:left;left:auto;margin-left:0;margin-right:0;right:auto}.ontario-column.ontario-xxlarge-centered,.ontario-columns.ontario-xxlarge-centered{margin-left:auto;margin-right:auto;float:none}.ontario-column.ontario-xxlarge-uncentered,.ontario-columns.ontario-xxlarge-uncentered{float:left;margin-left:0;margin-right:0}.ontario-column.ontario-xxlarge-centered:last-child,.ontario-columns.ontario-xxlarge-centered:last-child{float:none}.ontario-column.ontario-xxlarge-uncentered:last-child,.ontario-columns.ontario-xxlarge-uncentered:last-child{float:left}.ontario-column.ontario-xxlarge-uncentered.ontario-opposite,.ontario-columns.ontario-xxlarge-uncentered.ontario-opposite{float:right}.ontario-row.ontario-xxlarge-collapse>.ontario-column,.ontario-row.ontario-xxlarge-collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-xxlarge-collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row.ontario-xxlarge-uncollapse>.ontario-column,.ontario-row.ontario-xxlarge-uncollapse>.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}}.ontario-input{border:2px solid #1a1a1a;border-radius:4px;box-sizing:border-box;color:#1a1a1a;display:block;font-size:1rem;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;line-height:1.5;margin:0 0 2.5rem;max-width:48rem;width:100%;padding:0.625rem 1rem;transition:box-shadow 0.1s ease-in-out}.ontario-input--2-char-width{max-width:8ex}.ontario-input--3-char-width{max-width:10ex}.ontario-input--4-char-width{max-width:12ex}.ontario-input--5-char-width{max-width:14ex}.ontario-input--7-char-width{max-width:17ex}.ontario-input--10-char-width{max-width:23ex}.ontario-input--20-char-width{max-width:41ex}.ontario-form-group:last-of-type{margin-bottom:2.5rem}.ontario-hide{display:none !important}.ontario-invisible{visibility:hidden !important}@media screen and (max-width: 39.99875em){.ontario-hide-for-small-only{display:none !important}}@media screen and (max-width: 0em), screen and (min-width: 40em){.ontario-show-for-small-only{display:none !important}}@media print, screen and (min-width: 40em){.ontario-hide-for-medium{display:none !important}}@media screen and (max-width: 39.99875em){.ontario-show-for-medium{display:none !important}}@media screen and (min-width: 40em) and (max-width: 72.99875em){.ontario-hide-for-medium-only{display:none !important}}@media screen and (max-width: 39.99875em), screen and (min-width: 73em){.ontario-show-for-medium-only{display:none !important}}@media print, screen and (min-width: 73em){.ontario-hide-for-large{display:none !important}}@media screen and (max-width: 72.99875em){.ontario-show-for-large{display:none !important}}@media screen and (min-width: 73em) and (max-width: 95.99875em){.ontario-hide-for-large-only{display:none !important}}@media screen and (max-width: 72.99875em), screen and (min-width: 96em){.ontario-show-for-large-only{display:none !important}}.ontario-show-for-sr,.ontario-show-on-focus{position:absolute;width:1px;height:1px;overflow:hidden;clip:rect(0, 0, 0, 0)}.ontario-show-on-focus:active,.ontario-show-on-focus:focus{position:static;width:auto;height:auto;overflow:visible;clip:auto}.ontario-show-for-landscape,.ontario-hide-for-portrait{display:block !important}@media screen and (orientation: landscape){.ontario-show-for-landscape,.ontario-hide-for-portrait{display:block !important}}@media screen and (orientation: portrait){.ontario-show-for-landscape,.ontario-hide-for-portrait{display:none !important}}.ontario-hide-for-landscape,.ontario-show-for-portrait{display:none !important}@media screen and (orientation: landscape){.ontario-hide-for-landscape,.ontario-show-for-portrait{display:none !important}}@media screen and (orientation: portrait){.ontario-hide-for-landscape,.ontario-show-for-portrait{display:block !important}}:host{--header-search-reset:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgZmlsbD0ibm9uZSI+PHBhdGggZD0iTTE5IDYuNEwxNy42IDUgMTIgMTAuNiA2LjQgNSA1IDYuNGw1LjYgNS42TDUgMTcuNiA2LjQgMTlsNS42LTUuNiA1LjYgNS42IDEuNC0xLjQtNS42LTUuNkwxOSA2LjR6IiBmaWxsPSIjMDAwIi8+PC9zdmc+)}.ontario-header__container{position:relative;z-index:5}@media screen and (min-width: 73em){.ontario-header__container{z-index:1}}.ontario-icon-container{display:flex;align-items:center}.ontario-icon-container-reset{display:flex;align-items:center}.ontario-icon-container-reset svg{fill:#1a1a1a}.ontario-subheader__menu a{border-radius:4px;color:#FFFFFF;display:inline;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1.125rem;font-weight:600;height:48px;line-height:1.4375rem;padding:0.75rem 1rem;text-decoration:none;white-space:nowrap}.ontario-subheader__menu a.ontario-link--active{border-radius:4px 4px 0 0;border-bottom:4px solid #FFFFFF}.ontario-subheader__menu a:hover{background-color:#666666;color:#FFFFFF}.ontario-subheader__menu a:active{background-color:#1a1a1a}.ontario-subheader__menu a:focus{box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:all 0.1s ease-in-out}.ontario-navigation{position:absolute;width:100%}@media screen and (min-width: 73em){.ontario-navigation{position:relative;max-width:72rem;width:auto;margin:0 auto}}.nav-ul-closed{background:white;position:absolute;transform:translateY(-100%);transition:transform 0.3s ease-in-out, visibility 0.1s ease;width:100%;visibility:hidden;z-index:4}.nav-ul-opened{visibility:visible;transform:translateY(0);transition:transform 0.4s ease-in-out}@media screen and (min-width: 73em){.nav-ul-opened{z-index:5}}.ontario-navigation ul{list-style:none;padding:0.5rem 0;margin:0;border-bottom:1px solid #cccccc}@media screen and (min-width: 73em){.ontario-navigation ul{border-bottom:none}}.ontario-navigation li{border-top:1px solid #cccccc;padding:0;margin-bottom:0}.ontario-navigation li:last-of-type{border-bottom:1px solid #cccccc}.ontario-navigation a{color:#1a1a1a;display:block;font-size:1.125rem;font-weight:600;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;text-decoration:none;padding:0.6730769231rem 1.5rem}.ontario-navigation a:hover{text-decoration:underline;background-color:#e6e6e6}.ontario-navigation a:active{text-decoration:underline;background-color:#cccccc}.ontario-navigation a:focus,.ontario-navigation a:active{box-shadow:0 0 0 4px #009ADB inset}.ontario-navigation a.ontario-link--active{border-left:6px solid #1a1a1a;background-color:#f2f2f2}.ontario-overlay{position:fixed;top:0;left:0;background:rgba(0, 0, 0, 0.6);width:100%;height:100%;z-index:2}.ontario-header{position:relative;overflow:hidden;z-index:5;background-color:#1a1a1a;color:#FFFFFF;display:flex;align-items:center;height:5.75rem}.ontario-header .ontario-row{display:flex;align-items:center;justify-content:flex-end}.ontario-header svg{width:2rem;height:2rem;margin-bottom:0}.ontario-header__logo-container a{display:inline-flex;height:100%;outline:none}.ontario-header__logo-container a:focus{box-shadow:0 0 0 4px #009ADB}.ontario-header__logo-container a img{width:45px;height:46px}@media screen and (min-width: 40em){.ontario-header__logo-container a img{width:180px;height:46px}}.ontario-navigation__container.ontario-navigation--open{visibility:visible;transform:translateY(0);transition:transform 0.4s ease-in-out}@media screen and (min-width: 73em){.ontario-navigation__container.ontario-navigation--open{z-index:5}}.ontario-navigation__container.ontario-navigation--closed{background:#FFFFFF;position:absolute;transform:translateY(-100%);transition:transform 0.3s ease-in-out, visibility 0.1s ease;width:100%;visibility:hidden;z-index:4}.ontario-header-button.ontario-navigation--open:hover{background-color:#666666}.ontario-header-button.ontario-navigation--open:active{background-color:#1a1a1a}.ontario-header-button.ontario-navigation--closed:active{background-color:#1a1a1a}.ontario-header__logo-container{height:46px}.ontario-header__logo-container svg{width:45px;height:46px}@media screen and (min-width: 40em){.ontario-header__logo-container svg{width:180px;height:46px}}.ontario-header__logo-container a{display:inline-block;height:100%}.ontario-header__logo-container a:focus{box-shadow:0 0 0 4px #009ADB}.ontario-header__search-container{position:relative;display:none}@media screen and (min-width: 73em){.ontario-header__search-container{display:flex}}@media screen and (min-width: 40em){.ontario-header__search-container{padding-right:1rem}}.ontario-input.ontario-header__search-input{border-width:0;margin-bottom:0;height:48px;padding-left:0.75rem;padding-right:7.2rem}.ontario-input.ontario-header__search-input:invalid+input[type=reset]{display:none}.ontario-input.ontario-header__search-input:focus~.ontario-header__search-submit{background-color:#0066CC;color:#FFFFFF}.ontario-input.ontario-header__search-input:focus~.ontario-header__search-submit svg{fill:#FFFFFF}.ontario-input.ontario-header__search-input:focus~.ontario-header__search-submit:hover{background-color:#00478F;color:#FFFFFF}.ontario-input.ontario-header__search-input::-ms-clear{display:none;width:0;height:0}.ontario-input.ontario-header__search-input:invalid:focus{box-shadow:0 0 0 4px #009ADB;-moz-box-shadow:none}.ontario-input.ontario-header__search-input:invalid:not(:focus){box-shadow:none;-moz-box-shadow:none}@media screen and (min-width: 40em) and (max-width: 73em){.ontario-input.ontario-header__search-input{padding-left:1rem;padding-right:6.4rem}}.ontario-header__search-submit{border:0;border-radius:0 3px 3px 0;background-color:#f2f2f2;color:#1a1a1a;display:flex;justify-content:center;align-items:center;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-weight:600;font-size:1.125rem;height:100%;line-height:1.56;position:absolute;right:1rem;top:0;cursor:pointer;padding-left:0.75rem;padding-right:0.75rem}.ontario-header__search-submit svg{fill:#1a1a1a}.ontario-header__search-submit:hover{background-color:#00478F;color:#FFFFFF}.ontario-header__search-submit:hover svg{fill:#FFFFFF}.ontario-header__search-submit:focus{outline:none;box-shadow:0 0 0 4px #009ADB;background-color:#00478F;color:#FFFFFF}.ontario-header__search-submit:focus svg{fill:#FFFFFF}.ontario-header__search-submit:active{background-color:#002142;color:#FFFFFF}.ontario-header__search-submit:active svg{fill:#FFFFFF}.ontario-header__search-submit svg{margin-right:0}input[type=reset].ontario-header__search-reset{position:absolute;display:flex;align-items:center;top:11px;right:80px;height:28px;width:28px;color:#1a1a1a;margin:0;padding:0.5rem;background-image:var(--header-search-reset);background-position:center center;background-repeat:no-repeat;background-color:transparent;outline:none;border:none;cursor:pointer}input[type=reset].ontario-header__search-reset:focus{box-shadow:0 0 0 4px #009ADB}.ontario-header__nav-right-container{display:flex;align-items:center;justify-content:flex-end}.ontario-header-button{background-color:#1a1a1a;border:none;border-radius:4px;box-sizing:border-box;box-shadow:none;color:#FFFFFF;cursor:pointer;display:flex;align-items:center;font-size:1.125rem;font-weight:600;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;height:48px;line-height:1.5555555556;text-align:center;text-decoration:none}.ontario-header-button:hover,.ontario-header-button:focus,.ontario-header-button:visited{color:#FFFFFF}.ontario-header-button--with-outline,.ontario-header-button--without-outline{background-color:#1a1a1a;color:#FFFFFF}.ontario-header-button--with-outline:hover,.ontario-header-button--without-outline:hover{background-color:#4d4d4d}.ontario-header-button--with-outline:active,.ontario-header-button--without-outline:active{background-color:#666666}.ontario-header-button--with-outline:focus,.ontario-header-button--without-outline:focus{background-color:#4d4d4d}.ontario-header-button--with-outline:active,.ontario-header-button--without-outline:active{background-color:#666666}.ontario-header-button--with-outline{border:2px solid #FFFFFF;margin:0 0 0 1rem;padding:0.375rem 1rem}.ontario-header-button--with-outline:hover{border:2px solid #FFFFFF;color:#FFFFFF}.ontario-header-button--with-outline:focus{background-color:#4d4d4d}@media screen and (max-width: 20em){.ontario-header-button--with-outline{padding:0.375rem}}.ontario-header-button--without-outline:focus{background-color:#4d4d4d}.ontario-header__menu-toggler{padding:0.375rem 1rem}@media screen and (max-width: 20em){.ontario-header__menu-toggler{padding-left:0.5rem;padding-right:0.5rem}}.ontario-header__menu-toggler span{display:flex}@media screen and (max-width: 20em){.ontario-header__menu-toggler span{display:none}}.ontario-header__menu-toggler svg{margin-right:6px}@media screen and (max-width: 20em){.ontario-header__menu-toggler svg{margin-right:0}}.ontario-header__language-toggler{padding:0.75rem}.ontario-header__language-toggler abbr[title]{text-decoration:none}.ontario-header__search-toggler{padding:0.5rem 0.75rem;margin-left:1rem}@media screen and (min-width: 40em){.ontario-header__search-toggler svg{margin-right:0.25rem}}.ontario-header__search-close{flex-direction:column-reverse;font-weight:400;margin-right:1rem;padding:0.15rem 0.25rem;position:relative;height:60px;display:none}.ontario-header__search-close span{position:relative;top:-3px;font-size:1rem;margin-left:0}.ontario-header__search-close span:last-of-type{top:0;height:1.875rem}@media screen and (min-width: 39.9375em){.ontario-header__search-close span{margin-right:0.25rem}}.ontario-header__search-close span:hover,.ontario-header__search-close span:focus{outline:none;text-decoration:none}.ontario-header__search-close svg{top:0}@media screen and (min-width: 40em){.ontario-header__search-close{flex-direction:row;padding:0.25rem 0.5rem 0.25rem 1rem;height:48px}.ontario-header__search-close span{top:0}.ontario-header__search-close svg{position:relative;width:2.5rem;height:2.5rem}}@media screen and (min-width: 73em){.ontario-header--search-open .ontario-header__search-close{display:none}}.ontario-header__search-close-container{display:none;justify-content:flex-end;padding-right:0}@media screen and (max-width: 40em){.ontario-header__search-close-container{width:auto;padding-left:0;padding-right:0}}@media screen and (max-width: 73em){.ontario-header--search-open .ontario-header__logo-container,.ontario-header--search-open .ontario-header__nav-right-container{display:none}.ontario-header--search-open .ontario-header__search-close-container,.ontario-header--search-open .ontario-header__search-container,.ontario-header--search-open .ontario-header__search-close{display:flex}}.ontario-navigation{position:absolute;width:100%}@media screen and (min-width: 73em){.ontario-navigation{position:relative;max-width:72rem;width:auto;margin:0 auto}}.ontario-navigation__container{background:#FFFFFF;position:absolute;transform:translateY(-100%);transition:transform 0.3s ease-in-out, visibility 0.1s ease;width:100%;visibility:hidden;z-index:4}@media screen and (min-width: 73em){.ontario-navigation__container{box-shadow:0 4px 12px rgba(0, 0, 0, 0.3);border-radius:4px;display:none;position:absolute;right:1rem;top:calc(100% - 0.5rem);min-width:290px;max-width:30%;z-index:5}}.ontario-navigation ul{list-style:none;padding:0.5rem 0;margin:0;border-bottom:1px solid #cccccc}@media screen and (min-width: 73em){.ontario-navigation ul{border-bottom:none}}.ontario-header-navigation__menu-item{border-top:1px solid #cccccc;padding:0;margin-bottom:0}.ontario-header-navigation__menu-item:last-of-type{border-bottom:1px solid #cccccc}.ontario-navigation a{color:#1a1a1a;display:block;font-size:1.125rem;font-weight:600;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;text-decoration:none;padding:0.6730769231rem 1.5rem}.ontario-navigation a:hover{text-decoration:underline;background-color:#e6e6e6}.ontario-navigation a:active{text-decoration:underline;background-color:#cccccc}.ontario-navigation a:focus,.ontario-navigation a:active{box-shadow:0 0 0 4px #009ADB inset}.ontario-navigation a.ontario-link--active{border-left:6px solid #1a1a1a;background-color:#f2f2f2}.ontario-navigation.ontario-navigation--open .ontario-navigation__container{visibility:visible;transform:translateY(0);transition:transform 0.4s ease-in-out}@media screen and (min-width: 73em){.ontario-navigation.ontario-navigation--open .ontario-navigation__container{transition:none;display:block}}.ontario-overlay{position:fixed;top:0;left:0;background:rgba(0, 0, 0, 0.6);width:100%;height:100%;z-index:2}.ontario-header__icon-container{display:flex;align-items:center}.ontario-navigation .ontario-header-button{visibility:hidden;position:absolute;right:1rem;z-index:6}.ontario-navigation .ontario-header-button svg{width:2rem;height:2rem;margin-bottom:0}.ontario-navigation--open .ontario-navigation .ontario-header-button{visibility:visible}.ontario-header+.ontario-navigation .ontario-header-button{top:-4.35rem}';

		const serviceOntarioServiceOntarioHeaderCss =
			'.ontario-service-subheader__description,.ontario-application-subheader__heading,.ontario-service-subheader__heading{font-style:normal;font-weight:700;text-rendering:optimizeLegibility;margin-bottom:1rem;font-feature-settings:normal;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif}.ontario-service-subheader__heading{font-size:1.4375rem;letter-spacing:0.02rem;line-height:1.39;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){.ontario-service-subheader__heading{font-size:1.75rem;letter-spacing:0.02rem;line-height:1.43}}.ontario-application-subheader__heading{font-size:1.25rem;letter-spacing:0.03rem;line-height:1.5;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){.ontario-application-subheader__heading{font-size:1.5rem;letter-spacing:0.0313rem;line-height:1.5}}.ontario-service-subheader__description{font-size:1.125rem;letter-spacing:0.03rem;line-height:1.56;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){.ontario-service-subheader__description{font-size:1.1875rem;letter-spacing:0.025rem;line-height:1.5}}.ontario-application-navigation a:focus,.ontario-application-navigation a:active,.ontario-header-button:focus,.ontario-input:focus,.ontario-input:active{box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:box-shadow 0.1s ease-in-out}.ontario-row{margin:0 auto;max-width:72rem;width:100%}.ontario-row:before,.ontario-row:after{content:"";display:table}.ontario-row:after{clear:both}.ontario-row.ontario-row--collapse>.ontario-column,.ontario-row.ontario-row--collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-row--collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row .ontario-row{margin:0 -1rem;max-width:none;width:auto}.ontario-row .ontario-row:before,.ontario-row .ontario-row:after{content:"";display:table}.ontario-row .ontario-row:after{clear:both}.ontario-row .ontario-row.ontario-row--collapse{margin:0;max-width:none;width:auto}.ontario-row .ontario-row.ontario-row--collapse:before,.ontario-row .ontario-row.ontario-row--collapse:after{content:"";display:table}.ontario-row .ontario-row.ontario-row--collapse:after{clear:both}.ontario-column,.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;width:100%;float:left}.ontario-column+.ontario-column:last-child,.ontario-column+.ontario-columns:last-child,.ontario-columns+.ontario-column:last-child,.ontario-columns+.ontario-columns:last-child{float:right}.ontario-column+.ontario-column.ontario-end,.ontario-column+.ontario-columns.ontario-end,.ontario-columns+.ontario-column.ontario-end,.ontario-columns+.ontario-columns.ontario-end{float:left}@media only screen{.ontario-small-push-0{position:relative;left:0;right:auto}.ontario-small-pull-0{position:relative;right:0;left:auto}.ontario-small-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-small-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-small-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-small-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-small-push-3{position:relative;left:25%;right:auto}.ontario-small-pull-3{position:relative;right:25%;left:auto}.ontario-small-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-small-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-small-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-small-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-small-push-6{position:relative;left:50%;right:auto}.ontario-small-pull-6{position:relative;right:50%;left:auto}.ontario-small-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-small-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-small-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-small-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-small-push-9{position:relative;left:75%;right:auto}.ontario-small-pull-9{position:relative;right:75%;left:auto}.ontario-small-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-small-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-small-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-small-pull-11{position:relative;right:91.6666666667%;left:auto}.ontario-column,.ontario-columns{position:relative;padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-small-1{width:8.3333333333%}.ontario-small-2{width:16.6666666667%}.ontario-small-3{width:25%}.ontario-small-4{width:33.3333333333%}.ontario-small-5{width:41.6666666667%}.ontario-small-6{width:50%}.ontario-small-7{width:58.3333333333%}.ontario-small-8{width:66.6666666667%}.ontario-small-9{width:75%}.ontario-small-10{width:83.3333333333%}.ontario-small-11{width:91.6666666667%}.ontario-small-12{width:100%}.ontario-small-offset-0{margin-left:0 !important}.ontario-small-offset-1{margin-left:8.3333333333% !important}.ontario-small-offset-2{margin-left:16.6666666667% !important}.ontario-small-offset-3{margin-left:25% !important}.ontario-small-offset-4{margin-left:33.3333333333% !important}.ontario-small-offset-5{margin-left:41.6666666667% !important}.ontario-small-offset-6{margin-left:50% !important}.ontario-small-offset-7{margin-left:58.3333333333% !important}.ontario-small-offset-8{margin-left:66.6666666667% !important}.ontario-small-offset-9{margin-left:75% !important}.ontario-small-offset-10{margin-left:83.3333333333% !important}.ontario-small-offset-11{margin-left:91.6666666667% !important}.ontario-small-reset-order{float:left;left:auto;margin-left:0;margin-right:0;right:auto}.ontario-column.ontario-small-centered,.ontario-columns.ontario-small-centered{margin-left:auto;margin-right:auto;float:none}.ontario-column.ontario-small-uncentered,.ontario-columns.ontario-small-uncentered{float:left;margin-left:0;margin-right:0}.ontario-column.ontario-small-centered:last-child,.ontario-columns.ontario-small-centered:last-child{float:none}.ontario-column.ontario-small-uncentered:last-child,.ontario-columns.ontario-small-uncentered:last-child{float:left}.ontario-column.ontario-small-uncentered.ontario-opposite,.ontario-columns.ontario-small-uncentered.ontario-opposite{float:right}.ontario-row.ontario-small-collapse>.ontario-column,.ontario-row.ontario-small-collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-small-collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row.ontario-small-uncollapse>.ontario-column,.ontario-row.ontario-small-uncollapse>.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}}@media only screen and (min-width:40.063em){.ontario-medium-push-0{position:relative;left:0;right:auto}.ontario-medium-pull-0{position:relative;right:0;left:auto}.ontario-medium-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-medium-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-medium-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-medium-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-medium-push-3{position:relative;left:25%;right:auto}.ontario-medium-pull-3{position:relative;right:25%;left:auto}.ontario-medium-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-medium-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-medium-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-medium-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-medium-push-6{position:relative;left:50%;right:auto}.ontario-medium-pull-6{position:relative;right:50%;left:auto}.ontario-medium-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-medium-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-medium-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-medium-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-medium-push-9{position:relative;left:75%;right:auto}.ontario-medium-pull-9{position:relative;right:75%;left:auto}.ontario-medium-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-medium-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-medium-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-medium-pull-11{position:relative;right:91.6666666667%;left:auto}.ontario-column,.ontario-columns{position:relative;padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-medium-1{width:8.3333333333%}.ontario-medium-2{width:16.6666666667%}.ontario-medium-3{width:25%}.ontario-medium-4{width:33.3333333333%}.ontario-medium-5{width:41.6666666667%}.ontario-medium-6{width:50%}.ontario-medium-7{width:58.3333333333%}.ontario-medium-8{width:66.6666666667%}.ontario-medium-9{width:75%}.ontario-medium-10{width:83.3333333333%}.ontario-medium-11{width:91.6666666667%}.ontario-medium-12{width:100%}.ontario-medium-offset-0{margin-left:0 !important}.ontario-medium-offset-1{margin-left:8.3333333333% !important}.ontario-medium-offset-2{margin-left:16.6666666667% !important}.ontario-medium-offset-3{margin-left:25% !important}.ontario-medium-offset-4{margin-left:33.3333333333% !important}.ontario-medium-offset-5{margin-left:41.6666666667% !important}.ontario-medium-offset-6{margin-left:50% !important}.ontario-medium-offset-7{margin-left:58.3333333333% !important}.ontario-medium-offset-8{margin-left:66.6666666667% !important}.ontario-medium-offset-9{margin-left:75% !important}.ontario-medium-offset-10{margin-left:83.3333333333% !important}.ontario-medium-offset-11{margin-left:91.6666666667% !important}.ontario-medium-reset-order{float:left;left:auto;margin-left:0;margin-right:0;right:auto}.ontario-column.ontario-medium-centered,.ontario-columns.ontario-medium-centered{margin-left:auto;margin-right:auto;float:none}.ontario-column.ontario-medium-uncentered,.ontario-columns.ontario-medium-uncentered{float:left;margin-left:0;margin-right:0}.ontario-column.ontario-medium-centered:last-child,.ontario-columns.ontario-medium-centered:last-child{float:none}.ontario-column.ontario-medium-uncentered:last-child,.ontario-columns.ontario-medium-uncentered:last-child{float:left}.ontario-column.ontario-medium-uncentered.ontario-opposite,.ontario-columns.ontario-medium-uncentered.ontario-opposite{float:right}.ontario-row.ontario-medium-collapse>.ontario-column,.ontario-row.ontario-medium-collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-medium-collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row.ontario-medium-uncollapse>.ontario-column,.ontario-row.ontario-medium-uncollapse>.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}}@media only screen and (min-width:73.063em){.ontario-large-push-0{position:relative;left:0;right:auto}.ontario-large-pull-0{position:relative;right:0;left:auto}.ontario-large-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-large-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-large-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-large-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-large-push-3{position:relative;left:25%;right:auto}.ontario-large-pull-3{position:relative;right:25%;left:auto}.ontario-large-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-large-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-large-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-large-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-large-push-6{position:relative;left:50%;right:auto}.ontario-large-pull-6{position:relative;right:50%;left:auto}.ontario-large-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-large-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-large-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-large-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-large-push-9{position:relative;left:75%;right:auto}.ontario-large-pull-9{position:relative;right:75%;left:auto}.ontario-large-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-large-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-large-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-large-pull-11{position:relative;right:91.6666666667%;left:auto}.ontario-column,.ontario-columns{position:relative;padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-large-1{width:8.3333333333%}.ontario-large-2{width:16.6666666667%}.ontario-large-3{width:25%}.ontario-large-4{width:33.3333333333%}.ontario-large-5{width:41.6666666667%}.ontario-large-6{width:50%}.ontario-large-7{width:58.3333333333%}.ontario-large-8{width:66.6666666667%}.ontario-large-9{width:75%}.ontario-large-10{width:83.3333333333%}.ontario-large-11{width:91.6666666667%}.ontario-large-12{width:100%}.ontario-large-offset-0{margin-left:0 !important}.ontario-large-offset-1{margin-left:8.3333333333% !important}.ontario-large-offset-2{margin-left:16.6666666667% !important}.ontario-large-offset-3{margin-left:25% !important}.ontario-large-offset-4{margin-left:33.3333333333% !important}.ontario-large-offset-5{margin-left:41.6666666667% !important}.ontario-large-offset-6{margin-left:50% !important}.ontario-large-offset-7{margin-left:58.3333333333% !important}.ontario-large-offset-8{margin-left:66.6666666667% !important}.ontario-large-offset-9{margin-left:75% !important}.ontario-large-offset-10{margin-left:83.3333333333% !important}.ontario-large-offset-11{margin-left:91.6666666667% !important}.ontario-large-reset-order{float:left;left:auto;margin-left:0;margin-right:0;right:auto}.ontario-column.ontario-large-centered,.ontario-columns.ontario-large-centered{margin-left:auto;margin-right:auto;float:none}.ontario-column.ontario-large-uncentered,.ontario-columns.ontario-large-uncentered{float:left;margin-left:0;margin-right:0}.ontario-column.ontario-large-centered:last-child,.ontario-columns.ontario-large-centered:last-child{float:none}.ontario-column.ontario-large-uncentered:last-child,.ontario-columns.ontario-large-uncentered:last-child{float:left}.ontario-column.ontario-large-uncentered.ontario-opposite,.ontario-columns.ontario-large-uncentered.ontario-opposite{float:right}.ontario-row.ontario-large-collapse>.ontario-column,.ontario-row.ontario-large-collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-large-collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row.ontario-large-uncollapse>.ontario-column,.ontario-row.ontario-large-uncollapse>.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-push-0{position:relative;left:0;right:auto}.ontario-pull-0{position:relative;right:0;left:auto}.ontario-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-push-3{position:relative;left:25%;right:auto}.ontario-pull-3{position:relative;right:25%;left:auto}.ontario-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-push-6{position:relative;left:50%;right:auto}.ontario-pull-6{position:relative;right:50%;left:auto}.ontario-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-push-9{position:relative;left:75%;right:auto}.ontario-pull-9{position:relative;right:75%;left:auto}.ontario-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-pull-11{position:relative;right:91.6666666667%;left:auto}}@media only screen and (min-width:96.063em){.ontario-xlarge-push-0{position:relative;left:0;right:auto}.ontario-xlarge-pull-0{position:relative;right:0;left:auto}.ontario-xlarge-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-xlarge-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-xlarge-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-xlarge-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-xlarge-push-3{position:relative;left:25%;right:auto}.ontario-xlarge-pull-3{position:relative;right:25%;left:auto}.ontario-xlarge-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-xlarge-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-xlarge-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-xlarge-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-xlarge-push-6{position:relative;left:50%;right:auto}.ontario-xlarge-pull-6{position:relative;right:50%;left:auto}.ontario-xlarge-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-xlarge-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-xlarge-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-xlarge-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-xlarge-push-9{position:relative;left:75%;right:auto}.ontario-xlarge-pull-9{position:relative;right:75%;left:auto}.ontario-xlarge-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-xlarge-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-xlarge-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-xlarge-pull-11{position:relative;right:91.6666666667%;left:auto}.ontario-column,.ontario-columns{position:relative;padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-xlarge-1{width:8.3333333333%}.ontario-xlarge-2{width:16.6666666667%}.ontario-xlarge-3{width:25%}.ontario-xlarge-4{width:33.3333333333%}.ontario-xlarge-5{width:41.6666666667%}.ontario-xlarge-6{width:50%}.ontario-xlarge-7{width:58.3333333333%}.ontario-xlarge-8{width:66.6666666667%}.ontario-xlarge-9{width:75%}.ontario-xlarge-10{width:83.3333333333%}.ontario-xlarge-11{width:91.6666666667%}.ontario-xlarge-12{width:100%}.ontario-xlarge-offset-0{margin-left:0 !important}.ontario-xlarge-offset-1{margin-left:8.3333333333% !important}.ontario-xlarge-offset-2{margin-left:16.6666666667% !important}.ontario-xlarge-offset-3{margin-left:25% !important}.ontario-xlarge-offset-4{margin-left:33.3333333333% !important}.ontario-xlarge-offset-5{margin-left:41.6666666667% !important}.ontario-xlarge-offset-6{margin-left:50% !important}.ontario-xlarge-offset-7{margin-left:58.3333333333% !important}.ontario-xlarge-offset-8{margin-left:66.6666666667% !important}.ontario-xlarge-offset-9{margin-left:75% !important}.ontario-xlarge-offset-10{margin-left:83.3333333333% !important}.ontario-xlarge-offset-11{margin-left:91.6666666667% !important}.ontario-xlarge-reset-order{float:left;left:auto;margin-left:0;margin-right:0;right:auto}.ontario-column.ontario-xlarge-centered,.ontario-columns.ontario-xlarge-centered{margin-left:auto;margin-right:auto;float:none}.ontario-column.ontario-xlarge-uncentered,.ontario-columns.ontario-xlarge-uncentered{float:left;margin-left:0;margin-right:0}.ontario-column.ontario-xlarge-centered:last-child,.ontario-columns.ontario-xlarge-centered:last-child{float:none}.ontario-column.ontario-xlarge-uncentered:last-child,.ontario-columns.ontario-xlarge-uncentered:last-child{float:left}.ontario-column.ontario-xlarge-uncentered.ontario-opposite,.ontario-columns.ontario-xlarge-uncentered.ontario-opposite{float:right}.ontario-row.ontario-xlarge-collapse>.ontario-column,.ontario-row.ontario-xlarge-collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-xlarge-collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row.ontario-xlarge-uncollapse>.ontario-column,.ontario-row.ontario-xlarge-uncollapse>.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}}@media only screen and (min-width:120.063em){.ontario-xxlarge-push-0{position:relative;left:0;right:auto}.ontario-xxlarge-pull-0{position:relative;right:0;left:auto}.ontario-xxlarge-push-1{position:relative;left:8.3333333333%;right:auto}.ontario-xxlarge-pull-1{position:relative;right:8.3333333333%;left:auto}.ontario-xxlarge-push-2{position:relative;left:16.6666666667%;right:auto}.ontario-xxlarge-pull-2{position:relative;right:16.6666666667%;left:auto}.ontario-xxlarge-push-3{position:relative;left:25%;right:auto}.ontario-xxlarge-pull-3{position:relative;right:25%;left:auto}.ontario-xxlarge-push-4{position:relative;left:33.3333333333%;right:auto}.ontario-xxlarge-pull-4{position:relative;right:33.3333333333%;left:auto}.ontario-xxlarge-push-5{position:relative;left:41.6666666667%;right:auto}.ontario-xxlarge-pull-5{position:relative;right:41.6666666667%;left:auto}.ontario-xxlarge-push-6{position:relative;left:50%;right:auto}.ontario-xxlarge-pull-6{position:relative;right:50%;left:auto}.ontario-xxlarge-push-7{position:relative;left:58.3333333333%;right:auto}.ontario-xxlarge-pull-7{position:relative;right:58.3333333333%;left:auto}.ontario-xxlarge-push-8{position:relative;left:66.6666666667%;right:auto}.ontario-xxlarge-pull-8{position:relative;right:66.6666666667%;left:auto}.ontario-xxlarge-push-9{position:relative;left:75%;right:auto}.ontario-xxlarge-pull-9{position:relative;right:75%;left:auto}.ontario-xxlarge-push-10{position:relative;left:83.3333333333%;right:auto}.ontario-xxlarge-pull-10{position:relative;right:83.3333333333%;left:auto}.ontario-xxlarge-push-11{position:relative;left:91.6666666667%;right:auto}.ontario-xxlarge-pull-11{position:relative;right:91.6666666667%;left:auto}.ontario-column,.ontario-columns{position:relative;padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}.ontario-xxlarge-1{width:8.3333333333%}.ontario-xxlarge-2{width:16.6666666667%}.ontario-xxlarge-3{width:25%}.ontario-xxlarge-4{width:33.3333333333%}.ontario-xxlarge-5{width:41.6666666667%}.ontario-xxlarge-6{width:50%}.ontario-xxlarge-7{width:58.3333333333%}.ontario-xxlarge-8{width:66.6666666667%}.ontario-xxlarge-9{width:75%}.ontario-xxlarge-10{width:83.3333333333%}.ontario-xxlarge-11{width:91.6666666667%}.ontario-xxlarge-12{width:100%}.ontario-xxlarge-offset-0{margin-left:0 !important}.ontario-xxlarge-offset-1{margin-left:8.3333333333% !important}.ontario-xxlarge-offset-2{margin-left:16.6666666667% !important}.ontario-xxlarge-offset-3{margin-left:25% !important}.ontario-xxlarge-offset-4{margin-left:33.3333333333% !important}.ontario-xxlarge-offset-5{margin-left:41.6666666667% !important}.ontario-xxlarge-offset-6{margin-left:50% !important}.ontario-xxlarge-offset-7{margin-left:58.3333333333% !important}.ontario-xxlarge-offset-8{margin-left:66.6666666667% !important}.ontario-xxlarge-offset-9{margin-left:75% !important}.ontario-xxlarge-offset-10{margin-left:83.3333333333% !important}.ontario-xxlarge-offset-11{margin-left:91.6666666667% !important}.ontario-xxlarge-reset-order{float:left;left:auto;margin-left:0;margin-right:0;right:auto}.ontario-column.ontario-xxlarge-centered,.ontario-columns.ontario-xxlarge-centered{margin-left:auto;margin-right:auto;float:none}.ontario-column.ontario-xxlarge-uncentered,.ontario-columns.ontario-xxlarge-uncentered{float:left;margin-left:0;margin-right:0}.ontario-column.ontario-xxlarge-centered:last-child,.ontario-columns.ontario-xxlarge-centered:last-child{float:none}.ontario-column.ontario-xxlarge-uncentered:last-child,.ontario-columns.ontario-xxlarge-uncentered:last-child{float:left}.ontario-column.ontario-xxlarge-uncentered.ontario-opposite,.ontario-columns.ontario-xxlarge-uncentered.ontario-opposite{float:right}.ontario-row.ontario-xxlarge-collapse>.ontario-column,.ontario-row.ontario-xxlarge-collapse>.ontario-columns{padding-left:0;padding-right:0}.ontario-row.ontario-xxlarge-collapse .ontario-row{margin-left:0;margin-right:0}.ontario-row.ontario-xxlarge-uncollapse>.ontario-column,.ontario-row.ontario-xxlarge-uncollapse>.ontario-columns{padding-left:1rem;padding-right:1rem;box-sizing:border-box;float:left}}.ontario-input{border:2px solid #1a1a1a;border-radius:4px;box-sizing:border-box;color:#1a1a1a;display:block;font-size:1rem;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;line-height:1.5;margin:0 0 2.5rem;max-width:48rem;width:100%;padding:0.625rem 1rem;transition:box-shadow 0.1s ease-in-out}.ontario-input--2-char-width{max-width:8ex}.ontario-input--3-char-width{max-width:10ex}.ontario-input--4-char-width{max-width:12ex}.ontario-input--5-char-width{max-width:14ex}.ontario-input--7-char-width{max-width:17ex}.ontario-input--10-char-width{max-width:23ex}.ontario-input--20-char-width{max-width:41ex}.ontario-form-group:last-of-type{margin-bottom:2.5rem}.ontario-hide{display:none !important}.ontario-invisible{visibility:hidden !important}@media screen and (max-width: 39.99875em){.ontario-hide-for-small-only{display:none !important}}@media screen and (max-width: 0em), screen and (min-width: 40em){.ontario-show-for-small-only{display:none !important}}@media print, screen and (min-width: 40em){.ontario-hide-for-medium{display:none !important}}@media screen and (max-width: 39.99875em){.ontario-show-for-medium{display:none !important}}@media screen and (min-width: 40em) and (max-width: 72.99875em){.ontario-hide-for-medium-only{display:none !important}}@media screen and (max-width: 39.99875em), screen and (min-width: 73em){.ontario-show-for-medium-only{display:none !important}}@media print, screen and (min-width: 73em){.ontario-hide-for-large{display:none !important}}@media screen and (max-width: 72.99875em){.ontario-show-for-large{display:none !important}}@media screen and (min-width: 73em) and (max-width: 95.99875em){.ontario-hide-for-large-only{display:none !important}}@media screen and (max-width: 72.99875em), screen and (min-width: 96em){.ontario-show-for-large-only{display:none !important}}.ontario-show-for-sr,.ontario-show-on-focus{position:absolute;width:1px;height:1px;overflow:hidden;clip:rect(0, 0, 0, 0)}.ontario-show-on-focus:active,.ontario-show-on-focus:focus{position:static;width:auto;height:auto;overflow:visible;clip:auto}.ontario-show-for-landscape,.ontario-hide-for-portrait{display:block !important}@media screen and (orientation: landscape){.ontario-show-for-landscape,.ontario-hide-for-portrait{display:block !important}}@media screen and (orientation: portrait){.ontario-show-for-landscape,.ontario-hide-for-portrait{display:none !important}}.ontario-hide-for-landscape,.ontario-show-for-portrait{display:none !important}@media screen and (orientation: landscape){.ontario-hide-for-landscape,.ontario-show-for-portrait{display:none !important}}@media screen and (orientation: portrait){.ontario-hide-for-landscape,.ontario-show-for-portrait{display:block !important}}.ontario-application-header{display:flex;align-items:center;background-color:#1a1a1a;color:#FFFFFF;height:3.125rem !important;position:relative;z-index:5}.ontario-application-header>.ontario-row{display:flex;align-items:center}.ontario-application-header-container{position:relative;width:100%}.ontario-header-button.ontario-application-navigation--open:hover{background-color:#666666}.ontario-header-button.ontario-application-navigation--closed:active{background-color:#1a1a1a}.ontario-header-button--with-outline{border:2px solid #FFFFFF;margin:0 0 0 1rem;padding:0.375rem 1rem}.ontario-application-subheader .ontario-header-button,.ontario-application-navigation .ontario-header-button{background-color:#4d4d4d}.ontario-header-button--closed:focus{box-shadow:none;outline:none;transition:none}.ontario-application-header__logo,.ontario-application-header__logo a,.ontario-application-header__lang-toggle,.ontario-application-subheader__container,.ontario-application-subheader__menu-container,.ontario-application-subheader__menu{display:flex;align-items:center;outline:none}.ontario-application-header__logo a:focus{box-shadow:0 0 0 4px #009ADB;transition:all 0.1s ease-in-out}.ontario-application-header__logo svg,.ontario-application-header__logo img{width:100px;height:25px}.ontario-application-header__lang-toggle{justify-content:flex-end}.ontario-application-header__lang-toggle a{font-size:1rem;line-height:1.375rem;height:auto;outline:none;padding:0.5rem 0.75rem}.ontario-application-subheader{padding:1.25rem 0;background-color:#404040;overflow:visible;position:relative;z-index:5}@media screen and (min-width: 73em){.ontario-application-subheader{z-index:0}}.ontario-application-subheader>.ontario-row{position:relative}.ontario-application-header-container{position:relative;z-index:5}.ontario-application-header>.ontario-row{display:flex;align-items:center}.ontario-application-subheader .ontario-header-button{visibility:visible}.ontario-application-subheader .ontario-header-button,.ontario-application-navigation .ontario-header-button{background-color:#4d4d4d}.ontario-application-subheader .ontario-header-button:hover,.ontario-application-navigation .ontario-header-button:hover{background-color:#666666}.ontario-application-subheader .ontario-header-button:active,.ontario-application-navigation .ontario-header-button:active{background-color:#1a1a1a}.ontario-header-button--without-outline:hover{background-color:#4d4d4d}.ontario-header-button--without-outline:focus{box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:all 0.1s ease-in-out}.ontario-application-subheader__heading{padding:0.375rem 0;margin-bottom:0;max-width:65%}.ontario-application-subheader__heading a{color:#FFFFFF;font-weight:600;text-decoration:none}.ontario-application-subheader__heading a:focus{box-shadow:0 0 0 4px #009ADB;transition:all 0.1s ease-in-out}.ontario-application-subheader__heading a:hover,.ontario-application-subheader__heading a:active,.ontario-application-subheader__heading a:visited{color:#FFFFFF;text-decoration:underline}.ontario-application-subheader .ontario-header-button{visibility:visible;background-color:#4d4d4d}.ontario-application-subheader .ontario-header-button:hover{background-color:#666666}.ontario-application-subheader .ontario-header-button:active{background-color:#1a1a1a}.ontario-header__menu-toggler span{display:flex}@media screen and (max-width: 20em){.ontario-header__menu-toggler span:last-of-type{display:none}}.ontario-header__menu-toggler svg{margin-right:6px}@media screen and (max-width: 20em){.ontario-header__menu-toggler svg{margin-right:0}}.ontario-application-subheader__container{align-items:center;justify-content:space-between}.ontario-application-subheader__menu{display:flex;align-items:center;list-style:none;margin:0;padding-left:0}.ontario-application-subheader__menu li{border-radius:4px;padding:0;margin:0 0 0 0.75rem;text-align:center}.ontario-application-subheader__menu-container a{box-sizing:border-box;border-radius:4px;color:#FFFFFF;display:inline-block;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1.125rem;font-weight:600;height:48px;line-height:1.4375rem;outline:none;padding:0.75rem;text-align:left;text-decoration:none;white-space:nowrap}.ontario-application-subheader__menu-container a.ontario-link--active{border-radius:4px 4px 0 0;border-bottom:4px solid #FFFFFF}.ontario-application-subheader__menu-container a:hover{background-color:#666666;color:#FFFFFF}.ontario-application-subheader__menu-container a:active{background-color:#1a1a1a}.ontario-application-subheader__menu-container a:focus{box-shadow:0 0 0 4px #009ADB;transition:all 0.1s ease-in-out}.ontario-application-navigation{position:absolute;width:100%}@media screen and (min-width: 73em){.ontario-application-navigation{position:relative;max-width:72rem;width:auto;margin:0 auto}}.ontario-application-navigation .ontario-header-button{visibility:hidden;position:absolute;top:-4.25rem;right:1rem;z-index:6}.ontario-application-navigation__container{background:#FFFFFF;position:absolute;top:0;width:100%;z-index:4}@media screen and (min-width: 40em){.ontario-application-navigation__container{background:#FFFFFF;position:absolute;z-index:4}}@media screen and (min-width: 73em){.ontario-application-navigation__container{box-shadow:0 4px 12px rgba(0, 0, 0, 0.3);border-radius:4px;position:absolute;right:0.75rem;top:-0.6rem;min-width:290px;max-width:30%;z-index:3;transition:none !important}}.ontario-application-navigation ul{list-style:none;padding:0.5rem 0;margin:0;border-bottom:1px solid #cccccc}@media screen and (min-width: 73em){.ontario-application-navigation ul{border-bottom:none}}.ontario-application-navigation li{border-top:1px solid #cccccc;padding:0;margin-bottom:0}.ontario-application-navigation li:last-of-type{border-bottom:1px solid #cccccc}.ontario-application-navigation a{color:#1a1a1a;display:block;font-size:1.125rem;font-weight:600;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;text-decoration:none;padding:0.6730769231rem 1.5rem}.ontario-application-navigation a:hover{text-decoration:underline;background-color:#e5e5e5}.ontario-application-navigation a:active{text-decoration:underline;background-color:#cccccc}.ontario-application-navigation a:focus,.ontario-application-navigation a:active{box-shadow:0 0 0 4px #009ADB inset}.ontario-application-navigation a.ontario-link--active{border-left:6px solid #1a1a1a;background-color:#f2f2f2}.ontario-navigation--open{visibility:visible;transform:translateY(0);transition:transform 0.4s ease-in-out}@media screen and (min-width: 73em){.ontario-navigation--open{z-index:5}}.ontario-navigation--closed{background:#FFFFFF;position:absolute;transform:translateY(-100%);transition:transform 0.3s ease-in-out, visibility 0.1s ease;width:100%;visibility:hidden;z-index:4}.ontario-application-navigation.ontario-navigation--open .ontario-application-navigation__container{visibility:visible;transform:translateY(0);transition:transform 0.4s ease-in-out}@media screen and (min-width: 73em){.ontario-application-navigation.ontario-navigation--open .ontario-application-navigation__container{transition:none;display:block}}.ontario-overlay{position:fixed;top:0;left:0;background:rgba(0, 0, 0, 0.6);width:100%;height:100%;z-index:2}.ontario-header-button.ontario-navigation--open:hover{background-color:#666666}.ontario-header-button.ontario-navigation--open:active{background-color:#1a1a1a}.ontario-header-button.ontario-navigation--closed:active{background-color:#1a1a1a}.ontario-header-button{background-color:#1a1a1a;border:none;border-radius:4px;box-sizing:border-box;box-shadow:none;color:#FFFFFF;cursor:pointer;display:flex;align-items:center;font-size:1.125rem;font-weight:600;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;height:48px;line-height:1.5555555556;text-align:center;text-decoration:none}.ontario-header-button:hover,.ontario-header-button:focus,.ontario-header-button:visited{color:#FFFFFF}.ontario-header-button--with-outline,.ontario-header-button--without-outline{background-color:#1a1a1a;color:#FFFFFF}.ontario-header-button--with-outline:hover,.ontario-header-button--without-outline:hover{background-color:#4d4d4d}.ontario-header-button--with-outline:active,.ontario-header-button--without-outline:active{background-color:#666666}.ontario-header-button--with-outline:focus,.ontario-header-button--without-outline:focus{background-color:#4d4d4d}.ontario-header-button--with-outline{border:2px solid #FFFFFF;margin:0 0 0 1rem;padding:0.375rem 1rem}.ontario-header-button--with-outline:hover{border:2px solid #FFFFFF;color:#FFFFFF}.ontario-header-button--with-outline:focus{background-color:#4d4d4d}@media screen and (max-width: 20em){.ontario-header-button--with-outline{padding:0.375rem}}.ontario-header__menu-toggler{padding:0.375rem 1rem}@media screen and (max-width: 20em){.ontario-header__menu-toggler{padding-left:0.5rem;padding-right:0.5rem}}.ontario-header__menu-toggler span{display:flex}@media screen and (max-width: 20em){.ontario-header__menu-toggler span{display:none}}.ontario-header__menu-toggler svg{margin-right:6px}@media screen and (max-width: 20em){.ontario-header__menu-toggler svg{margin-right:0}}.ontario-application-navigation__container{background:#FFFFFF;position:absolute;transform:translateY(-100%);transition:transform 0.3s ease-in-out, visibility 0.1s ease;width:100%;visibility:hidden;z-index:4}@media screen and (min-width: 73em){.ontario-application-navigation__container{box-shadow:0 4px 12px rgba(0, 0, 0, 0.3);border-radius:4px;display:none;position:absolute;right:1rem;top:calc(100% - 0.5rem);min-width:290px;max-width:30%;z-index:5}}.ontario-application-navigation.ontario-navigation--open .ontario-application-navigation__container{background:#FFFFFF;visibility:visible;transform:translateY(0);transition:transform 0.4s ease-in-out}@media screen and (min-width: 73em){.ontario-application-navigation.ontario-navigation--open .ontario-application-navigation__container{transition:none;display:block}}.ontario-application-navigation.ontario-navigation--open{background:#FFFFFF;z-index:4}.ontario-application-navigation ul{list-style:none;padding:0.5rem 0;margin:0;border-bottom:1px solid #cccccc}@media screen and (min-width: 73em){.ontario-application-navigation ul{border-bottom:none}}.ontario-application-navigation li{border-top:1px solid #cccccc;padding:0;margin-bottom:0}.ontario-application-navigation li:last-of-type{border-bottom:1px solid #cccccc}.ontario-application-navigation a{color:#1a1a1a;display:block;font-size:1.125rem;font-weight:600;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;text-decoration:none;padding:0.6730769231rem 1.5rem}.ontario-application-navigation a:hover{text-decoration:underline;background-color:#e5e5e5}.ontario-application-navigation a:active{text-decoration:underline;background-color:#cccccc}.ontario-application-navigation a:focus,.ontario-application-navigation a:active{box-shadow:0 0 0 4px #009ADB inset}.ontario-application-navigation a.ontario-link--active{border-left:6px solid #1a1a1a;background-color:#f2f2f2}.ontario-overlay{position:fixed;top:0;left:0;background:rgba(0, 0, 0, 0.6);width:100%;height:100%;z-index:2}.ontario-header__icon-container{display:flex;align-items:center}.ontario-service-header{height:3.125rem;z-index:5}.ontario-service-header__logo,.ontario-service-header__logo a,.ontario-service-header__lang-toggle,.ontario-service-subheader__container,.ontario-service-subheader__menu-container,.ontario-service-subheader__menu{display:flex}.ontario-service-header__logo img{width:100px;height:25px}.ontario-service-header__lang-toggle{justify-content:flex-end}.ontario-service-header__lang-toggle a{font-size:1rem;line-height:1.375rem;height:auto;padding:0.5rem 0.75rem}.ontario-service-subheader{padding:1rem 0;background-color:#03713D;overflow:hidden;position:relative;z-index:5}@media screen and (min-width: 73em){.ontario-service-subheader{z-index:0}}.ontario-service-subheader>.ontario-row{position:relative}.ontario-service-subheader .ontario-header-button{display:flex}.ontario-service-subheader .ontario-header-button{background-color:#03713D}.ontario-service-subheader .ontario-header-button .ontario-icon{width:2rem;height:2rem;margin-bottom:0}.ontario-service-subheader .ontario-header-button:hover{background-color:#048B4B}.ontario-service-subheader .ontario-header-button:active{background-color:#024122}.ontario-service-subheader .ontario-header-button:focus{box-shadow:0 0 0 4px #42C7FF}.ontario-service-subheader__link{text-decoration:none}a .ontario-service-subheader__heading-container{color:#FFFFFF;font-weight:600;text-decoration:none}a .ontario-service-subheader__heading-container:hover,a .ontario-service-subheader__heading-container:active,a .ontario-service-subheader__heading-container:visited{color:#FFFFFF;text-decoration:underline}a .ontario-service-subheader__heading-container:focus{box-shadow:0 0 0 4px #42C7FF}.ontario-service-subheader__heading{font-weight:600;padding:0 0 0.125rem 0;margin-bottom:0;text-decoration:none}.ontario-service-subheader__description{padding:0.125rem 0 0.25rem 0;margin-bottom:0;color:#FFFFFF;font-weight:600;text-decoration:none}.ontario-service-subheader__container{align-items:center;justify-content:space-between}.ontario-service-subheader__menu{list-style:none;margin:0;padding-left:0;align-items:center}.ontario-service-subheader__menu li{padding:0;margin-left:1rem}.ontario-service-subheader__menu a{border-radius:4px;color:#FFFFFF;display:block;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1.125rem;font-weight:600;height:48px;line-height:1.4375rem;padding:0.75rem;text-decoration:none;white-space:nowrap}.ontario-service-subheader__menu a.ontario-link--active{border-radius:4px 4px 0 0;border-bottom:0.25rem solid #FFFFFF}.ontario-service-subheader__menu a:hover{color:#FFFFFF;background-color:#048B4B}.ontario-service-subheader__menu a:active{color:#FFFFFF;background-color:#024122}.ontario-service-subheader__menu a:focus{box-shadow:0 0 0 4px #42C7FF}.ontario-overlay{display:none;position:fixed;top:0;left:0;background:rgba(26, 26, 26, 0.6);width:100%;height:100%;z-index:2}.ontario-navigation--open .ontario-service-subheader .ontario-header-button:first-of-type{display:none}.ontario-navigation--open .ontario-service-subheader .ontario-header-button:last-of-type{display:flex}@media screen and (max-width: 73em){.ontario-navigation--open .ontario-service-subheader-menu__container{position:relative;z-index:3}}.ontario-navigation--open .ontario-overlay{display:block}@media screen and (min-width: 73em){.ontario-navigation--open .ontario-overlay{display:none}}.ontario-colour-service-ontario-header-brand{background-color:#03713D}.ontario-colour-service-ontario-header-focus{background-color:#42C7FF}.ontario-colour-service-ontario-header-hover{background-color:#048B4B}.ontario-colour-service-ontario-header-active{background-color:#024122}';

		class OntarioHeader {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			get el() {
				return getElement(this);
			}
			/**
			 * The type of header.
			 */
			type = 'application';
			/**
			 * Information pertaining to the application header. This is only necessary for the 'application' header type.
			 *
			 * This includes the application name, URL and optional props for the number of links in the subheader for desktop, tablet, and mobile views.
			 *
			 * @example
			 *  <ontario-header
			 *    type="application"
			 *    application-header-info='{
			 *      "title": "Application name",
			 *      "href": "/application-homepage",
			 *      "maxSubheaderDesktopLinks": "3",
			 *      "maxSubheaderTabletLinks": "2",
			 *      "maxSubheaderMobileLinks": "1"
			 *    }'>
			 *  </ontario-header>
			 */
			applicationHeaderInfo;
			/**
			 * The items that will go inside the menu.
			 */
			menuItems;
			/**
			 * Option to disable fetching of the dynamic menu from the Ontario Header API
			 *
			 * @example
			 * 	<ontario-header
			 * 			type="ontario"
			 * 			disable-dynamic-menu="false"
			 *			menu-items='[{
			 *				"title": "Hint",
			 *				"href": "/ontario-hint"
			 *				"linkIsActive": "false"
			 *			},{
			 *				"title": "Hint",
			 *				"href": "/ontario-hint"
			 *				"linkIsActive": "false"
			 *			},{
			 *				"title": "Hint",
			 *				"href": "/ontario-hint"
			 *				"linkIsActive": "false"
			 *			},{
			 *				"title": "Hint",
			 *				"href": "/ontario-hint"
			 *				"linkIsActive": "false"
			 *			}]'>
			 *	</ontario-header>
			 */
			disableDynamicMenu = false;
			/**
			 * Information pertaining to the language toggle links.
			 *
			 * @example
			 * <ontario-header
			 * 	language-toggle-options='{
			 *    "englishLink": "/en",
			 *    "frenchLink": "/fr"
			 *  }'
			 *  ...
			 * >
			 * </ontario-header>
			 */
			languageToggleOptions;
			/**
			 * A custom function to pass to the language toggle button.
			 */
			customLanguageToggle;
			/**
			 * The language of the component.
			 * This is used for translations, and is by default set through event listeners checking for a language property from the header. If none is passed, it will default to English.
			 */
			language = 'en';
			/**
			 * The base path to an assets folder containing the Design System assets
			 */
			assetBasePath;
			/**
			 * The application header information is reassigned to applicationHeaderInfoState for parsing
			 */
			applicationHeaderInfoState;
			/**
			 * The menuItems is reassigned to itemState for parsing
			 *
			 * @example
			 * 	<ontario-header
			 * 			type="ontario"
			 * 			disable-dynamic-menu="true"
			 *			menu-items='[{
			 *				"title": "Hint",
			 *				"href": "/ontario-hint"
			 *				"linkIsActive": "false"
			 *			},{
			 *				"title": "Hint",
			 *				"href": "/ontario-hint"
			 *				"linkIsActive": "false"
			 *			},{
			 *				"title": "Hint",
			 *				"href": "/ontario-hint"
			 *				"linkIsActive": "false"
			 *			},{
			 *				"title": "Hint",
			 *				"href": "/ontario-hint"
			 *				"linkIsActive": "false"
			 *			}]'>
			 *	</ontario-header>
			 */
			menuItemState;
			/**
			 * Check to see if menu is dynamic or static
			 */
			isDynamicMenu = false;
			/**
			 * The languageToggleOptions is reassigned to languageState for parsing
			 *
			 * @example
			 * 	<ontario-header
			 *		language-toggle-options='{
			 *			"englishLink":"/en",
			 *			"frenchLink": "/fr"
			 *		}'
			 *	</ontario-header>
			 */
			languageState;
			/**
			 * Toggler for the menu and the search button
			 */
			menuToggle = false;
			searchToggle = false;
			/**
			 * Assigning values to elements to use them as ref
			 */
			header;
			menuButton;
			menuButtonDesktop;
			menuButtonTablet;
			menuButtonMobile;
			searchBar;
			searchButton;
			translations = translations;
			parseApplicationHeaderInfo() {
				const applicationHeaderInfo = this.applicationHeaderInfo;
				if (applicationHeaderInfo) {
					if (typeof applicationHeaderInfo === 'string')
						this.applicationHeaderInfoState = JSON.parse(applicationHeaderInfo);
					else this.applicationHeaderInfoState = applicationHeaderInfo;
				}
			}
			parseMenuItems() {
				const isEnglish = this.language === 'en';
				if (!Array.isArray(this.menuItems) && typeof this.menuItems === 'string') {
					this.menuItemState = JSON.parse(this.menuItems);
					this.isDynamicMenu = false;
				} else if (Array.isArray(this.menuItems) && this.type === 'application') {
					this.menuItemState = this.menuItems;
					this.isDynamicMenu = false;
				} else {
					this.menuItemState = isEnglish ? OntarioHeaderDefaultData.en : OntarioHeaderDefaultData.fr;
					this.isDynamicMenu = false;
				}
			}
			parseLanguage() {
				const languageToggleOptions = this.languageToggleOptions;
				if (languageToggleOptions) {
					if (typeof languageToggleOptions === 'string') {
						this.languageState = JSON.parse(languageToggleOptions);
					} else {
						this.languageState = languageToggleOptions;
					}
				}
			}
			/**
			 * Logic to close the menu when anything outside the menu is clicked
			 */
			handleClick(event) {
				// if the button is clicked, return
				if (
					event.composedPath().includes(this.menuButton) ||
					event.composedPath().includes(this.menuButtonDesktop) ||
					event.composedPath().includes(this.menuButtonTablet) ||
					event.composedPath().includes(this.menuButtonMobile)
				) {
					return;
				}
				// If the click was outside the current component, do the following
				if (this.menuToggle) this.menuToggle = !this.menuToggle;
			}
			/**
			 * This listens for the `setAppLanguage` event sent from the language toggle when it is is connected to the DOM.
			 * It is used for the initial language when the input component loads.
			 */
			handleSetAppLanguage(event) {
				this.language = validateLanguage(event);
				this.parseMenuItems();
			}
			/**
			 * This listens for the `headerLanguageToggled` event sent from the language toggle when it is is connected to the DOM.
			 * It is used for changing the component language after the language toggle has been activated.
			 */
			handleLanguageToggle(event) {
				this.handleSetAppLanguage(event.detail.newLanguage);
			}
			/**
			 * Logic to handle the menu toggling
			 */
			handleMenuToggle = () => {
				this.menuToggle = !this.menuToggle;
				this.searchToggle = undefined;
			};
			/**
			 * Logic to handle the search toggling
			 */
			handleSearchToggle = () => {
				this.searchToggle = !this.searchToggle;
			};
			/**
			 * event.preventDefault(): https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault
			 * location.href: https://developer.mozilla.org/en-US/docs/Web/API/Location/href
			 */
			handleSubmit = (event) => {
				event.preventDefault();
				location.href = `${this.translations.header.ontarioSearchURL[`${this.language}`]}${event.target[0].value}`;
			};
			/**
			 * Logic to make the focus go back to the menu button when the list ends
			 */
			trapMenuFocus = (e) => {
				let dataType = e.target?.dataset.type;
				if (dataType === 'app-desktop') {
					this.menuButtonDesktop.focus();
				} else if (dataType === 'app-tablet') {
					this.menuButtonTablet.focus();
				} else if (dataType === 'app-mobile') {
					this.menuButtonMobile.focus();
				} else {
					this.menuButton.focus();
				}
			};
			/**
			 * Call to Ontario Menu API to fetch linksets to populate header component
			 */
			async fetchOntarioMenu() {
				const isEnglish = this.language === 'en';
				// If menu has already been fetched and contains dynamic menu items, do not run fetch again
				if (!this.isDynamicMenu) {
					const apiUrl = isEnglish ? config.ONTARIO_HEADER_API_URL_EN : config.ONTARIO_HEADER_API_URL_FR;
					const response = await fetch(apiUrl)
						.then((response) => response.json())
						.then((json) => json.linkset[0].item)
						.catch(() => {
							console.error('Unable to retrieve data from Ontario Menu API');
							return [];
						});
					if (response.length > 0) {
						const externalMenuItems = response.map((item) => {
							return { href: item.href, title: item.title };
						});
						this.menuItemState = externalMenuItems;
						this.isDynamicMenu = true;
					}
				}
				return;
			}
			/**
			 * Generate a link to the given image based on the base asset path.
			 * @param imageName Name of the image to build the path to
			 * @returns Path to image with asset path
			 */
			getImageAssetSrcPath(imageName) {
				return `${this.assetBasePath ? this.assetBasePath : getAssetPath('./assets')}/${imageName}`;
			}
			/**
			 * This function generates the menu items in a <li>, accordingly, to the given parameters.
			 *
			 * href and title are necessary, but rest are not.
			 *
			 * @param href - the href of the menu item
			 * @param title - the title of the menu item
			 * @param linkIsActive - when set to true, this will add the classes necessary to style the link in a way that indicates to the user what the active page/link is
			 * @param liClass - if there is a class that is related to the <a> portion of the menu item, put it here
			 * @param onClick - for any custom onClick event a user might want to add to their menu links
			 * @param onBlur - when set to true, it will call the function trapMenuFocus(), otherwise nothing is done (used in lastLink)
			 */
			generateMenuItem(href, title, linkIsActive, type, liClass, onClick, onBlur) {
				return hAsync(
					'li',
					{ class: liClass },
					hAsync(
						'a',
						{
							'class': linkIsActive === true ? `ontario-link--active` : ``,
							'href': href,
							'onClick': onClick,
							'onBlur': onBlur ? this.trapMenuFocus : undefined,
							'data-type': type,
						},
						title,
					),
				);
			}
			/**
			 * This function generates the menu dropdown button for the ontario header component.
			 *
			 * @param viewportSize - the size of the screen where the function is being called. It can either be set to `desktop`, `tablet` or `mobile`. This dictates the classes used on the menu button, as well as the ref to keep the focus trapped when the menu is open.
			 */
			renderMenuButton(viewportSize) {
				if (!this.isMenuVisible(viewportSize)) {
					return;
				}
				return hAsync(
					'button',
					{
						'class':
							viewportSize === 'desktop'
								? 'ontario-header__menu-toggler ontario-header-button ontario-header-button--with-outline ontario-show-for-large'
								: viewportSize === 'tablet'
									? 'ontario-header__menu-toggler ontario-header-button ontario-header-button--with-outline ontario-hide-for-small ontario-show-for-medium ontario-hide-for-large'
									: viewportSize === 'mobile'
										? 'ontario-header__menu-toggler ontario-header-button ontario-header-button--with-outline ontario-show-for-small-only'
										: 'ontario-header__menu-toggler ontario-header-button ontario-header-button--with-outline',
						'id': this.type === 'ontario' ? 'ontario-header-menu-toggler' : 'ontario-application-header-menu-toggler',
						'aria-controls': 'ontario-navigation',
						'aria-label': this.menuToggle
							? this.translations.header.closeMenu[`${this.language}`]
							: this.translations.header.openMenu[`${this.language}`],
						'onClick': this.handleMenuToggle,
						'type': 'button',
						'ref':
							viewportSize === 'desktop'
								? (el) => (this.menuButtonDesktop = el)
								: viewportSize === 'tablet'
									? (el) => (this.menuButtonTablet = el)
									: viewportSize === 'mobile'
										? (el) => (this.menuButtonMobile = el)
										: (el) => (this.menuButton = el),
					},
					hAsync('span', {
						class: 'ontario-header__icon-container',
						innerHTML: this.menuToggle ? OntarioIconClose$1 : OntarioIconMenu$1,
					}),
					hAsync('span', null, 'Menu'),
				);
			}
			/**
			 * A helper function to generate navigation dropdown links with onBlur functionality. This is used for the application header.
			 *
			 * @param item - the menu item to be looped over (contains the title and href)
			 * @param index
			 * @param links - the number of links associated with the maxSubheader[size]Links in the application header info prop. This will determine how many links should be displayed in the dropdown.
			 * @param viewportSize - the size of the viewport. It can be set to `desktop`, `tablet` or `mobile`.
			 * @returns
			 */
			generateNavigationLinks(item, index, links, viewportSize) {
				const lastLink =
					index + 1 === (links ? this.menuItemState.length - links : this.menuItemState.length) ? true : false;
				return this.generateMenuItem(
					item.href,
					item.title,
					item.linkIsActive,
					viewportSize,
					'',
					item.onClickHandler,
					lastLink,
				);
			}
			/**
			 * The onEscapePressed function clears the searchbar form when Escape is pressed
			 */
			onEscapePressed(event) {
				if (event.key === 'Escape') {
					event.path[0].value = '';
				}
			}
			isMenuVisible(viewportSize) {
				const { menuItemState, applicationHeaderInfoState } = this;
				const { maxSubheaderMobileLinks, maxSubheaderTabletLinks, maxSubheaderDesktopLinks } =
					applicationHeaderInfoState ?? {};
				const numOfMenuItems = menuItemState?.length ?? 0;
				if (numOfMenuItems <= 0) {
					return false;
				}
				if (viewportSize === 'mobile') {
					return numOfMenuItems - (maxSubheaderMobileLinks ?? 0) > 0;
				}
				if (viewportSize === 'tablet') {
					return numOfMenuItems - (maxSubheaderTabletLinks ?? 0) > 0;
				}
				if (viewportSize === 'desktop') {
					return numOfMenuItems - (maxSubheaderDesktopLinks ?? 0) > 0;
				}
				return true;
			}
			componentWillLoad() {
				this.parseApplicationHeaderInfo();
				this.parseMenuItems();
				this.parseLanguage();
			}
			componentDidRender() {
				if (this.disableDynamicMenu === false && this.type === 'ontario') {
					this.fetchOntarioMenu();
				}
			}
			/**
			 * Handles the focus when menu/toggle button is clicked.
			 * When search button is clicked, the search bar is in focus,
			 * when the closed button is clicked, the search button is back into focus.
			 * When the menu is closed, the menu button should be out of focus.
			 */
			componentDidUpdate() {
				if (this.type == 'ontario') {
					if (this.searchToggle === true) this.searchBar.focus();
					if (this.searchToggle === false) this.searchButton.focus();
					if (this.menuToggle === false) this.menuButton.blur();
				}
			}
			render() {
				const isServiceOntarioType = this.type === 'serviceOntario';
				if (this.type == 'ontario') {
					return hAsync(
						'div',
						null,
						hAsync(
							'div',
							{ class: 'ontario-header__container', ref: (el) => (this.header = el) },
							hAsync(
								'header',
								{
									class: this.searchToggle ? 'ontario-header ontario-header--search-open' : 'ontario-header',
									id: 'ontario-header',
								},
								hAsync(
									'div',
									{ class: 'ontario-row' },
									hAsync(
										'div',
										{
											class:
												'ontario-header__logo-container ontario-columns ontario-small-2 ontario-medium-4 ontario-large-3',
										},
										hAsync(
											'a',
											{ href: this.translations.header.logoLink[`${this.language}`] },
											hAsync('img', {
												class: 'ontario-show-for-medium',
												src: this.getImageAssetSrcPath('ontario-logo--desktop.svg'),
												alt: this.translations.header.logoAltText[`${this.language}`],
											}),
											hAsync('img', {
												class: 'ontario-show-for-small-only',
												src: this.getImageAssetSrcPath('ontario-logo--mobile.svg'),
												alt: this.translations.header.logoAltText[`${this.language}`],
											}),
										),
									),
									hAsync(
										'form',
										{
											name: 'searchForm',
											id: 'ontario-search-form-container',
											onSubmit: this.handleSubmit,
											class:
												'ontario-header__search-container ontario-columns ontario-small-10 ontario-medium-offset-3 ontario-medium-6 ontario-large-offset-0 ontario-large-6',
											novalidate: true,
										},
										hAsync(
											'label',
											{ htmlFor: 'ontario-search-input-field', class: 'ontario-show-for-sr' },
											this.translations.header.search[`${this.language}`],
										),
										hAsync(Input$1, {
											'type': 'text',
											'name': 'search',
											'id': 'ontario-search-input-field',
											'autoComplete': 'off',
											'aria-autocomplete': 'none',
											'className': 'ontario-input ontario-header__search-input',
											'required': true,
											'ref': (el) => (this.searchBar = el),
											'onKeyDown': this.onEscapePressed,
										}),
										hAsync(Input$1, {
											'className': 'ontario-header__search-reset',
											'id': 'ontario-search-reset',
											'type': 'reset',
											'value': '',
											'aria-label': this.translations.header.clearSearchField[`${this.language}`],
										}),
										hAsync(
											'button',
											{ class: 'ontario-header__search-submit', id: 'ontario-search-submit', type: 'submit' },
											hAsync(
												'span',
												{ class: 'ontario-show-for-sr' },
												this.translations.header.submit[`${this.language}`],
											),
											hAsync('span', { class: 'ontario-header__icon-container', innerHTML: OntarioIconSearch$1 }),
										),
									),
									hAsync(
										'div',
										{
											class:
												'ontario-header__nav-right-container ontario-columns ontario-small-10 ontario-medium-8 ontario-large-3',
										},
										hAsync('ontario-language-toggle', {
											url: this.language === 'en' ? this.languageState?.frenchLink : this.languageState?.englishLink,
											size: 'default',
											customLanguageToggle: this.customLanguageToggle,
										}),
										hAsync(
											'button',
											{
												'class':
													'ontario-header__search-toggler ontario-header-button ontario-header-button--without-outline ontario-hide-for-large',
												'id': 'ontario-header-search-toggler',
												'aria-controls': 'ontario-search-form-container',
												'onClick': this.handleSearchToggle,
												'ref': (el) => (this.searchButton = el),
											},
											hAsync('span', { class: 'ontario-header__icon-container', innerHTML: OntarioIconSearchWhite$1 }),
											hAsync(
												'span',
												{ class: 'ontario-show-for-medium ontario-show' },
												this.translations.header.search[`${this.language}`],
											),
										),
										this.renderMenuButton('ontario-header'),
									),
									hAsync(
										'div',
										{
											class: 'ontario-header__search-close-container ontario-columns ontario-small-2 ontario-medium-3',
										},
										hAsync(
											'button',
											{
												'class':
													'ontario-header__search-close ontario-header-button ontario-header-button--without-outline',
												'id': 'ontario-header-search-close',
												'aria-label': this.translations.header.closeSearch[`${this.language}`],
												'type': 'button',
												'onClick': this.handleSearchToggle,
											},
											hAsync(
												'span',
												{ 'aria-hidden': `${!this.searchToggle}` },
												this.translations.header.close[`${this.language}`],
											),
											hAsync('span', { class: 'ontario-header__icon-container', innerHTML: OntarioIconClose$1 }),
										),
									),
								),
							),
							hAsync(
								'nav',
								{
									role: 'navigation',
									class: this.menuToggle ? 'ontario-navigation ontario-navigation--open' : 'ontario-navigation',
									id: 'ontario-navigation',
								},
								hAsync(
									'div',
									{ class: 'ontario-navigation__container' },
									hAsync(
										'ul',
										null,
										this.menuItemState?.map((item, index) => {
											const lastLink = index + 1 === this.menuItemState.length;
											const activeLinkRegex = item.title.replace(/\s+/g, '-').toLowerCase();
											const linkIsActive = window.location.pathname.includes(activeLinkRegex);
											return this.isDynamicMenu
												? this.generateMenuItem(
														item.href,
														item.title,
														linkIsActive,
														'ontario-header',
														'ontario-header-navigation__menu-item',
														undefined,
														lastLink,
													)
												: this.generateMenuItem(
														item.href,
														item.title,
														item.linkIsActive,
														'ontario-header',
														'ontario-header-navigation__menu-item',
														item.onClickHandler,
														lastLink,
													);
										}),
									),
								),
							),
						),
						this.menuToggle && hAsync('div', { class: 'ontario-hide-for-large ontario-overlay' }),
					);
				} else {
					return hAsync(
						'div',
						null,
						hAsync(
							'div',
							{
								class: 'ontario-application-header-container',
								id: 'ontario-application-header',
								ref: (el) => (this.header = el),
							},
							hAsync(
								'header',
								{ class: 'ontario-application-header', id: 'ontario-header' },
								hAsync(
									'div',
									{ class: 'ontario-row' },
									hAsync(
										'div',
										{ class: 'ontario-columns ontario-small-6 ontario-application-header__logo' },
										hAsync(
											'a',
											{ href: this.translations.header.logoLink[`${this.language}`] },
											hAsync('img', {
												src: this.getImageAssetSrcPath('ontario-logo--desktop.svg'),
												alt: this.translations.header.logoAltText[`${this.language}`],
											}),
										),
									),
									hAsync(
										'div',
										{ class: 'ontario-columns ontario-small-6 ontario-application-header__lang-toggle' },
										hAsync('ontario-language-toggle', {
											size: 'small',
											url: this.language === 'en' ? this.languageState?.frenchLink : this.languageState?.englishLink,
											customLanguageToggle: this.customLanguageToggle,
										}),
									),
								),
							),
							hAsync(
								'div',
								{ class: 'ontario-application-subheader-menu__container' },
								hAsync(
									'section',
									{ class: `ontario-application-subheader ${isServiceOntarioType ? 'ontario-service-subheader' : ''}` },
									hAsync(
										'div',
										{ class: 'ontario-row' },
										hAsync(
											'div',
											{ class: 'ontario-columns ontario-small-12 ontario-application-subheader__container' },
											!isServiceOntarioType
												? hAsync(
														'p',
														{ class: 'ontario-application-subheader__heading' },
														hAsync(
															'a',
															{ href: this.applicationHeaderInfoState?.href },
															this.applicationHeaderInfoState?.title,
														),
													)
												: hAsync(
														'a',
														{ href: this.applicationHeaderInfoState?.href, class: 'ontario-service-subheader__link' },
														hAsync(
															'div',
															{ class: 'ontario-service-subheader__heading-container' },
															hAsync(
																'p',
																{ class: 'ontario-service-subheader__heading' },
																this.translations.header.serviceOntario[`${this.language}`],
															),
															hAsync(
																'p',
																{ class: 'ontario-service-subheader__description' },
																this.applicationHeaderInfoState?.title,
															),
														),
													),
											hAsync(
												'div',
												{ class: 'ontario-application-subheader__menu-container' },
												!!this.applicationHeaderInfoState?.maxSubheaderDesktopLinks &&
													hAsync(
														'ul',
														{
															class: `${
																isServiceOntarioType
																	? 'ontario-service-subheader__menu'
																	: 'ontario-application-subheader__menu'
															} ontario-show-for-large`,
														},
														this.menuItemState
															?.slice(0, this.applicationHeaderInfoState?.maxSubheaderDesktopLinks)
															.map((item) =>
																this.generateMenuItem(
																	item.href,
																	item.title,
																	item.linkIsActive,
																	'app-desktop',
																	'',
																	item.onClickHandler,
																),
															),
													),
												!!this.applicationHeaderInfoState?.maxSubheaderTabletLinks &&
													hAsync(
														'ul',
														{
															class:
																'ontario-application-subheader__menu ontario-hide-for-small ontario-show-for-medium ontario-hide-for-large',
														},
														this.menuItemState
															?.slice(0, this.applicationHeaderInfoState?.maxSubheaderTabletLinks)
															.map((item) =>
																this.generateMenuItem(
																	item.href,
																	item.title,
																	item.linkIsActive,
																	'app-tablet',
																	'',
																	item.onClickHandler,
																),
															),
													),
												!!this.applicationHeaderInfoState?.maxSubheaderMobileLinks &&
													hAsync(
														'ul',
														{ class: 'ontario-application-subheader__menu ontario-show-for-small-only' },
														this.menuItemState
															?.slice(0, this.applicationHeaderInfoState.maxSubheaderMobileLinks)
															.map((item) =>
																this.generateMenuItem(
																	item.href,
																	item.title,
																	item.linkIsActive,
																	'app-mobile',
																	'',
																	item.onClickHandler,
																),
															),
													),
												this.menuItemState !== undefined &&
													this.applicationHeaderInfoState?.maxSubheaderDesktopLinks !== this.menuItemState.length &&
													this.renderMenuButton('desktop'),
												this.menuItemState !== undefined &&
													this.applicationHeaderInfoState?.maxSubheaderTabletLinks !== this.menuItemState.length &&
													this.renderMenuButton('tablet'),
												this.menuItemState !== undefined &&
													this.applicationHeaderInfoState?.maxSubheaderMobileLinks !== this.menuItemState.length &&
													this.renderMenuButton('mobile'),
											),
										),
									),
								),
								hAsync(
									'nav',
									{
										role: 'navigation',
										class:
											this.menuToggle === true
												? 'ontario-application-navigation ontario-navigation--open'
												: 'ontario-application-navigation',
										id: 'ontario-application-navigation',
									},
									hAsync(
										'div',
										{ class: 'ontario-application-navigation__container' },
										hAsync(
											'ul',
											{ class: 'ontario-show-for-large' },
											this.menuItemState
												?.slice(this.applicationHeaderInfoState?.maxSubheaderDesktopLinks, this.menuItemState.length)
												.map((item, index) => {
													return this.generateNavigationLinks(
														item,
														index,
														this.applicationHeaderInfoState?.maxSubheaderDesktopLinks,
														'app-desktop',
													);
												}),
										),
										hAsync(
											'ul',
											{ class: 'ontario-show-for-medium ontario-hide-for-small ontario-hide-for-large' },
											this.menuItemState
												?.slice(this.applicationHeaderInfoState?.maxSubheaderTabletLinks, this.menuItemState.length)
												.map((item, index) => {
													return this.generateNavigationLinks(
														item,
														index,
														this.applicationHeaderInfoState?.maxSubheaderTabletLinks,
														'app-tablet',
													);
												}),
										),
										hAsync(
											'ul',
											{ class: 'ontario-show-for-small-only' },
											this.menuItemState
												?.slice(this.applicationHeaderInfoState?.maxSubheaderMobileLinks, this.menuItemState.length)
												.map((item, index) => {
													return this.generateNavigationLinks(
														item,
														index,
														this.applicationHeaderInfoState?.maxSubheaderMobileLinks,
														'app-mobile',
													);
												}),
										),
									),
								),
							),
						),
						this.menuToggle && hAsync('div', { class: 'ontario-hide-for-large ontario-overlay' }),
					);
				}
			}
			static get assetsDirs() {
				return ['./assets'];
			}
			static get watchers() {
				return {
					applicationHeaderInfo: ['parseApplicationHeaderInfo'],
					menuItems: ['parseMenuItems'],
					languageToggleOptions: ['parseLanguage'],
				};
			}
			static get style() {
				return {
					application: ontarioApplicationHeaderCss,
					ontario: ontarioHeaderCss,
					serviceOntario: serviceOntarioServiceOntarioHeaderCss,
				};
			}
			static get cmpMeta() {
				return {
					$flags$: 41,
					$tagName$: 'ontario-header',
					$members$: {
						type: [1],
						applicationHeaderInfo: [1, 'application-header-info'],
						menuItems: [1, 'menu-items'],
						disableDynamicMenu: [4, 'disable-dynamic-menu'],
						languageToggleOptions: [1, 'language-toggle-options'],
						customLanguageToggle: [16, 'custom-language-toggle'],
						language: [1025],
						assetBasePath: [1, 'asset-base-path'],
						applicationHeaderInfoState: [32],
						menuItemState: [32],
						isDynamicMenu: [32],
						languageState: [32],
						menuToggle: [32],
						searchToggle: [32],
						translations: [32],
					},
					$listeners$: [
						[10, 'click', 'handleClick'],
						[8, 'setAppLanguage', 'handleSetAppLanguage'],
						[8, 'headerLanguageToggled', 'handleLanguageToggle'],
					],
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioHintExpanderCss =
			'.ontario-hint-expander__button:focus,.ontario-hint-expander__button:active{box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:box-shadow 0.1s ease-in-out}.ontario-hint-expander__container{max-width:48rem}.ontario-hint-expander__button{color:#0066CC;cursor:pointer;background:none;border:none;display:flex;align-items:center;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-weight:400;font-size:1rem;text-align:left;margin:0 0 1rem 0;padding:0 0.25rem 0 0}.ontario-hint-expander__button-icon--close{display:none;margin-right:0.25rem}.ontario-hint-expander__button-icon--open{display:inline-block;margin-right:0.25rem}.ontario-hint-expander__button:hover{color:#00478F}.ontario-hint-expander__button:active{color:#002142}.ontario-hint-expander__button>*{pointer-events:none}.ontario-hint-expander__content{border-left:4px solid #cccccc;color:#1a1a1a;background-color:#f2f2f2;display:none;padding:1rem 1rem 1rem calc(1rem + 0.25rem);margin:0 0 1rem 0.25rem}.ontario-hint-expander__content *:first-child{margin-top:0}.ontario-hint-expander__content *:last-child{margin-bottom:0}.ontario-hint-expander__content img{width:100%}@media screen and (min-width: 40em){.ontario-hint-expander__content img{width:50%}}.ontario-hint-expander__content.ontario-expander__content--opened{display:block}.ontario-hint-expander__container.ontario-expander--active .ontario-hint-expander__button-icon--close{display:inline-block}.ontario-hint-expander__container.ontario-expander--active .ontario-hint-expander__button-icon--open{display:none}.ontario-hint-expander__checkbox-exists-true{margin:0.75rem 0 0 0.5rem}@media screen and (max-width: 40em){.ontario-hint-expander__checkbox-exists-true{margin-top:1rem}}.ontario-input+.ontario-hint-expander__container{margin-top:-1.5rem !important}.ontario-checkboxes__item .ontario-hint-expander__container,.ontario-radios__item .ontario-hint-expander__container{margin-left:0.5rem}.ontario-checkboxes__label+.ontario-hint-expander__container,.ontario-radios__label+.ontario-hint-expander__container{margin-top:0.75rem}@media screen and (max-width: 40em){.ontario-checkboxes__label+.ontario-hint-expander__container,.ontario-radios__label+.ontario-hint-expander__container{margin-top:1rem}}';

		class OntarioHintExpander {
			constructor(hostRef) {
				registerInstance(this, hostRef);
				this.toggleExpanderEvent = createEvent(this, 'toggleExpanderEvent');
			}
			get host() {
				return getElement(this);
			}
			/**
			 * The content type of the hint.
			 * If no prop is passed, it will default to a string.
			 * If the hint requires multiple lines or HTML, the `hintContentType` prop should be set to `html`.
			 */
			hintContentType = 'string';
			/**
			 * Text to display as the hint expander question/statement
			 */
			hint;
			/**
			 * Content to display as the hint, once the expander is toggled open.
			 * Please note that any content that is passed into this prop will only be displayed as a string.
			 * If you would like to add HTML content, supply child content to the component.
			 *
			 * @example
			 * <ontario-hint-expander hint="This is the hint"
			 *   <img src="https://www.jquery-az.com/html/images/banana.jpg" title="Title of image" alt="alt text here"/>
			 *   <p> Here is the content beside the image </p>
			 * </ontario-hint-expander>
			 */
			content;
			/**
			 * Used to used to establish a relationship between hint text content and elements using aria-describedby. This is optional - if no ID is passed, one will be generated.
			 */
			elementId;
			hintState;
			/**
			 * Emitted when a keyboard input or mouse event occurs.
			 */
			toggleExpanderEvent;
			/**
			 * Watch for changes to the `hintContentType` prop for validation purposes.
			 * If none is provided, or the wrong type is provided, it will default to `string`.
			 */
			checkHintContentType() {
				if (this.hintContentType !== 'string' && this.hintContentType !== 'html') {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' hintContentType ')
						.addRegularText('for')
						.addMonospaceText(' <ontario-hint-text> ')
						.addRegularText('was not one of the permitted types. A default type of `string` will be applied.')
						.printMessage();
					return (this.hintContentType = 'string');
				}
				return this.hintContentType;
			}
			/*
			 * Watch for changes in the `hint` prop for validation purposes.
			 * If no `hint` prop is provided, the `hint` will be set to the host element textContent (if it exists).
			 */
			updateHintContent() {
				this.hintState = this.hint ?? this.host.textContent ?? '';
				this.validateHint(this.hintState);
			}
			/*
			 * Watch for changes to the `content` prop for validation purposes.
			 *
			 * Validate the `content` and make sure the `content` has a value.
			 * Log a warning if user doesn't input a value for the `content` or element content.
			 */
			validateContent(newValue) {
				if (validatePropExists(newValue)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' content ')
						.addRegularText('for')
						.addMonospaceText(' <ontario-hint-expander> ')
						.addRegularText('was not provided')
						.printMessage();
				}
			}
			onClick = (ev) => {
				const hintExpander = ev.target;
				const hintExpanderParent = hintExpander?.parentElement;
				hintExpanderParent?.classList.toggle('ontario-expander--active');
				let content = hintExpanderParent?.querySelector("[data-toggle='ontario-expander-content']");
				content?.classList.toggle('ontario-expander__content--opened');
				content?.classList.contains('ontario-expander__content--opened')
					? content.setAttribute('aria-hidden', 'false')
					: content?.setAttribute('aria-hidden', 'true');
				hintExpanderParent?.classList.contains('ontario-expander--active')
					? hintExpanderParent?.setAttribute('aria-expanded', 'true')
					: hintExpanderParent?.setAttribute('aria-expanded', 'false');
				this.toggleExpanderEvent.emit(ev);
			};
			/*
			 * Watch for changes in the `hint` prop for validation purposes.
			 *
			 * Validate the `hint` and make sure the `hint` has a value.
			 * Log a warning if user doesn't input a value for the `hint`.
			 */
			validateHint(newValue) {
				if (validatePropExists(newValue)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' hint ')
						.addRegularText('for')
						.addMonospaceText(' <ontario-hint-expander> ')
						.addRegularText('was not provided')
						.printMessage();
				}
			}
			/**
			 * Set `hint` using internal component logic
			 */
			componentWillLoad() {
				this.elementId = this.elementId ?? v4();
				this.updateHintContent();
				this.checkHintContentType();
				this.validateContent(this.content);
			}
			/**
			 * This helper is used to help load translations for any slots + text content passed in by the user.
			 */
			componentDidLoad() {
				const observer = new MutationObserver((mutations) => {
					mutations.forEach((mutation) => {
						if (mutation.type === 'attributes') {
							this.updateHintContent();
						}
					});
				});
				const options = { attributes: true };
				observer.observe(this.host, options);
			}
			getId() {
				return this.elementId ?? '';
			}
			render() {
				return hAsync(
					'div',
					{ key: 'de3d223cc99fe939b37472aeb127046ad1e7cfb4', class: 'ontario-hint-expander__container' },
					hAsync(
						'button',
						{
							'key': '3102d97aa969066c32c20a8967eff971e0134f76',
							'class': 'ontario-hint-expander__button',
							'onClick': this.onClick,
							'id': `hint-expander-button-${this.getId()}`,
							'aria-controls': `hint-expander-content-${this.getId()}`,
							'aria-expanded': 'false',
							'data-toggle': 'ontario-collapse',
						},
						hAsync(
							'span',
							{
								key: 'b8856b64b6f4319ccac743a6f2c9a742648a2b18',
								class: 'ontario-hint-expander__button-icon--close ontario-icon',
							},
							hAsync('ontario-icon-chevron-up', { key: '6aa07816393bc8768e0304b58c66226e7502ca8a', colour: 'inherit' }),
						),
						hAsync(
							'span',
							{ key: '5bfe9d549dfcce83d26ec351856d3cc1c1f4d9c2', class: 'ontario-hint-expander__button-icon--open' },
							hAsync('ontario-icon-chevron-down', {
								key: '24650b2b0254fe5429cb43195d93f2b3a653b168',
								colour: 'inherit',
							}),
						),
						this.hint,
					),
					hAsync(
						'div',
						{
							'key': '7925aa9f5f883ecb0739cdb068b1a1cfe2b40714',
							'class': 'ontario-hint-expander__content',
							'id': `hint-expander-content-${this.getId()}`,
							'aria-labelledby': `hint-expander-button-${this.getId()}`,
							'aria-hidden': 'true',
							'data-toggle': 'ontario-expander-content',
						},
						this.hintContentType === 'string' ? this.content : hAsync('span', { innerHTML: this.content }),
					),
				);
			}
			static get watchers() {
				return {
					hintContentType: ['checkHintContentType'],
					hint: ['updateHintContent'],
					content: ['validateContent'],
				};
			}
			static get style() {
				return ontarioHintExpanderCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-hint-expander',
					$members$: {
						hintContentType: [1025, 'hint-content-type'],
						hint: [1],
						content: [1025],
						elementId: [1025, 'element-id'],
						hintState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioHintTextCss =
			'.ontario-hint{color:#4d4d4d;display:inline-block;margin:0 0 1rem 0;width:100%;max-width:48rem}.ontario-hint p{margin-bottom:1rem}.ontario-hint p:first-of-type{margin-top:0}.ontario-hint p:last-of-type{margin-bottom:0}.ontario-hint a[x-apple-data-detectors]{color:inherit;cursor:none;text-decoration:none}';

		/**
		 * Use hint text to help users understand how to complete fields in a form.
		 *
		 * @part hint-text - The container for the hint text content. This part can be used to apply custom styles to the hint text.
		 */
		class OntarioHintText {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			get host() {
				return getElement(this);
			}
			/**
			 * The content type of the hint.
			 * If no prop is passed, it will default to a string.
			 * If the hint requires multiple lines or HTML, the `hintContentType` prop should be set to `html`.
			 */
			hintContentType = 'string';
			/**
			 * Text to display as the hint text statement.
			 *
			 * Setting the hint can be done using the host element textContent or through setting this property.  This property will take precedence.
			 *
			 * @example
			 * <ontario-hint-text hint="Override Hint Text">Hint Text</ontario-button>
			 *
			 * The resulting hint text will display `"Override Hint Text"`.
			 */
			hint;
			/*
			 * Used to establish a relationship between the hint text content and elements using aria-describedby. This is optional -  if no ID is provided, one will be generated.
			 */
			elementId;
			hintState;
			/**
			 * @part hint-text - The container for the hint text content. This part can be used to apply custom styles to the hint text.
			 */
			/**
			 * Watch for changes to the `hintContentType` prop for validation purposes.
			 * If none is provided, or the wrong type is provided, it will default to `string`.
			 */
			checkHintContentType() {
				if (this.hintContentType !== 'string' && this.hintContentType !== 'html') {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' hintContentType ')
						.addRegularText('for')
						.addMonospaceText(' <ontario-hint-text> ')
						.addRegularText('was not one of the permitted types. A default type of `string` will be applied.')
						.printMessage();
					return (this.hintContentType = 'string');
				}
				return this.hintContentType;
			}
			/*
			 * Watch for changes in the `hint` prop for validation purposes.
			 * If no `hint` prop is provided, the `hint` will be set to the host element textContent (if it exists).
			 */
			updateHintContent() {
				this.hintState = this.hint ?? this.host.textContent ?? '';
				this.validateHintContent(this.hintState);
			}
			/*
			 * Validate the `hint` and make sure the `hint` has a value.
			 * Log a warning if user doesn't input a value for the `hint` or element content.
			 */
			validateHintContent(newValue) {
				// If element content is not provided, check whether prop exists
				if (!this.host.textContent) {
					if (validatePropExists(newValue)) {
						const message = new ConsoleMessageClass();
						message
							.addDesignSystemTag()
							.addMonospaceText(' hint ')
							.addRegularText('for')
							.addMonospaceText(' <ontario-hint-text> ')
							.addRegularText('was not provided')
							.printMessage();
					}
				}
			}
			getId() {
				return this.elementId ?? '';
			}
			/**
			 * This method returns the ontario-hint-text id. It is used to make sure the hint text and `aria-describedby` value of other form components match when the internal hint text props are used.
			 *
			 * @returns Promise<string | undefined>
			 */
			async getHintTextId() {
				return this.elementId;
			}
			/**
			 * Set `hint` using internal component logic
			 */
			componentWillLoad() {
				this.updateHintContent();
				this.checkHintContentType();
				this.elementId = this.elementId ?? v4();
			}
			/**
			 * This helper is used to help load translations for any slots + text content passed in by the user.
			 */
			componentDidLoad() {
				const observer = new MutationObserver((mutations) => {
					mutations.forEach((mutation) => {
						if (mutation.type === 'attributes') {
							this.updateHintContent();
						}
					});
				});
				const options = { attributes: true };
				observer.observe(this.host, options);
			}
			render() {
				return this.hintContentType === 'string'
					? hAsync('p', { part: 'hint-text', id: this.getId(), class: 'ontario-hint' }, this.hintState)
					: hAsync('div', { id: this.getId(), class: 'ontario-hint', innerHTML: this.hintState });
			}
			static get watchers() {
				return {
					hintContentType: ['checkHintContentType'],
					hint: ['updateHintContent'],
				};
			}
			static get style() {
				return ontarioHintTextCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-hint-text',
					$members$: {
						hintContentType: [1025, 'hint-content-type'],
						hint: [1],
						elementId: [1025, 'element-id'],
						hintState: [32],
						getHintTextId: [64],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const IconColours = ['black', 'blue', 'grey', 'white', 'inherit'];

		function getDefaultExportFromCjs(x) {
			return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
		}

		var lib;
		var hasRequiredLib;

		function requireLib() {
			if (hasRequiredLib) return lib;
			hasRequiredLib = 1;
			lib = (function (e) {
				var r = {};
				function t(n) {
					if (r[n]) return r[n].exports;
					var a = (r[n] = { i: n, l: false, exports: {} });
					return e[n].call(a.exports, a, a.exports, t), (a.l = true), a.exports;
				}
				return (
					(t.m = e),
					(t.c = r),
					(t.d = function (e, r, n) {
						t.o(e, r) || Object.defineProperty(e, r, { enumerable: true, get: n });
					}),
					(t.r = function (e) {
						'undefined' != typeof Symbol &&
							Symbol.toStringTag &&
							Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' }),
							Object.defineProperty(e, '__esModule', { value: true });
					}),
					(t.t = function (e, r) {
						if ((1 & r && (e = t(e)), 8 & r)) return e;
						if (4 & r && 'object' == typeof e && e && e.__esModule) return e;
						var n = Object.create(null);
						if (
							(t.r(n),
							Object.defineProperty(n, 'default', { enumerable: true, value: e }),
							2 & r && 'string' != typeof e)
						)
							for (var a in e)
								t.d(
									n,
									a,
									function (r) {
										return e[r];
									}.bind(null, a),
								);
						return n;
					}),
					(t.n = function (e) {
						var r =
							e && e.__esModule
								? function () {
										return e.default;
									}
								: function () {
										return e;
									};
						return t.d(r, 'a', r), r;
					}),
					(t.o = function (e, r) {
						return Object.prototype.hasOwnProperty.call(e, r);
					}),
					(t.p = ''),
					t((t.s = 0))
				);
			})([
				function (e, r, t) {
					t.r(r),
						t.d(r, 'validateHTMLColorName', function () {
							return l;
						}),
						t.d(r, 'validateHTMLColorSpecialName', function () {
							return i;
						}),
						t.d(r, 'validateHTMLColorHex', function () {
							return u;
						}),
						t.d(r, 'validateHTMLColorRgb', function () {
							return g;
						}),
						t.d(r, 'validateHTMLColorHsl', function () {
							return y;
						}),
						t.d(r, 'validateHTMLColorHwb', function () {
							return L;
						}),
						t.d(r, 'validateHTMLColorLab', function () {
							return S;
						}),
						t.d(r, 'validateHTMLColorLch', function () {
							return m;
						}),
						t.d(r, 'validateHTMLColor', function () {
							return G;
						});
					const n = (e) => e && 'string' == typeof e,
						a = [
							'AliceBlue',
							'AntiqueWhite',
							'Aqua',
							'Aquamarine',
							'Azure',
							'Beige',
							'Bisque',
							'Black',
							'BlanchedAlmond',
							'Blue',
							'BlueViolet',
							'Brown',
							'BurlyWood',
							'CadetBlue',
							'Chartreuse',
							'Chocolate',
							'Coral',
							'CornflowerBlue',
							'Cornsilk',
							'Crimson',
							'Cyan',
							'DarkBlue',
							'DarkCyan',
							'DarkGoldenrod',
							'DarkGray',
							'DarkGrey',
							'DarkGreen',
							'DarkKhaki',
							'DarkMagenta',
							'DarkOliveGreen',
							'DarkOrange',
							'DarkOrchid',
							'DarkRed',
							'DarkSalmon',
							'DarkSeaGreen',
							'DarkSlateBlue',
							'DarkSlateGray',
							'DarkSlateGrey',
							'DarkTurquoise',
							'DarkViolet',
							'DeepPink',
							'DeepSkyBlue',
							'DimGray',
							'DimGrey',
							'DodgerBlue',
							'FireBrick',
							'FloralWhite',
							'ForestGreen',
							'Fuchsia',
							'Gainsboro',
							'GhostWhite',
							'Gold',
							'Goldenrod',
							'Gray',
							'Grey',
							'Green',
							'GreenYellow',
							'HoneyDew',
							'HotPink',
							'IndianRed',
							'Indigo',
							'Ivory',
							'Khaki',
							'Lavender',
							'LavenderBlush',
							'LawnGreen',
							'LemonChiffon',
							'LightBlue',
							'LightCoral',
							'LightCyan',
							'LightGoldenrodYellow',
							'LightGray',
							'LightGrey',
							'LightGreen',
							'LightPink',
							'LightSalmon',
							'LightSalmon',
							'LightSeaGreen',
							'LightSkyBlue',
							'LightSlateGray',
							'LightSlateGrey',
							'LightSteelBlue',
							'LightYellow',
							'Lime',
							'LimeGreen',
							'Linen',
							'Magenta',
							'Maroon',
							'MediumAquamarine',
							'MediumBlue',
							'MediumOrchid',
							'MediumPurple',
							'MediumSeaGreen',
							'MediumSlateBlue',
							'MediumSlateBlue',
							'MediumSpringGreen',
							'MediumTurquoise',
							'MediumVioletRed',
							'MidnightBlue',
							'MintCream',
							'MistyRose',
							'Moccasin',
							'NavajoWhite',
							'Navy',
							'OldLace',
							'Olive',
							'OliveDrab',
							'Orange',
							'OrangeRed',
							'Orchid',
							'PaleGoldenrod',
							'PaleGreen',
							'PaleTurquoise',
							'PaleVioletRed',
							'PapayaWhip',
							'PeachPuff',
							'Peru',
							'Pink',
							'Plum',
							'PowderBlue',
							'Purple',
							'RebeccaPurple',
							'Red',
							'RosyBrown',
							'RoyalBlue',
							'SaddleBrown',
							'Salmon',
							'SandyBrown',
							'SeaGreen',
							'SeaShell',
							'Sienna',
							'Silver',
							'SkyBlue',
							'SlateBlue',
							'SlateGray',
							'SlateGrey',
							'Snow',
							'SpringGreen',
							'SteelBlue',
							'Tan',
							'Teal',
							'Thistle',
							'Tomato',
							'Turquoise',
							'Violet',
							'Wheat',
							'White',
							'WhiteSmoke',
							'Yellow',
							'YellowGreen',
						],
						o = ['currentColor', 'inherit', 'transparent'],
						l = (e) => {
							let r = false;
							return n(e) && a.map((t) => (e.toLowerCase() === t.toLowerCase() && (r = true), null)), r;
						},
						i = (e) => {
							let r = false;
							return n(e) && o.map((t) => (e.toLowerCase() === t.toLowerCase() && (r = true), null)), r;
						},
						u = (e) => {
							if (n(e)) {
								const r = /^#([\da-f]{3}){1,2}$|^#([\da-f]{4}){1,2}$/i;
								return e && r.test(e);
							}
							return false;
						},
						d = '(([\\d]{0,5})((\\.([\\d]{1,5}))?))',
						s = `(${d}%)`,
						c = '(([0-9]|[1-9][0-9]|100)%)',
						f = `(${c}|(0?((\\.([\\d]{1,5}))?))|1)`,
						h = `([\\s]{0,5})\\)?)(([\\s]{0,5})(\\/?)([\\s]{1,5})${`(((${c}))|(0?((\\.([\\d]{1,5}))?))|1))?`}([\\s]{0,5})\\)`,
						$ = '(-?(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-9][0-9]|3[0-5][0-9])((\\.([\\d]{1,5}))?)|360)(deg)?)',
						g = (e) => {
							if (n(e)) {
								const r = '([\\s]{0,5})([\\d]{1,5})%?([\\s]{0,5}),?',
									t = '((([\\s]{0,5}),?([\\s]{0,5}))|(([\\s]{1,5})))',
									n = new RegExp(
										`^(rgb)a?\\(${`${r}${t}`}${`${r}${t}`}${`${r}${t}`}(${'(\\/?([\\s]{0,5})(0?\\.?([\\d]{1,5})%?([\\s]{0,5}))?|1|0)'})?\\)$`,
									);
								return e && n.test(e);
							}
							return false;
						},
						y = (e) => {
							if (n(e)) {
								const r = new RegExp(
									`^(hsl)a?\\((([\\s]{0,5})(${$}|${'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-9][0-9]|3[0-9][0-9]|400)grad)'}|${'((([0-5])?\\.([\\d]{1,5})|6\\.([0-9]|1[0-9]|2[0-8])|[0-6])rad)'}|${'((0?((\\.([\\d]{1,5}))?)|1)turn)'})((([\\s]{0,5}),([\\s]{0,5}))|(([\\s]{1,5}))))(([\\s]{0,5})(0|${c})((([\\s]{0,5}),([\\s]{0,5}))|(([\\s]{1,5}))))(([\\s]{0,5})(0|${c})([\\s]{0,5})\\)?)(([\\s]{0,5})(\\/?|,?)([\\s]{0,5})(((${c}))|(0?((\\.([\\d]{1,5}))?))|1))?\\)$`,
								);
								return e && r.test(e);
							}
							return false;
						},
						L = (e) => {
							if (n(e)) {
								const r = new RegExp(`^(hwb\\(([\\s]{0,5})${$}([\\s]{1,5}))((0|${c})([\\s]{1,5}))((0|${c})${h}$`);
								return e && r.test(e);
							}
							return false;
						},
						S = (e) => {
							if (n(e)) {
								const r = '(-?(([0-9]|[1-9][0-9]|1[0-5][0-9])((\\.([\\d]{1,5}))?)?|160))',
									t = new RegExp(`^(lab\\(([\\s]{0,5})${s}([\\s]{1,5})${r}([\\s]{1,5})${r}${h}$`);
								return e && t.test(e);
							}
							return false;
						},
						m = (e) => {
							if (n(e)) {
								const r = '((([0-9]|[1-9][0-9])?((\\.([\\d]{1,5}))?)|100)(%)?)',
									t = '' + d,
									n = `((${$})|(0|${f})|(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-9][0-9]|3[0-5][0-9])((\\.([\\d]{1,5}))?)|360))`,
									a = `(\\/([\\s]{0,5})${f})`,
									o = new RegExp(
										`^lch\\(${`(([\\s]{0,5})${r}([\\s]{1,5})${t}([\\s]{1,5})${n}([\\s]{0,5})(${a})?)`}\\)$`,
									);
								return e && o.test(e);
							}
							return false;
						},
						G = (e) => !!((e && u(e)) || g(e) || y(e) || L(e) || S(e) || m(e));
					r.default = (e) => !!((e && u(e)) || l(e) || i(e) || g(e) || y(e) || L(e) || S(e) || m(e));
				},
			]);
			return lib;
		}

		var libExports = requireLib();
		var validateColor = /*@__PURE__*/ getDefaultExportFromCjs(libExports);

		const ontarioIconCss$1L =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconAccessibility {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-accessibility> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-accessibility> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '040815161873ef2b245e5b6d5c60cc94bbb75757',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'a930d586c1ef0ade8f956195e130c8016a899b96',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'accessibility',
						},
						hAsync('path', {
							key: '168f3f757d0367975973cc582abe6457e0a3bec6',
							d: 'M18.4 11.2l-4.1.2 2.3-2.6c.2-.3.3-.8.2-1.3-.1-.3-.2-.6-.5-.8l-5.4-3.2c-.4-.3-1-.2-1.4.1L6.8 6.1c-.5.5-.6 1.2-.1 1.7.4.5 1.2.5 1.7.1l2-1.8 1.9 1.1-4.2 4.3c-.1.1-.1.2-.2.2-.5.2-1 .4-1.4.7L8 13.9c.5-.2 1-.4 1.5-.4 1.9 0 3.5 1.6 3.5 3.5 0 .6-.1 1.1-.4 1.5l1.5 1.5a5.29 5.29 0 0 0 .9-3c0-1.2-.4-2.4-1.1-3.3l3.3-.3-.2 4.8c-.1.7.4 1.2 1.1 1.3h.1c.6 0 1.1-.5 1.2-1.1l.2-5.9c0-.3-.1-.7-.3-.9-.3-.3-.6-.4-.9-.4zM18 5.5a2 2 0 0 0 2-2 2 2 0 0 0-2-2 2 2 0 0 0-2 2 2 2 0 0 0 2 2zm-5.5 16.1a5.29 5.29 0 0 1-3 .9C6.5 22.5 4 20 4 17a5.29 5.29 0 0 1 .9-3l1.5 1.5c-.2.5-.4 1-.4 1.5 0 1.9 1.6 3.5 3.5 3.5.6 0 1.1-.1 1.5-.4l1.5 1.5z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1L;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-accessibility',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1K =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconAccount {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-account> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-account> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '6ba362a8d293aa134d80a87dcefeedf9d64dabd7',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'cf481c3817c885ecfaac8fcc3456697dbc6e2c66',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'account',
						},
						hAsync('path', {
							key: 'f65d143f0df70cc4478a3c0d9755a774624d348e',
							d: 'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2a7.2 7.2 0 0 1-6-3.22c.03-2 4-3.08 6-3.08 2 0 5.97 1.1 6 3.08a7.2 7.2 0 0 1-6 3.22z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1K;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-account',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1J =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconAdd {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-add> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-add> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '4f0970fd732d581fefb8bf4ff18ffb0dad51163a',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '2d3cef39bc4396cac16fa7efc7e54a3198dd6874',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							fill: 'none',
							viewBox: '0 0 24 24',
							id: 'add',
						},
						hAsync('path', {
							key: 'dca068d0e4dddd70ced1ba8949a56c9376f1aa6d',
							d: 'M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.4 0-8-3.6-8-8s3.6-8 8-8 8 3.6 8 8-3.6 8-8 8z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1J;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-add',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1I =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconAddAlt {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-add-alt> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-add-alt> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '19b33d29e8d859375523f72fbffef8a8d1941376',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '988d8bf41a119186089d7462a6818ccedc539d5f',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							fill: 'none',
							viewBox: '0 0 24 24',
							id: 'add-alt',
						},
						hAsync('path', {
							key: '74e64ba1180107a248544077b11fd65f671e6f3e',
							d: 'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1I;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-add-alt',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1H =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconAlertError {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-alert-error> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			get host() {
				return getElement(this);
			}
			/**
			 * Validate that the `colour` attribute is not set by users
			 * Prints a warning message if the `colour` attribute is set
			 */
			validateColour() {
				if (this.host.hasAttribute('colour')) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' colour ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-alert-error> ')
						.addRegularText('cannot be set. The provided colour is ignored.')
						.printMessage();
				}
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '080d9965b36782f0044f4c6b0728fd820df73830',
						class: `ontario-icon ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '0c066c0777fdf1adea3fa6b49a42e5b29ec72a40',
							class: 'svg-icon',
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							fill: 'none',
							viewBox: '0 0 24 24',
							id: 'alert-error',
						},
						hAsync('path', {
							key: 'b5c90bab331d620b89732891e89b36cca164b107',
							d: 'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z',
							fill: '#cd0000',
						}),
						hAsync('path', {
							key: '8e73e0ca55b20a1637e73ff3bb2ad6869c77ba8b',
							d: 'M11 17h2v-2h-2v2zm0-4h2V7h-2v6z',
							fill: '#fff',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
				};
			}
			static get style() {
				return ontarioIconCss$1H;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-alert-error',
					$members$: {
						iconWidth: [2, 'icon-width'],
						iconWidthState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1G =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconAlertInformation {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-alert-information> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			get host() {
				return getElement(this);
			}
			/**
			 * Validate that the `colour` attribute is not set by users
			 * Prints a warning message if the `colour` attribute is set
			 */
			validateColour() {
				if (this.host.hasAttribute('colour')) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' colour ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-alert-information> ')
						.addRegularText('cannot be set. The provided colour is ignored.')
						.printMessage();
				}
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '935a6e02a60f34c00fccc4666731b941a64fdd80',
						class: `ontario-icon ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'df00c3b6aa230d601849f1c6a59d8dc8084ab4ab',
							class: 'svg-icon',
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							fill: 'none',
							viewBox: '0 0 24 24',
							id: 'alert-information',
						},
						hAsync('path', {
							key: '1200f4af6c8629dfdf9c0bd28f334e1a41dfabee',
							d: 'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z',
							fill: '#1080a6',
						}),
						hAsync('path', {
							key: '9169dd8b56c5ab208bfc2defd275e907c2b4739f',
							d: 'M11 17h2v-6h-2v6zm0-8h2V7h-2v2z',
							fill: '#fff',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
				};
			}
			static get style() {
				return ontarioIconCss$1G;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-alert-information',
					$members$: {
						iconWidth: [2, 'icon-width'],
						iconWidthState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1F =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconAlertSuccess {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-alert-success> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			get host() {
				return getElement(this);
			}
			/**
			 * Validate that the `colour` attribute is not set by users
			 * Prints a warning message if the `colour` attribute is set
			 */
			validateColour() {
				if (this.host.hasAttribute('colour')) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' colour ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-alert-success> ')
						.addRegularText('cannot be set. The provided colour is ignored.')
						.printMessage();
				}
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '8f6cb16d77b3a8de266c0b9c66ce922c723ee3df',
						class: `ontario-icon ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '06ba52d0725b5da030d1f91bd809c227a4ed830d',
							class: 'svg-icon',
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							fill: 'none',
							viewBox: '0 0 24 24',
							id: 'alert-success',
						},
						hAsync('path', {
							key: '583067de0785a0715df027714f7bf9a41ce6bdc1',
							d: 'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.4-1.4 3.6 3.58L17.17 7l1.4 1.42L10 17z',
							fill: '#118847',
						}),
						hAsync('path', {
							key: '01ca5b79dc1a9bf7ded054fd93905d5dc2ec5c86',
							d: 'M5 12l5 5 8.58-8.58L17.17 7 10 14.17 6.4 10.6 5 12z',
							fill: '#fff',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
				};
			}
			static get style() {
				return ontarioIconCss$1F;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-alert-success',
					$members$: {
						iconWidth: [2, 'icon-width'],
						iconWidthState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1E =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconAlertWarning {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-alert-warning> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			get host() {
				return getElement(this);
			}
			/**
			 * Validate that the `colour` attribute is not set by users
			 * Prints a warning message if the `colour` attribute is set
			 */
			validateColour() {
				if (this.host.hasAttribute('colour')) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' colour ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-alert-warning> ')
						.addRegularText('cannot be set. The provided colour is ignored.')
						.printMessage();
				}
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '7fc27406ecbba9ea1c361e68dd2bdf195cd0f482',
						class: `ontario-icon ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '134ba2924fd2969dbc70ba0f99ec644f548de60f',
							class: 'svg-icon',
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							fill: 'none',
							viewBox: '0 0 24 24',
							id: 'alert-warning',
						},
						hAsync('path', {
							key: '0aa5ae9fccf4db8d83e00eb75479ac1380829dce',
							d: 'M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z',
							fill: '#ffd440',
						}),
						hAsync('path', {
							key: '307169b7a8f7ad94c6c7c838cddccd2d3df2dd90',
							d: 'M11 10h2v4h-2zm0 6h2v2h-2z',
							fill: '#000',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
				};
			}
			static get style() {
				return ontarioIconCss$1E;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-alert-warning',
					$members$: {
						iconWidth: [2, 'icon-width'],
						iconWidthState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1D =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconArrowUp {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-arrow-up> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-arrow-up> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'cb71ff461c7b1a6ebd212002e517befa8b51f2cc',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'd6edc46d675110d43a137db9fef11255bde128db',
							class: 'ontario-icon',
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							fill: '#000000',
							id: 'arrow-up',
						},
						hAsync('path', { key: 'bb064cc3fb612dc1550906c2d214d912e08aa312', d: 'M0 0h24v24H0V0z', fill: 'none' }),
						hAsync('path', {
							key: '51d8ada57f5ba1b2171643cdb1f5ee31d3012bf8',
							d: 'M4 12l1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1D;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-arrow-up',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1C =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconAttach {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-attach> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-attach> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'e5b60babcc9301c78721997bbd375388ae19c658',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'ee7ba29426a89a0690fe03fbeaebca516a08327d',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							fill: 'none',
							viewBox: '0 0 24 24',
							id: 'attach',
						},
						hAsync('path', {
							key: '66c2452af99ad9706463ad02477529d8461203a3',
							d: 'M16.5 6v11.5a4 4 0 1 1-8 0V5a2.5 2.5 0 1 1 5 0v10.5c0 .55-.45 1-1 1s-1-.45-1-1V6H10v9.5a2.5 2.5 0 1 0 5 0V5a4 4 0 1 0-8 0v12.5a5.5 5.5 0 1 0 11 0V6h-1.5z',
							fill: '#000',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1C;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-attach',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1B =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconBookmarkOff {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-bookmark-off> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-bookmark-off> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'c0dc21cd56c7116e067100eb8de8074939ba5ada',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'bd81149d021fc0189b06ae027f7f10881d2ff1e5',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'bookmark-off',
						},
						hAsync('path', {
							key: '9a3385062a7b80cda5bdf315ebb1147b00d24bb8',
							d: 'M17 3H7c-1.1 0-2 .9-2 2v16l7-3 7 3V5c0-1.1-.9-2-2-2zm0 15l-5-2.18L7 18V5h10v13z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1B;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-bookmark-off',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1A =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconBookmarkOn {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-bookmark-on> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-bookmark-on> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '783ff1ebe859ca90a303149ee9379ee0917841e5',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '598a4569ccbfbc08af1dd02815ecaefaf1d4a722',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'bookmark-on',
						},
						hAsync('path', {
							key: '3a888a982c03f40b1038d8102fe33c7abc53c5be',
							d: 'M17 3H7c-1.1 0-2 .9-2 2v16l7-3 7 3V5c0-1.1-.9-2-2-2z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1A;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-bookmark-on',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1z =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconCalendar {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-calendar> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-calendar> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '53f2999425630aa7f29057a0d394a3e6a793bc23',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '7c66f8602085002307be98269f54d77cce53e87a',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'calendar',
						},
						hAsync('path', {
							key: '19224d6c879786bd0eaa80eca308a862bc43e251',
							d: 'M9 10v2H7v-2h2zm4 0v2h-2v-2h2zm4 0v2h-2v-2h2zm2-7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h1V1h2v2h8V1h2v2h1zm0 16V8H5v11h14zM9 14v2H7v-2h2zm4 0v2h-2v-2h2zm4 0v2h-2v-2h2z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1z;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-calendar',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1y =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconCamera {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-camera> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-camera> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'c072eb0c3365a2d086f4e8ab793051aa8242f31a',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '4a4df9f36bd81d18a3f5e381c9f534140f04f92f',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'camera',
						},
						hAsync('path', {
							key: '791583bf4d6c91537463d8fd09c1e086f92d8d68',
							d: 'M9 2L7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2h-3.17L15 2H9zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-1.8a3.2 3.2 0 0 0 0-6.4 3.2 3.2 0 1 0 0 6.4z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1y;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-camera',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1x =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconChevronDown {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-chevron-down> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-chevron-down> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '31bfbfe1ccf2e4490f982d3dc9e6547eccadce67',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '51441a939395015afd1a6c613899248309eae5f1',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							fill: 'none',
							viewBox: '0 0 24 24',
							id: 'chevron-down',
						},
						hAsync('path', {
							key: '659488c567c4cea091069202ea474e63e503ff95',
							d: 'M7.4 8.6l4.6 4.58 4.6-4.58L18 10l-6 6-6-6 1.4-1.4z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1x;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-chevron-down',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1w =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconChevronLeft {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-chevron-left> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-chevron-left> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'd0367cc400f7dafaadd4446cc49f94751b08823f',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '4e828ea6cf7316ad20016972c92c77556208433e',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							fill: 'none',
							viewBox: '0 0 24 24',
							id: 'chevron-left',
						},
						hAsync('path', {
							key: 'f23f80e605887912ba55e1180eb380f2a2c13f02',
							d: 'M15.4 7.4L14 6l-6 6 6 6 1.4-1.4-4.58-4.6 4.58-4.6z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1w;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-chevron-left',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1v =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconChevronRight {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-chevron-right> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-chevron-right> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '4dd0b383f5b6c0ebbf2a86cb6320b08f52346d84',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'ae88b227bb985225013521411d25659f4546f5dc',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							fill: 'none',
							viewBox: '0 0 24 24',
							id: 'chevron-right',
						},
						hAsync('path', {
							key: 'e1ed07083ea893a97ad9609d0387c31dbcc5fcd4',
							d: 'M10 6L8.6 7.4l4.58 4.6-4.58 4.6L10 18l6-6-6-6z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1v;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-chevron-right',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1u =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconChevronUp {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-chevron-up> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-chevron-up> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '780efdb611a36ef2f1c85367e965749a78de0a9e',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '23988058cb5a09c78dbf098a33b1ceaab1b6c1fa',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							fill: 'none',
							viewBox: '0 0 24 24',
							id: 'chevron-up',
						},
						hAsync('path', {
							key: '99d9025adf888efe8c5527dcece7a89198ae241d',
							d: 'M7.4 15.4l4.6-4.58 4.6 4.58L18 14l-6-6-6 6 1.4 1.4z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1u;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-chevron-up',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1t =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconClock {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-clock> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-clock> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'ae7c83582f991b73743e027920e6623bdded3d94',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '4dcd4dbe69326b66c2d9ea7ae01b6b2668962666',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'clock',
						},
						hAsync('path', {
							key: '57a93938a43dc71a5418c277693a4341775f7035',
							d: 'M12 2a10 10 0 0 0-7.071 2.929 10 10 0 0 0 0 14.142A10 10 0 0 0 12 22a10 10 0 0 0 10-10 10 10 0 0 0-2.929-7.071A10 10 0 0 0 12 2zm4.2 14.2L11 13V7h1.5v5.2l4.5 2.7-.8 1.3z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1t;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-clock',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1s =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconClose {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-close> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-close> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '91d3d8f6e75d07768ddfb985a6d1dad1377bf71b',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '72c130b464f3bd2668e8640f1a7d19dda9babf66',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							fill: 'none',
							viewBox: '0 0 24 24',
							id: 'close',
						},
						hAsync('path', {
							key: '61183abf4f612b5cc835a9d47c371e3d324dab2e',
							d: 'M19 6.4L17.6 5 12 10.6 6.4 5 5 6.4l5.6 5.6L5 17.6 6.4 19l5.6-5.6 5.6 5.6 1.4-1.4-5.6-5.6L19 6.4z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1s;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-close',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1r =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconCloseHeader {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-close-header> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-close-header> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'f473a6baac0111576e2ebfd59e64301fa81f8091',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '12c1750cc07d7486fda4a373f75be34bbf7c2f77',
							xmlns: 'http://www.w3.org/2000/svg',
							width: '32',
							height: '32',
							fill: '#000000',
							viewBox: '0 0 24 24',
							id: 'close-header',
						},
						hAsync('path', {
							key: 'a801ac5621df2fb5feb0119d190468037a5a1ff7',
							d: 'M19 6.4L17.6 5 12 10.6 6.4 5 5 6.4l5.6 5.6L5 17.6 6.4 19l5.6-5.6 5.6 5.6 1.4-1.4-5.6-5.6L19 6.4z',
							fill: '#ffffff',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1r;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-close-header',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1q =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconCloud {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-cloud> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-cloud> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '6f10c9eb04f2fa71f04ac941cb3b50e6f36a4a8e',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '837185b70872975219b245859f94a2715088e543',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'cloud',
						},
						hAsync('path', {
							key: '92d37d35a6fd194bbf0bd16331bafbc70c9aef66',
							d: 'M19.35 10.04A7.49 7.49 0 0 0 12 4C9.1 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.9 0 14c0 3.3 2.7 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1q;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-cloud',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1p =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconCollapse {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-collapse> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-collapse> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'ac1fe33030ca276d501c3f76beeffa92954fe8de',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '0161301e33e106bb19105f1a6d8a9686bc075a54',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							fill: 'none',
							viewBox: '0 0 24 24',
							id: 'collapse',
						},
						hAsync('path', { key: '5fc0ab8cdde27a93e7894164c7b390aea409c216', d: 'M19 13H5v-2h14v2z' }),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1p;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-collapse',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1o =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconCreditCard {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-credit-card> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-credit-card> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'd31170b2dd70d943fe1d9155d39928ddb3b19212',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '493f9b20845a85a4f515dba6f995d2684fb9d56e',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							fill: 'none',
							viewBox: '0 0 24 24',
							id: 'credit-card',
						},
						hAsync('path', {
							key: 'fbcb888a18584c22d7300b788b154fe576d24b56',
							d: 'M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 14H4v-6h16v6zm0-10H4V6h16v2z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1o;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-credit-card',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1n =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconCriticalAlertWarning {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-critical-alert-warning> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-critical-alert-warning> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '08d2b06536c8e7d90b5e4efaf5845680cc70557f',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'c2b4f24abebbb4458a8b650de93a02daace9cc85',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							viewBox: '0 0 24 24',
							fill: 'none',
							xmlns: 'http://www.w3.org/2000/svg',
							id: 'critical-alert-warning',
						},
						hAsync('path', {
							key: '5546f28d27acc5b7f02538225e77a5c1ac799b77',
							d: 'M1 21H23L12 2L1 21ZM13 18H11V16H13V18ZM13 14H11V10H13V14Z',
							fill: 'white',
						}),
						hAsync('rect', {
							key: '2341716ca005857c0d72b18bedfd3f6dc6f278e9',
							x: '11',
							y: '10',
							width: '2',
							height: '4',
							fill: 'black',
						}),
						hAsync('rect', {
							key: '36b33c788a55f6f0709afeed313a319361c06807',
							x: '11',
							y: '16',
							width: '2',
							height: '2',
							fill: 'black',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1n;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-critical-alert-warning',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1m =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconDelete {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-delete> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-delete> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '7120b51d834ab446d3cbeb09b07b15c4b518ef01',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '4965c9acb804016d1aa2c580e801e07db9c1d949',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'delete',
						},
						hAsync('path', {
							key: '22c59fcf0332e2dd4fdf183e9fcad8d1c9316f61',
							d: 'M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1m;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-delete',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1l =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconDocument {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-document> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-document> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '67e7c76dc449a36927055b997b40f09520acc5b6',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '05f424f388bd6707e4af24b76035f143e84841b2',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'document',
						},
						hAsync('path', {
							key: 'e99cb152c49e1c8a7ed5aa7a14013f27f24961b8',
							d: 'M13 9h5.5L13 3.5V9zM6 2h8l6 6v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V4c0-1.1.9-2 2-2zm9 16v-2H6v2h9zm3-4v-2H6v2h12z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1l;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-document',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1k =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconDownload {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-download> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-download> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '6d01423125531dec1fc54790c3fdf8f1f4814493',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '5b72b61d6ad04a2d1dc3bd827d6b459626ece101',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'download',
						},
						hAsync('path', {
							key: 'b52236b2f5472fe86066764fdf8591ffc7284dae',
							d: 'M5 20h14v-2H5v2zM19 9h-4V3H9v6H5l7 7 7-7z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1k;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-download',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1j =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconDropdownArrow {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-dropdown-arrow> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			get host() {
				return getElement(this);
			}
			/**
			 * Validate that the `colour` attribute is not set by users
			 * Prints a warning message if the `colour` attribute is set
			 */
			validateColour() {
				if (this.host.hasAttribute('colour')) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' colour ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-dropdown-arrow> ')
						.addRegularText('cannot be set. The provided colour is ignored.')
						.printMessage();
				}
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '67d80d1b6dc26438c0cf30aba91a16e6a8223dff',
						class: `ontario-icon ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'ae348f5fb43f3e56bee65cf2d85cc690f48861c9',
							class: 'svg-icon',
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							fill: 'none',
							viewBox: '0 0 24 24',
							id: 'dropdown-arrow',
						},
						hAsync('path', {
							key: 'bfffc54b0a30059b62e1a59df886b62ba9d161e8',
							d: 'M7.965 10a.4.4 0 0 0-.37.247.4.4 0 0 0 .087.436l4.035 4.035a.4.4 0 0 0 .566 0l4.035-4.035a.4.4 0 0 0 .087-.436.4.4 0 0 0-.37-.247h-8.07z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
				};
			}
			static get style() {
				return ontarioIconCss$1j;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-dropdown-arrow',
					$members$: {
						iconWidth: [2, 'icon-width'],
						iconWidthState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1i =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconEdit {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-edit> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-edit> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '8326edea9621a4db6cb6a2f32a1f96fd3abdd769',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'a7676367d584b88b6088adff166b7666d5f81ead',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'edit',
						},
						hAsync('path', {
							key: '0d16b28cf5acd02fd0a955ccf8f3bfd88b131a3c',
							d: 'M3 17.25V21h3.75L17.8 9.94 14.06 6.2 3 17.25zm17.7-10.2c.4-.4.4-1.02 0-1.4L18.37 3.3c-.4-.4-1.02-.4-1.4 0l-1.83 1.83 3.75 3.75 1.83-1.83z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1i;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-edit',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1h =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconEmail {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-email> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-email> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '3844271dc66082de3bcc17807d9de2c6de6555ed',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'c913f28a6e86c94ff3eaf1faf2c7ba1830691836',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							fill: 'none',
							viewBox: '0 0 24 24',
							id: 'email',
						},
						hAsync('path', {
							key: '5a6060464344439577f9b3a4e93bb570f0005aed',
							d: 'M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1h;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-email',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1g =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconExpand {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-expand> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-expand> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'd3a6a0b06680d927ea84725c13070485b0e1c01f',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '211cfe70cedecc40f6ab8f5ccee8cf388e809713',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							fill: 'none',
							viewBox: '0 0 24 24',
							id: 'expand',
						},
						hAsync('path', {
							key: '70eafcd7bac0f8a72e41617c544952918a13c687',
							d: 'M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1g;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-expand',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1f =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconExport {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-export> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-export> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '279e654599137ed929cad64ffb7d0f3a50afd83c',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '18fa2d641d08bcbd7cf15c94e56e4dd39b5fbca1',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'export',
						},
						hAsync('path', {
							key: 'e6cd771fc86f30285bf3c9467757f69941425d25',
							d: 'M19 12v7H5v-7H3v7c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zm-6 .67l2.6-2.58 1.4 1.4-5 5-5-5 1.4-1.4 2.6 2.58V3h2v9.67z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1f;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-export',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1e =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconFacebook {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-facebook> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-facebook> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '3fa1d1a7623ccbeffc43ea341334dd34d8e048ec',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '7423fbd5cb95e3be0fe94166de34027615d76a98',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'facebook',
						},
						hAsync('path', {
							key: '5622e2fe6af8261a30e2777446ee3a30400b349d',
							d: 'M17 2v4h-2c-.7 0-1 .8-1 1.5V10h3v4h-3v8h-4v-8H7v-4h3V6a4 4 0 0 1 4-4h3z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1e;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-facebook',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1d =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconFacebookAlt {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-facebook-alt> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-facebook-alt> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '4193ee0f2f771b951da6fc9d87d6cb80aca80d12',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '1aafef83de897f6b34023799dd4cedb0b0ce8fde',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'facebook-alt',
						},
						hAsync('path', {
							key: 'e9617246464dd087edfdb45b81484cc4ec63473a',
							d: 'M5 3h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2zm13 2h-2.5A3.5 3.5 0 0 0 12 8.5V11h-2v3h2v7h3v-7h3v-3h-3V9a1 1 0 0 1 1-1h2V5z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1d;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-facebook-alt',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1c =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconFavouriteOff {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-favourite-off> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-favourite-off> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '80806ddbe7e02002efe7b296e8bff7fa8c50639c',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '28ef581548efa40bfda21fde422aedf587da1138',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'favourite-off',
						},
						hAsync('path', {
							key: '2a1177c940c0f76f6aa57769ee67bae97f86b235',
							d: 'M12.1 18.55l-.1.1-.1-.1C7.14 14.24 4 11.4 4 8.5 4 6.5 5.5 5 7.5 5c1.54 0 3.04 1 3.57 2.36h1.86C13.46 6 14.96 5 16.5 5c2 0 3.5 1.5 3.5 3.5 0 2.9-3.14 5.74-7.9 10.05zM16.5 3c-1.74 0-3.4.8-4.5 2.08C10.9 3.8 9.24 3 7.5 3 4.42 3 2 5.4 2 8.5c0 3.77 3.4 6.86 8.55 11.53L12 21.35l1.45-1.32C18.6 15.36 22 12.27 22 8.5 22 5.4 19.58 3 16.5 3z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1c;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-favourite-off',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1b =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconFavouriteOn {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-favourite-on> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-favourite-on> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'ea17701cf40ce72f6fbd6ce25040963dacc7f026',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'c8f45af6991aba2865635dc2cfdd2039f86fdf95',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'favourite-on',
						},
						hAsync('path', {
							key: '02628986c2f96c239f217063ca94b5b5c8be4bc2',
							d: 'M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3A5.99 5.99 0 0 1 12 5.09 5.99 5.99 0 0 1 16.5 3C19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1b;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-favourite-on',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1a =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconFilter {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-filter> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-filter> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '9b080057e74b47d292fe685e9ca1524b41348547',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'fe6a332dcded0b6646ca753bde65b15710298d75',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'filter',
						},
						hAsync('path', {
							key: '7dfc8015cd6c73814b12243cecc76e983093da3c',
							d: 'M14 12v7.88a.96.96 0 0 1-.29.83c-.4.4-1.02.4-1.4 0l-2-2a.99.99 0 0 1-.29-.83V12h-.03L4.2 4.62a1 1 0 0 1 .17-1.4c.2-.14.4-.22.62-.22h14c.22 0 .43.08.62.22a1 1 0 0 1 .17 1.4L14.03 12H14z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1a;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-filter',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$19 =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconFlickr {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-flickr> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-flickr> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '46f8aebe162aaba9bab6b4b511251ce9aa0a04bd',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'e63febb4da331f6672181bd4b030a63cb1589884',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'flickr',
						},
						hAsync('path', {
							key: '045c1c86982cf015c5a1ba4477f83dfddadf9bc6',
							d: 'M11 12C11 14.5 9 16.5 6.5 16.5C4 16.5 2 14.5 2 12C2 9.5 4 7.5 6.5 7.5C9 7.5 11 9.5 11 12ZM17.5 7.5C15 7.5 13 9.5 13 12C13 14.5 15 16.5 17.5 16.5C20 16.5 22 14.5 22 12C22 9.5 20 7.5 17.5 7.5Z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$19;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-flickr',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$18 =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconGrid {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-grid> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-grid> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '6111529d75bbe19843a682c03e900781e46918b5',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '735be49759eafbdfa145f71ee55f9ce4859868f2',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'grid',
						},
						hAsync('path', {
							key: '584a2c9fc57869f0c7725b40a268e3f490fa819c',
							d: 'M3.5 11.5h5v-6h-5v6zm0 7h5v-6h-5v6zm6 0h5v-6h-5v6zm6 0h5v-6h-5v6zm-6-7h5v-6h-5v6zm6-6v6h5v-6h-5z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$18;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-grid',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$17 =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconHelp {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-help> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-help> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'b31c7ddaa6bc1fb9231be2fe0fc6be9c9028d5f8',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '1b5270962ac7cbc65a129ec1091f1fb0390d5bce',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							fill: 'none',
							viewBox: '0 0 24 24',
							id: 'help',
						},
						hAsync('path', {
							key: '43d380e2cc8b5d3024f40ff6ea1f8b34b7dec309',
							d: 'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.6-.86.6-1.4 0-1.1-.9-2-2-2s-2 .9-2 2H8a4 4 0 1 1 8 0 3.18 3.18 0 0 1-.93 2.25z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$17;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-help',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$16 =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconInstagram {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-instagram> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-instagram> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '1c908969d96b8ab17c4ce93c8ee3a01db4ae3c07',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'afed10ad759624bb8b56e5915603a640a7be6187',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'instagram',
						},
						hAsync('path', {
							key: '0227cf54a5956526e39fdeb8b33460d8e93cb25e',
							d: 'M7.8 2h8.4C19.4 2 22 4.6 22 7.8v8.4a5.8 5.8 0 0 1-5.8 5.8H7.8C4.6 22 2 19.4 2 16.2V7.8A5.8 5.8 0 0 1 7.8 2zm-.2 2A3.6 3.6 0 0 0 4 7.6v8.8A3.6 3.6 0 0 0 7.6 20h8.8a3.6 3.6 0 0 0 3.6-3.6V7.6A3.6 3.6 0 0 0 16.4 4H7.6zm9.65 1.5a1.25 1.25 0 0 1 1.25 1.25A1.25 1.25 0 0 1 17.25 8 1.25 1.25 0 0 1 16 6.75a1.25 1.25 0 0 1 1.25-1.25zM12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5zm0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$16;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-instagram',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$15 =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconInteracEn {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-interac-en> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			get host() {
				return getElement(this);
			}
			/**
			 * Validate that the `colour` attribute is not set by users
			 * Prints a warning message if the `colour` attribute is set
			 */
			validateColour() {
				if (this.host.hasAttribute('colour')) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' colour ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-interac-en> ')
						.addRegularText('cannot be set. The provided colour is ignored.')
						.printMessage();
				}
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '151d0ff1d04ce36bc6ba450c4fde686ed73ed3fc',
						class: `ontario-icon ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'd49c20a6acd764d7dd2953d7a58eac4e32336c42',
							class: 'svg-icon',
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'interac-en',
						},
						hAsync('path', {
							'key': '1103a5343a8798808a50648e30584fe75c1efc32',
							'fill-rule': 'evenodd',
							'd': 'M16.008 18.403c0 .7-.584 1.285-1.285 1.285H1.837c-.7 0-1.285-.584-1.285-1.285V5.517c0-.7.584-1.285 1.285-1.285h12.886c.7 0 1.285.584 1.285 1.285v12.886z',
							'fill': '#ecaa20',
						}),
						hAsync('path', {
							key: '94e11c885bd98b02dc383d4ca58f00639a48508b',
							d: 'M30.178 4H1.837C.98 4 .28 4.7.28 5.557v12.886C.28 19.3.98 20 1.837 20h28.34a1.56 1.56 0 0 0 1.557-1.557V5.557c0-.895-.7-1.557-1.557-1.557zM1.837 19.69c-.7 0-1.285-.584-1.285-1.285V5.518c0-.7.584-1.285 1.285-1.285h12.886c.7 0 1.285.584 1.285 1.285v12.886c0 .7-.584 1.285-1.285 1.285H1.837zm29.625-1.285c0 .7-.584 1.285-1.285 1.285h-14.56c.428-.273.662-.74.662-1.285V5.518c0-.545-.273-1.012-.662-1.285h14.56c.7 0 1.285.584 1.285 1.285v12.886z',
							fill: '#fff',
						}),
						hAsync('path', {
							key: 'f2be9e833c2ea620c5fd7fc488308b469ff6532d',
							d: 'M16.28 5.558v12.886c0 .545-.273 1.012-.662 1.285h14.56c.7 0 1.285-.584 1.285-1.285V5.558c0-.7-.584-1.285-1.285-1.285h-14.56c.39.272.662.74.662 1.285z',
							fill: '#636466',
						}),
						hAsync('path', {
							key: '6ee364b486dc8406b224aff3442438af9796e318',
							d: 'M19.122 9.564c1.05 0 1.207.74 1.207 1.83 0 1.05-.117 1.83-1.207 1.83-1.05 0-1.207-.74-1.207-1.83s.156-1.83 1.207-1.83zm0 3.114c.428 0 .467-.35.467-1.285s-.078-1.285-.467-1.285c-.428 0-.467.35-.467 1.285-.04.934.04 1.285.467 1.285zm1.674-2.176h.662v.3a.72.72 0 0 1 .662-.389c.428 0 .662.234.662.74V13.1h-.662v-1.83c0-.273-.078-.35-.272-.35-.234 0-.35.156-.35.428V13.1h-.662v-2.608h-.04zm3.192-.86h-.662v3.504h.662V9.643zm.584-.036h.662v.584h-.662v-.584zm0 .895h.662v2.647h-.662v-2.647zm1.246 0h.662v.3a.72.72 0 0 1 .662-.389c.428 0 .662.234.662.74V13.1h-.662v-1.83c0-.273-.078-.35-.273-.35-.233 0-.35.156-.35.428V13.1h-.662v-2.608h-.04zm3.036 1.44v.195c0 .3.078.623.35.623.234 0 .3-.156.35-.506h.623c-.04.623-.312.973-.973.973-.973 0-1.012-.74-1.012-1.402 0-.7.156-1.363 1.05-1.363.78 0 .973.545.973 1.324v.156h-1.363zm.7-.428c0-.4-.078-.623-.35-.623s-.35.273-.35.506v.117h.7z',
							fill: '#fff',
						}),
						hAsync(
							'g',
							{ key: 'a8728c40ba1b5fefb93eb3aa98149914e541c3bf', fill: '#000' },
							hAsync('path', {
								key: '7005354079ced76d84d7ec52ccc63bbc6188ce6b',
								d: 'M2.85 12.915c-.234-.04-.35.04-.35.04V10.97l.74-.156v.3s.195-.428.7-.545c.584-.117.78.195.78.7v1.985l-.78.195v-1.87c0-.312-.156-.35-.3-.312-.234.04-.4.312-.4.584v1.285c0-.04-.156-.195-.4-.234zm6.345-.74V9.4l.74-.156v.35s.195-.467.623-.584c.117-.04.195 0 .195 0v.7s-.156 0-.4.078c-.273.117-.4.35-.4.7v1.518l-.78.156z',
							}),
							hAsync('path', {
								key: '70e5386d04b841c596faf0480b4e3c2915fe21cf',
								d: 'M5.38 13.068s-.117-.156-.117-.818v-1.362l-.39.078v-.584l.39-.078V9.68l.78-.195v.623l.545-.117v.584l-.545.117v1.402c0 .623.156.78.156.78l-.818.195z',
							}),
							hAsync('path', {
								key: '7f169c3d26187643442e4cc467fcd377de804a78',
								d: 'M6.664 11.435c0-.506.078-.857.234-1.13.195-.3.467-.545.895-.623.856-.195 1.13.3 1.13.973v.35l-1.48.35v.04c0 .467.117.7.4.623.273-.04.3-.195.35-.428v-.117l.7-.156v.117c0 .273-.078.934-1.05 1.168-.934.195-1.168-.35-1.168-1.168zm1.13-1.246c-.234.04-.4.3-.4.7l.74-.195v-.117c.04-.312-.078-.467-.35-.4zm5.526-.39c-.04-.856.195-1.518 1.13-1.713.584-.117.817 0 .934.156s.156.35.156.623v.04l-.74.156v-.117c0-.3-.078-.428-.3-.4-.273.078-.4.35-.4.856v.234c0 .545.078.78.4.7.272-.04.3-.3.3-.506v-.156l.74-.156v.117c0 .7-.4 1.13-1.05 1.285-.934.3-1.13-.273-1.168-1.13zM10.8 11c0-.623.4-.856.934-1.1.506-.195.506-.3.506-.506 0-.156-.078-.273-.3-.234a.36.36 0 0 0-.312.35v.156l-.7.156s0-.234.04-.428c.117-.4.467-.623 1.05-.78.74-.156 1.012.156 1.012.662v1.246c0 .584.117.662.117.662l-.7.156s-.078-.117-.078-.234c0 0-.156.4-.7.506-.584.195-.856-.156-.856-.623zm1.44-.895s-.156.117-.4.233-.35.273-.35.467.117.3.3.273c.234-.04.4-.273.4-.545.04-.195.04-.4.04-.428z',
							}),
							hAsync('path', {
								'key': 'd071acf5e27d74331bef797a94769ee5a815ca3e',
								'fill-rule': 'evenodd',
								'd': 'M3.472 14.122l1.246.817a.68.68 0 0 1 .272.545v3.62h-1.4a1.31 1.31 0 0 1-1.324-1.324v-4.165a.45.45 0 0 1 .467-.467c.272 0 .467.234.467.467V16c0 .078.04.117.117.117s.117-.078.117-.156c.04-.04.04-1.83.04-1.83z',
							}),
							hAsync('path', {
								key: '8598ea94a7448377bf0f604ee5bd68618f6bbe14',
								d: 'M1.02 14.394c-.04.078-.078.156-.078.234 0 .234.195.428.428.428h.078c.04 0 .35-.078.584-.117v-.74l-1.013.195z',
							}),
							hAsync('use', { key: '60034507beac027a9dfd34d2ec7a4f49c0431877', href: '#B3' }),
							hAsync('use', { key: '6c0d57c59d8e2211f7ebfb66049808bbee47d956', href: '#B3', y: '1.014' }),
							hAsync('path', {
								key: '2a22349e9e91b4bd99b58d7b36cd708a64f6501f',
								d: 'M1.214 14.045V9.607l.818-.195v4.438l-.818.195zM14.762 7.62a.78.78 0 0 1-.779-.779.78.78 0 0 1 .779-.779.78.78 0 0 1 .779.779.78.78 0 0 1-.779.779zm0-1.48a.701.701 0 1 0 0 1.402.7.7 0 0 0 .701-.701c-.04-.4-.35-.7-.7-.7z',
							}),
							hAsync('path', {
								key: 'b4d4a45581698a7b25873b61f81ab949a5759b5e',
								d: 'M14.45 6.334h.35c.117 0 .234.078.234.234 0 .117-.04.234-.156.234.078 0 .156.078.156.195v.195c0 .04.04.078.04.078h-.156s-.04-.04-.04-.078v-.195c0-.117-.04-.156-.156-.156h-.117v.428h-.156v-.935zm.273.428c.117 0 .156-.078.156-.156 0-.117-.04-.156-.156-.156h-.117v.312h.117z',
							}),
						),
						hAsync(
							'defs',
							{ key: '0b31c7335631813a5ba048773e3dff058da02da6' },
							hAsync('path', {
								key: '59da551bef74af91e3a9269615c5036169d30b8e',
								id: 'B3',
								d: 'M1.02 15.406c-.04.078-.078.156-.078.234 0 .234.195.43.428.43h.078c.04 0 .35-.078.584-.117v-.74l-1.013.195z',
							}),
						),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
				};
			}
			static get style() {
				return ontarioIconCss$15;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-interac-en',
					$members$: {
						iconWidth: [2, 'icon-width'],
						iconWidthState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$14 =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconInteracEnAlt {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-interac-en-alt> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			get host() {
				return getElement(this);
			}
			/**
			 * Validate that the `colour` attribute is not set by users
			 * Prints a warning message if the `colour` attribute is set
			 */
			validateColour() {
				if (this.host.hasAttribute('colour')) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' colour ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-interac-en-alt> ')
						.addRegularText('cannot be set. The provided colour is ignored.')
						.printMessage();
				}
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'f0982495a00db0dea09f2dc3080b5bbf64415783',
						class: `ontario-icon ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'e3c895a09a1795dbbf523ba8aad5a326da90a6fa',
							class: 'svg-icon',
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'interac-en-alt',
						},
						hAsync('path', {
							key: 'a9c0008cabe3869af5b9db60160468b4b6fdc1e1',
							d: 'M18.463 17.052H5.548a1.62 1.62 0 0 1-1.304-.693v5.093c0 .733.57 1.304 1.304 1.304h12.915c.733 0 1.304-.57 1.304-1.304V16.36c-.285.448-.774.693-1.304.693z',
							fill: '#636466',
						}),
						hAsync('path', {
							key: '20823687e26a053f77613472c2f8c0cb1ed7d85d',
							d: 'M5.548 16.808h12.915c.733 0 1.304-.57 1.304-1.304V2.59c0-.652-.49-1.222-1.14-1.304H5.59c-.733 0-1.304.57-1.304 1.304v12.915c-.04.733.53 1.304 1.263 1.304z',
							fill: '#ecaa20',
						}),
						hAsync(
							'g',
							{ key: 'f53254e44fe6cc6154ff8c5e3b8c80d31c717daa', fill: '#fff' },
							hAsync('path', {
								key: '576a7845c7c345468857fae00c971d051882b6e0',
								d: 'M18.463 1H5.548A1.55 1.55 0 0 0 4 2.548v18.904A1.55 1.55 0 0 0 5.548 23h12.915a1.55 1.55 0 0 0 1.548-1.548V2.548A1.55 1.55 0 0 0 18.463 1zM4.244 2.6c0-.733.57-1.304 1.304-1.304h13.037c.652.08 1.14.6 1.14 1.304v12.915c0 .733-.57 1.304-1.304 1.304H5.507c-.733 0-1.304-.57-1.304-1.304V2.6h.04zm15.522 18.904c0 .733-.57 1.304-1.304 1.304H5.548c-.733 0-1.304-.57-1.304-1.304V16.4a1.62 1.62 0 0 0 1.304.693h12.915a1.62 1.62 0 0 0 1.304-.693v5.093zM8.36 18.723c.774 0 .896.57.896 1.344s-.08 1.344-.896 1.344c-.774 0-.896-.57-.896-1.344 0-.815.08-1.344.896-1.344zm0 2.322c.326 0 .367-.285.367-.978s-.04-.978-.367-.978-.367.285-.367.978.04.978.367.978z',
							}),
							hAsync('use', { key: '8d536f88ad660f81a4420c6de0a672fa270b11e5', href: '#B' }),
							hAsync('path', {
								key: '9660683a4890ecf086005d65d0f3daf65be33c4a',
								d: 'M11.985 18.763h-.5v2.607h.5v-2.607zm.448-.04h.5v.448h-.5v-.448zm0 .692h.5v1.956h-.5v-1.956z',
							}),
							hAsync('use', { key: '7287eb8b829e13774c4c2b7d3ac60eef0bca2d4c', href: '#B', x: '3.748' }),
							hAsync('path', {
								key: '46acdc059db428a6e166e86d488eead2ad8c2d02',
								d: 'M15.652 20.473v.163c0 .245.08.448.244.448s.244-.122.285-.367h.448c0 .448-.244.693-.693.693-.733 0-.774-.57-.774-1.06 0-.53.082-1.018.774-1.018.57 0 .733.407.733.978v.122h-1.02v.04zm.49-.326c0-.285-.04-.448-.244-.448s-.244.204-.244.407v.08h.49v-.04z',
							}),
						),
						hAsync(
							'g',
							{ key: 'b0c41f4ea30aa9b4e9c470d1b4d46ae84ee8e10e', fill: '#000' },
							hAsync('path', {
								key: '340dbf655b393fb487b3dd765cc7072d804ca823',
								d: 'M6.526 10.004c-.204-.04-.367.04-.367.04V8.048l.733-.163v.326s.204-.448.733-.57c.57-.122.774.204.774.693v1.996l-.774.163V8.62c0-.285-.122-.367-.285-.326-.204.04-.367.285-.367.6v1.304c-.04-.04-.163-.204-.448-.204zm6.396-.774V6.46l.733-.163v.367s.204-.5.6-.57c.122-.04.204 0 .204 0v.693s-.163 0-.367.08c-.285.122-.407.326-.407.693v1.548l-.774.122z',
							}),
							hAsync('path', {
								key: '4579dad6ff53480924b9526d6e1b84dfcb23866f',
								d: 'M9.093 10.126s-.122-.163-.122-.815V7.926l-.367.08v-.57l.367-.08v-.61l.774-.163v.61l.53-.122v.57l-.53.122V9.19c0 .652.163.774.163.774l-.815.163z',
							}),
							hAsync('path', {
								key: '959fec8cf611e52d5942fd28818a8ff8131c0a78',
								d: 'M10.356 8.496c0-.5.08-.856.204-1.14.163-.326.5-.53.896-.652.856-.204 1.14.326 1.14.978v.367l-1.507.367v.04c0 .5.082.693.407.6.245-.04.326-.204.367-.407v-.122l.693-.163v.122c0 .285-.082.937-1.06 1.14-.896.244-1.14-.326-1.14-1.14zm1.14-1.263c-.244.04-.367.285-.367.693l.733-.163V7.64c.04-.326-.082-.448-.367-.407zm5.582-.367c-.04-.856.204-1.507 1.14-1.752.6-.122.815 0 .937.163s.163.326.163.6v.04l-.733.163v-.12c0-.326-.082-.448-.326-.367-.285.08-.407.326-.407.856v.244c0 .53.08.774.407.733.285-.04.326-.285.326-.53v-.122l.733-.163v.122c0 .693-.367 1.14-1.06 1.304-.978.244-1.18-.326-1.18-1.18zM14.5 8.048c0-.652.367-.856.937-1.1.53-.204.53-.326.53-.5s-.082-.285-.326-.204c-.244.04-.285.244-.326.367v.122l-.733.163s0-.204.04-.407c.122-.367.448-.652 1.06-.774.774-.163 1.018.163 1.018.693V7.64c0 .6.122.693.122.693l-.693.163s-.08-.122-.08-.244c0 0-.163.407-.693.53-.57.08-.856-.244-.856-.733zm1.467-.896s-.163.122-.367.204c-.245.122-.326.244-.326.5 0 .204.122.326.326.244.244-.04.367-.285.367-.57v-.367z',
							}),
							hAsync('path', {
								'key': '9389e93e4f850a24769f2d59b7f6beb80c641723',
								'fill-rule': 'evenodd',
								'd': 'M7.178 11.184l1.222.856c.163.122.285.326.285.53v3.667H7.3a1.36 1.36 0 0 1-1.344-1.344v-4.155c0-.245.204-.49.49-.49a.47.47 0 0 1 .489.489v2.404c0 .08.04.122.122.122s.122-.04.122-.163v-1.915z',
							}),
							hAsync('path', {
								key: 'e0a51f9d193530760c70e95d595c43815381ba5b',
								d: 'M4.693 11.47c-.04.082-.08.163-.08.244 0 .245.204.407.407.407h.08c.04 0 .326-.08.57-.122v-.733l-.978.204zm0 1.02c-.04.082-.08.163-.08.245 0 .244.204.407.407.407h.08c.04 0 .326-.082.57-.122v-.733l-.978.204zm0 1.018c-.04.082-.08.163-.08.244a.41.41 0 0 0 .407.408h.08c.04 0 .326-.082.57-.122v-.733l-.978.204zm.203-2.364v-4.48l.815-.204v4.482l-.815.204zM18.504 4.64c-.448 0-.767-.38-.767-.788a.77.77 0 0 1 .767-.774.75.75 0 0 1 .775.774c0 .407-.367.788-.775.788zm0-1.48c-.367 0-.693.326-.693.693s.326.693.693.693.693-.326.693-.693-.326-.693-.693-.693z',
							}),
							hAsync('path', {
								key: '2a9e93452e412ef07b9234be50f914d9ef9956f2',
								d: 'M18.22 3.404h.326c.122 0 .245.08.245.244 0 .122-.04.204-.163.244.08 0 .163.08.163.204V4.3c0 .04.04.08.04.08h-.163s-.04-.04-.04-.08v-.204c0-.122-.04-.163-.122-.163h-.122v.407h-.163v-.937zm.244.407c.08 0 .163-.04.163-.163s-.04-.163-.163-.163h-.122v.326h.122z',
							}),
						),
						hAsync(
							'defs',
							{ key: 'e2ef2181e152ec190a251cd5dea874b0813fb2c6' },
							hAsync('path', {
								key: '132a85be92f0ea6530afdb7b8c15cbf9179bfeb6',
								id: 'B',
								d: 'M9.582 19.414h.49v.244a.53.53 0 0 1 .489-.285c.326 0 .49.163.49.57v1.467h-.49v-1.344c0-.204-.082-.285-.204-.285-.163 0-.285.122-.285.326v1.304h-.49v-1.996z',
							}),
						),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
				};
			}
			static get style() {
				return ontarioIconCss$14;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-interac-en-alt',
					$members$: {
						iconWidth: [2, 'icon-width'],
						iconWidthState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$13 =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconInteracFr {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-interac-fr> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			get host() {
				return getElement(this);
			}
			/**
			 * Validate that the `colour` attribute is not set by users
			 * Prints a warning message if the `colour` attribute is set
			 */
			validateColour() {
				if (this.host.hasAttribute('colour')) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' colour ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-interac-fr> ')
						.addRegularText('cannot be set. The provided colour is ignored.')
						.printMessage();
				}
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'b97247b7a171eafe596d654af091c85562c9e4ad',
						class: `ontario-icon ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '51d6387c73b07d195baeb0b34602ef48103b3b4e',
							class: 'svg-icon',
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'interac-fr',
						},
						hAsync('path', {
							'key': '94443d38843f2b5e7886732b01b3464b72dc0075',
							'fill-rule': 'evenodd',
							'd': 'M15.998 18.442c0 .7-.584 1.285-1.285 1.285H1.827c-.7 0-1.285-.584-1.285-1.285V5.556c0-.7.584-1.285 1.285-1.285h12.886c.7 0 1.285.584 1.285 1.285v12.886z',
							'fill': '#ecaa20',
						}),
						hAsync('path', {
							key: 'ea96fcb2d2cf547034cf22cadf82e4e1c7fe0f96',
							d: 'M37.876 4H1.827C.97 4 .27 4.7.27 5.557v12.886C.27 19.3.97 20 1.827 20h36.05c.856 0 1.557-.7 1.557-1.557V5.557c0-.856-.7-1.557-1.557-1.557zM1.827 19.728c-.7 0-1.285-.584-1.285-1.285V5.557c0-.7.584-1.285 1.285-1.285h12.886c.7 0 1.285.584 1.285 1.285v12.886c0 .7-.584 1.285-1.285 1.285H1.827zm37.333-1.285c0 .7-.584 1.285-1.285 1.285H15.57c.428-.273.662-.74.662-1.285V5.557c0-.545-.273-1.012-.662-1.285h22.307c.7 0 1.285.584 1.285 1.285v12.886z',
							fill: '#fff',
						}),
						hAsync('path', {
							key: '12cc76626bc790c4a743b6d89ce15778556045d3',
							d: 'M16.27 5.556v12.886c0 .545-.272 1.012-.662 1.285h22.307c.7 0 1.285-.584 1.285-1.285V5.556c0-.7-.584-1.285-1.285-1.285H15.608c.39.31.662.78.662 1.285z',
							fill: '#636466',
						}),
						hAsync('path', {
							key: 'dfe5150899dc0f25b32db8bb046162c82472b77d',
							d: 'M21.993 9.684v.545h-1.246v.857h1.168v.584h-1.168v.934h1.285v.584h-1.986V9.684h1.947zm.467.856h.662v.3a.72.72 0 0 1 .662-.389c.428 0 .662.234.662.74v1.946h-.662v-1.83c0-.273-.078-.35-.273-.35-.233 0-.35.156-.35.428v1.752h-.7V10.54zm4.204-.856h-.662v3.504h.662V9.684zm.584-.04h.662v.584h-.662v-.584zm0 .895h.662v2.647h-.662V10.54zm3.192 0v2.5c0 .7-.3 1.05-1.1 1.05-.584 0-.895-.272-.895-.7h.662c0 .078.04.156.117.195a.55.55 0 0 0 .234.078c.273 0 .4-.195.4-.467v-.35c-.156.195-.35.3-.584.3-.545 0-.818-.35-.818-1.324 0-.623.078-1.363.818-1.363.195 0 .428.078.545.35v-.272h.623zm-1.012 2.063c.273 0 .35-.3.35-.74 0-.662-.078-.895-.35-.895-.3 0-.35.234-.35.934.04.4.078.7.35.7zm1.596-2.063h.662v.3a.72.72 0 0 1 .662-.389c.428 0 .662.234.662.74v1.946h-.662v-1.83c0-.273-.078-.35-.273-.35-.234 0-.35.156-.35.428v1.752h-.7V10.54zm3.076 1.402v.195c0 .3.078.623.35.623.234 0 .3-.156.35-.506h.623c-.04.623-.3.973-.973.973-.973 0-1.012-.74-1.012-1.402 0-.7.156-1.363 1.05-1.363.78 0 .973.545.973 1.324v.156H34.1zm.7-.4c0-.4-.078-.623-.35-.623s-.35.273-.35.506v.117h.7z',
							fill: '#fff',
						}),
						hAsync(
							'g',
							{ key: 'd5859d3efcb16c2967aef4afb8e85e0f3305e4db', fill: '#000' },
							hAsync('path', {
								key: 'b63d48ffa650b183edaff7259f96ee11291e04df',
								d: 'M2.84 12.954c-.234-.04-.35.04-.35.04V11.01l.74-.156v.3s.195-.428.74-.545c.584-.117.78.195.78.7v1.985l-.78.195v-1.87c0-.3-.156-.35-.3-.3-.234.04-.4.3-.4.584v1.285c0-.04-.156-.195-.428-.234zm6.345-.74V9.45l.74-.156v.35s.195-.467.623-.584c.117-.04.195 0 .195 0v.7s-.156 0-.4.078c-.273.117-.4.35-.4.7v1.518l-.78.156z',
							}),
							hAsync('path', {
								key: 'bac7d84c6d3ee598a2ab5d83c8a7577ea862cab4',
								d: 'M5.37 13.11s-.117-.195-.117-.818V10.93l-.39.078v-.584l.39-.078V9.76l.78-.195v.623l.545-.117v.584l-.545.117v1.402c0 .623.156.78.156.78l-.818.156z',
							}),
							hAsync('path', {
								key: '51387aaf07d56d9cbb1e24d466cafa2c472045ff',
								d: 'M6.654 11.474c0-.506.078-.856.234-1.13.195-.3.467-.545.895-.623.856-.195 1.13.3 1.13.973v.35l-1.48.35v.04c0 .467.117.7.4.623.273-.04.3-.195.35-.428v-.117l.7-.156v.117c0 .273-.078.934-1.05 1.168-.934.195-1.168-.4-1.168-1.168zm1.13-1.246c-.234.04-.4.312-.4.7l.74-.195v-.117c.04-.3-.04-.467-.35-.4zM13.3 9.84c-.04-.856.195-1.518 1.13-1.713.584-.117.817.04.934.156.117.156.156.35.156.623v.04l-.74.156v-.117c0-.3-.078-.428-.3-.4-.273.078-.4.35-.4.856v.234c0 .545.078.78.4.7.272-.078.3-.3.3-.506v-.156l.74-.156v.117c0 .7-.4 1.13-1.05 1.285-.934.272-1.13-.273-1.168-1.13zm-2.53 1.167c0-.623.4-.856.934-1.1.506-.195.506-.3.506-.506 0-.156-.078-.273-.3-.234a.36.36 0 0 0-.312.35v.156l-.7.156s0-.234.04-.428c.117-.4.467-.623 1.05-.78.74-.195 1.012.156 1.012.662v1.246c0 .584.117.662.117.662l-.7.156s-.078-.117-.078-.234c0 0-.156.4-.7.506-.545.195-.856-.117-.856-.623zm1.48-.856s-.156.117-.4.233-.35.273-.35.467.117.3.3.273c.234-.04.4-.273.4-.545 0-.195.04-.4.04-.428z',
							}),
							hAsync('path', {
								'key': '1393beb022357d725c29d5ed2c8536de3b530500',
								'fill-rule': 'evenodd',
								'd': 'M3.5 14.16l1.207.818a.68.68 0 0 1 .272.545v3.62h-1.4a1.31 1.31 0 0 1-1.324-1.324v-4.165a.45.45 0 0 1 .467-.467c.273 0 .467.234.467.467v2.375c0 .078.04.117.117.117s.117-.078.117-.156c.078-.04.078-1.83.078-1.83z',
							}),
							hAsync('path', {
								key: 'c4155798d56dcfd7f60491b26892d48f4dcc6fc2',
								d: 'M1 14.433c-.04.078-.078.156-.078.234 0 .234.195.428.428.428h.078c.04 0 .35-.078.584-.117v-.74L1 14.433zm0 1.014c-.04.078-.078.156-.078.233 0 .234.195.428.428.428h.078c.04 0 .35-.078.584-.117v-.78L1 15.447zm0 1.01c-.04.078-.078.156-.078.234 0 .234.195.428.428.428h.078c.04 0 .35-.078.584-.117v-.74L1 16.458zm.204-2.376V9.644l.818-.195v4.438l-.818.195zm12.73-7.6h.234l.156.7h.04l.156-.7h.234v.973h-.156v-.818l-.195.818h-.117l-.195-.818v.818h-.156v-.973zm.974 0h.272c.3 0 .35.195.35.467s-.04.467-.35.467h-.272v-.934zm.156.856h.117c.117 0 .195-.078.195-.35s-.04-.35-.195-.35h-.117v.7z',
							}),
						),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
				};
			}
			static get style() {
				return ontarioIconCss$13;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-interac-fr',
					$members$: {
						iconWidth: [2, 'icon-width'],
						iconWidthState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$12 =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconInteracFrAlt {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-interac-fr-alt> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			get host() {
				return getElement(this);
			}
			/**
			 * Validate that the `colour` attribute is not set by users
			 * Prints a warning message if the `colour` attribute is set
			 */
			validateColour() {
				if (this.host.hasAttribute('colour')) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' colour ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-interac-fr-alt> ')
						.addRegularText('cannot be set. The provided colour is ignored.')
						.printMessage();
				}
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'e93887f9e31530fe10cf6b660730f1d020669329',
						class: `ontario-icon ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '7f9fe57d2ad0325457e68220f0f2a1df1c310c6c',
							class: 'svg-icon',
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'interac-fr-alt',
						},
						hAsync('path', {
							key: '7565e85237927e852d4448925c26997029f0985b',
							d: 'M18.463 17.052H5.548a1.62 1.62 0 0 1-1.304-.693v5.093c0 .733.57 1.304 1.304 1.304h12.915c.733 0 1.304-.57 1.304-1.304V16.36c-.285.448-.774.693-1.304.693z',
							fill: '#636466',
						}),
						hAsync('path', {
							key: '006e1bc633cc820d4befc94d04f040a27baebab9',
							d: 'M5.548 16.807h12.915c.733 0 1.304-.57 1.304-1.304V2.59c0-.652-.49-1.222-1.14-1.304H5.548c-.733 0-1.304.57-1.304 1.304v12.915c0 .733.57 1.304 1.304 1.304z',
							fill: '#ecaa20',
						}),
						hAsync(
							'g',
							{ key: 'ac68edfd6b0ca9265191cb4c14bf1350e6f0528f', fill: '#fff' },
							hAsync('path', {
								key: 'f87e83eefc06e7c87491c5089358e9568925a70e',
								d: 'M18.463 1H5.548A1.55 1.55 0 0 0 4 2.548v18.904A1.55 1.55 0 0 0 5.548 23h12.915a1.55 1.55 0 0 0 1.548-1.548V2.548C20.052 1.693 19.36 1 18.463 1zM4.244 2.6c0-.733.57-1.304 1.304-1.304h13.037c.652.08 1.14.6 1.14 1.304v12.915c0 .733-.57 1.304-1.304 1.304H5.548c-.733 0-1.304-.57-1.304-1.304V2.6zm15.522 18.904c0 .733-.57 1.304-1.304 1.304H5.548c-.733 0-1.304-.57-1.304-1.304V16.4a1.62 1.62 0 0 0 1.304.693h12.915a1.62 1.62 0 0 0 1.304-.693v5.093zM7.83 18.764v.407h-.937v.6h.856v.448h-.856v.693h.937v.448H6.363v-2.607H7.83zm.326.65h.5v.244a.53.53 0 0 1 .489-.285c.326 0 .5.163.5.57V21.4h-.5v-1.344c0-.204-.08-.285-.204-.285-.163 0-.285.122-.285.326V21.4h-.5v-1.996zm3.137-.65h-.5v2.607h.5v-2.607zm.447-.04h.5v.448h-.5v-.448zm0 .692h.5v1.956h-.5v-1.956zm2.364.001V21.3c0 .53-.244.774-.815.774-.407 0-.652-.204-.652-.53h.5c0 .082.04.122.082.163s.122.04.163.04c.204 0 .285-.163.285-.367v-.285c-.122.163-.245.245-.407.245-.407 0-.6-.285-.6-.978 0-.448.08-1.018.6-1.018.122 0 .326.082.407.285v-.204h.448zm-.733 1.548c.204 0 .285-.244.285-.57 0-.5-.082-.652-.245-.652-.204 0-.244.163-.244.693-.082.285-.04.53.204.53z',
							}),
							hAsync('path', {
								key: 'ad20212ad1bd837587f5d40ea76b986b89cd4de7',
								d: 'M14.5 19.414h.5v.244a.53.53 0 0 1 .489-.285c.326 0 .5.163.5.57V21.4h-.5v-1.344c0-.204-.08-.285-.204-.285-.163 0-.285.122-.285.326V21.4h-.5v-1.996zm2.323 1.06v.163c0 .244.08.448.244.448s.244-.122.285-.367h.448c0 .448-.244.693-.692.693-.733 0-.774-.57-.774-1.06 0-.53.122-1.018.774-1.018.57 0 .733.407.733.978v.122h-1.018v.04zm.53-.326c0-.285-.04-.448-.244-.448s-.245.204-.245.407v.08h.5v-.04z',
							}),
						),
						hAsync(
							'g',
							{ key: 'e2ffca23f1b183dcc48cd87d53139a9cabcb5649', fill: '#000' },
							hAsync('path', {
								key: '5a3ef90a55f8e4f106c978b96ed75dc984a0730d',
								d: 'M6.567 10.004c-.204 0-.367.04-.367.04V8.048l.733-.163v.326s.204-.448.733-.57c.57-.122.774.204.774.693v1.996l-.774.163V8.62c0-.285-.122-.367-.285-.326-.204.04-.367.285-.367.6v1.304c-.08-.04-.204-.204-.448-.204zm6.355-.774V6.46l.733-.163v.367s.204-.5.6-.57c.122-.04.204 0 .204 0v.693s-.163 0-.367.08c-.285.122-.407.326-.407.693v1.548l-.774.122z',
							}),
							hAsync('path', {
								key: '5cf8f7db7a0be402ccc81b7d43e9dd96cd53c74d',
								d: 'M9.093 10.127s-.122-.163-.122-.815V7.926l-.367.08v-.57l.367-.08v-.61l.774-.163v.61l.53-.122v.57l-.53.122V9.19c0 .652.163.774.163.774l-.815.163z',
							}),
							hAsync('path', {
								key: '67ce45204aae94f7b4737da734d6993e5eedb726',
								d: 'M10.356 8.495c0-.5.08-.856.204-1.14.163-.326.5-.53.896-.652.856-.204 1.14.326 1.14.978v.367l-1.507.367v.04c0 .5.082.693.407.6.245-.04.326-.204.367-.407v-.122l.693-.163v.122c0 .285-.082.937-1.06 1.14-.896.204-1.14-.326-1.14-1.14zm1.18-1.263c-.245.04-.367.285-.367.693l.733-.163V7.64c0-.326-.08-.448-.367-.407zm5.542-.366c-.04-.856.204-1.507 1.14-1.752.6-.122.815 0 .937.163s.163.326.163.6v.04l-.733.163v-.12c0-.326-.082-.448-.326-.367-.285.08-.407.326-.407.856v.244c0 .53.08.774.407.733.285-.04.326-.285.326-.53v-.122l.733-.163v.122c0 .693-.367 1.14-1.06 1.304-.978.244-1.14-.326-1.18-1.18zM14.5 8.048c0-.652.367-.856.937-1.1.53-.204.53-.326.53-.5s-.082-.285-.326-.204c-.244.04-.285.244-.326.367v.122l-.733.163s0-.204.04-.407c.122-.367.448-.652 1.06-.774.774-.163 1.018.163 1.018.693V7.64c0 .6.122.693.122.693l-.693.122s-.08-.122-.08-.244c0 0-.163.407-.693.53s-.856-.204-.856-.693zm1.467-.896s-.163.122-.367.204c-.244.122-.326.244-.326.5 0 .204.122.326.326.244.245-.04.367-.285.367-.57v-.367z',
							}),
							hAsync('path', {
								'key': 'a2d2747984df8ea1eb4b492dd8f31ff62ef08226',
								'fill-rule': 'evenodd',
								'd': 'M7.218 11.185l1.222.855c.163.122.285.326.285.53v3.667H7.34a1.36 1.36 0 0 1-1.344-1.344v-4.156c0-.244.204-.49.49-.49a.47.47 0 0 1 .489.489v2.404c0 .082.04.122.122.122s.122-.04.122-.163v-1.915z',
							}),
							hAsync('use', { key: '13bebd6c9719a9486e6ae1ec2f6ed8ed851400b1', href: '#B2' }),
							hAsync('path', {
								key: '79946660d1c3a1e4cef7c0aa394801ea192ef66b',
								d: 'M4.693 12.49c-.04.08-.08.163-.08.244 0 .245.204.407.407.407h.08c.04 0 .326-.082.57-.122v-.733l-.978.204z',
							}),
							hAsync('use', { key: '17437207fcd4d14e5afffc7b5cd1d063c1654842', href: '#B2', y: '2.036' }),
							hAsync('path', {
								key: '6a3f2ddfab85bf73cce69f5e97d3f65b6dc79a5a',
								d: 'M4.896 11.144v-4.48l.815-.204v4.482l-.815.204zM17.7 3.484h.244l.163.733.163-.733h.244v.978h-.163v-.815l-.163.815h-.163l-.163-.815h-.04v.815H17.7v-.978z',
							}),
							hAsync('path', {
								key: '5e884fcbbd8d255e892837d7b6f5486e799ebc6b',
								d: 'M18.667 3.484h.285c.285 0 .326.204.326.49s-.04.49-.326.49h-.285v-.978zm.163.856h.122c.122 0 .163-.08.163-.367s-.04-.367-.163-.367h-.122v.733z',
							}),
						),
						hAsync(
							'defs',
							{ key: '5b773213c5abca63a0e879d13693301c1d9545f5' },
							hAsync('path', {
								key: '5eba93bf556d3435e2c9496d41299c9087ee3d9f',
								id: 'B2',
								d: 'M4.693 11.47c-.04.082-.08.163-.08.245 0 .244.204.407.407.407h.08c.04 0 .326-.082.57-.122v-.733l-.978.204z',
							}),
						),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
				};
			}
			static get style() {
				return ontarioIconCss$12;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-interac-fr-alt',
					$members$: {
						iconWidth: [2, 'icon-width'],
						iconWidthState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$11 =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconLinkedin {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-linkedin> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-linkedin> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '6f3967acf2d27a1d06836b9e2c0af73d2b61501d',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '49827619a8ce42c29ed462674c71012a856ec07b',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'linkedin',
						},
						hAsync('path', {
							key: 'cf44051fc28b31bb25a703925595b0e8cb0fa4f1',
							d: 'M21 21h-4v-6.75c0-1.06-1.2-1.94-2.25-1.94S13 13.2 13 14.25V21H9V9h4v2c.66-1.07 2.36-1.76 3.5-1.76a4.51 4.51 0 0 1 4.5 4.51V21zM7 21H3V9h4v12zM5 3a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2 2 2 0 0 1 2-2z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$11;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-linkedin',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$10 =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconLinkedinAlt {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-linkedin-alt> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-linkedin-alt> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '9a3232c2685f82055d1b492026c8005b4b816984',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'cdfb0dd67c808c9fb57719be0e721abb3a8171a5',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'linkedin-alt',
						},
						hAsync('path', {
							key: 'ac9d8fbcb00ba1f7f708358da75fe093efeced17',
							d: 'M19 3a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14zm-.5 15.5v-5.3a3.26 3.26 0 0 0-3.26-3.26 2.9 2.9 0 0 0-2.32 1.3v-1.1h-2.8v8.37h2.8v-4.93c0-.77.62-1.4 1.4-1.4a1.4 1.4 0 0 1 1.4 1.4v4.93h2.8zM6.88 8.56a1.68 1.68 0 0 0 1.68-1.68c0-.93-.75-1.7-1.68-1.7a1.69 1.69 0 0 0-1.69 1.69c0 .93.76 1.68 1.7 1.68zm1.4 9.94v-8.37H5.5v8.37h2.77z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$10;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-linkedin-alt',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$$ =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconList {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-list> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-list> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'fe5f7b5b04d954dcdc9dc231bb722a5c9a11b014',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '031b4d51ae6b0121bd8136f67063aa0c29486740',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'list',
						},
						hAsync('path', {
							key: 'b4c8a9c67915881afe0081a1824a768992ee268c',
							d: 'M4 10.5a1.5 1.5 0 1 0 0 3 1.5 1.5 0 1 0 0-3zm0-6a1.5 1.5 0 1 0 0 3 1.5 1.5 0 1 0 0-3zm0 12c-.83 0-1.5.68-1.5 1.5A1.51 1.51 0 0 0 4 19.5 1.51 1.51 0 0 0 5.5 18c0-.82-.67-1.5-1.5-1.5zM7 19h14v-2H7v2zm0-6h14v-2H7v2zm0-8v2h14V5H7z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$$;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-list',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$_ =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconLiveChat {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-live-chat> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-live-chat> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '9831a33797b1f97e259f7dd0d0d1acb86cbbdaf3',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '42ea21659f5076e58b999a5ef72da792b7c91e4a',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'live-chat',
						},
						hAsync('path', {
							key: 'b22413ebc0bbbed3f18d8407439cdfd0f64722c9',
							d: 'M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 9h12v2H6V9zm8 5H6v-2h8v2zm4-6H6V6h12v2z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$_;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-live-chat',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$Z =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconLocationOff {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-location-off> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-location-off> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'ece9f9fcffc2199c462de5b768b4cac5ae12a58b',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'c2f6942d8aa2e30fb478d0fc93d6800a31eeac75',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'location-off',
						},
						hAsync('path', {
							key: 'c28f6a3f4256412703d4e8290f7b192228852c47',
							d: 'M20.94 11c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06c-1.13.12-2.2.46-3.16.97l1.5 1.5C10.16 5.2 11.06 5 12 5c3.87 0 7 3.13 7 7a7.03 7.03 0 0 1-.52 2.65l1.5 1.5c.5-.96.84-2.02.97-3.15H23v-2h-2.06zM3 4.27L5.04 6.3c-1.07 1.3-1.8 2.92-1.98 4.7H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c1.77-.2 3.38-.9 4.7-1.98L19.73 21 21 19.73 4.27 3 3 4.27zm13.27 13.27C15.1 18.45 13.6 19 12 19c-3.87 0-7-3.13-7-7 0-1.6.55-3.1 1.46-4.27l9.8 9.8z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$Z;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-location-off',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$Y =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconLocationOn {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-location-on> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-location-on> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'c4a6b298ea954c244f9638c8f4d43baccaf30268',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '7f1f913fc385e09aeb0d9604fcef1d5ae9de4bdf',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'location-on',
						},
						hAsync('path', {
							key: 'bad084e862d63c53b8f17fe07c2f90c8c8845931',
							d: 'M12 8a4 4 0 1 0 0 8 4 4 0 1 0 0-8zm8.94 3c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06C6.83 3.52 3.52 6.83 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c4.17-.46 7.48-3.77 7.94-7.94H23v-2h-2.06zM12 19c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$Y;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-location-on',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$X =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconLockOff {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-lock-off> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-lock-off> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '215774e2b2e43e1591db53b17638cc9b06472006',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'd1bb2d1280623ed57adcf8ae3a96c7d88941e9fb',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'lock-off',
						},
						hAsync('path', {
							key: 'a4eceae1502b4c8e32a59fafa4a890034301de9c',
							d: 'M18 8a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V10a2 2 0 0 1 2-2h9V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3H7a5 5 0 0 1 5-5 5 5 0 0 1 3.536 1.464A5 5 0 0 1 17 6v2h1zm-6 9a2 2 0 0 0 2-2 2 2 0 0 0-2-2 2 2 0 0 0-2 2 2 2 0 0 0 2 2z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$X;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-lock-off',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$W =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconLockOn {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-lock-on> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-lock-on> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'bf6da76f6ee9a826f038a357e1347665e2a718a5',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '12c87279a2e6823babd9cfbfa2af721400cb8085',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'lock-on',
						},
						hAsync('path', {
							key: '0e722f3f8e6ddda51f3e67b52a0119aab6db379b',
							d: 'M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.7 1.4-3.1 3.1-3.1s3.1 1.4 3.1 3.1v2z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$W;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-lock-on',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$V =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconMap {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-map> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-map> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '0b08aa3657326ef58e2d7776d25423d60be8d475',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '6c463d3a7ad552bbd8d1e24b351ead5398b82e86',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'map',
						},
						hAsync('path', {
							key: '1882d656ce97ac85bf40f2f66582ca79204b8864',
							d: 'M20.5 3l-.16.03L15 5.1 9 3 3.36 4.9c-.2.07-.36.25-.36.48V20.5c0 .28.22.5.5.5l.16-.03L9 18.9l6 2.1 5.64-1.9c.2-.07.36-.25.36-.48V3.5c0-.28-.22-.5-.5-.5zM15 19l-6-2.1V5l6 2.1V19z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$V;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-map',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$U =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconMastercard {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-mastercard> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			get host() {
				return getElement(this);
			}
			/**
			 * Validate that the `colour` attribute is not set by users
			 * Prints a warning message if the `colour` attribute is set
			 */
			validateColour() {
				if (this.host.hasAttribute('colour')) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' colour ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-mastercard> ')
						.addRegularText('cannot be set. The provided colour is ignored.')
						.printMessage();
				}
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'd150ea2b950753c0f6f721f1d72a4fb595f89faa',
						class: `ontario-icon ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'f244137dda77d7181a53c2645fb63ef4b56e1a2d',
							class: 'svg-icon',
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'mastercard',
						},
						hAsync('circle', {
							key: '30806a800c500c8ff4a70bba51a75f016adb32ed',
							cx: '8',
							cy: '12',
							r: '6.5',
							fill: '#eb001b',
						}),
						hAsync('circle', {
							key: '2b9826d666dc6e14ff1005d32c7d1a34123d5887',
							cx: '16',
							cy: '12',
							r: '6.5',
							fill: '#f79e1b',
						}),
						hAsync('path', {
							key: 'ddbe133712120618713950d9b6f64c7398af870d',
							d: 'M12 17.124S9.5 15.5 9.5 12 12 6.876 12 6.876 14.5 8.5 14.5 12 12 17.124 12 17.124z',
							fill: '#ff5f00',
						}),
						hAsync('path', {
							key: '44e868fe0299512193c001f05d87e20e00c29809',
							d: 'M21.173 16.85v-.3h.125v-.06H21v.06h.117v.3h.055zm.578 0v-.35h-.1l-.105.25-.105-.25h-.1v.35h.065v-.265l.098.227h.067l.098-.227v.265h.063z',
							fill: '#f79e1b',
						}),
						hAsync(
							'g',
							{ key: '1ee3b59b9e3a48997a74754c5b21a7acc9a3e1e3', fill: '#231f20' },
							hAsync('path', {
								key: 'a7c9714d10fc235552a9dd47b3cd34caacd151d9',
								d: 'M5.275 21.953v-1.098a.66.66 0 0 0-.187-.503.65.65 0 0 0-.501-.192.68.68 0 0 0-.35.072c-.108.055-.2.137-.265.24-.06-.1-.145-.18-.246-.235a.64.64 0 0 0-.332-.076.58.58 0 0 0-.513.26v-.216H2.5v1.75h.384V21c-.016-.12.023-.245.105-.333s.203-.138.324-.132c.253 0 .38.165.38.46v.974h.384V21c-.016-.12.024-.244.105-.333s.202-.138.323-.132c.26 0 .384.165.384.46v.974l.384-.007zm5.687-1.75h-.626v-.53h-.384v.53h-.348v.348h.355v.806c0 .406.157.648.608.648.168.001.333-.046.476-.136l-.1-.326c-.102.06-.218.095-.337.1-.183 0-.253-.117-.253-.293v-.798h.622l-.004-.348zm3.247-.044c-.186-.005-.368.096-.46.256v-.212h-.377v1.75h.38v-.98c0-.29.124-.45.366-.45a.62.62 0 0 1 .238.044l.117-.366c-.087-.03-.178-.047-.27-.048l.007.007zm-4.9.183a1.31 1.31 0 0 0-.714-.183c-.443 0-.732.212-.732.56 0 .286.212.46.604.516l.183.026c.21.03.308.084.308.183 0 .136-.14.212-.4.212a.93.93 0 0 1-.582-.183l-.183.297c.222.155.487.234.758.227.505 0 .798-.238.798-.57s-.23-.47-.61-.523l-.183-.026c-.165-.022-.297-.055-.297-.172s.124-.205.333-.205c.193.002.382.054.55.15l.168-.308zM19.5 20.16c-.186-.005-.368.096-.46.256v-.212h-.377v1.75h.38v-.98c0-.29.124-.45.366-.45a.62.62 0 0 1 .238.044l.117-.366c-.087-.03-.18-.047-.27-.048l.007.007zm-4.906.915c-.01.246.09.492.265.664s.423.265.67.25c.23.012.453-.063.63-.21l-.183-.308a.77.77 0 0 1-.458.158.56.56 0 0 1-.517-.56.56.56 0 0 1 .517-.56.77.77 0 0 1 .458.157l.183-.308c-.176-.146-.4-.22-.63-.21-.246-.014-.493.08-.67.25s-.274.418-.265.664v.007zm3.566 0v-.87h-.38v.212c-.13-.166-.34-.264-.55-.256-.243 0-.476.096-.647.268s-.268.404-.268.647.096.476.268.647.405.268.647.268c.21.008.42-.1.55-.256v.212h.38v-.87zm-1.417 0c.02-.323.338-.557.65-.484a.54.54 0 0 1 .4.422c.056.315-.195.62-.518.622-.3.004-.55-.264-.53-.56zm-4.595-.915c-.243.003-.474.103-.643.277s-.263.408-.26.65.103.474.277.643.408.262.65.26c.263.014.522-.07.727-.238l-.183-.282c-.145.116-.324.18-.51.183-.126.01-.25-.028-.35-.108s-.16-.195-.175-.32h1.3v-.146c0-.55-.34-.915-.83-.915l-.005-.004zm0 .34c.114-.003.227.042.31.12a.44.44 0 0 1 .133.304h-.915a.45.45 0 0 1 .465-.425h.007zm9.54.578V19.5h-.366v.915c-.13-.166-.34-.264-.55-.256-.243 0-.476.096-.647.268s-.268.404-.268.647.096.476.268.647.404.268.647.268c.21.008.42-.1.55-.256v.212h.366v-.868zm.635.62c.046-.001.092.017.126.05s.052.077.052.123-.02.1-.052.123-.08.05-.126.05c-.07-.001-.136-.043-.165-.106-.018-.043-.018-.093 0-.136a.18.18 0 0 1 .095-.091c.017-.007.072-.013.07-.013zm0 .31c.035 0 .07-.015.095-.04s.036-.058.036-.09c0-.05-.03-.1-.078-.12s-.112-.01-.15.03a.14.14 0 0 0 0 .183.14.14 0 0 0 .102.04h-.005zm-1.394-1.414c.315.074.49.43.365.723a.54.54 0 0 1-.484.321.54.54 0 0 1-.501-.347.54.54 0 0 1 .619-.697zm-13.505.484v-.875h-.38v.212c-.065-.083-.148-.15-.244-.194s-.2-.066-.306-.062c-.243 0-.476.096-.647.268s-.268.404-.268.647.096.476.268.647.404.268.647.268c.21.008.42-.1.55-.256v.212h.38v-.868zm-1.417 0c.02-.32.334-.558.65-.484a.54.54 0 0 1 .399.421c.056.315-.194.62-.518.623a.55.55 0 0 1-.535-.56h.004z',
							}),
							hAsync('path', {
								key: '7fb5cb0c1c0137bbb4294307810ceedbec8c2174',
								d: 'M22.335 21.79c.017-.001.033.002.047.012.005.005.01.01.013.017s.004.014.003.02c-.005.023-.008.028-.013.032-.01.01-.024.015-.038.016l.052.06h-.04l-.048-.06h-.016v.06h-.034v-.158h.075zm-.04.03v.043h.04c.012 0 .023.002.023-.008v-.023c0-.01-.002-.013-.023-.012h-.04z',
							}),
						),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
				};
			}
			static get style() {
				return ontarioIconCss$U;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-mastercard',
					$members$: {
						iconWidth: [2, 'icon-width'],
						iconWidthState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$T =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconMastercardAlt {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-mastercard-alt> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			get host() {
				return getElement(this);
			}
			/**
			 * Validate that the `colour` attribute is not set by users
			 * Prints a warning message if the `colour` attribute is set
			 */
			validateColour() {
				if (this.host.hasAttribute('colour')) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' colour ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-mastercard-alt> ')
						.addRegularText('cannot be set. The provided colour is ignored.')
						.printMessage();
				}
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '231fd79682e5157711a65fcb3b6b5deddd21aea8',
						class: `ontario-icon ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '72407e787b2abb48fcad200a9ba68c5fd318676c',
							class: 'svg-icon',
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'mastercard-alt',
						},
						hAsync('circle', {
							key: 'dfb1d3e9f648019d1f5b5a0a587722e1f05841fc',
							cx: '8',
							cy: '12',
							r: '6.5',
							fill: '#eb001b',
						}),
						hAsync('circle', {
							key: '3886c20763f3eb481bc7d04e93bd551a5a4bf818',
							cx: '16',
							cy: '12',
							r: '6.5',
							fill: '#f79e1b',
						}),
						hAsync('path', {
							key: '674de37b35f0750209185aebe092be71e8dc68f3',
							d: 'M12 17.124S9.5 15.5 9.5 12 12 6.876 12 6.876 14.5 8.5 14.5 12 12 17.124 12 17.124z',
							fill: '#ff5f00',
						}),
						hAsync('path', {
							key: '3d1301398badeefee3e7492a15f49d97fbdfcb28',
							d: 'M21.173 16.85v-.3h.125v-.06H21v.06h.117v.3h.055zm.578 0v-.35h-.1l-.105.25-.105-.25h-.1v.35h.065v-.265l.098.227h.067l.098-.227v.265h.063z',
							fill: '#f79e1b',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
				};
			}
			static get style() {
				return ontarioIconCss$T;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-mastercard-alt',
					$members$: {
						iconWidth: [2, 'icon-width'],
						iconWidthState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$S =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconMediaFastForward {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-media-fast-forward> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-media-fast-forward> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'c0589aefce7c064b3cb816d37ba7d03e1f9d1c6e',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'a91c8ac0708d7e8905518048990e1abda40eb32b',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'media-fast-forward',
						},
						hAsync('path', {
							key: 'a5a42ac1e6a29c9e70b284fe9640f6aeaed6cc09',
							d: 'M4 18l8.5-6L4 6v12zm9-12v12l8.5-6L13 6z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$S;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-media-fast-forward',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$R =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconMediaFastRewind {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-media-fast-rewind> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-media-fast-rewind> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'e5f35af2d0209732f36ed1b08aedd808e2145b50',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'b621cef98cadc8940baf349efc841fdc8a9744ca',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'media-fast-rewind',
						},
						hAsync('path', {
							key: 'f919a3abb3502064016cb55cffead7b895caea25',
							d: 'M11 18V6l-8.5 6 8.5 6zm.5-6l8.5 6V6l-8.5 6z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$R;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-media-fast-rewind',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$Q =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconMediaPause {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-media-pause> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-media-pause> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '193d91a4bb644fcd34240f55427ae039fca9d0a5',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'ce4b3720d87b8007dd7f0333673e83dcc9bab52e',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'media-pause',
						},
						hAsync('path', { key: '07b4d3e8b1eeae9a36c12552206823f469f7a8c8', d: 'M6 19h4V5H6v14zm8-14v14h4V5h-4z' }),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$Q;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-media-pause',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$P =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconMediaPlay {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-media-play> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-media-play> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '7261084a668d60a9293ebb55d287127f98464c94',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '1f8e11a8a6ef9955c90c41bc2228bf016d8418d5',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'media-play',
						},
						hAsync('path', { key: '9c94fd11a060e915b08792a96b82999730ece5cd', d: 'M8 5v14l11-7L8 5z' }),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$P;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-media-play',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$O =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconMediaStop {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-media-stop> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-media-stop> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '14bc4c751de2e901b8d48d013f5293a6e2c2471b',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '9194906f608ef471d0992bd275f4d1ad60c89f9c',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'media-stop',
						},
						hAsync('path', { key: 'fdd5ff0853bb5b472c12cadfb1dfd20f5aa510a5', d: 'M6 6H18V18H6V6Z' }),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$O;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-media-stop',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$N =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconMenu {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-menu> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-menu> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '77cc6faed206a0254ae796e84bdcd19d1df9f950',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '043be3221bcf4154d18f8a94eb7802383a631fd8',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							fill: 'none',
							viewBox: '0 0 24 24',
							id: 'menu',
						},
						hAsync('path', {
							key: 'a4e0b52c0f301e52408bf0712a93d3db2e46edf4',
							d: 'M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$N;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-menu',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$M =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconMenuHeader {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-menu-header> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-menu-header> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '620e175cfa3e03bb4c0e599205fe662f60bb04b1',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '7829e93fc65149495b9f17ad5a91551bcc454f53',
							xmlns: 'http://www.w3.org/2000/svg',
							width: '32',
							height: '32',
							fill: '#ffffff',
							viewBox: '0 0 24 24',
							id: 'menu-header',
						},
						hAsync('path', {
							key: '8237842ecaede5fa20e9946acc6af460a7d56a1f',
							d: 'M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z',
							fill: '#ffffff',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$M;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-menu-header',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$L =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconMicrophoneOff {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-microphone-off> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-microphone-off> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'deb72799cd76ddc709c39aa2fdd9e3e2a2adbf4c',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '2e94d5e53dec9885fe311b6bb1b3925ef525e927',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'microphone-off',
						},
						hAsync('path', {
							key: 'a278b5c28b92c391c77a0772b7ed92d90590334f',
							d: 'M19 11c0 1.2-.34 2.3-.9 3.28l-1.23-1.23c.27-.62.43-1.3.43-2.05H19zm-4 .16L9 5.18V5a3 3 0 0 1 3-3 3 3 0 0 1 3 3v6.16zM4.27 3L21 19.73 19.73 21l-4.2-4.2a7.03 7.03 0 0 1-2.54.91V21h-2v-3.28c-3.28-.5-6-3.3-6-6.72h1.7c0 3 2.54 5.1 5.3 5.1.8 0 1.6-.2 2.3-.52l-1.66-1.66L12 14a3 3 0 0 1-3-3v-.72l-6-6L4.27 3z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$L;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-microphone-off',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$K =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconMicrophoneOn {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-microphone-on> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-microphone-on> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '3c2cbd298efd2a4e86b47ec70b788e8b47a2e098',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '6723cb26dca42b717f8fae176b1d2b597e389828',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'microphone-on',
						},
						hAsync('path', {
							key: '9ce7490c553131609b58f8fc6dc240198f954318',
							d: 'M12 2a3 3 0 0 1 3 3v6a3 3 0 0 1-3 3 3 3 0 0 1-3-3V5a3 3 0 0 1 3-3zm7 9c0 3.53-2.6 6.44-6 6.93V21h-2v-3.07c-3.4-.5-6-3.4-6-6.93h2a5 5 0 0 0 5 5 5 5 0 0 0 5-5h2z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$K;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-microphone-on',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$J =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconMoreVertical {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-more-vertical> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-more-vertical> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '2bb45e985eeffb9174809c915ff638c30d08778d',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '2e0255479c64ef3856d2273b1c0dc9ef93d92e5c',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'more-vertical',
						},
						hAsync('path', {
							key: '2433945c2402d511343e0fad6af06c1dbc64a569',
							d: 'M12 16a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2 2 2 0 0 1 2-2zm0-6a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2 2 2 0 0 1 2-2zm0-6a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2 2 2 0 0 1 2-2z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$J;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-more-vertical',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$I =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconNewWindow {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-new-window> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-new-window> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'c40ae594024439deabfe669221c7afafca5c997b',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '4cf4ad750a252c86732a8ba638dcab445e5b9b81',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							fill: 'none',
							viewBox: '0 0 24 24',
							id: 'new-window',
						},
						hAsync('path', {
							key: 'c7a34a53492801e3c53e031d0dffe6a72aa16eb9',
							d: 'M19 19H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.6l-9.83 9.83 1.4 1.4L19 6.4V10h2V3h-7z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$I;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-new-window',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$H =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconNext {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-next> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-next> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '7cdb25fc43777474b639cfdbb9ff24dbf5e90bbb',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '5b2f0e1463ca74975d3d0c507224789c1d41bf82',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'next',
						},
						hAsync('path', {
							key: '4d327c08d831ddb81fedcf7e0a91b0fa54938de9',
							d: 'M22 12a10 10 0 0 1-10 10 10 10 0 0 1-7.071-2.929 10 10 0 0 1 0-14.142 10 10 0 0 1 10.898-2.168 10 10 0 0 1 5.412 5.412A10 10 0 0 1 22 12zm-12 6l6-6-6-6-1.4 1.4 4.6 4.6-4.6 4.6L10 18z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$H;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-next',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$G =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconNotification {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-notification> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-notification> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '7f3a7c99c4419be332e75e2ea51e2730bdce784a',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '5996cea2cfb5056a307f504b2582d8ca929eba10',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'notification',
						},
						hAsync('path', {
							key: '6f271fdd66edd6695dddef0c49cb9578b0dd0395',
							d: 'M21 19v1H3v-1l2-2v-6a6.99 6.99 0 0 1 5-6.71V4a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.3A6.99 6.99 0 0 1 19 11v6l2 2zm-7 2a2 2 0 0 1-2 2 2 2 0 0 1-2-2',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$G;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-notification',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$F =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconPasswordHide {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-password-hide> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-password-hide> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'b180ce4767d7b36d828f0611ee3e03df74885b3e',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'eef231fa57e949321dd9efd3e2af457ae6260698',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'password-hide',
						},
						hAsync('path', {
							key: 'bc8ddc973044813821134593f7f32870d0217fe4',
							d: 'M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.5-1.26 2.7-2.9 3.43-4.75-1.73-4.4-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27L4.74 7c-1.66 1.3-2.96 3-3.74 5 1.73 4.4 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55A2.82 2.82 0 0 0 9 12c0 1.66 1.34 3 3 3a2.82 2.82 0 0 0 .65-.08l1.55 1.55c-.67.33-1.4.53-2.2.53-2.76 0-5-2.24-5-5 0-.8.2-1.53.53-2.2zm4.3-.78L15 12.17V12c0-1.66-1.34-3-3-3l-.17.01z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$F;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-password-hide',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$E =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconPasswordShow {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-password-show> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-password-show> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'dfd88764b0146cf22364d6b6041c21f25d852f60',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '720a4190b52704be9d078063c7b1bb9831238c89',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'password-show',
						},
						hAsync('path', {
							key: '8530a89769a535bfd4f58b5c82bbb21d3c5b19c6',
							d: 'M12 4.5C7 4.5 2.73 7.6 1 12c1.73 4.4 6 7.5 11 7.5s9.27-3.1 11-7.5c-1.73-4.4-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$E;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-password-show',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$D =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconPhone {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-phone> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-phone> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '5c87805e6d300cf50fa3782920c9dfe2b1b49bc0',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '95c438e3ee415f4b1bd0f25768057677719fb5b8',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							fill: 'none',
							viewBox: '0 0 24 24',
							id: 'phone',
						},
						hAsync('path', {
							key: '8fbdbd5530a9f4483cca1e198cb76bb156260266',
							d: 'M20 15.38c-1.23 0-2.42-.2-3.53-.56-.35-.12-.74-.03-1 .24l-1.57 1.97c-2.83-1.35-5.48-3.9-6.9-6.83l1.95-1.66a1.02 1.02 0 0 0 .24-1.02c-.37-1.1-.56-2.3-.56-3.53A1 1 0 0 0 7.65 3H4.2C3.65 3 3 3.24 3 4c0 9.3 7.73 17 17 17 .7 0 1-.63 1-1.18v-3.45a1 1 0 0 0-.99-.99z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$D;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-phone',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$C =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconPhoto {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-photo> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-photo> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'b1cabc34bab9cbba0c976054bc24edd6d0d28c40',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '93250ec947aa78618ecd1bc635bebe62ce865ac7',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'photo',
						},
						hAsync('path', {
							key: '4604cb06f0468d891a6f03056679c81b5a90ef9f',
							d: 'M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3 3.5-4.5 4.5 6H5l3.5-4.5z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$C;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-photo',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$B =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconPinLocationOff {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-pin-location-off> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-pin-location-off> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'aae2c5909148c070e94a477ea22ed4f38c56b163',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '7c0059df4f92fab47e2638b61ab2960569ca7def',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'pin-location-off',
						},
						hAsync('path', {
							key: '5905dcdd001e8b0e14c60b65bbaaf504909bdca8',
							d: 'M16.37 16.1l-4.73-4.74L3.27 3 2 4.27l3.18 3.18C5.06 7.95 5 8.46 5 9c0 5.25 7 13 7 13s1.67-1.85 3.37-4.35L18.73 21 20 19.72l-3.63-3.62zM12 6.5A2.5 2.5 0 0 1 14.5 9c0 .73-.33 1.4-.83 1.85l3.63 3.65c.98-1.88 1.7-3.82 1.7-5.5a7 7 0 0 0-7-7c-2 0-3.76.82-5.04 2.14l3.2 3.2A2.47 2.47 0 0 1 12 6.5z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$B;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-pin-location-off',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$A =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconPinLocationOn {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-pin-location-on> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-pin-location-on> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '90a2e79e2ed986c362a8ac739839bc91037df58f',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'a6bc1b7658a06624fb32094ca24b662daf9c7a97',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'pin-location-on',
						},
						hAsync('path', {
							key: '4e960d23127cf05e0877272edeffd7f92730dcbe',
							d: 'M12 11.5A2.5 2.5 0 0 1 9.5 9 2.5 2.5 0 0 1 12 6.5 2.5 2.5 0 0 1 14.5 9a2.5 2.5 0 0 1-.732 1.768A2.5 2.5 0 0 1 12 11.5zM12 2a7 7 0 0 0-7 7c0 5.25 7 13 7 13s7-7.75 7-13a7 7 0 0 0-7-7z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$A;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-pin-location-on',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$z =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconPrevious {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-previous> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-previous> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'c23053b38ea1f15038fbfb480c50a1024e8e2ef7',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '1c71a1f44f56469f868fdba34cabf13c7913fdb5',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'previous',
						},
						hAsync('path', {
							key: '96156cd83fcff7901016cc22800d1e3dadd70496',
							d: 'M22 12a10 10 0 0 1-10 10 10 10 0 0 1-7.071-2.929 10 10 0 0 1 0-14.142 10 10 0 0 1 10.898-2.168 10 10 0 0 1 5.412 5.412A10 10 0 0 1 22 12zm-6.6 4.6L10.8 12l4.6-4.6L14 6l-6 6 6 6 1.4-1.4z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$z;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-previous',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$y =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconPrint {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-print> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-print> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '4b410905ba7847885122e2b9afcc47ec283f8536',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '9f92246b9f6d5fb138e42e0e94202c087619312d',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'print',
						},
						hAsync('path', {
							key: '765394bbbb1288e8453d41451967f0c7eefcb6da',
							d: 'M19 8H5c-1.66 0-3 1.34-3 3v6h4v4h12v-4h4v-6c0-1.66-1.34-3-3-3zm-3 11H8v-5h8v5zm3-7c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-1-9H6v4h12V3z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$y;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-print',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$x =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconRemove {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-remove> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-remove> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '17b172242cfaec42e6fbc07eb2f2464370381e50',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '6b38f84fe0125be1af6ff4bbff8787983008d49a',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							fill: 'none',
							viewBox: '0 0 24 24',
							id: 'remove',
						},
						hAsync('path', {
							key: 'd63607623733d367ca5b694d97b05bbb0c383362',
							d: 'M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.4 0-8-3.6-8-8s3.6-8 8-8 8 3.6 8 8-3.6 8-8 8z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$x;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-remove',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$w =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconRemoveAlt {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-remove-alt> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-remove-alt> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'e321bac30815ca5125d28ef016b9276d07a14ee6',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '81e718713a3e8d0e62715c7c7a88368c52eecaef',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							fill: 'none',
							viewBox: '0 0 24 24',
							id: 'remove-alt',
						},
						hAsync('path', {
							key: '64badfe690e3bc0b2d14aa9b89dcdc122f7a5c5d',
							d: 'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11H7v-2h10v2z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$w;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-remove-alt',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$v =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconReplay {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-replay> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-replay> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '5d4f3fd8b64cf5449ccfba148543a64e86edad7b',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '069303adc7be6725e40990f50f29c37a094fe3b9',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'replay',
						},
						hAsync('path', {
							key: 'a840a071179a449e63e5c0f0f30d6cf5e3580e01',
							d: 'M17.65 6.35C16.2 4.9 14.2 4 12 4a7.99 7.99 0 0 0-7.99 8A7.99 7.99 0 0 0 12 20c3.73 0 6.84-2.55 7.73-6h-2.08A5.99 5.99 0 0 1 12 18c-3.3 0-6-2.7-6-6s2.7-6 6-6c1.66 0 3.14.7 4.22 1.78L13 11h7V4l-2.35 2.35z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$v;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-replay',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$u =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconRssFeed {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-rss-feed> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-rss-feed> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'c26b785df5e76189569f49ac17393bda1494e7c1',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'd129ff5680fc7ab3420c92e242f791bf011c99d0',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'rss-feed',
						},
						hAsync('path', {
							key: '83ba95bd8ec4c23d992702b6f4e92f678dad2020',
							d: 'M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83C19.56 11.4 12.6 4.44 4 4.44zm0 5.66v2.83A7.08 7.08 0 0 1 11.07 20h2.83A9.9 9.9 0 0 0 4 10.1zM6.18 20a2.18 2.18 0 1 0 0-4.36 2.18 2.18 0 1 0 0 4.36z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$u;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-rss-feed',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$t =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconSave {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-save> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-save> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '043d823bb4a2f18c21c8ba646bf997ab4225a593',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '01d6ac85d4ea92052d405519d16d4b2a6f8ca96e',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'save',
						},
						hAsync('path', {
							key: '2886107f89169a4ad064b3f42485cc8bc0671dd6',
							d: 'M17 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$t;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-save',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$s =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconSearch {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-search> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-search> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'bf96493fb19de02ed5b113624fefd4f66eb4e80c',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '95b6dbd9ec7b20eb06d520e225265efea07af7df',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							fill: 'none',
							viewBox: '0 0 24 24',
							id: 'search',
						},
						hAsync('path', {
							key: '9dfc27e749cc1c4a93ebc9dc182c2b924e006f7b',
							d: 'M15.5 14h-.8l-.28-.27A6.47 6.47 0 0 0 16 9.5a6.5 6.5 0 1 0-13 0A6.5 6.5 0 0 0 9.5 16a6.47 6.47 0 0 0 4.23-1.57l.27.28v.8l5 5 1.5-1.5-5-5zm-6 0C7 14 5 12 5 9.5S7 5 9.5 5 14 7 14 9.5 12 14 9.5 14z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$s;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-search',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$r =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconSearchWhite {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-search-white> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-search-white> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'e33d6f6905bc8c1ce9aee4f861da08963a23be59',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '41b44e7e6ddb9dab6a9b72317c6a935ca3760b3c',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							width: '32',
							height: '32',
							viewBox: '0 0 24 24',
							fill: '#ffffff',
							id: 'search-white',
						},
						hAsync('path', {
							key: 'bb68cd7d54f3e9d7e7da808e58b8bd8f008c961a',
							d: 'M15.5 14h-.8l-.28-.27A6.47 6.47 0 0 0 16 9.5a6.5 6.5 0 1 0-13 0A6.5 6.5 0 0 0 9.5 16a6.47 6.47 0 0 0 4.23-1.57l.27.28v.8l5 5 1.5-1.5-5-5zm-6 0C7 14 5 12 5 9.5S7 5 9.5 5 14 7 14 9.5 12 14 9.5 14z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$r;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-search-white',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$q =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconSentiment1 {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-sentiment-1> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-sentiment-1> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '4ef3bd926e1f5fad3cc1266eedf45c18c269ce33',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '0a985b7261dd86d278fac5127715fb44fd8d849b',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'sentiment-1',
						},
						hAsync('path', {
							key: 'f19dc7bbb0057ad7cdd3b19dfe126bb60c9cb198',
							d: 'M12 2a10 10 0 1 0 0 20 10.01 10.01 0 0 0 10-10A10.01 10.01 0 0 0 11.99 2zm0 18a8 8 0 1 1 0-16 8 8 0 1 1 0 16zm0-6c-2.33 0-4.32 1.45-5.12 3.5h1.67c.7-1.2 1.97-2 3.45-2s2.75.8 3.45 2h1.67c-.8-2.05-2.8-3.5-5.12-3.5zm3.5-3a1.5 1.5 0 1 0 0-3 1.5 1.5 0 1 0 0 3zm-7 0a1.5 1.5 0 1 0 0-3 1.5 1.5 0 1 0 0 3z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$q;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-sentiment-1',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$p =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconSentiment2 {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-sentiment-2> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-sentiment-2> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '183a3bd7ca2886044bdadec2fa662a2a841d2cbd',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'f6fb13305cec4d6ccb34576e0bab2dd44e2b47e7',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'sentiment-2',
						},
						hAsync('path', {
							key: '105fa98d56c8f5c8dad53a92ffd8762d09fa8f34',
							d: 'M12 2a10 10 0 1 0 0 20 10.01 10.01 0 0 0 10-10A10.01 10.01 0 0 0 11.99 2zm0 18a8 8 0 1 1 0-16 8 8 0 1 1 0 16zm0-3.5c.73 0 1.4.2 1.97.53l1-1.14A5.39 5.39 0 0 0 12 15a5.61 5.61 0 0 0-3 .88c.97 1.1.01.02 1 1.14a4.03 4.03 0 0 1 1.98-.52zm3.5-5.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 1 0 0 3zm-7 0a1.5 1.5 0 1 0 0-3 1.5 1.5 0 1 0 0 3z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$p;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-sentiment-2',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$o =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconSentiment3 {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-sentiment-3> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-sentiment-3> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '922f496cd2954707d1c233ffbcbf10e743e6eb53',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '0601fcdde1cf6dd722d1da519a81eaadd432c1a1',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'sentiment-3',
						},
						hAsync('path', {
							key: '5bc4b26906853f72f8bc7b86307826636ffc421c',
							d: 'M12 2a10 10 0 1 0 0 20 10.01 10.01 0 0 0 10-10A10.01 10.01 0 0 0 11.99 2zm0 18a8 8 0 1 1 0-16 8 8 0 1 1 0 16zm0-4a3.8 3.8 0 0 1-1.96-.52l-1 1.15c.86.55 1.87.87 2.97.87a5.49 5.49 0 0 0 2.98-.88c-.97-1.1-.01-.02-1-1.15a3.8 3.8 0 0 1-1.97.53zm3.5-5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 1 0 0 3zm-7 0a1.5 1.5 0 1 0 0-3 1.5 1.5 0 1 0 0 3z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$o;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-sentiment-3',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$n =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconSentiment4 {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-sentiment-4> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-sentiment-4> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '315374cbe1c89ad55ae722a9e9a8fd068a02f4c6',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '8584488da607e7c0a3fda36c2473eb9f99735ccf',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'sentiment-4',
						},
						hAsync('path', {
							key: '8d5ae2de2fe2c955697540911af18df0203cd27e',
							d: 'M12 2a10 10 0 1 0 0 20 10.01 10.01 0 0 0 10-10A10.01 10.01 0 0 0 11.99 2zm0 18a8 8 0 1 1 0-16 8 8 0 1 1 0 16zm0-2.5c2.33 0 4.32-1.45 5.12-3.5h-1.67c-.7 1.2-1.97 2-3.45 2s-2.75-.8-3.45-2H6.88c.8 2.05 2.8 3.5 5.12 3.5zm3.5-6.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 1 0 0 3zm-7 0a1.5 1.5 0 1 0 0-3 1.5 1.5 0 1 0 0 3z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$n;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-sentiment-4',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$m =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconSentiment5 {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-sentiment-5> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-sentiment-5> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '9c4f4634a2cea0c7677921f5a3cb9fd2cc1efac8',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '005efdc7bccba37ff2a3f6d3a10f4baff3f54ae9',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'sentiment-5',
						},
						hAsync('path', {
							key: 'ff4d4060bdac614f31ee5a1de5657893b85798cf',
							d: 'M12 2a10 10 0 1 0 0 20 10.01 10.01 0 0 0 10-10A10.01 10.01 0 0 0 11.99 2zm0 18a8 8 0 1 1 0-16 8 8 0 1 1 0 16zm-5-6c.78 2.34 2.72 4 5 4s4.22-1.66 5-4H7zm8.5-3a1.5 1.5 0 1 0 0-3 1.5 1.5 0 1 0 0 3zm-7 0a1.5 1.5 0 1 0 0-3 1.5 1.5 0 1 0 0 3z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$m;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-sentiment-5',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$l =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconSettings {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-settings> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-settings> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '96f3b089b6b9dd3d125135fb9c8bd72b697688c4',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '7b61221c1881300ef8d14c3ccf124f8ed049fe2a',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'settings',
						},
						hAsync('path', {
							key: '47ac8ae75c2936567067d8ad4dfa86e83de6f8c7',
							d: 'M12 15.5A3.5 3.5 0 0 1 8.5 12 3.5 3.5 0 0 1 12 8.5a3.5 3.5 0 0 1 3.5 3.5 3.5 3.5 0 0 1-3.5 3.5zm7.43-2.53a7.77 7.77 0 0 0 .07-.97 8.55 8.55 0 0 0-.07-1l2.1-1.63c.2-.15.24-.42.12-.64l-2-3.46a.49.49 0 0 0-.61-.22l-2.5 1c-.52-.4-1.06-.73-1.7-.98l-.37-2.65c-.04-.24-.25-.42-.5-.42h-4c-.25 0-.46.18-.5.42l-.37 2.65c-.63.25-1.17.6-1.7.98l-2.5-1a.49.49 0 0 0-.61.22l-2 3.46c-.13.22-.07.5.12.64L4.57 11l-.07 1a7.77 7.77 0 0 0 .07.97l-2.1 1.66c-.2.15-.25.42-.12.64l2 3.46c.12.22.4.3.6.22l2.5-1c.52.4 1.06.74 1.7 1l.37 2.65c.04.24.25.42.5.42h4c.25 0 .46-.18.5-.42l.37-2.65a7.28 7.28 0 0 0 1.69-.99l2.5 1c.22.08.5 0 .6-.22l2-3.46c.12-.22.07-.5-.12-.64l-2.1-1.66z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$l;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-settings',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$k =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconShare {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-share> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-share> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '16454fc71948b2aa4db01540ad7e1c33d3904ad9',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '6fcf53dc0b608550a562e79f396a1f6553e67389',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'share',
						},
						hAsync('path', {
							key: 'e094708ade2d01a9ae4add6576c3b68c3e4a2627',
							d: 'M18 16.08c-.76 0-1.44.3-1.96.77L8.9 12.7c.05-.23.1-.46.1-.7s-.04-.47-.1-.7l7.05-4.1c.54.5 1.25.8 2.04.8 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.1.7L8.04 9.8C7.5 9.3 6.8 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.8 0 1.5-.3 2.04-.8l7.12 4.16a2.82 2.82 0 0 0-.08.65c0 1.6 1.3 2.92 2.92 2.92s2.92-1.3 2.92-2.92-1.3-2.92-2.92-2.92z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$k;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-share',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$j =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconSort {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-sort> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-sort> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '65ed85342ecdbf46ec4ba0b3c4a951123453c2f5',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'fa4d3943963572b8f025211359cc341b8e274c9f',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'sort',
						},
						hAsync('path', {
							key: '1d48956a6ea15149ba07872a235de0c97b43aac0',
							d: 'M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$j;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-sort',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$i =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconTag {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-tag> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-tag> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '1ed3b6ca0bf851caccee428498fc7cbd03df359a',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '20d47d0591bceeddd19a8384f1146d7b2a05a80a',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'tag',
						},
						hAsync('path', {
							key: '722d470acac060c435fc21d64bf5c14765b35d1d',
							d: 'M5.5 7A1.5 1.5 0 0 1 4 5.5 1.5 1.5 0 0 1 5.5 4 1.5 1.5 0 0 1 7 5.5 1.5 1.5 0 0 1 5.5 7zm15.9 4.58l-9-9C12.05 2.22 11.55 2 11 2H4c-1.1 0-2 .9-2 2v7c0 .55.22 1.05.6 1.4l9 9c.37.36.87.6 1.42.6s1.05-.23 1.4-.6l7-7c.37-.36.6-.86.6-1.4a2 2 0 0 0-.59-1.42z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$i;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-tag',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$h =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconTextMessage {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-text-message> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-text-message> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '45e4ac070edf568109ae4ffe7ecf8f308092dadf',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'c95f96179a4f8cff4230cdb6e780c6f932b12044',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'text-message',
						},
						hAsync('path', {
							key: '222eca5ecc4a5a6483bce40da148d79a4fdd4360',
							d: 'M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM9 11H7V9h2v2zm4 0h-2V9h2v2zm4 0h-2V9h2v2z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$h;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-text-message',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$g =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconTimer {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-timer> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-timer> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '94c2aa5e551ad4ad600c2cb87a5cb3a20cfe816d',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'c782fd978f1e2e44c84f8c1a0226a57e794372ba',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'timer',
						},
						hAsync('path', {
							key: '374ca0c61d8f5c5a6c16dab7d95e6fa9621405e1',
							d: 'M15 1H9v2h6V1zm-4 13h2V8h-2v6zm8.03-6.6l1.42-1.42c-.43-.5-.9-1-1.4-1.4l-1.42 1.42A8.96 8.96 0 0 0 12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9 9-4.03 9-9c0-2.12-.74-4.07-1.97-5.6zM12 20c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$g;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-timer',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$f =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconTransportBicycle {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-transport-bicycle> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-transport-bicycle> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '0f763277963ab297e2748a74fe85f00aae34890d',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '14ff7ce3cdd2fba9afe4d4bfa0bc4541b547d6bf',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'transport-bicycle',
						},
						hAsync('path', {
							key: 'e4802af0f73016c3f31cf10d34c711d9adf80c1e',
							d: 'M15.208 6.167a1.84 1.84 0 0 0 1.833-1.833A1.84 1.84 0 0 0 15.208 2.5a1.84 1.84 0 0 0-1.833 1.833 1.84 1.84 0 0 0 1.833 1.833zm-9.625 5.958C3.017 12.125 1 14.142 1 16.708s2.017 4.583 4.583 4.583 4.583-2.017 4.583-4.583-2.017-4.583-4.583-4.583zm0 7.792a3.25 3.25 0 0 1-3.208-3.208A3.25 3.25 0 0 1 5.583 13.5a3.25 3.25 0 0 1 3.208 3.208 3.25 3.25 0 0 1-3.208 3.208zM10.9 10.75l2.2-2.2.733.733a6.42 6.42 0 0 0 4.675 1.925V9.375c-1.375 0-2.475-.55-3.3-1.375l-1.742-1.742c-.458-.367-.917-.55-1.467-.55a1.71 1.71 0 0 0-1.283.55L8.15 8.825a1.81 1.81 0 0 0-.55 1.283c0 .55.183 1.008.55 1.283l2.933 2.567v4.583h1.833v-5.683L10.9 10.75zm7.517 1.375c-2.567 0-4.583 2.017-4.583 4.583s2.017 4.583 4.583 4.583S23 19.275 23 16.708s-2.017-4.583-4.583-4.583zm0 7.792a3.25 3.25 0 0 1-3.208-3.208 3.25 3.25 0 0 1 3.208-3.208 3.25 3.25 0 0 1 3.208 3.208 3.25 3.25 0 0 1-3.208 3.208z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$f;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-transport-bicycle',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$e =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconTransportBus {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-transport-bus> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-transport-bus> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '0b7af2b287616b1dd8b6d90a8b2fe2a2a62b9707',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'bfd00eab247a3cd6bdd61f3412ad3075418d1bac',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'transport-bus',
						},
						hAsync('path', {
							key: '4b96e7e96d6e86a074166fb6fb0d7aebf8a4290b',
							d: 'M4 16c0 .88.4 1.67 1 2.22V20c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1h8v1c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1.78c.6-.55 1-1.34 1-2.22V6c0-3.5-3.58-4-8-4s-8 .5-8 4v10zm3.5 1a1.5 1.5 0 1 1 0-3 1.5 1.5 0 1 1 0 3zm9 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 1 1 0 3zm1.5-6H6V6h12v5z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$e;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-transport-bus',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$d =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconTransportCar {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-transport-car> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-transport-car> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '8c3f8a6519495cf8d9b2747f26fa4aedc62f74dc',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'cf8ad362514cf669f2cf77af76db7f1fc5982425',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'transport-car',
						},
						hAsync('path', {
							key: '01c26f5bb45a032b51faaa3a26c6d47b87a6ccaf',
							d: 'M18.92 6c-.2-.6-.76-1-1.42-1h-11c-.66 0-1.2.42-1.42 1L3 12v8c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1h12v1c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-8l-2.08-6zM6.5 16a1.5 1.5 0 1 1 0-3 1.5 1.5 0 1 1 0 3zm11 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 1 1 0 3zM5 11l1.5-4.5h11L19 11H5z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$d;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-transport-car',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$c =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconTransportWalk {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-transport-walk> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-transport-walk> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '8239b6c01f0e61a40a97fcbaf277195284530569',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '278bad7bdb09e9e81c2ab5c171907083d3bf6e76',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'transport-walk',
						},
						hAsync('path', {
							key: '2738ae1fe7baf1f98fdad139dd0d8941a617c8c3',
							d: 'M13.326 5.407a1.96 1.96 0 0 0 1.954-1.953A1.96 1.96 0 0 0 13.326 1.5a1.96 1.96 0 0 0-1.953 1.953 1.96 1.96 0 0 0 1.954 1.953zm-3.614 3.32L6.977 22.5h2.05l1.758-7.814 2.05 1.954v5.86h1.954v-7.326l-2.05-1.953.586-2.93c1.27 1.465 3.026 2.442 5.174 2.442V10.78c-1.856 0-3.22-.977-4.002-2.344l-.977-1.563c-.39-.586-.977-.977-1.66-.977-.193 0-.56.005-.78.098L6 8.142v4.59h1.953v-3.32l1.758-.684z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$c;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-transport-walk',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$b =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconTty {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-tty> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-tty> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '599fe5acb8b619bdc599533237d05d7921237b4a',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'd6c29f430daf4c43c540d3c5a5af5782a9c12674',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							fill: 'none',
							viewBox: '0 0 24 24',
							id: 'tty',
						},
						hAsync('path', {
							key: 'c0682d6f3579b37ff1e0192293271c917187a349',
							d: 'M2.2 6.056c5.41-5.41 14.177-5.403 19.58 0 .237.237.276.605.1.886l-1.688 2.7c-.09.142-.225.25-.385.3s-.333.047-.488-.016l-3.376-1.35c-.144-.058-.266-.16-.346-.293s-.116-.288-.1-.443l.232-2.325a11.07 11.07 0 0 0-7.48 0l.233 2.325c.015.155-.02.3-.1.443s-.202.236-.346.293L4.67 9.928c-.156.062-.33.068-.488.016s-.296-.16-.385-.3L2.11 6.94c-.086-.137-.123-.3-.104-.46s.09-.31.205-.425zm3.54 7.976V12.47A.47.47 0 0 0 5.281 12H3.72a.47.47 0 0 0-.469.469v1.563a.47.47 0 0 0 .469.469H5.28a.47.47 0 0 0 .469-.469zm3.75 0V12.47A.47.47 0 0 0 9.031 12H7.47a.47.47 0 0 0-.469.469v1.563a.47.47 0 0 0 .469.469H9.03a.47.47 0 0 0 .469-.469zm3.75 0V12.47a.47.47 0 0 0-.469-.469H11.22a.47.47 0 0 0-.469.469v1.563a.47.47 0 0 0 .469.469h1.563a.47.47 0 0 0 .469-.469zm3.75 0V12.47a.47.47 0 0 0-.469-.469H14.97a.47.47 0 0 0-.469.469v1.563a.47.47 0 0 0 .469.469h1.563a.47.47 0 0 0 .469-.469zm3.75 0V12.47a.47.47 0 0 0-.469-.469H18.72a.47.47 0 0 0-.469.469v1.563a.47.47 0 0 0 .469.469h1.563a.47.47 0 0 0 .469-.469zM7.625 17.78V16.22a.47.47 0 0 0-.469-.469H5.594a.47.47 0 0 0-.469.469v1.563a.47.47 0 0 0 .469.469h1.563a.47.47 0 0 0 .469-.469zm3.75 0V16.22a.47.47 0 0 0-.469-.469H9.344a.47.47 0 0 0-.469.469v1.563a.47.47 0 0 0 .469.469h1.563a.47.47 0 0 0 .469-.469zm3.75 0V16.22a.47.47 0 0 0-.469-.469h-1.562a.47.47 0 0 0-.469.469v1.563a.47.47 0 0 0 .469.469h1.563a.47.47 0 0 0 .469-.469zm3.75 0V16.22a.47.47 0 0 0-.469-.469h-1.562a.47.47 0 0 0-.469.469v1.563a.47.47 0 0 0 .469.469h1.563a.47.47 0 0 0 .469-.469zM5.75 21.53V19.97a.47.47 0 0 0-.469-.469H3.72a.47.47 0 0 0-.469.469v1.563a.47.47 0 0 0 .469.469H5.28a.47.47 0 0 0 .469-.469zm11.25 0V19.97a.47.47 0 0 0-.469-.469H7.47a.47.47 0 0 0-.469.469v1.563a.47.47 0 0 0 .469.469h9.063a.47.47 0 0 0 .469-.469zm3.75 0V19.97a.47.47 0 0 0-.469-.469H18.72a.47.47 0 0 0-.469.469v1.563a.47.47 0 0 0 .469.469h1.563a.47.47 0 0 0 .469-.469z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$b;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-tty',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$a =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconTwitter {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-twitter> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-twitter> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '4c4d0054e8c0bfcce9392b9fbe3ba8f0884203f5',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'ea429b1da32f8656226cf7c84bc19fa8725ab3ad',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'twitter',
						},
						hAsync('path', {
							key: '56d15fe253c062f769ce43debf4c4299a9690ed9',
							d: 'M22.46 6c-.77.35-1.6.58-2.46.7a4.3 4.3 0 0 0 1.88-2.38 8.64 8.64 0 0 1-2.72 1.05C18.37 4.5 17.26 4 16 4c-2.35 0-4.27 1.92-4.27 4.3a4.46 4.46 0 0 0 .11.98C8.28 9.1 5.1 7.38 3 4.8c-.37.63-.58 1.37-.58 2.15 0 1.5.75 2.8 1.9 3.56-.7 0-1.37-.2-1.95-.5v.03c0 2.08 1.48 3.82 3.44 4.2a4.22 4.22 0 0 1-1.13.15c-.27 0-.54-.03-.8-.08a4.28 4.28 0 0 0 4 2.98c-1.46 1.16-3.3 1.84-5.33 1.84-.34 0-.68-.02-1.02-.06C3.44 20.3 5.7 21 8.12 21c7.88 0 12.2-6.54 12.2-12.2 0-.2 0-.37-.01-.56.84-.6 1.56-1.36 2.14-2.23z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$a;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-twitter',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$9 =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconTwitterAlt {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-twitter-alt> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-twitter-alt> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '7072860b7f161bc3fa148ac9619ba029a9d517bc',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'e6975e0a1b7b2a263f1978ca074b00526485f008',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'twitter-alt',
						},
						hAsync('path', {
							key: '0e82a4cb5a1e7cd3dbaa0e4eb905248dffd968a0',
							d: 'M5 3h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2zm12.7 6.33c.48-.4 1.04-.88 1.3-1.4-.4.2-.9.34-1.44.4.5-.36.9-.83 1.12-1.47-.52.28-1.05.52-1.7.64-1.55-1.87-5.26-.35-4.6 2.45-2.6-.16-4.2-1.34-5.52-2.8-.75 1.22-.1 3.07.8 3.58-.46-.03-.8-.17-1.14-.33.04 1.54.9 2.28 2.08 2.68-.36.07-.76.1-1.14.03C7.8 14.2 8.58 14.86 9.9 15c-.9.76-2.56 1.3-3.9 1.08 1.15.73 2.46 1.3 4.28 1.23 4.4-.2 7.36-3.36 7.43-7.98z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$9;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-twitter-alt',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$8 =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconUpload {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-upload> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-upload> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'd01f692c5eab7fdb475637da2b6f094bb44c2003',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'c804dda5d9379b0a58f5aa8052c81863fa09654a',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'upload',
						},
						hAsync('path', {
							key: '5ad0a13abfeedc0513366e11eb7a9c994f61889f',
							d: 'M9 16v-6H5l7-7 7 7h-4v6H9zm-4 4v-2h14v2H5z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$8;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-upload',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$7 =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconVideo {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-video> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-video> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'dd2a7fa16dec91dbb64725e974ee85c58bbb925a',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '322cf168816b7dd37cfa0356e263edd7fc1415dd',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'video',
						},
						hAsync('path', {
							key: 'd16ae57f038f52a56d7fa206ce4c0c8efb12ff24',
							d: 'M21 3H3c-1.1 0-2 .9-2 2v12a2 2 0 0 0 2 2h5v2h8v-2h5c1.1 0 2-.9 2-2V5a2 2 0 0 0-2-2zm0 14H3V5h18v12zm-5-6l-7 4V7l7 4z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$7;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-video',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$6 =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconVisa {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-visa> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			get host() {
				return getElement(this);
			}
			/**
			 * Validate that the `colour` attribute is not set by users
			 * Prints a warning message if the `colour` attribute is set
			 */
			validateColour() {
				if (this.host.hasAttribute('colour')) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' colour ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-visa> ')
						.addRegularText('cannot be set. The provided colour is ignored.')
						.printMessage();
				}
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '28870e21ad247112de02ff7056d4a22b93426b55',
						class: `ontario-icon ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '9dd7ddad9d612a2c7fe78eb3749200016edb424e',
							class: 'svg-icon',
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'visa',
						},
						hAsync('path', {
							key: 'f7aafd58e3690a9ab8c1ad47fab827e458094767',
							d: 'M23 5H1v13.974h22V5z',
							fill: '#fff',
						}),
						hAsync('path', {
							key: '4f456332df03f88447bd01304b8bc1d6cc34c3ae',
							d: 'M22.633 16.703H1.367v1.905h21.267v-1.905z',
							fill: '#fcb316',
						}),
						hAsync('path', {
							key: 'f5be2a587529409aeb034a741d376d34f0873504',
							d: 'M22.633 5.367H1.367v1.905h21.267V5.367zM9.882 9.37l-2.2 5.245H6.245l-1.08-4.186c-.06-.255-.122-.357-.326-.458-.326-.173-.866-.346-1.334-.448l.03-.153h2.312a.62.62 0 0 1 .621.53l.57 3.045L8.445 9.38H9.88v-.01zm5.612 3.534c.01-1.385-1.915-1.457-1.895-2.078 0-.183.183-.387.57-.438a2.65 2.65 0 0 1 1.334.234l.234-1.1a3.55 3.55 0 0 0-1.273-.234c-1.344 0-2.28.713-2.292 1.73-.01.754.672 1.17 1.18 1.426.53.255.703.418.703.652 0 .356-.418.5-.815.5-.682.01-1.08-.183-1.395-.336l-.245 1.15c.316.143.906.275 1.507.275 1.446.01 2.383-.693 2.383-1.782zm3.544 1.7h1.253l-1.1-5.245h-1.16a.62.62 0 0 0-.58.387l-2.037 4.858h1.426l.285-.784h1.742l.173.784zM17.52 12.76l.713-1.966.407 1.966h-1.12zm-5.703-3.4l-1.12 5.245H9.342l1.12-5.245h1.355z',
							fill: '#10357f',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
				};
			}
			static get style() {
				return ontarioIconCss$6;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-visa',
					$members$: {
						iconWidth: [2, 'icon-width'],
						iconWidthState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$5 =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconVoteDislike {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-vote-dislike> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-vote-dislike> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '043cdf517f868b1b192c33b23a884ab036518854',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '4ef7c48577f3e4c95734107f079fa8c6b34adaab',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'vote-dislike',
						},
						hAsync('path', {
							key: 'b55a834d2bb7ec1aee15c8c4ec625d626620a8e3',
							d: 'M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.1.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.3l-.95 4.57-.03.32c0 .4.17.8.44 1.06L9.83 23l6.6-6.6c.36-.36.58-.86.58-1.4V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$5;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-vote-dislike',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$4 =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconVoteLike {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-vote-like> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-vote-like> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'a1212a800e50261e5714acb7376fd5a51c164e7c',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'b5e839c8cd6a7e0a4f0f991d6ff6ffed22656d16',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'vote-like',
						},
						hAsync('path', {
							key: '5dc80707028710ae0fe47b7079647ce2912ca089',
							d: 'M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.3l.95-4.57.03-.32c0-.4-.17-.8-.44-1.06L14.17 1 7.6 7.6c-.37.36-.6.86-.6 1.4v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.1-.23.14-.47.14-.73v-2z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$4;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-vote-like',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$3 =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconVpnKey {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-vpn-key> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-vpn-key> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: 'ef7d305fa3b264af5c36a5b53800019007919c5f',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '14733749a5340d4d07b7e5a6778d23058716e6b7',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'vpn-key',
						},
						hAsync('path', {
							key: 'a2d506f5477af1fdc3e7d4fb8a3a7232dc5ca454',
							d: 'M12.65 10A5.99 5.99 0 0 0 7 6c-3.3 0-6 2.7-6 6s2.7 6 6 6a5.99 5.99 0 0 0 5.65-4H17v4h4v-4h2v-4H12.65zM7 14c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$3;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-vpn-key',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$2 =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconWheelchair {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-wheelchair> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-wheelchair> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '82b731e8b80dbcf9a30bfb8185cfe1dbf4698a3b',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: 'cd3c85b10f76685d29a01ddcb3300bffcaae9992',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'wheelchair',
						},
						hAsync('path', {
							key: '0afe6a1ec6fd8c90885b7767d31af26db3bc51de',
							d: 'M19 13v-2c-1.54.02-3.1-.75-4.07-1.83l-1.3-1.43c-.25-.24-.4-.316-.64-.46a2.01 2.01 0 0 0-1.2-.26c-1.05.1-1.8 1.02-1.8 2.07V15c0 1.1.9 2 2 2h5v5h2v-5.5c0-1.1-.9-2-2-2h-3v-3.45c1.3 1.07 3.25 1.94 5 1.95zm-6.17 5c-.4 1.16-1.52 2-2.83 2-1.66 0-3-1.34-3-3 0-1.3.84-2.4 2-2.83V12.1A5 5 0 0 0 5 17c0 2.76 2.24 5 5 5a5 5 0 0 0 4.9-4h-2.07zM12 6a2 2 0 1 0 0-4 2 2 0 1 0 0 4z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$2;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-wheelchair',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss$1 =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconWifi {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-wifi> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-wifi> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '62c5ff77bb1e8036bbebe26d30b56f6b6e85e3bb',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '8cedac526899a0ed1a9ab715eebd6d29f957e183',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'wifi',
						},
						hAsync('path', {
							key: '8d34d2c1a51d89935016e85b44150dd504fcf822',
							d: 'M1 9l2 2a12.73 12.73 0 0 1 18 0l2-2A15.57 15.57 0 0 0 1 9zm8 8l3 3 3-3c-1.65-1.66-4.34-1.66-6 0zm-4-4l2 2c2.76-2.76 7.24-2.76 10 0l2-2C15.14 9.14 8.87 9.14 5 13z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss$1;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-wifi',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioIconCss =
			'.ontario-icon svg,.ontario-icon{display:inline-block;stroke-width:0;stroke:currentColor;fill:currentColor;vertical-align:middle;overflow:hidden}.ontario-icon--blue svg{stroke:#0066CC;fill:#0066CC}.ontario-icon--grey svg{stroke:#666666;fill:#666666}.ontario-icon--black svg{stroke:#1A1A1A;fill:#1A1A1A}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}.ontario-icon--white svg{stroke:#FFFFFF;fill:#FFFFFF}';

		class OntarioIconYoutube {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The icon width will autogenerate the height since the icons are in square format, thus preserving
			 * the aspect ratio.
			 */
			iconWidth = 24;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's width depending on validation result.
			 */
			iconWidthState;
			/**
			 * Watch for changes in the `iconWidth` variable for validation purpose.
			 * If the user input is not a number or is a negative number then `iconWidth` will be set to its default (24).
			 */
			validateWidth() {
				if (isNaN(this.iconWidth) || (!isNaN(this.iconWidth) && this.iconWidth <= 0)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' icon-width ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-icon-youtube> ')
						.addRegularText(
							`${isNaN(this.iconWidth) ? 'was set to a non-numeric value' : 'was set to a negative number'}; only a positive number is allowed. The default size of`,
						)
						.addMonospaceText(' 24px ')
						.addRegularText('was assumed.')
						.printMessage();
					this.iconWidthState = 24;
				} else {
					this.iconWidthState = this.iconWidth;
				}
			}
			/**
			 * Set the icon's colour.
			 */
			colour = 'black';
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconColourState;
			/**
			 * Mutable variable, for internal use only.
			 * Set the icon's colour based on validation result.
			 */
			iconCustomColourState;
			/**
			 * Watch for changes in the `colour` variable for validation purpose.
			 * If the user input doesn't match one of the enum values then `colour` will be set to its default (`black`).
			 * If a match is found in one of the enum values then `colour` will be set to the matching enum value.
			 */
			validateColour() {
				const isValid = validateValueAgainstArray(this.colour, IconColours);
				if (isValid) {
					this.iconColourState = this.colour;
				} else {
					if (validateColor(this.colour)) {
						this.iconCustomColourState = this.colour;
					} else {
						this.iconColourState = this.warnDefaultColour();
					}
				}
			}
			/**
			 * Print the invalid colour warning message
			 * @returns default colour (black)
			 */
			warnDefaultColour() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' colour ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-icon-youtube> ')
					.addRegularText('was set to an invalid colour; only')
					.addMonospaceText(' black, blue, grey or white ')
					.addRegularText('are supported. The default colour')
					.addMonospaceText(' black ')
					.addRegularText('is assumed.')
					.printMessage();
				return 'black';
			}
			/**
			 * Stencil component lifecycle method that is called once after the component is first connected to the DOM.
			 */
			componentWillLoad() {
				this.validateColour();
				this.validateWidth();
			}
			/**
			 * Returns the HTML code to be rendered into a custom element.
			 */
			render() {
				return hAsync(
					'div',
					{
						key: '698ac79a09bb455a384af3c3ce30e58a58737e2d',
						class: `ontario-icon ontario-icon--${this.iconColourState} ontario-icon--width-${this.iconWidthState}`,
						style: { width: `${this.iconWidthState}px` },
					},
					hAsync(
						'svg',
						{
							key: '3518ae010f4d9e2248358a78ccda4e74a478ded7',
							class: 'svg-icon',
							style: { fill: `${this.iconCustomColourState}`, stroke: `${this.iconCustomColourState}` },
							role: 'img',
							xmlns: 'http://www.w3.org/2000/svg',
							viewBox: '0 0 24 24',
							id: 'youtube',
						},
						hAsync('path', {
							key: '7366687e29d889201f3fe060c4560f7e498d220c',
							d: 'M10 15l5.2-3L10 9v6zm11.56-7.83c.13.47.22 1.1.28 1.9l.1 2.1.06.84c0 2.2-.16 3.8-.44 4.83a2.34 2.34 0 0 1-1.73 1.73c-.47.13-1.33.22-2.65.28l-3.6.1L12 19c-4.2 0-6.8-.16-7.83-.44a2.34 2.34 0 0 1-1.73-1.73c-.13-.47-.22-1.1-.28-1.9l-.1-2.1L2 12c0-2.2.16-3.8.44-4.83a2.34 2.34 0 0 1 1.73-1.73c.47-.13 1.33-.22 2.65-.28l3.6-.1L12 5c4.2 0 6.8.16 7.83.44a2.34 2.34 0 0 1 1.73 1.73z',
						}),
					),
				);
			}
			static get watchers() {
				return {
					iconWidth: ['validateWidth'],
					colour: ['validateColour'],
				};
			}
			static get style() {
				return ontarioIconCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-icon-youtube',
					$members$: {
						iconWidth: [2, 'icon-width'],
						colour: [1],
						iconWidthState: [32],
						iconColourState: [32],
						iconCustomColourState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioInputCss =
			'@charset "UTF-8";.ontario-input:focus,.ontario-input:active{box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:box-shadow 0.1s ease-in-out}h6,.ontario-h6,h5,.ontario-h5,h4,.ontario-h4,h3,.ontario-h3,h2,.ontario-h2,h1>.ontario-label--heading,.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1,h1,.ontario-h1{font-style:normal;font-weight:700;text-rendering:optimizeLegibility;margin-bottom:1rem;font-feature-settings:normal;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif}h1>.ontario-label--heading,.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1,h1,.ontario-h1{font-size:2rem;letter-spacing:0.04rem;line-height:1.29;margin:2.5rem 0 1.5rem 0;max-width:70rem}@media screen and (min-width: 40em){h1>.ontario-label--heading,.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1,h1,.ontario-h1{font-size:2.5rem;letter-spacing:0.04rem;line-height:1.2}}h2,.ontario-h2{font-size:1.6875rem;letter-spacing:0.03rem;line-height:1.37;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h2,.ontario-h2{font-size:2.0625rem;letter-spacing:0.02rem;line-height:1.33}}h3,.ontario-h3{font-size:1.4375rem;letter-spacing:0.02rem;line-height:1.39;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h3,.ontario-h3{font-size:1.75rem;letter-spacing:0.02rem;line-height:1.43}}h4,.ontario-h4{font-size:1.25rem;letter-spacing:0.03rem;line-height:1.5;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h4,.ontario-h4{font-size:1.5rem;letter-spacing:0.0313rem;line-height:1.5}}h5,.ontario-h5{font-size:1.125rem;letter-spacing:0.03rem;line-height:1.56;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h5,.ontario-h5{font-size:1.1875rem;letter-spacing:0.025rem;line-height:1.5}}h6,.ontario-h6{font-size:1rem;line-height:1.56;letter-spacing:0.03rem;max-width:48rem;margin:0 0 0.75rem 0}@media screen and (min-width: 40em){h6,.ontario-h6{font-size:1rem;letter-spacing:0.025rem;line-height:1.5}}.ontario-lead-statement{font-size:1.25rem;line-height:1.6;max-width:70rem}@media screen and (min-width: 40em){.ontario-lead-statement{font-size:1.375rem}}html{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem}body{font-size:1rem;line-height:1.6;background-color:#FFFFFF;color:#1a1a1a;margin:0}p{font-size:inherit;margin-bottom:1.25rem;text-rendering:optimizeLegibility;margin:0 0 1.5rem 0}cite{font-style:italic;line-height:inherit}strong{font-weight:700;line-height:inherit}*,*::before,*::after{box-sizing:inherit}main p,main p:not(.ontario-lead-statement),main dd,main li{max-width:48rem}hr{border:0;padding:0;margin:2.5rem 0;border-bottom:4px solid #cccccc}hr.ontario-hr--dark{border-bottom:4px solid #1a1a1a}a{color:#0066CC;text-decoration:underline}a:visited{color:#551A8B}a:hover{color:#00478F}a:active{color:#002142}a:focus{-moz-box-shadow:0 0 0 4px #009ADB;-webkit-box-shadow:0 0 0 4px #009ADB;box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:all 0.1s ease-in-out}p{margin:0 0 1.5rem 0}p+h1,p+h2,p+h3,p+h4,p+h5,p+h6,ul+h1,ul+h2,ul+h3,ul+h4,ul+h5,ul+h6,ol+h1,ol+h2,ol+h3,ol+h4,ol+h5,ol+h6,h1+h2,h2+h3,h3+h4,h4+h5,h5+h6{margin-top:2rem}p code,td code,li code{line-height:2.25rem}input[type=text],input[type=number],input[type=email],input[type=date],input[type=color],input[type=search],input[type=tel],textarea{background-origin:initial;height:auto;-webkit-appearance:none;-moz-appearance:none}input[type=checkbox]+label,input[type=radio]+label{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400;margin-left:0;margin-right:0}fieldset{border:0;margin:0;padding:0;page-break-inside:avoid}legend,label{display:block;margin:0}select{background-origin:initial;height:auto;-webkit-appearance:none;-moz-appearance:none}ul,ol{padding:0}ul{margin-left:2rem}ul li{padding:0 0 0.75rem 0}ol{margin-left:1.75rem}ol li{padding:0 0 0.75rem 0.25rem}ul li:last-child,ol li:last-child{padding-bottom:0}ul[class*=columns-] li:last-child,ol[class*=columns-] li:last-child{padding-bottom:0.75rem}ul ul,ol ul{margin:0.5rem 0 0.5rem 2rem}ul ol,ol ol{margin:0.5rem 0 0.5rem 1.75rem}p+ul,p+ol{margin-top:-0.75rem}@media screen and (min-width: 40em){ul{margin:0.5rem 0 1.5rem 3rem}ol{margin:0.5rem 0 1.5rem 2.75rem}ul ul,ol ul{margin:0.5rem 0 0.5rem 3rem}ul ol,ol ol{margin:0.5rem 0 0.5rem 2.75rem}}.ontario-form-group:last-of-type{margin-bottom:2.5rem}.ontario-form-group:last-of-type{margin-bottom:3rem}.ontario-fieldset__legend{color:#1a1a1a;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1.1875rem;font-weight:700;margin:0 0 1rem 0;line-height:1.5;max-width:38.75em;white-space:normal;width:100%;hyphens:auto}@media screen and (max-width: 40em){.ontario-fieldset__legend{font-size:1.125rem;line-height:1.56}}.ontario-fieldset__legend--large,.ontario-fieldset__legend--heading{letter-spacing:0.02rem;line-height:1.2}.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1{display:inline-block;margin:0}@media screen and (max-width: 40em){.ontario-fieldset__legend--large,.ontario-fieldset__legend--heading{font-size:1.4375rem;line-height:1.39}}.ontario-fieldset__legend--large{font-size:1.75rem}.ontario-fieldset__legend-required-flag,.ontario-fieldset__legend-optional-flag{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400}.ontario-fieldset__legend-required-flag:before,.ontario-fieldset__legend-optional-flag:before{content:""}.ontario-label__flag{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400}.ontario-label__flag:before{content:""}.ontario-label{cursor:pointer;color:#1a1a1a;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1.1875rem;font-weight:700;line-height:1.5;margin:0 0 1rem 0;max-width:38.75em;white-space:normal;width:100%;hyphens:auto}@media screen and (max-width: 40em){.ontario-label{font-size:1.125rem;line-height:1.56}}.ontario-label--large{font-size:1.75rem;letter-spacing:0.02rem;line-height:1.2;max-width:26.25em}@media screen and (max-width: 40em){.ontario-label--large{font-size:1.4375rem;line-height:1.39}}h1>.ontario-label--heading{display:inline-block;margin:0}.ontario-label__flag{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400}.ontario-label__flag:before{content:""}.ontario-input{border:2px solid #1a1a1a;border-radius:4px;box-sizing:border-box;color:#1a1a1a;display:block;font-size:1rem;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;line-height:1.5;margin:0 0 2.5rem;max-width:48rem;width:100%;padding:0.625rem 1rem;transition:box-shadow 0.1s ease-in-out}.ontario-input--2-char-width{max-width:8ex}.ontario-input--3-char-width{max-width:10ex}.ontario-input--4-char-width{max-width:12ex}.ontario-input--5-char-width{max-width:14ex}.ontario-input--7-char-width{max-width:17ex}.ontario-input--10-char-width{max-width:23ex}.ontario-input--20-char-width{max-width:41ex}.ontario-form-group:last-of-type{margin-bottom:2.5rem}.ontario-hide{display:none !important}.ontario-invisible{visibility:hidden !important}@media screen and (max-width: 39.99875em){.ontario-hide-for-small-only{display:none !important}}@media screen and (max-width: 0em), screen and (min-width: 40em){.ontario-show-for-small-only{display:none !important}}@media print, screen and (min-width: 40em){.ontario-hide-for-medium{display:none !important}}@media screen and (max-width: 39.99875em){.ontario-show-for-medium{display:none !important}}@media screen and (min-width: 40em) and (max-width: 72.99875em){.ontario-hide-for-medium-only{display:none !important}}@media screen and (max-width: 39.99875em), screen and (min-width: 73em){.ontario-show-for-medium-only{display:none !important}}@media print, screen and (min-width: 73em){.ontario-hide-for-large{display:none !important}}@media screen and (max-width: 72.99875em){.ontario-show-for-large{display:none !important}}@media screen and (min-width: 73em) and (max-width: 95.99875em){.ontario-hide-for-large-only{display:none !important}}@media screen and (max-width: 72.99875em), screen and (min-width: 96em){.ontario-show-for-large-only{display:none !important}}.ontario-show-for-sr,.ontario-show-on-focus{position:absolute;width:1px;height:1px;overflow:hidden;clip:rect(0, 0, 0, 0)}.ontario-show-on-focus:active,.ontario-show-on-focus:focus{position:static;width:auto;height:auto;overflow:visible;clip:auto}.ontario-show-for-landscape,.ontario-hide-for-portrait{display:block !important}@media screen and (orientation: landscape){.ontario-show-for-landscape,.ontario-hide-for-portrait{display:block !important}}@media screen and (orientation: portrait){.ontario-show-for-landscape,.ontario-hide-for-portrait{display:none !important}}.ontario-hide-for-landscape,.ontario-show-for-portrait{display:none !important}@media screen and (orientation: landscape){.ontario-hide-for-landscape,.ontario-show-for-portrait{display:none !important}}@media screen and (orientation: portrait){.ontario-hide-for-landscape,.ontario-show-for-portrait{display:block !important}}.ontario-error-messaging{display:flex;align-items:flex-start;margin:-0.25rem 0 0.5rem 0;color:#D81A21;max-width:48rem}.ontario-error-messaging__content{margin-left:0.5rem}.ontario-input__error{border-color:#D81A21 !important}.ontario-error__hidden{display:none}.ontario-input{border:2px solid #1a1a1a;border-radius:4px;box-sizing:border-box;color:#1a1a1a;display:block;font-size:1rem;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;line-height:1.5;margin:0 0 2.5rem;max-width:48rem;padding:0.625rem 1rem;transition:box-shadow 0.1s ease-in-out;width:100%}.ontario-input-hint-expander--true{margin-bottom:1rem}.ontario-input--2-char-width{max-width:8ex}.ontario-input--3-char-width{max-width:10ex}.ontario-input--4-char-width{max-width:12ex}.ontario-input--5-char-width{max-width:14ex}.ontario-input--7-char-width{max-width:17ex}.ontario-input--10-char-width{max-width:23ex}.ontario-input--20-char-width{max-width:41ex}.ontario-input--error input{border:0.125rem solid #CD0000}';

		class OntarioInput {
			constructor(hostRef) {
				registerInstance(this, hostRef);
				this.inputOnInput = createEvent(this, 'inputOnInput');
				this.inputOnChange = createEvent(this, 'inputOnChange');
				this.inputOnBlur = createEvent(this, 'inputOnBlur');
				this.inputOnFocus = createEvent(this, 'inputOnFocus');
				this.inputErrorOccurred = createEvent(this, 'inputErrorOccurred');
				if (hostRef.$hostElement$['s-ei']) {
					this.internals = hostRef.$hostElement$['s-ei'];
				} else {
					this.internals = hostRef.$hostElement$.attachInternals();
					hostRef.$hostElement$['s-ei'] = this.internals;
				}
			}
			get element() {
				return getElement(this);
			}
			internals;
			hintTextRef;
			/**
			 * The text to display as the input label
			 *
			 * @example
			 * <ontario-input
			 *   caption='{
			 *     "captionText": "Address",
			 *     "captionType": "heading",
			 *   }
			 *   required="true"
			 *   ...>
			 * </ontario-input>
			 */
			caption;
			/**
			 * The unique identifier of the input. This is optional - if no ID is passed, one will be generated.
			 */
			elementId;
			/**
			 * The width of the input field. If no value is assigned, it will present as the `default` input width.
			 */
			inputWidth = 'default';
			/**
			 * The name assigned to the input. The name value is used to reference form data after a form is submitted.
			 */
			name;
			/**
			 * Used to include the ontario-hint-text component for the input.
			 * This is optional.
			 */
			hintText;
			/**
			 * This is used to determine whether the input is required or not.
			 * This prop also gets passed to the InputCaption utility to display either an optional or required flag in the label.
			 * If no prop is set, it will default to false (optional).
			 *
			 * _Please add a validation messaging using `requiredValidationMessage` if setting this property._
			 *
			 * @example
			 * <ontario-input
			 *		id="address-line-1"
			 *		caption="Address line 1"
			 *		required
			 *		required-validation-message="Please enter an address, including street number and street name"
			 *		name="address-line-1"
			 *		hint-text="Street and number or P.O. box."
			 *	></ontario-input>
			 */
			required = false;
			/**
			 * The input type value.
			 *
			 * If no `type` is provided, it will default to 'text'.
			 */
			type = 'text';
			/**
			 * The input content value.
			 *
			 * This is optional.
			 */
			value;
			/**
			 * Set this to display an
			 */
			errorMessage;
			/**
			 * The language of the component.
			 * This is used for translations, and is by default set through event listeners checking for a language property from the header. If no language is passed, it will default to English.
			 */
			language = 'en';
			/**
			 * Used to include the ontario-hint-expander component for the input component.
			 * This is passed in as an object with key-value pairs.
			 *
			 * This is optional.
			 *
			 * @example
			 * <ontario-input
			 *   caption='{
			 *     "caption": "Address",
			 *     "captionType": "heading",
			 *   }
			 *   hint-expander='{
			 *    "hint": "Hint expander",
			 *    "content": "This is the content"
			 *   }'
			 *   required="true"
			 * >
			 * </ontario-input>
			 */
			hintExpander;
			/**
			 * Used for the `aria-describedby` value of the input. This will match with the id of the hint text.
			 */
			hintTextId;
			/**
			 * Enable live validation on the input.  Custom live validation can be performed using an `inputValidator`
			 * validation function.  It will also validate the `required` state if no errors are returned from
			 * the `inputValidator`.  Please set a `requiredValidationMessage` to report concisely to the end user what
			 * they are required to set.
			 */
			enableLiveValidation = false;
			/**
			 * Validate the validity of the input value `onBlur`.  This `async` function should return a result
			 * to trigger an error message.  Returning `undefined` or `null` will clear it.
			 */
			inputValidator;
			/**
			 * Used to add a custom function to the input onInput event.
			 */
			customOnInput;
			/**
			 * Used to add a custom function to the input onChange event.
			 */
			customOnChange;
			/**
			 * Used to add a custom function to the input onBlur event.
			 */
			customOnBlur;
			/**
			 * Used to add a custom function to the input onFocus event.
			 */
			customOnFocus;
			/**
			 * Custom error message to display if a required field is not filled out.  _Please add a
			 * custom message when setting an input as required_.
			 */
			requiredValidationMessage;
			/**
			 * The hint text options are re-assigned to the internalHintText array.
			 */
			internalHintText;
			/**
			 * The hint expander options are re-assigned to the internalHintExpander array.
			 */
			internalHintExpander;
			/**
			 * Instantiate an InputCaption object for internal logic use
			 */
			captionState;
			/**
			 * Track if the input has been interacted with, used to validate if
			 * a `required` field is in error.
			 */
			hasBeenInteractedWith = false;
			/**
			 * Global translations for accessing built-in translations
			 */
			translations = translations;
			/**
			 * Emitted when a input  occurs when an input has been changed.
			 */
			inputOnInput;
			/**
			 * Emitted when a keyboard input or mouse event occurs when an input has been changed.
			 */
			inputOnChange;
			/**
			 * Emitted when a keyboard input event occurs when an input has lost focus.
			 */
			inputOnBlur;
			/**
			 * Emitted when a keyboard input event occurs when an input has gained focus.
			 */
			inputOnFocus;
			/**
			 * Emitted when an error message is reported to the component.
			 */
			inputErrorOccurred;
			/**
			 * This listens for the `setAppLanguage` event sent from the test language toggler when it is is connected to the DOM. It is used for the initial language when the input component loads.
			 * @param event The language that has been selected.
			 */
			handleSetAppLanguage(event) {
				this.language = validateLanguage(event);
			}
			/**
			 * Handles an update to the language should the user request a language update from the language toggle.
			 * @param event The language that has been selected.
			 */
			handleHeaderLanguageToggled(event) {
				this.language = validateLanguage(event.detail.newLanguage);
			}
			/**
			 * Handle the change in the `value` property and validate if the input has been interacted with by
			 * the user to aid in determining if the required state should produce an error.
			 */
			handleValueChange() {
				this.hasBeenInteractedWith = this.hasBeenInteractedWith || !!this.value;
			}
			/*
			 * Watch for changes in the `name` prop for validation purposes.
			 *
			 * Validate the `name` and make sure the `name` prop has a value.
			 * Log a warning if user doesn't input a value for the `name`.
			 */
			validateName(newValue) {
				if (validatePropExists(newValue)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' name ')
						.addRegularText('for')
						.addMonospaceText(' <ontario-input> ')
						.addRegularText('was not provided')
						.printMessage();
				}
			}
			/**
			 * Watch for changes to the `hintText` prop.
			 *
			 * If a `hintText` prop is passed, the `constructHintTextObject` function will convert it to the correct format, and set the result to the `internalHintText` state.
			 */
			parseHintText() {
				if (this.hintText) {
					const hintTextObject = constructHintTextObject(this.hintText);
					this.internalHintText = hintTextObject;
				}
			}
			/**
			 * Watch for changes to the `hintExpander` prop.
			 *
			 * If a `hintExpander` prop is passed, it will be parsed (if it is a string), and the result will be set to the `internalHintExpander` state.
			 */
			parseHintExpander() {
				const hintExpander = this.hintExpander;
				if (hintExpander) {
					if (typeof hintExpander === 'string') this.internalHintExpander = JSON.parse(hintExpander);
					else this.internalHintExpander = hintExpander;
				}
			}
			/**
			 * Watch for changes to the `caption` prop.
			 *
			 * The caption will be run through the InputCaption constructor to convert it to the correct format, and set the result to the `captionState` state.
			 * @param newValue: Caption | string
			 */
			updateCaptionState(newValue) {
				this.captionState = new InputCaption(
					this.element.tagName,
					newValue,
					this.translations,
					this.language,
					false,
					this.required,
				);
			}
			/**
			 * Watch for changes in the `language` prop to render either the English or French translations
			 */
			updateLanguage() {
				this.updateCaptionState(this.caption);
			}
			/**
			 * Handle the component being blurred and perform validation logic on the input.  Custom validation
			 * takes persistance, followed by validating the required state.
			 *
			 * Finally, an event is emitted to notify anything listening for the `inputErrorOccurred` that
			 * an error occurred.
			 */
			async handleComponentBlur() {
				if (this.enableLiveValidation) {
					// Call inputValidator function to perform custom validation
					const validationResult = this.inputValidator && this.inputValidator(this.value);
					await validationResult?.then((x) => (this.errorMessage = x?.errorMessage));
					// Validate the `required` field
					// Only report a required error if no other error message is reported via validation
					if (this.required && this.hasBeenInteractedWith && !validationResult)
						if (!this.value)
							this.errorMessage =
								this.requiredValidationMessage ||
								this.translations.input.requiredFieldError[this.getComponentLanguage()];
						else this.errorMessage = undefined;
				}
			}
			broadcastInputErrorOccurredEvent() {
				// Emit event to notify anyone who wants to listen for errors occurring
				this.inputErrorOccurred.emit({ inputId: this.getId(), errorMessage: this.errorMessage ?? '' });
			}
			/**
			 * Function to handle input events and the information pertaining to the input to emit.
			 */
			handleEvent(event, eventType) {
				const input = event.target;
				// Update the component value to match the value of the input element.
				this.value = input?.value;
				this.internals?.setFormValue?.(this.value ?? '');
				handleInputEvent(
					event,
					eventType,
					input,
					this.inputOnChange,
					this.inputOnFocus,
					this.inputOnBlur,
					this.inputOnInput,
					'input',
					this.customOnChange,
					this.customOnFocus,
					this.customOnBlur,
					this.customOnInput,
					this.element,
				);
			}
			getId() {
				// A UUID is assigned in `componentWillLoad` if there is no given `elementId`.
				return this.elementId ?? '';
			}
			getValue() {
				return this.value ?? '';
			}
			getClass() {
				if (this.hintExpander) {
					return this.inputWidth === 'default'
						? `ontario-input ontario-input-hint-expander--true`
						: `ontario-input ontario-input--${this.inputWidth} ontario-input-hint-expander--true`;
				} else {
					return this.inputWidth === 'default' ? `ontario-input` : `ontario-input ontario-input--${this.inputWidth}`;
				}
			}
			getComponentLanguage() {
				return this.language ?? 'en';
			}
			/**
			 * If a `hintText` prop is passed, the id generated from it will be set to the internal `hintTextId` state to match with the input `aria-describedBy` attribute.
			 */
			async componentDidLoad() {
				this.hintTextId = await this.hintTextRef?.getHintTextId();
			}
			componentWillLoad() {
				this.updateCaptionState(this.caption);
				this.elementId = this.elementId ?? v4();
				this.parseHintText();
				this.parseHintExpander();
				this.validateName(this.name);
				this.language = validateLanguage(this.language);
			}
			render() {
				const error = !!this.errorMessage;
				return hAsync(
					'div',
					{
						key: 'a7222e6476454f5d3d7063306b93db212abb3b01',
						class: `ontario-form-group ${error ? 'ontario-input--error' : ''}`,
					},
					this.captionState.getCaption(this.getId(), !!this.internalHintExpander),
					this.internalHintText &&
						hAsync('ontario-hint-text', {
							key: '89d1b50018069434bf7ff24d784b6dc065ea7205',
							hint: this.internalHintText.hint,
							hintContentType: this.internalHintText.hintContentType,
							ref: (el) => (this.hintTextRef = el),
						}),
					hAsync(ErrorMessage, {
						key: 'dd096e7cfe445817532bc7c0cf681048f417c390',
						message: this.errorMessage,
						error: error,
					}),
					hAsync(Input$1, {
						'key': '6f8e1f78a9c9d3f21335ff5b3dca8f4d0d53e3a7',
						'aria-describedBy': this.hintTextId,
						'className': this.getClass(),
						'id': this.getId(),
						'name': this.name,
						'onInput': (e) => this.handleEvent(e, EventType.Input),
						'onChange': (e) => this.handleEvent(e, EventType.Change),
						'onBlur': (e) => this.handleEvent(e, EventType.Blur),
						'onFocus': (e) => this.handleEvent(e, EventType.Focus),
						'type': this.type,
						'value': this.getValue(),
						'required': !!this.required,
					}),
					this.internalHintExpander &&
						hAsync('ontario-hint-expander', {
							key: 'f25a94ba009fa257660a0dbe6c77d00d28668351',
							hint: this.internalHintExpander.hint,
							content: this.internalHintExpander.content,
							hintContentType: this.internalHintExpander.hintContentType,
						}),
				);
			}
			static get formAssociated() {
				return true;
			}
			static get watchers() {
				return {
					value: ['handleValueChange'],
					name: ['validateName'],
					hintText: ['parseHintText'],
					hintExpander: ['parseHintExpander'],
					caption: ['updateCaptionState'],
					language: ['updateLanguage'],
					errorMessage: ['broadcastInputErrorOccurredEvent'],
				};
			}
			static get style() {
				return ontarioInputCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 73,
					$tagName$: 'ontario-input',
					$members$: {
						caption: [1],
						elementId: [1025, 'element-id'],
						inputWidth: [1025, 'input-width'],
						name: [1],
						hintText: [1, 'hint-text'],
						required: [4],
						type: [1025],
						value: [1025],
						errorMessage: [1025, 'error-message'],
						language: [1025],
						hintExpander: [1, 'hint-expander'],
						enableLiveValidation: [4, 'enable-live-validation'],
						inputValidator: [16, 'input-validator'],
						customOnInput: [16, 'custom-on-input'],
						customOnChange: [16, 'custom-on-change'],
						customOnBlur: [16, 'custom-on-blur'],
						customOnFocus: [16, 'custom-on-focus'],
						requiredValidationMessage: [1, 'required-validation-message'],
						hintTextId: [32],
						internalHintText: [32],
						internalHintExpander: [32],
						captionState: [32],
						hasBeenInteractedWith: [32],
						translations: [32],
					},
					$listeners$: [
						[8, 'setAppLanguage', 'handleSetAppLanguage'],
						[8, 'headerLanguageToggled', 'handleHeaderLanguageToggled'],
						[2, 'blur', 'handleComponentBlur'],
					],
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const supportedLanguages = ['en', 'fr'];

		const ontarioLanguageToggleCss =
			'.ontario-language-toggler:focus{box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:box-shadow 0.1s ease-in-out}.ontario-hide{display:none !important}.ontario-invisible{visibility:hidden !important}@media screen and (max-width: 39.99875em){.ontario-hide-for-small-only{display:none !important}}@media screen and (max-width: 0em), screen and (min-width: 40em){.ontario-show-for-small-only{display:none !important}}@media print, screen and (min-width: 40em){.ontario-hide-for-medium{display:none !important}}@media screen and (max-width: 39.99875em){.ontario-show-for-medium{display:none !important}}@media screen and (min-width: 40em) and (max-width: 72.99875em){.ontario-hide-for-medium-only{display:none !important}}@media screen and (max-width: 39.99875em), screen and (min-width: 73em){.ontario-show-for-medium-only{display:none !important}}@media print, screen and (min-width: 73em){.ontario-hide-for-large{display:none !important}}@media screen and (max-width: 72.99875em){.ontario-show-for-large{display:none !important}}@media screen and (min-width: 73em) and (max-width: 95.99875em){.ontario-hide-for-large-only{display:none !important}}@media screen and (max-width: 72.99875em), screen and (min-width: 96em){.ontario-show-for-large-only{display:none !important}}.ontario-show-for-sr,.ontario-show-on-focus{position:absolute;width:1px;height:1px;overflow:hidden;clip:rect(0, 0, 0, 0)}.ontario-show-on-focus:active,.ontario-show-on-focus:focus{position:static;width:auto;height:auto;overflow:visible;clip:auto}.ontario-show-for-landscape,.ontario-hide-for-portrait{display:block !important}@media screen and (orientation: landscape){.ontario-show-for-landscape,.ontario-hide-for-portrait{display:block !important}}@media screen and (orientation: portrait){.ontario-show-for-landscape,.ontario-hide-for-portrait{display:none !important}}.ontario-hide-for-landscape,.ontario-show-for-portrait{display:none !important}@media screen and (orientation: landscape){.ontario-hide-for-landscape,.ontario-show-for-portrait{display:none !important}}@media screen and (orientation: portrait){.ontario-hide-for-landscape,.ontario-show-for-portrait{display:block !important}}.ontario-language-toggler{background-color:#1a1a1a;border:none;border-radius:4px;box-sizing:border-box;box-shadow:none;color:#FFFFFF;cursor:pointer;display:flex;align-items:center;font-size:1.125rem;font-weight:600;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;height:48px;line-height:1.5555555556;text-align:center;text-decoration:none}.ontario-language-toggler:hover{background-color:#4d4d4d}.ontario-language-toggler:active{background-color:#666666;color:#FFFFFF}.ontario-language-toggler:focus{background-color:#4d4d4d;color:#FFFFFF}.ontario-language-toggler:visited{color:#FFFFFF}.ontario-language-toggler abbr[title]{text-decoration:none}.ontario-language-toggler--default{padding:0.75rem}.ontario-language-toggler--small{font-size:1rem;line-height:1.375rem;height:auto;outline:none;padding:0.5rem 0.75rem}';

		class OntarioLanguageToggle {
			constructor(hostRef) {
				registerInstance(this, hostRef);
				this.setAppLanguage = createEvent(this, 'setAppLanguage');
				this.headerLanguageToggled = createEvent(this, 'headerLanguageToggled');
			}
			/**
			 * The language of the component.
			 *
			 * In most cases, the language toggle should be the source of truth for determining the site language.
			 *
			 * Only pass a language value here if necessary.
			 */
			language;
			/**
			 * The size of the language toggle button.
			 *
			 * If no prop is passed, it will be set to the `default` size.
			 */
			size = 'default';
			/**
			 * The URL to change to when the language toggle button is clicked.
			 *
			 * This is optional.
			 */
			url;
			/**
			 * A custom function to pass to the language toggle button.
			 *
			 * This is optional.
			 */
			customLanguageToggle;
			translations = translations;
			/**
			 * Internal state used as the source of truth for component language.
			 */
			languageState;
			/**
			 * Internal state used to render the text on the language toggle UI.
			 */
			oppositeLanguageLabel = undefined;
			/**
			 * Updates the language and languageState props when changes to the language prop are detected.
			 */
			updateLanguage() {
				if (this.language) {
					if (!validateValueAgainstArray(this.language, supportedLanguages)) {
						this.showLanguageWarning(this.language);
						this.language = this.translations.siteLanguage.abbreviation.en;
					}
					this.languageState = this.language;
				}
				this.setAppLanguageHandler();
			}
			/**
			 * Event that fires during the setAppLanguageHandler() method.
			 *
			 * The event contains the current language (after language logic has already occurred).
			 */
			setAppLanguage;
			/**
			 * Event that fires when the language toggle is pressed/clicked.
			 *
			 * The event contains the oldLanguage along with the newLanguage.
			 */
			headerLanguageToggled;
			/**
			 * This function sets the languageState (if not already set).
			 *
			 * It also emits the setAppLanguage() event, updates the component language label, and
			 * updates the <html> tag lang attribute with the languageState value.
			 *
			 * It gets called by the connectedCallback() component lifecycle hook, and by the
			 * updateLanguage() method, which is fired on the watch for the language prop.
			 */
			setAppLanguageHandler() {
				const defaultLang = this.translations.siteLanguage.abbreviation.en;
				const rootLang = getRootHTMLElement()?.lang;
				// If languageState is not set, set it equal to the following cadence:
				// language prop value, <html> tag lang attribute, or default to "en"
				if (!this.languageState) {
					if (this.language) {
						this.languageState = this.language;
					} else if (rootLang) {
						if (validateValueAgainstArray(rootLang, supportedLanguages)) {
							this.languageState = rootLang;
						} else {
							this.showLanguageWarning(rootLang, 'document');
							this.languageState = defaultLang;
						}
					} else {
						this.languageState = defaultLang;
					}
				}
				this.setAppLanguage.emit(this.languageState);
				this.oppositeLanguageLabel = {
					fullWord: this.getOppositeLanguageFullWord(),
					abbreviation: this.getOppositeLanguageAbbrievation(),
				};
				this.updateHTMLLang();
			}
			/**
			 * An event that emits to other components that the language toggle button has been toggled.
			 *
			 * @param {Language} oldLanguage - The language prior to the language toggle being pressed.
			 * @param {globalThis.Event} event - event that triggered the function (e.g. onclick).
			 */
			handleHeaderLanguageToggled(oldLanguage, event) {
				this.languageState =
					oldLanguage === this.translations.siteLanguage.abbreviation.en
						? this.translations.siteLanguage.abbreviation.fr
						: this.translations.siteLanguage.abbreviation.en;
				this.headerLanguageToggled.emit({ oldLanguage: oldLanguage, newLanguage: this.languageState });
				this.updateHTMLLang();
				if (this.customLanguageToggle && event) {
					this.customLanguageToggle(event);
				}
			}
			/**
			 * Prints a warning message to the console about using an incorrect language for the component.
			 *
			 * @param {string} lang - The incorrect language that was received.
			 * @param {string} type - prop/document | Where the incorrect language is coming from.
			 */
			showLanguageWarning(lang, type = 'prop') {
				const propOrDocumentMessage =
					type === 'prop'
						? `The language prop value of ${lang} `
						: `The HTML document lang attribute value of ${lang} `;
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addRegularText(propOrDocumentMessage)
					.addRegularText('is not a valid language value for the ')
					.addMonospaceText(' <ontario-language-toggle> ')
					.addRegularText(`component. Valid language values are ${printArray([...supportedLanguages])}. `)
					.addRegularText(
						`A default language value of ${this.translations.siteLanguage.abbreviation.en} will be applied.`,
					)
					.printMessage();
			}
			/**
			 * Returns abbreviated text for the opposite language.
			 *
			 * @returns {Language}
			 */
			getOppositeLanguageAbbrievation() {
				return this.languageState === this.translations.siteLanguage.abbreviation.en
					? this.translations.siteLanguage.abbreviation.fr
					: this.translations.siteLanguage.abbreviation.en;
			}
			/**
			 * Returns full word text for the opposite language.
			 *
			 * @returns {string}
			 */
			getOppositeLanguageFullWord() {
				return this.languageState === this.translations.siteLanguage.abbreviation.en
					? this.translations.siteLanguage.fullWord.fr
					: this.translations.siteLanguage.fullWord.en;
			}
			/*
			 * Updates the <html> lang attribute based on component languageState.
			 */
			updateHTMLLang = () => {
				const htmlElement = getRootHTMLElement();
				if (htmlElement) {
					htmlElement.setAttribute('lang', this.languageState);
				}
			};
			/**
			 * Component life cycle hook.
			 *
			 * https://stenciljs.com/docs/component-lifecycle#connectedcallback
			 */
			connectedCallback() {
				this.setAppLanguageHandler();
			}
			/**
			 * Component life cycle hook.
			 *
			 * https://stenciljs.com/docs/component-lifecycle#componentdidload
			 */
			componentDidLoad() {
				/**
				 * Creates a MutationObserver (a type of watch) on the <html> tag lang attribute.
				 *
				 * When changes occur, the oppositeLanguageLabel state variable regenerates.
				 *
				 * This is to act as a form of callback and create a subtle delay between page content
				 * updating and the language toggle label updating.
				 */
				const observer = new MutationObserver((mutations) => {
					mutations.forEach((mutation) => {
						switch (mutation.type) {
							case 'attributes':
								switch (mutation.attributeName) {
									case 'lang':
										this.oppositeLanguageLabel = {
											fullWord: this.getOppositeLanguageFullWord(),
											abbreviation: this.getOppositeLanguageAbbrievation(),
										};
										break;
								}
								break;
						}
					});
				});
				// Only create/trigger the MutationObserver if the <html> element exists.
				if (getRootHTMLElement()) {
					const options = { attributes: true };
					observer.observe(getRootHTMLElement(), options);
				}
			}
			render() {
				return hAsync(
					'a',
					{
						'key': '6c86a21b82c98dfad80eb1095af399847286c6bd',
						'aria-label': this.translations.languageToggle.ariaLabel[`${this.oppositeLanguageLabel?.abbreviation}`],
						'class':
							this.size === 'default'
								? 'ontario-language-toggler ontario-language-toggler--default'
								: 'ontario-language-toggler ontario-language-toggler--small',
						'href': this.url ? this.url : '#',
						'hreflang': this.oppositeLanguageLabel?.abbreviation,
						'lang': this.oppositeLanguageLabel?.abbreviation,
						'onClick': (e) => this.handleHeaderLanguageToggled(this.languageState, e),
					},
					this.size === 'small'
						? hAsync('span', null, this.oppositeLanguageLabel?.fullWord)
						: hAsync(
								Fragment,
								null,
								hAsync(
									'abbr',
									{ title: this.oppositeLanguageLabel?.fullWord, class: 'ontario-show-for-small-only' },
									this.oppositeLanguageLabel?.abbreviation.toUpperCase(),
								),
								hAsync('span', { class: 'ontario-show-for-medium' }, this.oppositeLanguageLabel?.fullWord),
							),
				);
			}
			static get watchers() {
				return {
					language: ['updateLanguage'],
				};
			}
			static get style() {
				return ontarioLanguageToggleCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-language-toggle',
					$members$: {
						language: [1025],
						size: [1],
						url: [1025],
						customLanguageToggle: [16, 'custom-language-toggle'],
						translations: [32],
						languageState: [32],
						oppositeLanguageLabel: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioLoadingIndicatorCss =
			'.ontario-loading-indicator__overlay,.ontario-loading-indicator__overlay--within-container{position:fixed;width:100%;left:0;right:0;top:0;bottom:0;background-color:rgba(255, 255, 255, 0.7);z-index:9999}.ontario-loading-indicator__overlay[aria-hidden=false],.ontario-loading-indicator__overlay--within-container[aria-hidden=false]{display:block}.ontario-loading-indicator__overlay[aria-hidden=true],.ontario-loading-indicator__overlay--within-container[aria-hidden=true]{display:none}.ontario-loading-indicator__overlay--within-container{position:absolute}.ontario-loading-indicator{display:flex;flex-direction:column;align-items:center;justify-content:center;position:absolute;top:50%;transform:translateY(-50%);width:100%;height:100%}.ontario-loading-indicator p{color:#4d4d4d;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;line-height:1.5;font-weight:700;word-spacing:0.025rem;margin:0.75rem 0 0}.ontario-loading-indicator__spinner{animation:rotator 1.5s linear infinite;width:3rem;height:3rem;overflow:visible}.ontario-loading-indicator__spinner circle{stroke-dasharray:1, 200;stroke-dashoffset:0;stroke-linecap:round;stroke:#4d4d4d;animation:dash 1.5s ease-in-out infinite}@keyframes rotator{100%{transform:rotate(360deg)}}@keyframes dash{0%{stroke-dasharray:1, 200;stroke-dashoffset:0}50%{stroke-dasharray:89, 200;stroke-dashoffset:-35px}100%{stroke-dasharray:89, 200;stroke-dashoffset:-124px}}';

		class OntarioLoadingIndicator {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The type of loading indicator to render.
			 */
			type = 'large';
			/**
			 * A boolean value to determine whether or not the loading indicator is loading (i.e: is visible) or not.
			 */
			isLoading = false;
			/**
			 * The message that tells the user what is happening or why the user is waiting.
			 * If no message prop is passed, it will default to "Loading". Translations for this default message are included.
			 *
			 * This is optional.
			 */
			message;
			/**
			 * A boolean value to determine whether the loading indicator overlay covers the full page or not. By default, this is set to `true`.
			 *
			 * If set to `false`, the loading indicator overlay will be positioned absolutely relative to its container. Note that this will only work if the containing element has a style rule specifying it to be positioned relatively.
			 */
			fullScreenOverlay = true;
			/**
			 * The language of the component.
			 * This is used for translations, and is by default set through event listeners checking for a language property from the header. If no language is passed, it will default to English.
			 */
			language;
			translations = translations;
			/**
			 * Mutable variables, for internal use only.
			 */
			isLoadingState;
			typeState;
			/**
			 * This listens for the `setAppLanguage` event sent from the test language toggler when it is is connected to the DOM. It is used for the initial language when the input component loads.
			 */
			handleSetAppLanguage(event) {
				if (!this.language) {
					this.language = validateLanguage(event);
				}
			}
			handleHeaderLanguageToggled(event) {
				this.language = validateLanguage(event);
			}
			/**
			 * Watch for changes in the `isLoading` prop.
			 */
			isLoadingChanged(newIsLoading) {
				this.isLoadingState = newIsLoading;
			}
			/**
			 * Watch for changes in the `type` variable for validation purposes.
			 *
			 * If the user input doesn't match one of the array values then `type` will be set to its default (`large`).
			 * If a match is found in one of the array values then `type` will be set to the matching array key value.
			 */
			validateType() {
				const isValid = validateValueAgainstArray(this.type, ['large', 'small']);
				if (isValid) {
					return (this.typeState = this.type);
				} else {
					this.warnDefaultType();
					return (this.typeState = 'large');
				}
			}
			/**
			 * Print the invalid `type` warning message.
			 * @returns default type ('large')
			 */
			warnDefaultType() {
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' type ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-loading-indicator> ')
					.addRegularText('was set to an invalid type; only')
					.addMonospaceText(' large or small ')
					.addRegularText('are supported. The default type')
					.addMonospaceText(' large ')
					.addRegularText('is assumed.')
					.printMessage();
			}
			componentWillLoad() {
				this.language = validateLanguage(this.language);
				this.validateType();
				this.isLoadingState = this.isLoading;
			}
			render() {
				return this.typeState === 'large'
					? hAsync(
							'div',
							{
								'class': this.fullScreenOverlay
									? `ontario-loading-indicator__overlay`
									: `ontario-loading-indicator__overlay--within-container`,
								'aria-hidden': this.isLoadingState ? 'false' : 'true',
								'role': 'alert',
								'aria-live': 'assertive',
							},
							hAsync(
								'div',
								{ class: 'ontario-loading-indicator' },
								hAsync(
									'svg',
									{
										class: 'ontario-loading-indicator__spinner',
										viewBox: '25 25 50 50',
										xmlns: 'http://www.w3.org/2000/svg',
									},
									hAsync('circle', { 'cx': '50', 'cy': '50', 'r': '20', 'fill': 'none', 'stroke-width': '4' }),
								),
								hAsync('p', null, this.message ?? this.translations.loading[`${this.language}`]),
							),
						)
					: hAsync('p', null, 'The small loading indicator is still under development.');
			}
			static get watchers() {
				return {
					isLoading: ['isLoadingChanged'],
					type: ['validateType'],
				};
			}
			static get style() {
				return ontarioLoadingIndicatorCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-loading-indicator',
					$members$: {
						type: [1],
						isLoading: [4, 'is-loading'],
						message: [1],
						fullScreenOverlay: [4, 'full-screen-overlay'],
						language: [1025],
						translations: [32],
						isLoadingState: [32],
						typeState: [32],
					},
					$listeners$: [
						[8, 'setAppLanguage', 'handleSetAppLanguage'],
						[8, 'headerLanguageToggled', 'handleHeaderLanguageToggled'],
					],
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioPageAlertCss =
			'@charset "UTF-8";h6,.ontario-h6,h5,.ontario-h5,h4,.ontario-h4,h3,.ontario-h3,h2,.ontario-h2,h1,.ontario-h1{font-style:normal;font-weight:700;text-rendering:optimizeLegibility;margin-bottom:1rem;font-feature-settings:normal;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif}h1,.ontario-h1{font-size:2rem;letter-spacing:0.04rem;line-height:1.29;margin:2.5rem 0 1.5rem 0;max-width:70rem}@media screen and (min-width: 40em){h1,.ontario-h1{font-size:2.5rem;letter-spacing:0.04rem;line-height:1.2}}h2,.ontario-h2{font-size:1.6875rem;letter-spacing:0.03rem;line-height:1.37;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h2,.ontario-h2{font-size:2.0625rem;letter-spacing:0.02rem;line-height:1.33}}h3,.ontario-h3{font-size:1.4375rem;letter-spacing:0.02rem;line-height:1.39;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h3,.ontario-h3{font-size:1.75rem;letter-spacing:0.02rem;line-height:1.43}}h4,.ontario-h4{font-size:1.25rem;letter-spacing:0.03rem;line-height:1.5;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h4,.ontario-h4{font-size:1.5rem;letter-spacing:0.0313rem;line-height:1.5}}h5,.ontario-h5{font-size:1.125rem;letter-spacing:0.03rem;line-height:1.56;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h5,.ontario-h5{font-size:1.1875rem;letter-spacing:0.025rem;line-height:1.5}}h6,.ontario-h6{font-size:1rem;line-height:1.56;letter-spacing:0.03rem;max-width:48rem;margin:0 0 0.75rem 0}@media screen and (min-width: 40em){h6,.ontario-h6{font-size:1rem;letter-spacing:0.025rem;line-height:1.5}}.ontario-lead-statement{font-size:1.25rem;line-height:1.6;max-width:70rem}@media screen and (min-width: 40em){.ontario-lead-statement{font-size:1.375rem}}html{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem}body{font-size:1rem;line-height:1.6;background-color:#FFFFFF;color:#1a1a1a;margin:0}p{font-size:inherit;margin-bottom:1.25rem;text-rendering:optimizeLegibility;margin:0 0 1.5rem 0}cite{font-style:italic;line-height:inherit}strong{font-weight:700;line-height:inherit}*,*::before,*::after{box-sizing:inherit}main p,main p:not(.ontario-lead-statement),main dd,main li{max-width:48rem}hr{border:0;padding:0;margin:2.5rem 0;border-bottom:4px solid #cccccc}hr.ontario-hr--dark{border-bottom:4px solid #1a1a1a}a{color:#0066CC;text-decoration:underline}a:visited{color:#551A8B}a:hover{color:#00478F}a:active{color:#002142}a:focus{-moz-box-shadow:0 0 0 4px #009ADB;-webkit-box-shadow:0 0 0 4px #009ADB;box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:all 0.1s ease-in-out}p{margin:0 0 1.5rem 0}p+h1,p+h2,p+h3,p+h4,p+h5,p+h6,ul+h1,ul+h2,ul+h3,ul+h4,ul+h5,ul+h6,ol+h1,ol+h2,ol+h3,ol+h4,ol+h5,ol+h6,h1+h2,h2+h3,h3+h4,h4+h5,h5+h6{margin-top:2rem}p code,td code,li code{line-height:2.25rem}input[type=text],input[type=number],input[type=email],input[type=date],input[type=color],input[type=search],input[type=tel],textarea{background-origin:initial;height:auto;-webkit-appearance:none;-moz-appearance:none}input[type=checkbox]+label,input[type=radio]+label{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400;margin-left:0;margin-right:0}fieldset{border:0;margin:0;padding:0;page-break-inside:avoid}legend,label{display:block;margin:0}select{background-origin:initial;height:auto;-webkit-appearance:none;-moz-appearance:none}ul,ol{padding:0}ul{margin-left:2rem}ul li{padding:0 0 0.75rem 0}ol{margin-left:1.75rem}ol li{padding:0 0 0.75rem 0.25rem}ul li:last-child,ol li:last-child{padding-bottom:0}ul[class*=columns-] li:last-child,ol[class*=columns-] li:last-child{padding-bottom:0.75rem}ul ul,ol ul{margin:0.5rem 0 0.5rem 2rem}ul ol,ol ol{margin:0.5rem 0 0.5rem 1.75rem}p+ul,p+ol{margin-top:-0.75rem}@media screen and (min-width: 40em){ul{margin:0.5rem 0 1.5rem 3rem}ol{margin:0.5rem 0 1.5rem 2.75rem}ul ul,ol ul{margin:0.5rem 0 0.5rem 3rem}ul ol,ol ol{margin:0.5rem 0 0.5rem 2.75rem}}.ontario-alert{border-width:0 0 0 0.25rem;border-style:solid;padding:1.5rem;margin:2rem 0 2.5rem 0}.ontario-alert__header{display:-webkit-box;display:-ms-flexbox;display:flex}.ontario-alert__header-icon{display:inline-block;vertical-align:top;margin-right:0.95rem}.ontario-alert__header-title{margin-bottom:0.75rem;padding-top:0.125rem}.ontario-alert__body{margin-left:3.25rem;max-width:48rem}@media screen and (max-width: 40em){.ontario-alert__body{margin-left:0}}.ontario-alert__body p{margin-top:0}.ontario-alert__body p:last-of-type{margin-bottom:0.5rem}.ontario-alert__body p:last-of-type+ul{margin-top:1rem}.ontario-alert__body ul:last-of-type{margin-bottom:0.5rem}.ontario-alert--error ul{margin-left:1.25rem}.ontario-alert--error ul:last-of-type{margin-bottom:0.5rem}.ontario-alert--informational{border-color:#1080A6;background-color:#E2F0F4}.ontario-alert--warning{border-color:#FFD440;background-color:#FEF6DC}.ontario-alert--success{border-color:#118847;background-color:#E5f0E9}.ontario-alert--error{border-color:#CD0000;background-color:#FCEFF0}.ontario-alert--error a{color:#CD0000}.ontario-alert--error a:hover,.ontario-alert--error a:focus{color:#6b0000}.ontario-alert--error a:active{color:#280000}';

		class OntarioPageAlert {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			/**
			 * The type of page alert to render. If no value is provided, the `informational` type alert would be rendered.
			 *
			 * There are four possible values for page alert: `informational`, `warning`, `success` or `error`.
			 *
			 * @example
			 * <ontario-page-alert type="error">
			 * </ontario-page-alert>
			 */
			type = 'informational';
			/**
			 * The heading for the page alert.
			 *
			 * @example
			 * <ontario-page-alert heading="Licence plates">
			 * </ontario-page-alert>
			 */
			heading;
			/**
			 * The main content for the page alert. This can be rendered as either string or HTML content.
			 *
			 * @example
			 * <ontario-page-alert content="Please look out for an email confirmation with your receipt and order number.">
			 * </ontario-page-alert>
			 *
			 * or
			 *
			 * <ontario-page-alert>
			 *  <p>This is a sample page alert component using slots. <a href="#">Learn more</a>.</p>
			 * </ontario-page-alert>
			 */
			content;
			/**
			 * @returns the classes of the page alert container based on the alert `type`.
			 */
			getClass() {
				return `ontario-alert ontario-alert--${this.type}`;
			}
			renderIcon() {
				const iconProps = { 'icon-width': 36 };
				switch (this.type) {
					case 'informational':
						return hAsync('ontario-icon-alert-information', { ...iconProps });
					case 'success':
						return hAsync('ontario-icon-alert-success', { ...iconProps });
					case 'warning':
						return hAsync('ontario-icon-alert-warning', { ...iconProps });
					case 'error':
						return hAsync('ontario-icon-alert-error', { ...iconProps });
				}
			}
			renderContent() {
				const body = this.content;
				if (typeof body === 'string') {
					return hAsync('p', null, body);
				}
				return hAsync('slot', null);
			}
			render() {
				return hAsync(
					'div',
					{ key: 'bc89ba1ae733df97405d1431c21e94b6bde31659', class: this.getClass() },
					hAsync(
						'div',
						{ key: '823d43473763c86b7d62e50c6a9f38377eb85931', class: 'ontario-alert__header' },
						hAsync(
							'div',
							{ key: '186731136cf022db116adcb017c1d53be3589312', class: 'ontario-alert__header-icon' },
							this.renderIcon(),
						),
						hAsync(
							'h2',
							{ key: '01f2f4f91f6567cff09130359ac2cd6fb949574e', class: 'ontario-alert__header-title ontario-h4' },
							this.heading,
						),
					),
					hAsync(
						'div',
						{ key: 'c72fdccf42f2669259856c58be84085152dde302', class: 'ontario-alert__body' },
						this.renderContent(),
					),
				);
			}
			static get style() {
				return ontarioPageAlertCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-page-alert',
					$members$: {
						type: [1],
						heading: [1],
						content: [1],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioRadioButtonsCss =
			'@charset "UTF-8";.ontario-radios__input:focus+.ontario-radios__label:before,.ontario-input:focus,.ontario-input:active{box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:box-shadow 0.1s ease-in-out}h6,.ontario-h6,h5,.ontario-h5,h4,.ontario-h4,h3,.ontario-h3,h2,.ontario-h2,.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1,h1,.ontario-h1{font-style:normal;font-weight:700;text-rendering:optimizeLegibility;margin-bottom:1rem;font-feature-settings:normal;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif}.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1,h1,.ontario-h1{font-size:2rem;letter-spacing:0.04rem;line-height:1.29;margin:2.5rem 0 1.5rem 0;max-width:70rem}@media screen and (min-width: 40em){.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1,h1,.ontario-h1{font-size:2.5rem;letter-spacing:0.04rem;line-height:1.2}}h2,.ontario-h2{font-size:1.6875rem;letter-spacing:0.03rem;line-height:1.37;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h2,.ontario-h2{font-size:2.0625rem;letter-spacing:0.02rem;line-height:1.33}}h3,.ontario-h3{font-size:1.4375rem;letter-spacing:0.02rem;line-height:1.39;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h3,.ontario-h3{font-size:1.75rem;letter-spacing:0.02rem;line-height:1.43}}h4,.ontario-h4{font-size:1.25rem;letter-spacing:0.03rem;line-height:1.5;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h4,.ontario-h4{font-size:1.5rem;letter-spacing:0.0313rem;line-height:1.5}}h5,.ontario-h5{font-size:1.125rem;letter-spacing:0.03rem;line-height:1.56;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h5,.ontario-h5{font-size:1.1875rem;letter-spacing:0.025rem;line-height:1.5}}h6,.ontario-h6{font-size:1rem;line-height:1.56;letter-spacing:0.03rem;max-width:48rem;margin:0 0 0.75rem 0}@media screen and (min-width: 40em){h6,.ontario-h6{font-size:1rem;letter-spacing:0.025rem;line-height:1.5}}.ontario-lead-statement{font-size:1.25rem;line-height:1.6;max-width:70rem}@media screen and (min-width: 40em){.ontario-lead-statement{font-size:1.375rem}}html{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem}body{font-size:1rem;line-height:1.6;background-color:#FFFFFF;color:#1a1a1a;margin:0}p{font-size:inherit;margin-bottom:1.25rem;text-rendering:optimizeLegibility;margin:0 0 1.5rem 0}cite{font-style:italic;line-height:inherit}strong{font-weight:700;line-height:inherit}*,*::before,*::after{box-sizing:inherit}main p,main p:not(.ontario-lead-statement),main dd,main li{max-width:48rem}hr{border:0;padding:0;margin:2.5rem 0;border-bottom:4px solid #cccccc}hr.ontario-hr--dark{border-bottom:4px solid #1a1a1a}a{color:#0066CC;text-decoration:underline}a:visited{color:#551A8B}a:hover{color:#00478F}a:active{color:#002142}a:focus{-moz-box-shadow:0 0 0 4px #009ADB;-webkit-box-shadow:0 0 0 4px #009ADB;box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:all 0.1s ease-in-out}p{margin:0 0 1.5rem 0}p+h1,p+h2,p+h3,p+h4,p+h5,p+h6,ul+h1,ul+h2,ul+h3,ul+h4,ul+h5,ul+h6,ol+h1,ol+h2,ol+h3,ol+h4,ol+h5,ol+h6,h1+h2,h2+h3,h3+h4,h4+h5,h5+h6{margin-top:2rem}p code,td code,li code{line-height:2.25rem}input[type=text],input[type=number],input[type=email],input[type=date],input[type=color],input[type=search],input[type=tel],textarea{background-origin:initial;height:auto;-webkit-appearance:none;-moz-appearance:none}input[type=checkbox]+label,input[type=radio]+label{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400;margin-left:0;margin-right:0}fieldset{border:0;margin:0;padding:0;page-break-inside:avoid}legend,label{display:block;margin:0}select{background-origin:initial;height:auto;-webkit-appearance:none;-moz-appearance:none}ul,ol{padding:0}ul{margin-left:2rem}ul li{padding:0 0 0.75rem 0}ol{margin-left:1.75rem}ol li{padding:0 0 0.75rem 0.25rem}ul li:last-child,ol li:last-child{padding-bottom:0}ul[class*=columns-] li:last-child,ol[class*=columns-] li:last-child{padding-bottom:0.75rem}ul ul,ol ul{margin:0.5rem 0 0.5rem 2rem}ul ol,ol ol{margin:0.5rem 0 0.5rem 1.75rem}p+ul,p+ol{margin-top:-0.75rem}@media screen and (min-width: 40em){ul{margin:0.5rem 0 1.5rem 3rem}ol{margin:0.5rem 0 1.5rem 2.75rem}ul ul,ol ul{margin:0.5rem 0 0.5rem 3rem}ul ol,ol ol{margin:0.5rem 0 0.5rem 2.75rem}}.ontario-form-group:last-of-type{margin-bottom:2.5rem}.ontario-form-group:last-of-type{margin-bottom:3rem}.ontario-fieldset__legend{color:#1a1a1a;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1.1875rem;font-weight:700;margin:0 0 1rem 0;line-height:1.5;max-width:38.75em;white-space:normal;width:100%;hyphens:auto}@media screen and (max-width: 40em){.ontario-fieldset__legend{font-size:1.125rem;line-height:1.56}}.ontario-fieldset__legend--large,.ontario-fieldset__legend--heading{letter-spacing:0.02rem;line-height:1.2}.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1{display:inline-block;margin:0}@media screen and (max-width: 40em){.ontario-fieldset__legend--large,.ontario-fieldset__legend--heading{font-size:1.4375rem;line-height:1.39}}.ontario-fieldset__legend--large{font-size:1.75rem}.ontario-fieldset__legend-required-flag,.ontario-fieldset__legend-optional-flag{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400}.ontario-fieldset__legend-required-flag:before,.ontario-fieldset__legend-optional-flag:before{content:""}.ontario-label__flag{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400}.ontario-label__flag:before{content:""}.ontario-hide{display:none !important}.ontario-invisible{visibility:hidden !important}@media screen and (max-width: 39.99875em){.ontario-hide-for-small-only{display:none !important}}@media screen and (max-width: 0em), screen and (min-width: 40em){.ontario-show-for-small-only{display:none !important}}@media print, screen and (min-width: 40em){.ontario-hide-for-medium{display:none !important}}@media screen and (max-width: 39.99875em){.ontario-show-for-medium{display:none !important}}@media screen and (min-width: 40em) and (max-width: 72.99875em){.ontario-hide-for-medium-only{display:none !important}}@media screen and (max-width: 39.99875em), screen and (min-width: 73em){.ontario-show-for-medium-only{display:none !important}}@media print, screen and (min-width: 73em){.ontario-hide-for-large{display:none !important}}@media screen and (max-width: 72.99875em){.ontario-show-for-large{display:none !important}}@media screen and (min-width: 73em) and (max-width: 95.99875em){.ontario-hide-for-large-only{display:none !important}}@media screen and (max-width: 72.99875em), screen and (min-width: 96em){.ontario-show-for-large-only{display:none !important}}.ontario-show-for-sr,.ontario-show-on-focus{position:absolute;width:1px;height:1px;overflow:hidden;clip:rect(0, 0, 0, 0)}.ontario-show-on-focus:active,.ontario-show-on-focus:focus{position:static;width:auto;height:auto;overflow:visible;clip:auto}.ontario-show-for-landscape,.ontario-hide-for-portrait{display:block !important}@media screen and (orientation: landscape){.ontario-show-for-landscape,.ontario-hide-for-portrait{display:block !important}}@media screen and (orientation: portrait){.ontario-show-for-landscape,.ontario-hide-for-portrait{display:none !important}}.ontario-hide-for-landscape,.ontario-show-for-portrait{display:none !important}@media screen and (orientation: landscape){.ontario-hide-for-landscape,.ontario-show-for-portrait{display:none !important}}@media screen and (orientation: portrait){.ontario-hide-for-landscape,.ontario-show-for-portrait{display:block !important}}.ontario-input{border:2px solid #1a1a1a;border-radius:4px;box-sizing:border-box;color:#1a1a1a;display:block;font-size:1rem;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;line-height:1.5;margin:0 0 2.5rem;max-width:48rem;width:100%;padding:0.625rem 1rem;transition:box-shadow 0.1s ease-in-out}.ontario-input--2-char-width{max-width:8ex}.ontario-input--3-char-width{max-width:10ex}.ontario-input--4-char-width{max-width:12ex}.ontario-input--5-char-width{max-width:14ex}.ontario-input--7-char-width{max-width:17ex}.ontario-input--10-char-width{max-width:23ex}.ontario-input--20-char-width{max-width:41ex}.ontario-form-group:last-of-type{margin-bottom:2.5rem}.ontario-error-messaging{display:flex;align-items:flex-start;margin:-0.25rem 0 0.5rem 0;color:#D81A21;max-width:48rem}.ontario-error-messaging__content{margin-left:0.5rem}.ontario-input__error{border-color:#D81A21 !important}.ontario-error__hidden{display:none}.ontario-radios__item{position:relative;display:block;margin:0 0 1rem;padding:0 2rem 0}.ontario-radios__item:last-of-type{margin-bottom:0}.ontario-radios__input{cursor:pointer;margin:0;position:absolute;opacity:0;top:-2px;left:-2px;width:36px;height:36px;z-index:0}@media screen and (max-width: 40em){.ontario-radios__input{width:40px;height:40px;top:-1.5px;left:-1.5px}}.ontario-radios__label{cursor:pointer;color:#1a1a1a;display:inline-block;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:700;line-height:1.5;margin:0.2rem 0;max-width:38.75em;padding:0 0.75rem;touch-action:manipulation;white-space:normal;width:auto;white-space:normal}@media screen and (max-width: 40em){.ontario-radios__label{margin:0.3rem 0;padding:0 1rem}}.ontario-radios__label:before{content:"";border:2px solid #1a1a1a;border-radius:50%;box-sizing:border-box;position:absolute;top:0;left:0;width:32px;height:32px;transition:border 0.1s ease-in-out}@media screen and (max-width: 40em){.ontario-radios__label:before{width:36px;height:36px}}.ontario-radios__label:after{content:"";border-radius:50%;border:10px solid #1a1a1a;position:absolute;top:0;left:0;transform:translate(6px, 6px);opacity:0}@media screen and (max-width: 40em){.ontario-radios__label:after{border:12px solid #1a1a1a}}.ontario-radios__input:focus+.ontario-radios__label:before{-moz-box-shadow:0 0 0 4px #009ADB;-webkit-box-shadow:#009ADB}.ontario-radios__input:checked+.ontario-radios__label:after{opacity:1}.ontario-radios__hint-expander{margin:0.75rem 0 0 0.5rem}@media screen and (max-width: 40em){.ontario-radios__hint-expander{margin-top:1rem}}';

		class OntarioRadioButtons {
			constructor(hostRef) {
				registerInstance(this, hostRef);
				this.radioOnChange = createEvent(this, 'radioOnChange');
				this.radioOnBlur = createEvent(this, 'radioOnBlur');
				this.radioOnFocus = createEvent(this, 'radioOnFocus');
				this.inputErrorOccurred = createEvent(this, 'inputErrorOccurred');
				if (hostRef.$hostElement$['s-ei']) {
					this.internals = hostRef.$hostElement$['s-ei'];
				} else {
					this.internals = hostRef.$hostElement$.attachInternals();
					hostRef.$hostElement$['s-ei'] = this.internals;
				}
			}
			get element() {
				return getElement(this);
			}
			internals;
			hintTextRef;
			/**
			 * The text to display for the radio button legend.
			 *
			 * @example
			 * <ontario-radio-buttons
			 *   caption='{
			 *     "captionText": "Radio legend",
			 *     "captionType": "heading",
			 *    }'
			 *   required="true"
			 *   ...>
			 * </ontario-radio-buttons>
			 */
			caption;
			/**
			 * The language of the component.
			 * This is used for translations, and is by default set through event listeners checking for a language property from the header. If no language is passed, it will default to English.
			 */
			language;
			/**
			 * The name assigned to the radio button. The name value is used to reference form data after a form is submitted.
			 */
			name;
			/**
			 * Used to include the ontario-hint-text component for radio button group.
			 * This is optional.
			 */
			hintText;
			/**
			 * Used to include the ontario-hint-expander component for the radio button group.
			 * This is passed in as an object with key-value pairs.
			 *
			 * This is optional.
			 *
			 * @example
			 * <ontario-radio-buttons
			 *   caption='{
			 *     "captionText": "Radio legend",
			 *     "captionType": "heading",
			 *   }'
			 * 	 name="radios"
			 *   options='[
			 * 	   {
			 *        "value": "radio-option-1",
			 * 		  "elementId": "radio-1",
			 *        "label": "Radio option 1 label",
			 *        "hintExpander": {
			 *			  "hint": "Hint expander for radio option 1",
			 * 		      "content": "Example hint expander content for radio option 1."
			 *		  }
			 *     }
			 *   ]'
			 *   hint-expander='{
			 *     "hint": "Hint expander for the radio button group",
			 *     "content": "Example hint expander content for the radio button group."
			 *   }'
			 *   required="true"
			 * >
			 * </ontario-radio-buttons>
			 */
			hintExpander;
			/**
			 * This is used to determine whether the radio button is required or not.
			 * This prop also gets passed to the InputCaption utility to display either an optional or required flag in the label.
			 * If no prop is set, it will default to false (optional).
			 */
			required = false;
			/**
			 * The options for the radio button group.
			 *
			 * Each property will be passed in through an object in the options array.
			 * This can either be passed in as an object directly (if using react), or as a string in HTML.
			 * If there are multiple radio buttons in a group, each radio button will be displayed as an option.
			 *
			 * In the example below, the options are being passed in as a string and there are two radio buttons to be displayed in the group.
			 *
			 * @example
			 * <ontario-radio-buttons
			 *   caption='{
			 *     "captionText": "Radio legend",
			 *     "captionType": "heading",
			 *   }'
			 *   name="radios"
			 *   hint-text="Hint text for the radio button group."
			 *   options='[
			 *     {
			 *        "value": "radio-option-1",
			 * 		  "elementId": "radio-1",
			 *        "label": "Radio option 1 label"
			 *     },
			 *     {
			 *        "value": "radio-option-2",
			 * 		  "elementId": "radio-2",
			 *        "label": "Radio option 2 label",
			 *        "hintExpander": {
			 *			  "hint": "Hint expander for radio option 2",
			 * 		      "content": "Example hint expander content for radio option 2."
			 *		  }
			 *      }
			 *   ]'
			 *   required="true"
			 * >
			 * </ontario-radio-buttons>
			 */
			options;
			/**
			 * Set this to display an error message
			 */
			errorMessage;
			/**
			 * Used to add a custom function to the radio input onChange event.
			 */
			customOnChange;
			/**
			 * Used to add a custom function to the radio input onBlur event.
			 */
			customOnBlur;
			/**
			 * Used to add a custom function to the radio input onFocus event.
			 */
			customOnFocus;
			/**
			 * Used for the `aria-describedby` value of the radio button group. This will match with the id of the hint text.
			 */
			hintTextId;
			/**
			 * The hint text options are re-assigned to the internalHintText array.
			 */
			internalHintText;
			/**
			 * The hint expander options are re-assigned to the internalHintExpander array.
			 */
			internalHintExpander;
			/**
			 * The options are re-assigned to the internalOptions array.
			 */
			internalOptions;
			/**
			 * Instantiate an InputCaption object for internal logic use
			 */
			captionState;
			/**
			 * Emitted when a keyboard input or mouse event occurs when a radio option has been changed.
			 */
			radioOnChange;
			/**
			 * Emitted when a keyboard input event occurs when a radio option has lost focus.
			 */
			radioOnBlur;
			/**
			 * Emitted when a keyboard input event occurs when a radio option has gained focus.
			 */
			radioOnFocus;
			/**
			 * Emitted when an error message is reported to the component.
			 */
			inputErrorOccurred;
			/**
			 * This listens for the `setAppLanguage` event sent from the test language toggler when it is is connected to the DOM. It is used for the initial language when the input component loads.
			 */
			handleSetAppLanguage(event) {
				if (!this.language) {
					this.language = validateLanguage(event);
				}
			}
			handleHeaderLanguageToggled(event) {
				this.language = validateLanguage(event);
			}
			/**
			 * Watch for changes to the `hintText` prop.
			 *
			 * If a `hintText` prop is passed, the `constructHintTextObject` function will convert it to the correct format, and set the result to the `internalHintText` state.
			 */
			parseHintText() {
				if (this.hintText) {
					const hintTextObject = constructHintTextObject(this.hintText);
					this.internalHintText = hintTextObject;
				}
			}
			/**
			 * Watch for changes to the `hintExpander` prop.
			 *
			 * If a `hintExpander` prop is passed, it will be parsed (if it is a string), and the result will be set to the `internalHintExpander` state.
			 */
			parseHintExpander() {
				const hintExpander = this.hintExpander;
				if (hintExpander) {
					if (typeof hintExpander === 'string') this.internalHintExpander = JSON.parse(hintExpander);
					else this.internalHintExpander = hintExpander;
				}
			}
			/**
			 * Watch for changes to the `options` prop.
			 *
			 * If an `options` prop is passed, it will be parsed (if it is a string), and the result will be set to the `internalOptions` state. The result will be run through a validation function.
			 */
			parseOptions() {
				if (typeof this.options !== 'undefined') {
					if (!Array.isArray(this.options)) {
						this.internalOptions = JSON.parse(this.options);
					} else {
						this.internalOptions = this.options;
					}
				}
			}
			/*
			 * Watch for changes in the `name` prop for validation purposes.
			 *
			 * Validate the `name` and make sure the `name` prop has a value.
			 * Log a warning if user doesn't input a value for the `name`.
			 */
			validateName(newValue) {
				if (validatePropExists(newValue)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' name ')
						.addRegularText('for')
						.addMonospaceText(' <ontario-radio-buttons> ')
						.addRegularText('was not provided')
						.printMessage();
				}
			}
			/*
     * Watch for changes in the `options` prop for validation purposes.

     * Validate the `options` and make sure the `options` prop has a value.
     * Log a warning if user doesn't input a value for the `options`.
     */
			validateOptions(newValue) {
				if (validateObjectExists(newValue)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' options ')
						.addRegularText('for')
						.addMonospaceText(' <ontario-radio-buttons> ')
						.addRegularText('was not provided')
						.printMessage();
				}
			}
			/**
			 * Watch for changes to the `caption` prop.
			 *
			 * The caption will be run through the InputCaption constructor to convert it to the correct format, and set the result to the `captionState` state.
			 * @param newValue: Caption | string
			 */
			updateCaptionState(newValue) {
				this.captionState = new InputCaption(
					this.element.tagName,
					newValue,
					translations,
					this.language,
					true,
					this.required,
				);
			}
			/**
			 * Watch for changes to the `language` prop to render either the English or French translations
			 */
			updateLanguage() {
				this.updateCaptionState(this.caption);
			}
			broadcastInputErrorOccurredEvent() {
				// Emit event to notify anyone who wants to listen for errors occurring
				this.inputErrorOccurred.emit({ errorMessage: this.errorMessage ?? '' });
			}
			/**
			 * Function to handle radio buttons events and the information pertaining to the radio buttons to emit.
			 */
			handleEvent(event, eventType) {
				const input = event.target;
				// Reset all internalOptions checked states
				const changedOption = this.internalOptions
					.map((x) => {
						x.checked = false;
						return x;
					})
					.find((x) => x.value === input?.value);
				// Set the new checked state for the selected value
				if (changedOption) changedOption.checked = !changedOption?.checked;
				// Set the value within the form
				this.internals?.setFormValue?.(
					this.internalOptions
						.filter((x) => !!x.checked)
						.reduce((formData, currentValue) => {
							formData.append(this.name, currentValue.value);
							return formData;
						}, new FormData()),
				);
				handleInputEvent(
					event,
					eventType,
					input,
					this.radioOnChange,
					this.radioOnFocus,
					this.radioOnBlur,
					undefined,
					'radio',
					this.customOnChange,
					this.customOnFocus,
					this.customOnBlur,
					undefined,
					this.element,
				);
			}
			/**
			 * If a `hintText` prop is passed, the id generated from it will be set to the internal `hintTextId` state to match with the fieldset `aria-describedBy` attribute.
			 */
			async componentDidLoad() {
				this.hintTextId = await this.hintTextRef?.getHintTextId();
			}
			componentWillLoad() {
				this.updateCaptionState(this.caption);
				this.parseOptions();
				this.parseHintText();
				this.parseHintExpander();
				this.validateName(this.name);
				this.validateOptions(this.internalOptions);
				this.language = validateLanguage(this.language);
			}
			render() {
				const error = !!this.errorMessage;
				return hAsync(
					'div',
					{
						key: 'ba478aa73f71d17fba7f1a403f4758f6853b220b',
						class: `ontario-form-group ${error ? 'ontario-input--error' : ''}`,
					},
					hAsync(
						'fieldset',
						{
							'key': 'cae7a78b9c05a3b69b9af229e5c3ba1e4328b340',
							'class': 'ontario-fieldset',
							'aria-describedby': this.hintTextId,
						},
						this.captionState.getCaption(undefined, !!this.internalHintExpander),
						this.internalHintText &&
							hAsync('ontario-hint-text', {
								key: '122c784ca3b0219b6478b443cabc258d13ab3e7c',
								hint: this.internalHintText.hint,
								hintContentType: this.internalHintText.hintContentType,
								ref: (el) => (this.hintTextRef = el),
							}),
						hAsync(
							'div',
							{ key: '1580f017c32064bc1ec65cb21a28aa3e253c2fdd', class: 'ontario-radios' },
							hAsync(ErrorMessage, {
								key: 'd3c602b449e84c5d9b21836378835552fdeba767',
								message: this.errorMessage,
								error: error,
							}),
							this.internalOptions?.map((radioOption) =>
								hAsync(
									'div',
									{ class: 'ontario-radios__item' },
									hAsync(Input$1, {
										className: 'ontario-radios__input',
										id: radioOption.elementId,
										name: this.name,
										type: 'radio',
										value: radioOption.value,
										required: !!this.required,
										checked: !!radioOption.checked,
										onChange: (e) => this.handleEvent(e, EventType.Change),
										onBlur: (e) => this.handleEvent(e, EventType.Blur),
										onFocus: (e) => this.handleEvent(e, EventType.Focus),
									}),
									hAsync(
										'label',
										{ class: 'ontario-radios__label', htmlFor: radioOption.elementId },
										radioOption.label,
										radioOption.hintExpander &&
											this.captionState.getHintExpanderAccessibilityText(radioOption.label, true),
									),
									radioOption.hintExpander &&
										hAsync(
											'div',
											{ class: 'ontario-radios__hint-expander' },
											hAsync('ontario-hint-expander', {
												'hint': radioOption.hintExpander.hint,
												'content': radioOption.hintExpander.content,
												'hintContentType': radioOption.hintExpander.hintContentType,
												'input-exists': true,
											}),
										),
								),
							),
							this.internalHintExpander &&
								hAsync(
									'div',
									{ key: '6cd63cae4be79a78c328c13288d348537c8551ad', class: 'ontario-radios__hint-expander' },
									hAsync('ontario-hint-expander', {
										'key': 'e9abb0ecb680b50283438469d1425293e3a80440',
										'hint': this.internalHintExpander.hint,
										'content': this.internalHintExpander.content,
										'hintContentType': this.internalHintExpander.hintContentType,
										'input-exists': true,
									}),
								),
						),
					),
				);
			}
			static get formAssociated() {
				return true;
			}
			static get watchers() {
				return {
					hintText: ['parseHintText'],
					hintExpander: ['parseHintExpander'],
					options: ['parseOptions', 'validateOptions'],
					name: ['validateName'],
					caption: ['updateCaptionState'],
					language: ['updateLanguage'],
					errorMessage: ['broadcastInputErrorOccurredEvent'],
				};
			}
			static get style() {
				return ontarioRadioButtonsCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 73,
					$tagName$: 'ontario-radio-buttons',
					$members$: {
						caption: [1],
						language: [1025],
						name: [1],
						hintText: [1, 'hint-text'],
						hintExpander: [1, 'hint-expander'],
						required: [4],
						options: [1],
						errorMessage: [1025, 'error-message'],
						customOnChange: [16, 'custom-on-change'],
						customOnBlur: [16, 'custom-on-blur'],
						customOnFocus: [16, 'custom-on-focus'],
						hintTextId: [32],
						internalHintText: [32],
						internalHintExpander: [32],
						internalOptions: [32],
						captionState: [32],
					},
					$listeners$: [
						[8, 'setAppLanguage', 'handleSetAppLanguage'],
						[8, 'headerLanguageToggled', 'handleHeaderLanguageToggled'],
					],
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioSearchBoxCss =
			'@charset "UTF-8";.ontario-search__input.ontario-input:focus,.ontario-input:focus,.ontario-input:active{box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:box-shadow 0.1s ease-in-out}h6,.ontario-h6,h5,.ontario-h5,h4,.ontario-h4,h3,.ontario-h3,h2,.ontario-h2,h1>.ontario-label--heading,.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1,h1,.ontario-h1{font-style:normal;font-weight:700;text-rendering:optimizeLegibility;margin-bottom:1rem;font-feature-settings:normal;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif}h1>.ontario-label--heading,.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1,h1,.ontario-h1{font-size:2rem;letter-spacing:0.04rem;line-height:1.29;margin:2.5rem 0 1.5rem 0;max-width:70rem}@media screen and (min-width: 40em){h1>.ontario-label--heading,.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1,h1,.ontario-h1{font-size:2.5rem;letter-spacing:0.04rem;line-height:1.2}}h2,.ontario-h2{font-size:1.6875rem;letter-spacing:0.03rem;line-height:1.37;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h2,.ontario-h2{font-size:2.0625rem;letter-spacing:0.02rem;line-height:1.33}}h3,.ontario-h3{font-size:1.4375rem;letter-spacing:0.02rem;line-height:1.39;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h3,.ontario-h3{font-size:1.75rem;letter-spacing:0.02rem;line-height:1.43}}h4,.ontario-h4{font-size:1.25rem;letter-spacing:0.03rem;line-height:1.5;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h4,.ontario-h4{font-size:1.5rem;letter-spacing:0.0313rem;line-height:1.5}}h5,.ontario-h5{font-size:1.125rem;letter-spacing:0.03rem;line-height:1.56;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h5,.ontario-h5{font-size:1.1875rem;letter-spacing:0.025rem;line-height:1.5}}h6,.ontario-h6{font-size:1rem;line-height:1.56;letter-spacing:0.03rem;max-width:48rem;margin:0 0 0.75rem 0}@media screen and (min-width: 40em){h6,.ontario-h6{font-size:1rem;letter-spacing:0.025rem;line-height:1.5}}.ontario-lead-statement{font-size:1.25rem;line-height:1.6;max-width:70rem}@media screen and (min-width: 40em){.ontario-lead-statement{font-size:1.375rem}}html{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem}body{font-size:1rem;line-height:1.6;background-color:#FFFFFF;color:#1a1a1a;margin:0}p{font-size:inherit;margin-bottom:1.25rem;text-rendering:optimizeLegibility;margin:0 0 1.5rem 0}cite{font-style:italic;line-height:inherit}strong{font-weight:700;line-height:inherit}*,*::before,*::after{box-sizing:inherit}main p,main p:not(.ontario-lead-statement),main dd,main li{max-width:48rem}hr{border:0;padding:0;margin:2.5rem 0;border-bottom:4px solid #cccccc}hr.ontario-hr--dark{border-bottom:4px solid #1a1a1a}a{color:#0066CC;text-decoration:underline}a:visited{color:#551A8B}a:hover{color:#00478F}a:active{color:#002142}a:focus{-moz-box-shadow:0 0 0 4px #009ADB;-webkit-box-shadow:0 0 0 4px #009ADB;box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:all 0.1s ease-in-out}p{margin:0 0 1.5rem 0}p+h1,p+h2,p+h3,p+h4,p+h5,p+h6,ul+h1,ul+h2,ul+h3,ul+h4,ul+h5,ul+h6,ol+h1,ol+h2,ol+h3,ol+h4,ol+h5,ol+h6,h1+h2,h2+h3,h3+h4,h4+h5,h5+h6{margin-top:2rem}p code,td code,li code{line-height:2.25rem}input[type=text],input[type=number],input[type=email],input[type=date],input[type=color],input[type=search],input[type=tel],textarea{background-origin:initial;height:auto;-webkit-appearance:none;-moz-appearance:none}input[type=checkbox]+label,input[type=radio]+label{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400;margin-left:0;margin-right:0}fieldset{border:0;margin:0;padding:0;page-break-inside:avoid}legend,label{display:block;margin:0}select{background-origin:initial;height:auto;-webkit-appearance:none;-moz-appearance:none}ul,ol{padding:0}ul{margin-left:2rem}ul li{padding:0 0 0.75rem 0}ol{margin-left:1.75rem}ol li{padding:0 0 0.75rem 0.25rem}ul li:last-child,ol li:last-child{padding-bottom:0}ul[class*=columns-] li:last-child,ol[class*=columns-] li:last-child{padding-bottom:0.75rem}ul ul,ol ul{margin:0.5rem 0 0.5rem 2rem}ul ol,ol ol{margin:0.5rem 0 0.5rem 1.75rem}p+ul,p+ol{margin-top:-0.75rem}@media screen and (min-width: 40em){ul{margin:0.5rem 0 1.5rem 3rem}ol{margin:0.5rem 0 1.5rem 2.75rem}ul ul,ol ul{margin:0.5rem 0 0.5rem 3rem}ul ol,ol ol{margin:0.5rem 0 0.5rem 2.75rem}}.ontario-form-group:last-of-type{margin-bottom:2.5rem}.ontario-form-group:last-of-type{margin-bottom:3rem}.ontario-fieldset__legend{color:#1a1a1a;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1.1875rem;font-weight:700;margin:0 0 1rem 0;line-height:1.5;max-width:38.75em;white-space:normal;width:100%;hyphens:auto}@media screen and (max-width: 40em){.ontario-fieldset__legend{font-size:1.125rem;line-height:1.56}}.ontario-fieldset__legend--large,.ontario-fieldset__legend--heading{letter-spacing:0.02rem;line-height:1.2}.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1{display:inline-block;margin:0}@media screen and (max-width: 40em){.ontario-fieldset__legend--large,.ontario-fieldset__legend--heading{font-size:1.4375rem;line-height:1.39}}.ontario-fieldset__legend--large{font-size:1.75rem}.ontario-fieldset__legend-required-flag,.ontario-fieldset__legend-optional-flag{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400}.ontario-fieldset__legend-required-flag:before,.ontario-fieldset__legend-optional-flag:before{content:""}.ontario-label__flag{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400}.ontario-label__flag:before{content:""}.ontario-label{cursor:pointer;color:#1a1a1a;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1.1875rem;font-weight:700;line-height:1.5;margin:0 0 1rem 0;max-width:38.75em;white-space:normal;width:100%;hyphens:auto}@media screen and (max-width: 40em){.ontario-label{font-size:1.125rem;line-height:1.56}}.ontario-label--large{font-size:1.75rem;letter-spacing:0.02rem;line-height:1.2;max-width:26.25em}@media screen and (max-width: 40em){.ontario-label--large{font-size:1.4375rem;line-height:1.39}}h1>.ontario-label--heading{display:inline-block;margin:0}.ontario-label__flag{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400}.ontario-label__flag:before{content:""}.ontario-input{border:2px solid #1a1a1a;border-radius:4px;box-sizing:border-box;color:#1a1a1a;display:block;font-size:1rem;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;line-height:1.5;margin:0 0 2.5rem;max-width:48rem;width:100%;padding:0.625rem 1rem;transition:box-shadow 0.1s ease-in-out}.ontario-input--2-char-width{max-width:8ex}.ontario-input--3-char-width{max-width:10ex}.ontario-input--4-char-width{max-width:12ex}.ontario-input--5-char-width{max-width:14ex}.ontario-input--7-char-width{max-width:17ex}.ontario-input--10-char-width{max-width:23ex}.ontario-input--20-char-width{max-width:41ex}.ontario-form-group:last-of-type{margin-bottom:2.5rem}.ontario-hide{display:none !important}.ontario-invisible{visibility:hidden !important}@media screen and (max-width: 39.99875em){.ontario-hide-for-small-only{display:none !important}}@media screen and (max-width: 0em), screen and (min-width: 40em){.ontario-show-for-small-only{display:none !important}}@media print, screen and (min-width: 40em){.ontario-hide-for-medium{display:none !important}}@media screen and (max-width: 39.99875em){.ontario-show-for-medium{display:none !important}}@media screen and (min-width: 40em) and (max-width: 72.99875em){.ontario-hide-for-medium-only{display:none !important}}@media screen and (max-width: 39.99875em), screen and (min-width: 73em){.ontario-show-for-medium-only{display:none !important}}@media print, screen and (min-width: 73em){.ontario-hide-for-large{display:none !important}}@media screen and (max-width: 72.99875em){.ontario-show-for-large{display:none !important}}@media screen and (min-width: 73em) and (max-width: 95.99875em){.ontario-hide-for-large-only{display:none !important}}@media screen and (max-width: 72.99875em), screen and (min-width: 96em){.ontario-show-for-large-only{display:none !important}}.ontario-show-for-sr,.ontario-show-on-focus{position:absolute;width:1px;height:1px;overflow:hidden;clip:rect(0, 0, 0, 0)}.ontario-show-on-focus:active,.ontario-show-on-focus:focus{position:static;width:auto;height:auto;overflow:visible;clip:auto}.ontario-show-for-landscape,.ontario-hide-for-portrait{display:block !important}@media screen and (orientation: landscape){.ontario-show-for-landscape,.ontario-hide-for-portrait{display:block !important}}@media screen and (orientation: portrait){.ontario-show-for-landscape,.ontario-hide-for-portrait{display:none !important}}.ontario-hide-for-landscape,.ontario-show-for-portrait{display:none !important}@media screen and (orientation: landscape){.ontario-hide-for-landscape,.ontario-show-for-portrait{display:none !important}}@media screen and (orientation: portrait){.ontario-hide-for-landscape,.ontario-show-for-portrait{display:block !important}}.ontario-search__container{max-width:34rem;margin-bottom:2.5rem}.ontario-search__input-container{position:relative}.ontario-search__input.ontario-input{border:2px solid #1a1a1a;margin-bottom:0;height:3rem;padding-left:0.75rem;padding-right:8.5rem;width:100%}.ontario-search__input.ontario-input:invalid+input[type=reset]{display:none}input[type=reset].ontario-search__reset{position:absolute;display:flex;align-items:center;top:0.75rem;right:6rem;height:1.5rem;width:1.5rem;color:#1a1a1a;margin:0;padding:0.25rem;background-size:1.5rem;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgZmlsbD0ibm9uZSI+PHBhdGggZD0iTTE5IDYuNEwxNy42IDUgMTIgMTAuNiA2LjQgNSA1IDYuNGw1LjYgNS42TDUgMTcuNiA2LjQgMTlsNS42LTUuNiA1LjYgNS42IDEuNC0xLjQtNS42LTUuNkwxOSA2LjR6IiBmaWxsPSIjMDAwIi8+PC9zdmc+);background-position:center center;background-repeat:no-repeat;background-color:transparent;outline:none;border:none;cursor:pointer}input[type=reset].ontario-search__reset:focus{box-shadow:inset 0 0 0 4px #009ADB}@media screen and (max-width: 40em){input[type=reset].ontario-search__reset{right:5.5rem}}.ontario-search__submit{border:0;border-radius:0 3px 3px 0;background-color:#0066CC;color:#1a1a1a;display:flex;justify-content:center;align-items:center;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-weight:600;font-size:1.125rem;width:5rem;line-height:1.56;position:absolute;right:0;bottom:0;top:0;cursor:pointer}.ontario-search__submit:hover{background-color:#00478F;color:#FFFFFF}.ontario-search__submit:focus{outline:none;box-shadow:0 0 0 4px #009ADB;background-color:#00478F;color:#FFFFFF}.ontario-search__submit:active{background-color:#002142;color:#FFFFFF}.ontario-search__submit svg{fill:#FFFFFF;margin-right:0;margin-bottom:0;width:2rem;height:2rem;display:inline-block;vertical-align:middle;overflow:hidden}@media screen and (max-width: 40em){.ontario-search__submit{width:3rem}}input[type=search].ontario-search__input::-webkit-search-decoration,input[type=search].ontario-search__input::-webkit-search-cancel-button,input[type=search].ontario-search__input::-webkit-search-results-button,input[type=search].ontario-search__input::-webkit-search-results-decoration{-webkit-appearance:none}';

		class OntarioSearchBox {
			constructor(hostRef) {
				registerInstance(this, hostRef);
				this.searchOnSubmit = createEvent(this, 'searchOnSubmit');
				this.inputOnInput = createEvent(this, 'inputOnInput');
				this.inputOnChange = createEvent(this, 'inputOnChange');
				this.inputOnBlur = createEvent(this, 'inputOnBlur');
				this.inputOnFocus = createEvent(this, 'inputOnFocus');
			}
			get element() {
				return getElement(this);
			}
			internals;
			/**
			 * This Ref is used get a direct reference to the hint text element
			 */
			hintTextRef;
			/**
			 * This Ref is used get a direct reference to the search input element
			 */
			inputFieldRef;
			/**
			 * The language of the component.
			 * This is used for translations. If none is passed, it will default to English.
			 */
			language = 'en';
			/**
			 * The unique identifier of the search-box component. This is optional - if no ID is passed, one will be generated.
			 */
			elementId;
			/**
			 * The value of the search term.
			 * This is optional.
			 */
			value;
			/**
    * The text to display as the input label
    *
    * @example
    * <ontario-search-box
    *   caption='{
                    "captionText": "Search directory",
                    "captionType": "default"
                    }'
                required = "true"
    >
    </ontario-search-box>
    */
			caption;
			/**
			 * This is used to determine whether the dropdown list is required or not.
			 * This prop gets passed to the InputCaption utility to display either an optional or required flag in the label.
			 * If no prop is set, it will default to false (optional).
			 */
			required = false;
			/**
			 * This Function to perform a search operation.
			 * This function will be called when the search submit button is triggered.
			 * The value argument is used for as search term to use for the search operation. This parameter is optional.
			 * The performSearch prop can be set dynamically using JavaScript, allowing you to define custom search functionality when the search form is submitted.
			 *
			 * @example
			 * <ontario-search-box
			 *	  id="ontario-search-box"
			 *	  caption='Search directory'
			 * ></ontario-search-box>
			 *
			 * <script>
			 *	window.addEventListener('load', () => {
			 *		const searchBox = document.getElementById('ontario-search-box');
			 *		searchBox.performSearch = async (value) => {
			 * 			console.log('Performing search with value:', value);
			 *		};
			 *	});
			 * </script>
			 */
			performSearch;
			/**
			 * Used to include the ontario-hint-text component for the search-box.
			 * This is optional.
			 */
			hintText;
			/**
			 * Used to add a custom function to the input onInput event.
			 */
			customOnInput;
			/**
			 * Used to add a custom function to the input onChange event.
			 */
			customOnChange;
			/**
			 * Used to add a custom function to the input onBlur event.
			 */
			customOnBlur;
			/**
			 * Used to add a custom function to the input onFocus event.
			 */
			customOnFocus;
			/**
			 * Emitted when the search is submitted.
			 * Below is an example on how to hook into the event to get the event details.
			 *
			 * @example
			 *	<script>
			 *		document.getElementById('ontario-search-box').addEventListener('searchOnSubmit', (event) => {
			 *	 		const searchValue = event.detail;
			 *			console.log('Search submitted with value:', searchValue);
			 *	  };
			 * 	</script>
			 */
			searchOnSubmit;
			/**
			 * Emitted when a input occurs when an input has been changed.
			 */
			inputOnInput;
			/**
			 * Emitted when a keyboard input or mouse event occurs when an input has been changed.
			 */
			inputOnChange;
			/**
			 * Emitted when a keyboard input event occurs when an input has lost focus.
			 */
			inputOnBlur;
			/**
			 * Emitted when a keyboard input event occurs when an input has gained focus.
			 */
			inputOnFocus;
			/**
			 * The hint text options are re-assigned to the internalHintText array.
			 */
			internalHintText;
			/**
			 * Instantiate an InputCaption object for internal logic use
			 */
			captionState;
			/**
			 * Used for the `aria-describedby` value of the dropdown list. This will match with the id of the hint text.
			 */
			hintTextId;
			/**
			 * Watch for changes to the `hintText` prop.
			 *
			 * If a `hintText` prop is passed, the `constructHintTextObject` function will convert it to the correct format, and set the result to the `internalHintText` state.
			 */
			parseHintText() {
				if (this.hintText) {
					const hintTextObject = constructHintTextObject(this.hintText);
					this.internalHintText = hintTextObject;
				}
			}
			/**
			 * Watch for changes to the `caption` prop.
			 *
			 * The caption will be run through the InputCaption constructor to convert it to the correct format, and set the result to the `captionState` state.
			 * @param newValue: Caption | string
			 */
			updateCaptionState(newValue) {
				this.captionState = new InputCaption(
					this.element.tagName,
					newValue,
					translations,
					this.language,
					false,
					this.required,
				);
			}
			/**
			 * Watch for changes to the `language` prop to render either the English or French translations
			 */
			updateLanguage() {
				this.updateCaptionState(this.caption);
			}
			/**
			 * If a `hintText` prop is passed, the id generated from it will be set to the internal `hintTextId` state to match with the select `aria-describedBy` attribute.
			 */
			async componentDidLoad() {
				this.hintTextId = await this.hintTextRef?.getHintTextId();
			}
			componentWillLoad() {
				this.elementId = this.elementId;
				this.parseHintText();
				this.updateCaptionState(this.caption);
			}
			/**
			 * Function to handle input events and the information pertaining to the input to emit.
			 */
			handleEvent(event, eventType) {
				const input = event.target;
				// Update the component value to match the value of the input element.
				this.value = input?.value;
				this.internals?.setFormValue?.(this.value ?? '');
				handleInputEvent(
					event,
					eventType,
					input,
					this.inputOnChange,
					this.inputOnFocus,
					this.inputOnBlur,
					this.inputOnInput,
					'input',
					this.customOnChange,
					this.customOnFocus,
					this.customOnBlur,
					this.customOnInput,
					this.element,
				);
			}
			/**
			 * handleSearch function is called when the search submit button is clicked
			 */
			async handleSearch(event) {
				event.preventDefault();
				this.searchOnSubmit.emit(this.value);
				this.performSearch && (await this.performSearch(this.value));
			}
			getId() {
				return this.elementId ?? '';
			}
			getValue() {
				return this.value ?? '';
			}
			/**
			 *This function ensures that the focus returns to the search input field when the reset button is clicked.
			 */
			setFocus(inputRef) {
				if (inputRef) {
					inputRef.focus();
				}
			}
			/**
			 * when the reset button is clicked this function gets called
			 */
			handleFocus = () => {
				this.setFocus(this.inputFieldRef);
			};
			render() {
				const searchInputFieldId = 'ontario-search-input-field';
				return hAsync(
					'form',
					{
						key: '6982aff0714c199b80b49ef079a71bef8e1ac08e',
						name: 'searchForm',
						id: 'ontario-search-form-container',
						class:
							'ontario-search__container ontario-columns ontario-small-10 ontario-medium-offset-3 ontario-medium-6 ontario-large-offset-0 ontario-large-6',
						novalidate: true,
					},
					this.captionState.getCaption(searchInputFieldId, false, true) /* Note the _required_ text is disabled */,
					this.internalHintText &&
						hAsync('ontario-hint-text', {
							key: '4389f0cc8ca2aa8874cc2a049414ac576f1dd86b',
							hint: this.internalHintText.hint,
							hintContentType: this.internalHintText.hintContentType,
							ref: (el) => (this.hintTextRef = el),
						}),
					hAsync(
						'div',
						{ key: '2de3e979aaba0564b23684a0ba5baf21ccad998a', class: 'ontario-search__input-container' },
						hAsync(Input$1, {
							'key': 'f17f0ea83dc6095b5994453e034489260516bc73',
							'aria-describedBy': this.hintTextId,
							'type': 'search',
							'name': 'search',
							'id': searchInputFieldId,
							'autoComplete': 'off',
							'aria-autocomplete': 'none',
							'className': 'ontario-search__input ontario-input',
							'required': true,
							'ref': (el) => (this.inputFieldRef = el),
							'onInput': (e) => this.handleEvent(e, EventType.Input),
							'onChange': (e) => this.handleEvent(e, EventType.Change),
							'onBlur': (e) => this.handleEvent(e, EventType.Blur),
							'onFocus': (e) => this.handleEvent(e, EventType.Focus),
							'value': this.getValue(),
						}),
						hAsync(Input$1, {
							key: '033259e95d4b1e501bb27e546ebedfac84104578',
							className: 'ontario-search__reset',
							id: 'ontario-search-reset',
							type: 'reset',
							value: '',
							onClick: () => this.handleFocus(),
						}),
						hAsync(
							'button',
							{
								key: 'fa62c508bf4214935dfe8fa2c57ea60ee789b889',
								class: 'ontario-search__submit',
								type: 'submit',
								id: 'ontario-search-box__submit',
								onClick: (e) => this.handleSearch(e),
							},
							hAsync('span', { key: '7d3018072bf34aeb88c9fe4b2490ba0b7407503e', innerHTML: OntarioIconSearch$1 }),
						),
					),
				);
			}
			static get watchers() {
				return {
					hintText: ['parseHintText'],
					caption: ['updateCaptionState'],
					language: ['updateLanguage'],
				};
			}
			static get style() {
				return ontarioSearchBoxCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-search-box',
					$members$: {
						language: [1025],
						elementId: [1025, 'element-id'],
						value: [1025],
						caption: [1],
						required: [4],
						performSearch: [16, 'perform-search'],
						hintText: [1, 'hint-text'],
						customOnInput: [16, 'custom-on-input'],
						customOnChange: [16, 'custom-on-change'],
						customOnBlur: [16, 'custom-on-blur'],
						customOnFocus: [16, 'custom-on-focus'],
						internalHintText: [32],
						captionState: [32],
						hintTextId: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioStepIndicatorCss =
			'@charset "UTF-8";h6,.ontario-h6,h5,.ontario-h5,h4,.ontario-h4,h3,.ontario-h3,h2,.ontario-h2,h1,.ontario-h1{font-style:normal;font-weight:700;text-rendering:optimizeLegibility;margin-bottom:1rem;font-feature-settings:normal;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif}h1,.ontario-h1{font-size:2rem;letter-spacing:0.04rem;line-height:1.29;margin:2.5rem 0 1.5rem 0;max-width:70rem}@media screen and (min-width: 40em){h1,.ontario-h1{font-size:2.5rem;letter-spacing:0.04rem;line-height:1.2}}h2,.ontario-h2{font-size:1.6875rem;letter-spacing:0.03rem;line-height:1.37;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h2,.ontario-h2{font-size:2.0625rem;letter-spacing:0.02rem;line-height:1.33}}h3,.ontario-h3{font-size:1.4375rem;letter-spacing:0.02rem;line-height:1.39;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h3,.ontario-h3{font-size:1.75rem;letter-spacing:0.02rem;line-height:1.43}}h4,.ontario-h4{font-size:1.25rem;letter-spacing:0.03rem;line-height:1.5;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h4,.ontario-h4{font-size:1.5rem;letter-spacing:0.0313rem;line-height:1.5}}h5,.ontario-h5{font-size:1.125rem;letter-spacing:0.03rem;line-height:1.56;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h5,.ontario-h5{font-size:1.1875rem;letter-spacing:0.025rem;line-height:1.5}}h6,.ontario-h6{font-size:1rem;line-height:1.56;letter-spacing:0.03rem;max-width:48rem;margin:0 0 0.75rem 0}@media screen and (min-width: 40em){h6,.ontario-h6{font-size:1rem;letter-spacing:0.025rem;line-height:1.5}}.ontario-lead-statement{font-size:1.25rem;line-height:1.6;max-width:70rem}@media screen and (min-width: 40em){.ontario-lead-statement{font-size:1.375rem}}html{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem}body{font-size:1rem;line-height:1.6;background-color:#FFFFFF;color:#1a1a1a;margin:0}p{font-size:inherit;margin-bottom:1.25rem;text-rendering:optimizeLegibility;margin:0 0 1.5rem 0}cite{font-style:italic;line-height:inherit}strong{font-weight:700;line-height:inherit}*,*::before,*::after{box-sizing:inherit}main p,main p:not(.ontario-lead-statement),main dd,main li{max-width:48rem}hr{border:0;padding:0;margin:2.5rem 0;border-bottom:4px solid #cccccc}hr.ontario-hr--dark{border-bottom:4px solid #1a1a1a}a{color:#0066CC;text-decoration:underline}a:visited{color:#551A8B}a:hover{color:#00478F}a:active{color:#002142}a:focus{-moz-box-shadow:0 0 0 4px #009ADB;-webkit-box-shadow:0 0 0 4px #009ADB;box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:all 0.1s ease-in-out}p{margin:0 0 1.5rem 0}p+h1,p+h2,p+h3,p+h4,p+h5,p+h6,ul+h1,ul+h2,ul+h3,ul+h4,ul+h5,ul+h6,ol+h1,ol+h2,ol+h3,ol+h4,ol+h5,ol+h6,h1+h2,h2+h3,h3+h4,h4+h5,h5+h6{margin-top:2rem}p code,td code,li code{line-height:2.25rem}input[type=text],input[type=number],input[type=email],input[type=date],input[type=color],input[type=search],input[type=tel],textarea{background-origin:initial;height:auto;-webkit-appearance:none;-moz-appearance:none}input[type=checkbox]+label,input[type=radio]+label{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400;margin-left:0;margin-right:0}fieldset{border:0;margin:0;padding:0;page-break-inside:avoid}legend,label{display:block;margin:0}select{background-origin:initial;height:auto;-webkit-appearance:none;-moz-appearance:none}ul,ol{padding:0}ul{margin-left:2rem}ul li{padding:0 0 0.75rem 0}ol{margin-left:1.75rem}ol li{padding:0 0 0.75rem 0.25rem}ul li:last-child,ol li:last-child{padding-bottom:0}ul[class*=columns-] li:last-child,ol[class*=columns-] li:last-child{padding-bottom:0.75rem}ul ul,ol ul{margin:0.5rem 0 0.5rem 2rem}ul ol,ol ol{margin:0.5rem 0 0.5rem 1.75rem}p+ul,p+ol{margin-top:-0.75rem}@media screen and (min-width: 40em){ul{margin:0.5rem 0 1.5rem 3rem}ol{margin:0.5rem 0 1.5rem 2.75rem}ul ul,ol ul{margin:0.5rem 0 0.5rem 3rem}ul ol,ol ol{margin:0.5rem 0 0.5rem 2.75rem}}.ontario-button:focus,.ontario-button:active{box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:box-shadow 0.1s ease-in-out}.ontario-button{border:none;border-radius:4px;box-sizing:border-box;box-shadow:none;display:inline-block;font-size:1.125rem;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-weight:600;line-height:1.5555555556;margin:0 1.75rem 1.5rem 0;min-width:10rem;padding:0.625rem 1.5rem;text-align:center;text-decoration:none;cursor:pointer}@media screen and (max-width: 40em){.ontario-button{margin-right:0;display:block;width:100%}}.ontario-button .ontario-icon{margin-right:4px}.ontario-button--primary{background-color:#0066CC;color:#FFFFFF}.ontario-button--primary:hover{background-color:#00478F;color:#FFFFFF}.ontario-button--primary:focus{background-color:#00478F;color:#FFFFFF;transition:background-color 0.2s ease-out, box-shadow 0.1s ease-in-out}.ontario-button--primary:active{background-color:#002142;color:#FFFFFF;transition:background-color 0s, box-shadow 0.1s ease-in-out}.ontario-button--primary:visited{color:#FFFFFF}.ontario-button--secondary{background-color:#FFFFFF;border:2px solid #0066CC;color:#0066CC;padding-top:0.5rem;padding-bottom:0.5rem}.ontario-button--secondary:hover{background-color:#e0f0ff;border-color:#00478F;color:#00478F}.ontario-button--secondary:focus{background-color:#e0f0ff;border-color:#00478F;color:#00478F;transition:background-color 0.2s ease-out, box-shadow 0.1s ease-in-out}.ontario-button--secondary:active{background-color:#c2e0ff;border-color:#002142;color:#002142;transition:background-color 0s, box-shadow 0.1s ease-in-out}.ontario-button--secondary:visited{color:#0066CC}.ontario-button--tertiary{background-color:transparent;color:#0066CC;text-decoration:underline}.ontario-button--tertiary:hover{background-color:#e8e8e8;color:#00478F;text-decoration:underline}.ontario-button--tertiary:focus{background-color:#e8e8e8;color:#00478F;text-decoration:underline;transition:background-color 0.2s ease-out, box-shadow 0.1s ease-in-out}.ontario-button--tertiary:active{background-color:#d1d1d1;color:#002142;text-decoration:underline;transition:background-color 0s, box-shadow 0.1s ease-in-out}.ontario-button--tertiary:visited{color:#0066CC}.ontario-button--internalThemeDark{background-color:#1a1a1a;border:2px solid #FFFFFF;color:#FFFFFF}.ontario-button--internalThemeDark:hover{background-color:#4d4d4d}.ontario-button--internalThemeDark:focus{background-color:#4d4d4d;transition:background-color 0.2s ease-out, box-shadow 0.1s ease-in-out}.ontario-button--internalThemeDark:active{background-color:#4d4d4d;transition:background-color 0s, box-shadow 0.1s ease-in-out}.ontario-button--internalThemeDark:visited{color:#0066CC}.ontario-step-indicator{margin-bottom:2.5rem}.ontario-step-indicator .ontario-step-indicator--with-back-button--false,.ontario-step-indicator .ontario-step-indicator--with-back-button--true,.ontario-step-indicator .ontario-step-indicator--without-back-button,.ontario-step-indicator .ontario-step-indicator--with-back-button{display:flex;align-items:center;justify-content:space-between}.ontario-step-indicator .ontario-step-indicator--with-back-button--false,.ontario-step-indicator .ontario-step-indicator--without-back-button{justify-content:flex-end}.ontario-step-indicator .ontario-h4{margin:1.25rem 0}@media screen and (max-width: 40em){.ontario-step-indicator .ontario-h4{margin:1rem 0;text-align:right}}.ontario-step-indicator .ontario-button.ontario-button--tertiary{display:flex;align-items:center;margin:0.75rem 0;padding-left:0.5rem;padding-right:1rem;min-width:3rem}@media screen and (max-width: 40em){.ontario-step-indicator .ontario-button.ontario-button--tertiary{width:unset}}.ontario-step-indicator .ontario-button.ontario-button--tertiary .ontario-icon{margin:0 0.375rem 0 0;padding:0;min-width:24px;min-height:24px}.ontario-step-indicator hr{padding:0;margin:0}';

		class OntarioStepIndicator {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			get host() {
				return getElement(this);
			}
			/**
			 * A boolean value to determine whether or not the back button is displayed for the step indicator.
			 *
			 * This is optional. If no prop is passed, it will default to `false`.
			 */
			showBackButton = false;
			/**
			 * URL for the back element to set a path for where the link will lead.
			 *
			 * If a URL is passed in, the back element will display as an anchor tag.
			 * The back element will require either the backButtonURL prop or the customOnClick prop to be passed in order for the back element to display.
			 */
			backButtonUrl;
			/**
			 * A number value to indicate which step the user is currently on.
			 */
			currentStep;
			/**
			 * A number value to indicate to the user the total number of steps the form has.
			 */
			numberOfSteps;
			/**
			 * A number value to indicate to the user the percentage of the form that has been completed.
			 */
			percentageComplete;
			/**
			 * Used to add a custom function to the back button onClick event.
			 *
			 * If this function is passed in, the back element will display as a button.
			 * The back element will require either the backButtonURL prop or the customOnClick prop to be passed in order for the back element to display.
			 */
			customOnClick;
			/**
			 * The language of the component.
			 * This is used for translations, and is by default set through event listeners checking for a language property from the header. If none are passed, it will default to English.
			 */
			language;
			/**
			 * This listens for the `setAppLanguage` event sent from the test language toggler when it is is connected to the DOM. It is used for the initial language when the input component loads.
			 */
			handleSetAppLanguage(event) {
				if (!this.language) {
					this.language = validateLanguage(event);
				}
			}
			handleHeaderLanguageToggled(event) {
				this.language = validateLanguage(event);
			}
			translations = translations;
			handleCustomOnClick = (e) => {
				this.customOnClick && this.customOnClick(e);
			};
			componentWillLoad() {
				this.language = validateLanguage(this.language);
			}
			render() {
				return hAsync(
					'div',
					{ key: '99b28d54588042901db733dc07515778730104e0', class: 'ontario-step-indicator' },
					hAsync(
						'div',
						{ key: '4d7d0de7f7573d237eb1efdb189d47aa8edb0c97', class: 'ontario-row' },
						hAsync(
							'div',
							{ key: '59beefde92218fac06ea12335937a7eaa05f4a05', class: 'ontario-columns ontario-small-12' },
							hAsync(
								'div',
								{
									key: '6f6b3b31ad381ec965e24d2d0cb71fcb87a55e8e',
									class: `ontario-step-indicator--with-back-button--${this.showBackButton}`,
								},
								this.showBackButton === true &&
									!this.backButtonUrl &&
									hAsync(
										'button',
										{
											key: 'f81596ff5ef6e6c53921be03dd9d2156b6bebbfd',
											class: 'ontario-button ontario-button--tertiary',
											onClick: (e) => this.handleCustomOnClick(e),
										},
										hAsync('ontario-icon-chevron-left', {
											key: 'a7f93e91eb046d3927abd6c10db07302e1aa09a8',
											colour: 'blue',
										}),
										this.translations.stepIndicator.back[`${this.language}`],
									),
								this.showBackButton === true &&
									this.backButtonUrl &&
									hAsync(
										'a',
										{
											key: 'dcb41f75d9074ac2a2e423f75f5eafd1a628a221',
											class: 'ontario-button ontario-button--tertiary',
											href: this.backButtonUrl,
										},
										hAsync('ontario-icon-chevron-left', {
											key: '6d396d47d555552128c442d96e0f90ed8a1d2290',
											colour: 'blue',
										}),
										this.translations.stepIndicator.back[`${this.language}`],
									),
								this.percentageComplete
									? hAsync(
											'span',
											{ class: 'ontario-h4' },
											this.percentageComplete,
											this.language === 'en' ? '%' : hAsync('span', null, '\u00A0%'),
											' ',
											this.translations.stepIndicator.complete[`${this.language}`],
										)
									: hAsync(
											'span',
											{ class: 'ontario-h4' },
											this.translations.stepIndicator.step[`${this.language}`],
											'\u00A0',
											this.currentStep,
											' ',
											this.translations.stepIndicator.of[`${this.language}`],
											'\u00A0',
											this.numberOfSteps,
										),
							),
							hAsync('hr', { key: '50951805695a30af40d20f7500f8dc8ede620f71' }),
						),
					),
				);
			}
			static get style() {
				return ontarioStepIndicatorCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-step-indicator',
					$members$: {
						showBackButton: [4, 'show-back-button'],
						backButtonUrl: [1, 'back-button-url'],
						currentStep: [2, 'current-step'],
						numberOfSteps: [2, 'number-of-steps'],
						percentageComplete: [2, 'percentage-complete'],
						customOnClick: [16, 'custom-on-click'],
						language: [1025],
						translations: [32],
					},
					$listeners$: [
						[8, 'setAppLanguage', 'handleSetAppLanguage'],
						[8, 'headerLanguageToggled', 'handleHeaderLanguageToggled'],
					],
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const minimumGridColumns = 1;
		const maximumGridColumns = 12;

		function validateTableColumns(columns) {
			for (const column of columns) {
				if (!column.title || !column.key) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addRegularText(' The required keys for ')
						.addMonospaceText('title')
						.addRegularText(' and/or ')
						.addMonospaceText('key')
						.addRegularText(' in the ')
						.addMonospaceText('<ontario-table> tableColumns')
						.addRegularText(' options were not provided. ')
						.printMessage(ConsoleType.Error);
					return false; // Required keys are missing
				}
				if (column.type && column.type !== 'string' && column.type !== 'numeric') {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addRegularText(' The ')
						.addMonospaceText('type')
						.addRegularText(' key in the ')
						.addMonospaceText('<ontario-table> tableColumns')
						.addRegularText(' options is not a valid type. A default type of `string` will be applied.')
						.printMessage();
					return false; // Invalid type for 'type' key
				}
				if (column.colSpan && !(column.colSpan >= minimumGridColumns && column.colSpan <= maximumGridColumns)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addRegularText(' The ')
						.addMonospaceText('colSpan')
						.addRegularText(' in the ')
						.addMonospaceText('<ontario-table> tableColumns')
						.addRegularText(' options is not a valid type. The default colSpan value will be applied.')
						.printMessage();
					return false; // Invalid value for 'colSpan' key
				}
			}
			return true; // All validations passed
		}
		function validateTableRowOptions(options) {
			for (const option of options) {
				if (!option.data || Object.keys(option.data).length === 0) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addRegularText(' The required key for ')
						.addMonospaceText('data')
						.addRegularText(' in the ')
						.addMonospaceText('<ontario-table> tableData')
						.addRegularText(' options was not provided. ')
						.printMessage(ConsoleType.Error);
					return false; // Required key 'data' is missing
				}
			}
			return true; // All validations passed
		}

		const ontarioTableCss =
			'.ontario-table-container{position:relative;margin:0.5rem 0 2.5rem}.ontario-table-div{background:linear-gradient(to right, #FFFFFF 30%, rgba(255, 255, 255, 0)), linear-gradient(to right, rgba(255, 255, 255, 0), #FFFFFF 70%) 0 100%, linear-gradient(to right, rgba(0, 0, 0, 0.2) 0%, rgba(252, 0, 0, 0) 100.01%), linear-gradient(to left, rgba(0, 0, 0, 0.2) 0%, rgba(252, 0, 0, 0) 100.01%);background-repeat:no-repeat;background-size:2.5rem 100%, 2.5rem 100%, 0.875rem 100%, 0.875rem 100%;background-position:0 0, 100%, 0 0, 100%;background-attachment:local, local, scroll, scroll;overflow-x:auto}@media screen and (max-width: 40em){.ontario-table-div{overflow-x:scroll}}.ontario-table-scroll--wrapper{height:20px;overflow-x:auto;overflow-y:hidden;display:block}.ontario-table-container table{border-collapse:collapse;display:table;font-size:1.0625rem;font-weight:400;line-height:1.625rem}.ontario-table-container table.ontario-table--full-container-width{display:table;width:100%}.ontario-table-container table.ontario-table--zebra-stripes-enabled tbody tr:nth-child(even){background-color:rgba(0, 0, 0, 0.0509803922)}.ontario-table-container table:not(.ontario-table--no-zebra-stripes) tbody tr:first-child:nth-last-child(n+6):nth-child(even),.ontario-table-container table:not(.ontario-table--no-zebra-stripes) tbody tr:first-child:nth-last-child(n+6)~tr:nth-child(even){background-color:rgba(0, 0, 0, 0.0509803922)}@media screen and (max-width: 40em){.ontario-table-container table{font-size:1rem}}.ontario-table-container caption{background-color:rgba(0, 0, 0, 0.1019607843);display:table-caption;font-size:1.375rem;font-weight:700;line-height:2.1875rem;padding:1.125rem 1rem 1.125rem 1.5rem;text-align:left}@media screen and (max-width: 40em){.ontario-table-container caption{font-size:1.25rem;line-height:1.875rem;padding-left:1rem}}.ontario-table-container table thead{border:solid;border-width:0.1875rem 0;border-color:#1a1a1a;vertical-align:text-top}.ontario-table-container table thead th{font-size:1.125rem;line-height:1.5;margin:0;padding:1.75rem 1rem 1.75rem 1.5rem;text-align:left;text-size-adjust:none;-webkit-text-size-adjust:none}@media screen and (max-width: 40em){.ontario-table-container table thead th{font-size:1rem;line-height:1.3125rem;padding:1.5rem 0.5rem 1.5rem 1rem}}.ontario-table-container table thead th.ontario-table-cell--numeric{padding:1.75rem 1.5rem 1.75rem 1rem;text-align:right}@media screen and (max-width: 40em){.ontario-table-container table thead th.ontario-table-cell--numeric{padding:1.5rem 1rem 1.5rem 0.5rem}}.ontario-table-container table tbody{font-size:1rem;vertical-align:text-top}.ontario-table-container table tbody tr{border:solid;border-width:0.0625rem 0;border-color:rgba(0, 0, 0, 0.3019607843)}.ontario-table-container table tbody tr:last-child{border-width:0.1875rem 0;border-top-width:0;border-color:#1a1a1a}.ontario-table-container table tbody tr.ontario-table-row--highlight{background-color:rgba(225, 145, 0, 0.2352941176) !important}.ontario-table-container table tbody tr.ontario-table-row--highlight th{padding-left:1.5rem;display:flex;position:relative}.ontario-table-container table tbody tr.ontario-table-row--highlight th img.ontario-table--highlight-indicator{width:0.5rem;position:absolute;top:1.5rem;left:0}.ontario-table-container table tbody tr.ontario-table-row--subtotal{background-color:rgba(0, 123, 158, 0.1137254902) !important}.ontario-table-container tbody th,.ontario-table-container tfoot th,.ontario-table-container table td{padding:1.1875rem 1rem 1.1875rem 1.5rem;text-align:left;letter-spacing:0.025rem}.ontario-table-container tbody th,.ontario-table-container tfoot th{font-weight:700}@media screen and (max-width: 40em){.ontario-table-container tbody th,.ontario-table-container tfoot th{font-size:1rem;line-height:1.625rem;padding-right:0.5rem;padding-left:1rem}}.ontario-table-container table td img{vertical-align:top}@media screen and (max-width: 40em){.ontario-table-container table td img{max-width:none}}.ontario-table-container table td.ontario-table-cell--numeric{font-family:"Courier Prime", Courier, "Courier New", monospace;font-size:1.0625rem;padding:1.1875rem 1.5rem 1.1875rem 1rem;text-align:right}.ontario-table-container table td.ontario-table-cell--numeric strong{font-family:"Courier Prime", Courier, "Courier New", monospace}.ontario-table-container tbody tr.ontario-table-row--subtotal,.ontario-table-container tfoot tr{border:solid;border-width:0.1875rem 0;font-size:1rem;border-color:#1a1a1a}.ontario-table-container tbody tr.ontario-table-row--subtotal th,.ontario-table-container tfoot tr th{padding:1.4375rem 1rem 1.4375rem 1.5rem}.ontario-table-container tbody tr.ontario-table-row--subtotal td,.ontario-table-container tfoot tr td{font-weight:700;padding:1.4375rem 1rem 1.4375rem 1.5rem}.ontario-table-container tfoot{vertical-align:text-top}.ontario-table-container tfoot tr{background-color:rgba(0, 119, 160, 0.337254902) !important}.ontario-table-header--column-span-1{min-width:8.33333vw}.ontario-table-header--column-span-2{min-width:16.66666vw}.ontario-table-header--column-span-3{min-width:25vw}.ontario-table-header--column-span-4{min-width:33.33333vw}.ontario-table-header--column-span-5{min-width:41.66666vw}.ontario-table-header--column-span-6{min-width:50vw}.ontario-table-header--column-span-7{min-width:58.33333vw}.ontario-table-header--column-span-8{min-width:66.66666vw}.ontario-table-header--column-span-9{min-width:75vw}.ontario-table-header--column-span-10{min-width:83.33333vw}.ontario-table-header--column-span-11{min-width:91.66666vw}.ontario-table-header--column-span-12{min-width:100vw}.ontario-table-container .ontario-table--condensed td{padding:0.75rem 1rem 0.75rem 1.5rem;text-align:left}.ontario-table-container .ontario-table--condensed td.ontario-table-cell--numeric{padding:0.75rem 1.5rem 0.75rem 1rem;font-size:1.0625rem;text-align:right}.ontario-table-container .ontario-table--condensed tbody th,.ontario-table-container .ontario-table--condensed tfoot th{padding:0.75rem 1rem 0.75rem 1.5rem}.ontario-table-container .ontario-table--condensed tr.ontario-table-row--highlight th img.ontario-table--highlight-indicator{top:1.0625rem}.ontario-table-container .ontario-table--condensed tr.ontario-table-row--subtotal th,.ontario-table-container .ontario-table--condensed tr.ontario-table-row--subtotal td,.ontario-table-container .ontario-table--condensed tfoot tr th,.ontario-table-container .ontario-table--condensed tfoot tr td{padding:1rem 1rem 1rem 1.5rem}.ontario-table-container .ontario-table--condensed tr.ontario-table-row--subtotal td.ontario-table-cell--numeric,.ontario-table-container .ontario-table--condensed tfoot tr td.ontario-table-cell--numeric{text-align:right;padding:1rem 1.5rem 1rem 1rem}@media screen and (max-width: 40em){.ontario-table-container .ontario-table--condensed td{padding:0.75rem 0.5rem 0.75rem 1rem;font-size:1rem}.ontario-table-container .ontario-table--condensed td.ontario-table-cell--numeric{padding:0.75rem 1rem 0.75rem 0.5rem}.ontario-table-container .ontario-table--condensed tbody th{padding:0.75rem 0.5rem 0.75rem 1rem}.ontario-table-container .ontario-table--condensed tr.ontario-table-row--subtotal th,.ontario-table-container .ontario-table--condensed tr.ontario-table-row--subtotal td,.ontario-table-container .ontario-table--condensed tfoot tr th,.ontario-table-container .ontario-table--condensed tfoot tr td{padding:1rem 0.5rem 1rem 1rem}.ontario-table-container .ontario-table--condensed tr.ontario-table-row--subtotal td.ontario-table-cell--numeric,.ontario-table-container .ontario-table--condensed tfoot tr td.ontario-table-cell--numeric{text-align:right;padding:1rem 1rem 1rem 0.5rem}}';

		class OntarioTable {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			get element() {
				return getElement(this);
			}
			tableScrollWrapper;
			tableScrollDiv;
			table;
			/**
			 * Specifies the caption (or title) of the table.
			 *
			 * This is optional.
			 */
			caption;
			/**
			 * Used to define the columns of the table.
			 *
			 * @example;
			 * <ontario-table
			 *    table-columns='[
			 *      { "title": "Type of service", "key": "service" },
			 *      { "title": "Processing and delivery", "key": "processing" },
			 *      { "title": "Cost", "key": "cost", "type": "numeric" }
			 *    ]'
			 * >
			 * </ontario-table>
			 */
			tableColumns;
			/**
			 * Used to define the table body data. Note that the keys passed to the `data` object in the tableData should match the keys of the columns defined in the tableColumns prop.
			 *
			 * @example
			 * <ontario-table
			 *  table-data='[
			 *    {
			 *      "data": {
			 *        "service": "Regular service (online)",
			 *        "processing": "15 business days plus delivery by Canada Post",
			 *        "cost": "$15"
			 *      }
			 *    },
			 *    {
			 *      "data": {
			 *        "service": "Premium service (online)",
			 *        "cost": "$45",
			 *        "processing": "5 business days including delivery by courier"
			 *      }
			 *    }
			 *  ]'
			 * >
			 * </ontario-table>
			 */
			tableData;
			/**
			 * Indicates whether or not the table data should have alternate row zebra striping.
			 *
			 * This is optional. By default, zebra striping will be added when the table rows extend 5 rows. If zebra striping is needed to table rows less than 5 rows, the prop should be set to enabled. If no zebra stripes are needed, it should be set to disabled.
			 *
			 * The default will be set to auto.
			 */
			zebraStripes = 'auto';
			/**
			 * Used to specify whether or not table data in cells should have reduced top and bottom padding. This is useful for pages with multiple data-heavy tables such as a budget or financial data.
			 *
			 * This is optional. By default it will be set to false.
			 */
			condensed = false;
			/**
			 * Used to specify whether or not the table should extend the full width of its container.
			 *
			 * This is optional. By default, it will be set to false
			 */
			fullWidth = false;
			tableColumnsState;
			tableDataState;
			tableFooterState;
			processTableColumns() {
				this.tableColumns && this.parseOptions(this.tableColumns);
				validateTableColumns(this.tableColumnsState);
			}
			processTableData() {
				this.tableData && this.parseOptions(this.tableData);
				validateTableRowOptions(this.tableDataState);
			}
			// Parse the tableColumn & tableData options if they are strings
			// Transforms the data and stores it in respective state objects
			parseOptions(options) {
				const isString = typeof options === 'string';
				if (!options) {
					return;
				}
				try {
					if (options === this.tableColumns) {
						this.tableColumnsState = isString ? JSON.parse(options) : options;
					} else {
						this.tableDataState = isString ? JSON.parse(options) : options;
						this.transformTableData(this.tableDataState);
					}
				} catch (error) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addRegularText(' failed to parse props for ')
						.addMonospaceText('<ontario-table>')
						.addRegularText(' in ')
						.addMonospaceText('parseOptions()')
						.addRegularText(' method \n ')
						.addMonospaceText(error.stack)
						.printMessage(ConsoleType.Error);
				}
			}
			transformTableData = (tableData) => {
				// get column keys
				const columns = extractValuesByKey(this.tableColumnsState, 'key').filter((column) => column !== undefined);
				// organize table data data object according to the order of the column keys
				const organizedTableData = organizeObjectKeys(tableData, columns);
				// remove the footer table data into it's own state so that it can be rendered in a `tfoot` element
				const [updatedTableData, tableFooterData] = removeObjectsBySpecificKey(organizedTableData, 'footer', true);
				this.tableDataState = updatedTableData;
				this.tableFooterState = tableFooterData;
			};
			getZebraStripeClass = () => {
				return this.zebraStripes === 'disabled'
					? `ontario-table--no-zebra-stripes`
					: this.zebraStripes === 'enabled'
						? `ontario-table--zebra-stripes-enabled`
						: ``;
			};
			getTableClasses = () => {
				let tableClass = '';
				if (this.condensed && this.fullWidth) {
					tableClass = `ontario-table--condensed ontario-table--full-container-width`;
				} else if (this.condensed) {
					tableClass = `ontario-table--condensed`;
				} else if (this.fullWidth) {
					tableClass = `ontario-table--full-container-width`;
				}
				const zebraStripesClass = this.getZebraStripeClass();
				if (tableClass) {
					tableClass = `${tableClass} ${zebraStripesClass}`;
				} else {
					tableClass = zebraStripesClass;
				}
				return tableClass;
			};
			getColumnClasses = (columnData) => {
				if (columnData.type === 'numeric' && columnData.colSpan) {
					return `ontario-table-cell--numeric ontario-table-header--column-span-${columnData.colSpan}`;
				} else if (columnData.type === 'numeric') {
					return `ontario-table-cell--numeric`;
				} else if (columnData.colSpan) {
					return `ontario-table-header--column-span-${columnData.colSpan}`;
				}
				return;
			};
			// A function used to generate the table header and table definitions for the table body and table footer sections.
			generateTableDataHTML = (dataType, rowData, columns, rowClass) => {
				return hAsync(
					'tr',
					{ class: dataType === 'tableData' ? rowClass : '' },
					this.tableColumnsState.map((column, index) => {
						const type = column.type;
						const tdClass = type === 'numeric' ? `ontario-table-cell--numeric` : '';
						return index === 0
							? hAsync(
									'th',
									{ scope: 'row', innerHTML: rowData.data[`${columns[0]}`] },
									dataType === 'tableData' &&
										rowData.highlight &&
										hAsync('img', {
											class: 'ontario-table--highlight-indicator',
											src: getAssetPath('./assets/highlight-indicator.svg'),
										}),
								)
							: hAsync('td', { class: tdClass, innerHTML: rowData.data[`${columns[index]}`] });
					}),
				);
			};
			// Helper function to apply the scrollbar styles to the tops of tables
			applyScrollbar(tableElement, scrollerDiv) {
				scrollerDiv.style.visibility = 'visible';
				scrollerDiv.style.height = '20px';
				scrollerDiv.style.width = `${tableElement.scrollWidth}px`;
			}
			// The following logic adds scrollbar functionality to the tops of tables depending on their size.
			componentDidLoad() {
				const tables = this.table;
				const scrollerDivs = this.tableScrollDiv;
				const scrollerWrappers = this.tableScrollWrapper;
				let resizeObserver = new ResizeObserver(() => {
					this.applyScrollbar(tables, scrollerDivs);
				});
				this.applyScrollbar(tables, scrollerDivs);
				resizeObserver.observe(tables);
				tables.addEventListener('scroll', () => {
					this.applyScrollbar(tables, scrollerDivs);
					scrollerWrappers.scrollLeft = tables.scrollLeft;
				});
				scrollerWrappers.addEventListener('scroll', () => {
					this.applyScrollbar(tables, scrollerDivs);
					tables.scrollLeft = scrollerWrappers.scrollLeft;
				});
			}
			componentWillLoad() {
				this.processTableColumns();
				this.processTableData();
			}
			render() {
				const columns = extractValuesByKey(this.tableColumnsState, 'key');
				return hAsync(
					'div',
					{ key: '4f8842108ac7007576fe5ea75ec83de5cfbb2853', class: 'ontario-table-container' },
					hAsync(
						'div',
						{
							key: '69130c9552b854e80d267728f947032222eacbe7',
							class: 'ontario-table-scroll--wrapper',
							ref: (el) => (this.tableScrollWrapper = el),
						},
						hAsync('div', {
							key: 'cbd058d782c1d5a2aa70787af688b1fbd3607ba6',
							class: 'ontario-table-scroll--div',
							ref: (el) => (this.tableScrollDiv = el),
						}),
					),
					hAsync(
						'div',
						{
							key: '743c382ed2826bc49014af4d26283c812faf0199',
							class: 'ontario-table-div',
							ref: (el) => (this.table = el),
						},
						hAsync(
							'table',
							{ key: '6a1f6baed2928d4508aeb3260e750d1b52a189fa', class: this.getTableClasses() },
							this.caption && hAsync('caption', { key: 'aa662bd73b1b2315642e624e31e288ea096f583c' }, this.caption),
							this.tableColumnsState &&
								hAsync(
									'thead',
									{ key: 'c6844d209ce5eb7e5220cec715c1b0d858bd03a4' },
									hAsync(
										'tr',
										{ key: '160fc34659ac78321cd3c9309282c42c4f83819e' },
										this.tableColumnsState.map((columnData) => {
											const columnClass = this.getColumnClasses(columnData);
											return hAsync('th', {
												'scope': 'col',
												'key': columnData.key,
												'data-type': columnData.type,
												'class': columnClass,
												'innerHTML': columnData.title,
											});
										}),
									),
								),
							this.tableDataState &&
								hAsync(
									'tbody',
									{ key: '7774577acb957958aa317917636ee27c52ae10be' },
									this.tableDataState.map((rowData) => {
										const rowClass = rowData.highlight
											? `ontario-table-row--highlight`
											: rowData.subtotal
												? `ontario-table-row--subtotal`
												: undefined;
										return this.generateTableDataHTML('tableData', rowData, columns, rowClass);
									}),
								),
							!!this.tableFooterState.length &&
								hAsync(
									'tfoot',
									{ key: 'a293134380a5f33e008b05c419f371bd0c93308f' },
									this.tableFooterState.map((footerData) => {
										return this.generateTableDataHTML('tableData', footerData, columns, undefined);
									}),
								),
						),
					),
				);
			}
			static get assetsDirs() {
				return ['./assets'];
			}
			static get watchers() {
				return {
					tableColumns: ['processTableColumns'],
					tableData: ['processTableData'],
				};
			}
			static get style() {
				return ontarioTableCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-table',
					$members$: {
						caption: [1],
						tableColumns: [1, 'table-columns'],
						tableData: [1, 'table-data'],
						zebraStripes: [1, 'zebra-stripes'],
						condensed: [4],
						fullWidth: [4, 'full-width'],
						tableColumnsState: [32],
						tableDataState: [32],
						tableFooterState: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		// Define an enum for task statuses
		var TaskStatuses;
		(function (TaskStatuses) {
			TaskStatuses['NotStarted'] = 'notStarted';
			TaskStatuses['InProgress'] = 'inProgress';
			TaskStatuses['Completed'] = 'completed';
			TaskStatuses['CannotStartYet'] = 'cannotStartYet';
			TaskStatuses['Error'] = 'error';
			TaskStatuses['Optional'] = 'optional';
		})(TaskStatuses || (TaskStatuses = {}));
		// Map task statuses to badge colours
		const TaskToBadgeColour = {
			[TaskStatuses.NotStarted]: 'lightTeal',
			[TaskStatuses.InProgress]: 'teal',
			[TaskStatuses.Completed]: 'white',
			[TaskStatuses.CannotStartYet]: 'darkGrey',
			[TaskStatuses.Error]: 'red',
			[TaskStatuses.Optional]: 'grey',
		};

		const ontarioTaskCss =
			'.ontario-task__link:focus .ontario-task__label{box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:box-shadow 0.1s ease-in-out}.ontario-task{border-bottom:0.125rem solid #cccccc;padding:1.1875rem 0;list-style:none}.ontario-task__content{display:flex;justify-content:space-between;align-items:center}@media screen and (max-width: 40em){.ontario-task__content{display:flex;flex-direction:column;align-items:flex-start}}.ontario-task__label{text-align:left;margin:0;font-size:1.1875rem;font-weight:600;display:inline-block}@media screen and (max-width: 40em){.ontario-task__label{margin-bottom:0.5rem}}.ontario-task__label a{text-decoration:none;color:inherit}.ontario-task__label a:hover{text-decoration:underline}.ontario-task__link{display:block;text-decoration:underline;color:#0066CC;font-weight:normal}.ontario-task__hint-text--true{margin-bottom:0.5rem}.ontario-task__link:focus{outline:none;box-shadow:none}.ontario-task__link:focus .ontario-task__label{box-shadow:0 0 0 4px #009ADB inset}.ontario-task:has(.ontario-task__link):hover{background-color:#f2f2f2}.ontario-task--status-completed .ontario-task__link .ontario-task__label,.ontario-task--status-inprogress .ontario-task__link .ontario-task__label,.ontario-task--status-notstarted .ontario-task__link .ontario-task__label,.ontario-task--status-optional .ontario-task__link .ontario-task__label,.ontario-task--status-error .ontario-task__link .ontario-task__label{color:#0066CC;text-decoration:underline}.ontario-task--status-completed .ontario-task__link:visited .ontario-task__label,.ontario-task--status-inprogress .ontario-task__link:visited .ontario-task__label,.ontario-task--status-notstarted .ontario-task__link:visited .ontario-task__label,.ontario-task--status-optional .ontario-task__link:visited .ontario-task__label,.ontario-task--status-error .ontario-task__link:visited .ontario-task__label{color:#551A8B}.ontario-task--status-completed .ontario-task__link:hover .ontario-task__label,.ontario-task--status-inprogress .ontario-task__link:hover .ontario-task__label,.ontario-task--status-notstarted .ontario-task__link:hover .ontario-task__label,.ontario-task--status-optional .ontario-task__link:hover .ontario-task__label,.ontario-task--status-error .ontario-task__link:hover .ontario-task__label{color:#00478F}.ontario-task--status-completed .ontario-task__link:active .ontario-task__label,.ontario-task--status-inprogress .ontario-task__link:active .ontario-task__label,.ontario-task--status-notstarted .ontario-task__link:active .ontario-task__label,.ontario-task--status-optional .ontario-task__link:active .ontario-task__label,.ontario-task--status-error .ontario-task__link:active .ontario-task__label{color:#002142}ontario-hint-text::part(hint-text){margin:0}@media screen and (max-width: 40em){ontario-hint-text::part(hint-text){margin-top:0.5rem}}';

		class OntarioTask {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			get el() {
				return getElement(this);
			}
			// Reference to the ontario-hint-text element for this task.
			hintTextRef;
			/**
			 * Specifies the label of the task.
			 *
			 * This is required to provide the name of the task.
			 */
			label;
			/**
			 * A unique id for the task.
			 *
			 * This is required.
			 */
			taskId;
			/**
			 * Specifies an optional link associated with the task.
			 *
			 * If provided, clicking the task will navigate to this URL.
			 */
			link;
			/**
			 * Disables the task link when set to `true`.
			 *
			 * Default is `false`, meaning the link will be active if provided.
			 */
			deactivateLink = false;
			/**
			 * The language of the component.
			 *
			 * This is used for translations, and is by default set through event listeners checking for a language property from the header. If no language is passed, it will default to English.
			 */
			language;
			/**
			 * Used to include the ontario-hint-text component for the task.
			 *
			 * This is optional.
			 */
			hintText;
			/**
			 * Defines the status of the task, with default set to 'NotStarted'.
			 *
			 * Accepts values from `TaskStatuses` enum: `NotStarted`, `InProgress`, `Completed`.
			 */
			/**
			 * Defines the status of the task, with default set to 'NotStarted'.
			 *
			 * Accepts values from `TaskStatuses` enum: `NotStarted`, `InProgress`, `Completed`, etc.
			 */
			taskStatus = TaskStatuses.NotStarted;
			/**
			 * Allows consumers to define the heading level for the task label.
			 *
			 * Accepts 'h2', 'h3' or 'h4'. Default is 'h3'.
			 */
			headingLevel = 'h3';
			/**
			 * The hint text options are re-assigned to the internalHintText state.
			 */
			internalHintText;
			/**
			 * Mutable variable, for internal use only.
			 *
			 * Set the task's status state depending on validation result.
			 */
			taskStatusState = TaskStatuses.NotStarted;
			/**
			 * Watch for changes in `taskStatus` prop to validate its value.
			 */
			validateTaskStatus() {
				const validStatuses = Object.values(TaskStatuses);
				const isValidStatus = validStatuses.includes(this.taskStatus);
				this.taskStatusState = isValidStatus ? this.taskStatus : this.warnAndGetDefaultTaskStatus();
				// Update the `data-task-status` attribute
				this.el.setAttribute('data-task-status', this.taskStatusState);
			}
			/**
			 * Logs a warning to the console if the `taskStatus` prop is set to an invalid value.
			 *
			 * This function informs developers that the provided `taskStatus` is not recognized
			 * and resets the status to the default value of `'notStarted'`. The warning message
			 * specifies the valid task statuses to help guide correct usage.
			 *
			 * @returns The default task status `'notStarted'`.
			 */
			warnAndGetDefaultTaskStatus() {
				const validStatuses = Object.values(TaskStatuses).join(', ');
				const message = new ConsoleMessageClass();
				message
					.addDesignSystemTag()
					.addMonospaceText(' taskStatus ')
					.addRegularText('on')
					.addMonospaceText(' <ontario-task> ')
					.addRegularText('was set to an invalid taskStatus; only ')
					.addMonospaceText(validStatuses)
					.addRegularText(' are supported. The default taskStatus ')
					.addMonospaceText(TaskStatuses.NotStarted)
					.addRegularText(' is assumed.')
					.printMessage();
				return TaskStatuses.NotStarted;
			}
			/**
			 * Watch for changes in `headingLevel` prop to validate its value.
			 */
			validateHeadingLevel(newValue) {
				const allowedValues = ['h2', 'h3', 'h4'];
				// Validate the new value against the allowed values
				const isValid = validateValueAgainstArray(newValue, allowedValues);
				if (!isValid) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' headingLevel ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-task> ')
						.addRegularText('was set to an invalid value; only ')
						.addMonospaceText(allowedValues.join(', '))
						.addRegularText(' are supported. The default value ')
						.addMonospaceText('h3')
						.addRegularText(' is assumed.')
						.printMessage();
					this.headingLevel = 'h3';
				}
			}
			/**
			 * Watch for changes in `hintText` prop and parse it if available.
			 *
			 * If a `hintText` prop is passed, the `constructHintTextObject` function will convert it to the correct format,
			 * and the result will be stored in the `internalHintText` state.
			 */
			parseHintText() {
				if (this.hintText) {
					const hintTextObject = constructHintTextObject(this.hintText);
					this.internalHintText = hintTextObject;
				}
			}
			/**
			 * Listen for app language settings on the window to update the component language.
			 */
			handleSetAppLanguage(event) {
				if (!this.language) {
					this.language = validateLanguage(event);
				}
			}
			/**
			 * This listens for the `headerLanguageToggled` event sent from the language toggle when it is connected to the DOM.
			 * It is used for changing the component language after the language toggle has been activated.
			 */
			handleHeaderLanguageToggled(event) {
				this.language = validateLanguage(event);
			}
			/**
			 * Determines the badge colour based on the current `taskStatusState`.
			 *
			 * @returns {TaskBadgeColour}
			 */
			getBadgeColour() {
				return TaskToBadgeColour[this.taskStatusState] || 'grey';
			}
			/**
			 * Provides a translated task status string based on the current language.
			 */
			getTranslatedTaskStatus() {
				const resolvedLanguage = validateLanguage(this.language);
				return translations.taskStatus[this.taskStatusState][resolvedLanguage];
			}
			/**
			 * Renders hint text if available.
			 */
			renderHintText() {
				if (this.internalHintText) {
					return hAsync('ontario-hint-text', {
						hint: this.internalHintText.hint,
						hintContentType: this.internalHintText.hintContentType,
						ref: (el) => (this.hintTextRef = el),
					});
				}
				return null;
			}
			/**
			 * Returns the class name(s) for the task label.
			 */
			getClass() {
				return ['ontario-task__label', this.hintText && 'ontario-task__hint-text--true'].filter(Boolean).join(' ');
			}
			/**
			 * Renders the task label and status content.
			 *
			 * This includes dynamically rendering the heading element (h2, h3, or h4) based on the `headingLevel` prop,
			 * as well as the badge indicating the task status.
			 */
			renderTaskContent() {
				const headingProps = {
					id: `task-label--${this.taskId}`,
					class: this.getClass(),
				};
				return hAsync(
					'div',
					{ class: 'ontario-task__content' },
					hAsync(this.headingLevel, headingProps, this.label),
					this.taskStatusState &&
						hAsync(
							'ontario-badge',
							{
								'class': 'ontario-task__badge',
								'role': 'status',
								'aria-label': `${translations.taskStatus.taskStatus[validateLanguage(this.language)]} ${this.getTranslatedTaskStatus()} (${this.taskStatusState})`,
								'colour': this.getBadgeColour(),
							},
							this.getTranslatedTaskStatus(),
						),
				);
			}
			/**
			 * After the component loads, retrieve the hint text ID (if available) from the hintText component,
			 * and set it for the `aria-describedby` attribute.
			 */
			async componentDidLoad() {
				if (this.hintTextRef) {
					let hintTextId = this.hintTextRef.elementId;
					if (!hintTextId) {
						hintTextId = `hint-text--${this.taskId}`;
						this.hintTextRef.elementId = hintTextId;
					}
					const taskElement = this.el.shadowRoot?.querySelector('li');
					if (taskElement) {
						taskElement.setAttribute('aria-describedby', hintTextId);
					}
				}
			}
			/**
			 * Lifecycle method: before the component loads, parse the hint text and
			 * validate language and task status and heading level.
			 */
			async componentWillLoad() {
				this.parseHintText();
				this.language = validateLanguage(this.language);
				this.validateTaskStatus();
				this.validateHeadingLevel(this.headingLevel);
			}
			render() {
				const isLinkActive = this.link && !this.deactivateLink;
				const taskStatusClass = `ontario-task-status--${this.taskStatusState.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()}`;
				const taskContent = hAsync(
					Fragment,
					{ key: '4968807e30ded9336a79d517b25cd0bd35a14a3d' },
					this.renderTaskContent(),
					this.renderHintText(),
				);
				return hAsync(
					'li',
					{
						'key': 'a000b87343f37fbdcee5e96cada8c0344e1a7218',
						'class': `ontario-task ${taskStatusClass}`,
						'role': 'group',
						'aria-labelledby': `task-label--${this.taskId}`,
						'data-task-status': this.taskStatusState,
					},
					isLinkActive
						? hAsync('a', { 'href': this.link, 'class': 'ontario-task__link', 'aria-label': this.label }, taskContent)
						: hAsync('div', null, taskContent),
				);
			}
			static get watchers() {
				return {
					taskStatus: ['validateTaskStatus'],
					headingLevel: ['validateHeadingLevel'],
					hintText: ['parseHintText'],
				};
			}
			static get style() {
				return ontarioTaskCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-task',
					$members$: {
						label: [1],
						taskId: [1, 'task-id'],
						link: [1],
						deactivateLink: [4, 'deactivate-link'],
						language: [1025],
						hintText: [1025, 'hint-text'],
						taskStatus: [1, 'task-status'],
						headingLevel: [1, 'heading-level'],
						internalHintText: [32],
						taskStatusState: [32],
					},
					$listeners$: [
						[8, 'setAppLanguage', 'handleSetAppLanguage'],
						[8, 'headerLanguageToggled', 'handleHeaderLanguageToggled'],
					],
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioTaskListCss =
			'.ontario-task-list{border-top:0.125rem solid #cccccc;padding:0}.ontario-task-list__item{max-width:100%;list-style-type:none}';

		class OntarioTaskList {
			constructor(hostRef) {
				registerInstance(this, hostRef);
			}
			get el() {
				return getElement(this);
			}
			/**
			 * The label prop used for the task list heading.
			 */
			label;
			/**
			 * Allows consumers to define the heading level for the task list component.
			 *
			 * Accepts 'h1', 'h2', 'h3' or 'h4'. Default is 'h3'.
			 */
			headingLevel = 'h2';
			/**
			 * The language of the component.
			 * This is used for translations, and is by default set through event listeners checking for a language property from the header. If none are passed, it will default to English.
			 */
			language = 'en';
			/**
			 * State to track the number of completed tasks.
			 */
			completedTasks = 0;
			/**
			 * State to track the total number of tasks.
			 */
			totalTasks = 0;
			/**
			 * Class-level constant for task count delay in milliseconds.
			 *
			 * This delay ensures that the `ontario-task` custom elements are fully upgraded and rendered
			 * in the DOM before the `countTasks` method is executed. Without this delay, the component
			 * might attempt to query or count tasks before they are properly initialized, leading to
			 * inaccurate task counts.
			 */
			static TASK_COUNT_DELAY_MS = 50;
			/**
			 * Watch for changes in `headingLevel` prop to validate its value.
			 */
			validateHeadingLevel(newValue) {
				const allowedValues = ['h1', 'h2', 'h3', 'h4', 'h5'];
				// Validate the new value against the allowed values
				const isValid = validateValueAgainstArray(newValue, allowedValues);
				if (!isValid) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' headingLevel ')
						.addRegularText('on')
						.addMonospaceText(' <ontario-task-list> ')
						.addRegularText('was set to an invalid value; only ')
						.addMonospaceText(allowedValues.join(', '))
						.addRegularText(' are supported. The default value ')
						.addMonospaceText('h2')
						.addRegularText(' is assumed.')
						.printMessage();
					this.headingLevel = 'h2';
				}
			}
			/**
			 * Counts the total tasks and completed tasks by querying for `ontario-task` elements.
			 */
			countTasks() {
				const slot = this.el.shadowRoot?.querySelector('slot');
				const tasks = slot ? slot.assignedElements().filter((el) => el.tagName.toLowerCase() === 'ontario-task') : [];
				this.totalTasks = tasks.length;
				this.completedTasks = tasks.filter((task) => {
					// Get the status directly from the light DOM
					const status = task.getAttribute('data-task-status');
					return status === TaskStatuses.Completed;
				}).length;
			}
			/**
			 * Lifecycle method: before the component loads, validate heading level.
			 */
			async componentWillLoad() {
				this.validateHeadingLevel(this.headingLevel);
			}
			/**
			 * Ensure tasks are counted after custom elements are fully upgraded.
			 */
			connectedCallback() {
				// Wait for the custom element to be fully defined before counting
				customElements.whenDefined('ontario-task').then(() => {
					setTimeout(() => {
						this.countTasks();
					}, OntarioTaskList.TASK_COUNT_DELAY_MS);
				});
			}
			/**
			 * Use slotchange and MutationObserver to track changes in slot content.
			 */
			componentDidLoad() {
				const slot = this.el.shadowRoot?.querySelector('slot');
				if (slot) {
					slot.addEventListener('slotchange', () => {
						this.countTasks();
					});
				}
				// Observe changes to the light DOM for accurate counting
				const observer = new MutationObserver((_mutations) => {
					this.countTasks();
				});
				observer.observe(this.el, {
					childList: true,
					subtree: true,
					attributes: true,
					attributeFilter: ['data-task-status'],
				});
			}
			componentDidRender() {
				setTimeout(() => {
					this.countTasks();
				}, OntarioTaskList.TASK_COUNT_DELAY_MS);
			}
			render() {
				// Resolve the language to ensure valid translations are used.
				const resolvedLanguage = validateLanguage(this.language);
				const headingProps = {
					class: { 'ontario-task-list__heading': true },
				};
				return hAsync(
					'div',
					{ key: 'fb26534c596025f0bbbf729d923210760e31ff60', class: 'ontario-task-list__container' },
					hAsync(this.headingLevel, headingProps, this.label),
					hAsync(
						'p',
						{
							'key': '8344876cd43f5b4c06685a41d0f49a55817cb1ee',
							'class': 'ontario-task-list__completion-text',
							'aria-live': 'polite',
						},
						translations.taskGroup.completed[resolvedLanguage],
						'\u00A0',
						this.completedTasks,
						'\u00A0',
						translations.taskGroup.outOf[resolvedLanguage],
						'\u00A0',
						this.totalTasks,
						'\u00A0',
						translations.taskGroup.tasks[resolvedLanguage],
					),
					hAsync(
						'ul',
						{ key: '42962ee4027bf4df1309ef409106e040f98c5fd2', class: 'ontario-task-list', role: 'list' },
						hAsync('slot', { key: 'd226bd26241b20557f13a0acdb161ae474c915e1' }),
					),
				);
			}
			static get watchers() {
				return {
					headingLevel: ['validateHeadingLevel'],
				};
			}
			static get style() {
				return ontarioTaskListCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 9,
					$tagName$: 'ontario-task-list',
					$members$: {
						label: [1],
						headingLevel: [1, 'heading-level'],
						language: [1025],
						completedTasks: [32],
						totalTasks: [32],
					},
					$listeners$: undefined,
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		const ontarioTextareaCss =
			'@charset "UTF-8";.ontario-textarea:focus,.ontario-textarea:active,.ontario-input:focus,.ontario-input:active{box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:box-shadow 0.1s ease-in-out}h6,.ontario-h6,h5,.ontario-h5,h4,.ontario-h4,h3,.ontario-h3,h2,.ontario-h2,h1>.ontario-label--heading,.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1,h1,.ontario-h1{font-style:normal;font-weight:700;text-rendering:optimizeLegibility;margin-bottom:1rem;font-feature-settings:normal;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif}h1>.ontario-label--heading,.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1,h1,.ontario-h1{font-size:2rem;letter-spacing:0.04rem;line-height:1.29;margin:2.5rem 0 1.5rem 0;max-width:70rem}@media screen and (min-width: 40em){h1>.ontario-label--heading,.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1,h1,.ontario-h1{font-size:2.5rem;letter-spacing:0.04rem;line-height:1.2}}h2,.ontario-h2{font-size:1.6875rem;letter-spacing:0.03rem;line-height:1.37;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h2,.ontario-h2{font-size:2.0625rem;letter-spacing:0.02rem;line-height:1.33}}h3,.ontario-h3{font-size:1.4375rem;letter-spacing:0.02rem;line-height:1.39;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h3,.ontario-h3{font-size:1.75rem;letter-spacing:0.02rem;line-height:1.43}}h4,.ontario-h4{font-size:1.25rem;letter-spacing:0.03rem;line-height:1.5;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h4,.ontario-h4{font-size:1.5rem;letter-spacing:0.0313rem;line-height:1.5}}h5,.ontario-h5{font-size:1.125rem;letter-spacing:0.03rem;line-height:1.56;margin:0 0 0.75rem 0;max-width:48rem}@media screen and (min-width: 40em){h5,.ontario-h5{font-size:1.1875rem;letter-spacing:0.025rem;line-height:1.5}}h6,.ontario-h6{font-size:1rem;line-height:1.56;letter-spacing:0.03rem;max-width:48rem;margin:0 0 0.75rem 0}@media screen and (min-width: 40em){h6,.ontario-h6{font-size:1rem;letter-spacing:0.025rem;line-height:1.5}}.ontario-lead-statement{font-size:1.25rem;line-height:1.6;max-width:70rem}@media screen and (min-width: 40em){.ontario-lead-statement{font-size:1.375rem}}html{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem}body{font-size:1rem;line-height:1.6;background-color:#FFFFFF;color:#1a1a1a;margin:0}p{font-size:inherit;margin-bottom:1.25rem;text-rendering:optimizeLegibility;margin:0 0 1.5rem 0}cite{font-style:italic;line-height:inherit}strong{font-weight:700;line-height:inherit}*,*::before,*::after{box-sizing:inherit}main p,main p:not(.ontario-lead-statement),main dd,main li{max-width:48rem}hr{border:0;padding:0;margin:2.5rem 0;border-bottom:4px solid #cccccc}hr.ontario-hr--dark{border-bottom:4px solid #1a1a1a}a{color:#0066CC;text-decoration:underline}a:visited{color:#551A8B}a:hover{color:#00478F}a:active{color:#002142}a:focus{-moz-box-shadow:0 0 0 4px #009ADB;-webkit-box-shadow:0 0 0 4px #009ADB;box-shadow:0 0 0 4px #009ADB;outline:4px solid transparent;transition:all 0.1s ease-in-out}p{margin:0 0 1.5rem 0}p+h1,p+h2,p+h3,p+h4,p+h5,p+h6,ul+h1,ul+h2,ul+h3,ul+h4,ul+h5,ul+h6,ol+h1,ol+h2,ol+h3,ol+h4,ol+h5,ol+h6,h1+h2,h2+h3,h3+h4,h4+h5,h5+h6{margin-top:2rem}p code,td code,li code{line-height:2.25rem}input[type=text],input[type=number],input[type=email],input[type=date],input[type=color],input[type=search],input[type=tel],textarea{background-origin:initial;height:auto;-webkit-appearance:none;-moz-appearance:none}input[type=checkbox]+label,input[type=radio]+label{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400;margin-left:0;margin-right:0}fieldset{border:0;margin:0;padding:0;page-break-inside:avoid}legend,label{display:block;margin:0}select{background-origin:initial;height:auto;-webkit-appearance:none;-moz-appearance:none}ul,ol{padding:0}ul{margin-left:2rem}ul li{padding:0 0 0.75rem 0}ol{margin-left:1.75rem}ol li{padding:0 0 0.75rem 0.25rem}ul li:last-child,ol li:last-child{padding-bottom:0}ul[class*=columns-] li:last-child,ol[class*=columns-] li:last-child{padding-bottom:0.75rem}ul ul,ol ul{margin:0.5rem 0 0.5rem 2rem}ul ol,ol ol{margin:0.5rem 0 0.5rem 1.75rem}p+ul,p+ol{margin-top:-0.75rem}@media screen and (min-width: 40em){ul{margin:0.5rem 0 1.5rem 3rem}ol{margin:0.5rem 0 1.5rem 2.75rem}ul ul,ol ul{margin:0.5rem 0 0.5rem 3rem}ul ol,ol ol{margin:0.5rem 0 0.5rem 2.75rem}}.ontario-form-group:last-of-type{margin-bottom:2.5rem}.ontario-form-group:last-of-type{margin-bottom:3rem}.ontario-fieldset__legend{color:#1a1a1a;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1.1875rem;font-weight:700;margin:0 0 1rem 0;line-height:1.5;max-width:38.75em;white-space:normal;width:100%;hyphens:auto}@media screen and (max-width: 40em){.ontario-fieldset__legend{font-size:1.125rem;line-height:1.56}}.ontario-fieldset__legend--large,.ontario-fieldset__legend--heading{letter-spacing:0.02rem;line-height:1.2}.ontario-fieldset__legend--large h1,.ontario-fieldset__legend--heading h1{display:inline-block;margin:0}@media screen and (max-width: 40em){.ontario-fieldset__legend--large,.ontario-fieldset__legend--heading{font-size:1.4375rem;line-height:1.39}}.ontario-fieldset__legend--large{font-size:1.75rem}.ontario-fieldset__legend-required-flag,.ontario-fieldset__legend-optional-flag{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400}.ontario-fieldset__legend-required-flag:before,.ontario-fieldset__legend-optional-flag:before{content:""}.ontario-label__flag{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400}.ontario-label__flag:before{content:""}.ontario-label{cursor:pointer;color:#1a1a1a;font-family:"Raleway", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1.1875rem;font-weight:700;line-height:1.5;margin:0 0 1rem 0;max-width:38.75em;white-space:normal;width:100%;hyphens:auto}@media screen and (max-width: 40em){.ontario-label{font-size:1.125rem;line-height:1.56}}.ontario-label--large{font-size:1.75rem;letter-spacing:0.02rem;line-height:1.2;max-width:26.25em}@media screen and (max-width: 40em){.ontario-label--large{font-size:1.4375rem;line-height:1.39}}h1>.ontario-label--heading{display:inline-block;margin:0}.ontario-label__flag{font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;font-size:1rem;font-weight:400}.ontario-label__flag:before{content:""}.ontario-input{border:2px solid #1a1a1a;border-radius:4px;box-sizing:border-box;color:#1a1a1a;display:block;font-size:1rem;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;line-height:1.5;margin:0 0 2.5rem;max-width:48rem;width:100%;padding:0.625rem 1rem;transition:box-shadow 0.1s ease-in-out}.ontario-input--2-char-width{max-width:8ex}.ontario-input--3-char-width{max-width:10ex}.ontario-input--4-char-width{max-width:12ex}.ontario-input--5-char-width{max-width:14ex}.ontario-input--7-char-width{max-width:17ex}.ontario-input--10-char-width{max-width:23ex}.ontario-input--20-char-width{max-width:41ex}.ontario-form-group:last-of-type{margin-bottom:2.5rem}.ontario-hide{display:none !important}.ontario-invisible{visibility:hidden !important}@media screen and (max-width: 39.99875em){.ontario-hide-for-small-only{display:none !important}}@media screen and (max-width: 0em), screen and (min-width: 40em){.ontario-show-for-small-only{display:none !important}}@media print, screen and (min-width: 40em){.ontario-hide-for-medium{display:none !important}}@media screen and (max-width: 39.99875em){.ontario-show-for-medium{display:none !important}}@media screen and (min-width: 40em) and (max-width: 72.99875em){.ontario-hide-for-medium-only{display:none !important}}@media screen and (max-width: 39.99875em), screen and (min-width: 73em){.ontario-show-for-medium-only{display:none !important}}@media print, screen and (min-width: 73em){.ontario-hide-for-large{display:none !important}}@media screen and (max-width: 72.99875em){.ontario-show-for-large{display:none !important}}@media screen and (min-width: 73em) and (max-width: 95.99875em){.ontario-hide-for-large-only{display:none !important}}@media screen and (max-width: 72.99875em), screen and (min-width: 96em){.ontario-show-for-large-only{display:none !important}}.ontario-show-for-sr,.ontario-show-on-focus{position:absolute;width:1px;height:1px;overflow:hidden;clip:rect(0, 0, 0, 0)}.ontario-show-on-focus:active,.ontario-show-on-focus:focus{position:static;width:auto;height:auto;overflow:visible;clip:auto}.ontario-show-for-landscape,.ontario-hide-for-portrait{display:block !important}@media screen and (orientation: landscape){.ontario-show-for-landscape,.ontario-hide-for-portrait{display:block !important}}@media screen and (orientation: portrait){.ontario-show-for-landscape,.ontario-hide-for-portrait{display:none !important}}.ontario-hide-for-landscape,.ontario-show-for-portrait{display:none !important}@media screen and (orientation: landscape){.ontario-hide-for-landscape,.ontario-show-for-portrait{display:none !important}}@media screen and (orientation: portrait){.ontario-hide-for-landscape,.ontario-show-for-portrait{display:block !important}}.ontario-error-messaging{display:flex;align-items:flex-start;margin:-0.25rem 0 0.5rem 0;color:#D81A21;max-width:48rem}.ontario-error-messaging__content{margin-left:0.5rem}.ontario-input__error{border-color:#D81A21 !important}.ontario-error__hidden{display:none}.ontario-textarea{border:2px solid #1a1a1a;border-radius:4px;box-sizing:border-box;color:#1a1a1a;font-size:1rem;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;line-height:1.5;display:block;max-width:48rem;min-height:144px;margin:0 0 2.5rem;padding:0.625rem 1rem;transition:box-shadow 0.1s ease-in-out;white-space:pre-wrap;width:100%}.ontario-textarea.ontario-textarea-hint-expander--true{margin-bottom:1rem}.ontario-textarea--error textarea{border:0.125rem solid #CD0000}';

		class OntarioTextarea {
			constructor(hostRef) {
				registerInstance(this, hostRef);
				this.inputOnInput = createEvent(this, 'inputOnInput');
				this.inputOnChange = createEvent(this, 'inputOnChange');
				this.inputOnBlur = createEvent(this, 'inputOnBlur');
				this.inputOnFocus = createEvent(this, 'inputOnFocus');
				this.inputErrorOccurred = createEvent(this, 'inputErrorOccurred');
				if (hostRef.$hostElement$['s-ei']) {
					this.internals = hostRef.$hostElement$['s-ei'];
				} else {
					this.internals = hostRef.$hostElement$.attachInternals();
					hostRef.$hostElement$['s-ei'] = this.internals;
				}
			}
			get element() {
				return getElement(this);
			}
			internals;
			hintTextRef;
			/**
			 * The text to display as the textarea label.
			 *
			 * @example
			 * <ontario-input
			 *   caption='{
			 *     "captionText": "Address",
			 *     "captionType": "heading",
			 *   }'
			 *   required="true"
			 *   ...>
			 * </ontario-input>
			 */
			caption;
			/**
			 * The name assigned to the textarea. The name value is used to reference form data after a form is submitted.
			 */
			name;
			/**
			 * The unique identifier of the textarea. This is optional - if no ID is passed, one will be generated.
			 */
			elementId;
			/**
			 * This is used to determine whether the textarea is required or not.
			 * This prop also gets passed to the InputCaption utility to display either an optional or required flag in the label.
			 * If no prop is set, it will default to false (optional).
			 */
			required = false;
			/**
			 * The textarea content value.
			 */
			value;
			/**
     * Used to include the ontario-hint-text component for the textarea.
     * This is optional.

     */
			hintText;
			/**
			 * Used to include the ontario-hint-expander component for the textarea component.
			 * This is passed in as an object with key-value pairs.
			 *
			 * This is optional.
			 *
			 * @example
			 * <ontario-textarea
			 *   caption='{
			 *     "captionText": "What are your thoughts",
			 *     "captionType": "heading",
			 *   }'
			 * 	 name: "textarea"
			 *   hint-expander='{
			 *     "hint": "This is the hint expander",
			 *     "content": "This is the content for the hint expander"
			 *   }'
			 *   required="true"
			 * >
			 * </ontario-textarea>
			 */
			hintExpander;
			/**
			 * The language of the component.
			 * This is used for translations, and is by default set through event listeners checking for a language property from the header. If no language is passed, it will default to English.
			 */
			language;
			/**
			 * Set this to display an error message
			 */
			errorMessage;
			/**
			 * Used to add a custom function to the textarea onInput event.
			 */
			customOnInput;
			/**
			 * Used to add a custom function to the textarea onChange event.
			 */
			customOnChange;
			/**
			 * Used to add a custom function to the textarea onBlur event.
			 */
			customOnBlur;
			/**
			 * Used to add a custom function to the textarea onFocus event.
			 */
			customOnFocus;
			/**
			 * Used for the `aria-describedby` value of the textarea. This will match with the id of the hint text.
			 */
			hintTextId;
			/**
			 * The hint text options are re-assigned to the internalHintText array.
			 */
			internalHintText;
			/**
			 * The hint expander options are re-assigned to the internalHintExpander array.
			 */
			internalHintExpander;
			/**
			 * Instantiate an InputCaption object for internal logic use
			 */
			captionState;
			/**
			 * Emitted when a input event occurs when an input has been changed.
			 */
			inputOnInput;
			/**
			 * Emitted when a keyboard input or mouse event occurs when an input has been changed.
			 */
			inputOnChange;
			/**
			 * Emitted when a keyboard input event occurs when an input has lost focus.
			 */
			inputOnBlur;
			/**
			 * Emitted when a keyboard input event occurs when an input has gained focus.
			 */
			inputOnFocus;
			/**
			 * Emitted when an error message is reported to the component.
			 */
			inputErrorOccurred;
			/**
			 * This listens for the `setAppLanguage` event sent from the test language toggler when it is is connected to the DOM. It is used for the initial language when the textarea component loads.
			 */
			handleSetAppLanguage(event) {
				if (!this.language) {
					this.language = validateLanguage(event);
				}
			}
			handleHeaderLanguageToggled(event) {
				this.language = validateLanguage(event);
			}
			/**
			 * Watch for changes to the `hintText` prop.
			 *
			 * If a `hintText` prop is passed, the `constructHintTextObject` function will convert it to the correct format, and set the result to the `internalHintText` state.
			 */
			parseHintText() {
				if (this.hintText) {
					const hintTextObject = constructHintTextObject(this.hintText);
					this.internalHintText = hintTextObject;
				}
			}
			/**
			 * Watch for changes to the `hintExpander` prop.
			 *
			 * If a `hintExpander` prop is passed, it will be parsed (if it is a string), and the result will be set to the `internalHintExpander` state.
			 */
			parseHintExpander() {
				const hintExpander = this.hintExpander;
				if (hintExpander) {
					if (typeof hintExpander === 'string') this.internalHintExpander = JSON.parse(hintExpander);
					else this.internalHintExpander = hintExpander;
				}
			}
			/*
			 * Watch for changes in the `name` prop for validation purposes.
			 *
			 * Validate the `name` and make sure the `name` prop has a value.
			 * Log a warning if user doesn't input a value for the `name`.
			 */
			validateName(newValue) {
				if (validatePropExists(newValue)) {
					const message = new ConsoleMessageClass();
					message
						.addDesignSystemTag()
						.addMonospaceText(' name ')
						.addRegularText('for')
						.addMonospaceText(' <ontario-textarea> ')
						.addRegularText('was not provided')
						.printMessage();
				}
			}
			/**
			 * Watch for changes to the `caption` prop.
			 *
			 * The caption will be run through the InputCaption constructor to convert it to the correct format, and set the result to the `captionState` state.
			 * @param newValue: Caption | string
			 */
			updateCaptionState(newValue) {
				this.captionState = new InputCaption(
					this.element.tagName,
					newValue,
					translations,
					this.language,
					false,
					this.required,
				);
			}
			/**
			 * Watch for changes to the `language` prop to render either the English or French translations
			 */
			updateLanguage() {
				this.updateCaptionState(this.caption);
			}
			broadcastInputErrorOccurredEvent() {
				// Emit event to notify anyone who wants to listen for errors occurring
				this.inputErrorOccurred.emit({ inputId: this.getId(), errorMessage: this.errorMessage ?? '' });
			}
			/**
			 * Function to handle textarea events and the information pertaining to the textarea to emit.
			 */
			handleEvent(event, eventType) {
				const input = event.target;
				this.internals?.setFormValue?.(input?.value ?? '');
				handleInputEvent(
					event,
					eventType,
					input,
					this.inputOnChange,
					this.inputOnFocus,
					this.inputOnBlur,
					this.inputOnInput,
					'input',
					this.customOnChange,
					this.customOnFocus,
					this.customOnBlur,
					this.customOnInput,
					this.element,
				);
			}
			getId() {
				return this.elementId ?? '';
			}
			getValue() {
				return this.value ?? '';
			}
			getClass() {
				return this.hintExpander ? `ontario-textarea ontario-textarea-hint-expander--true` : `ontario-textarea`;
			}
			/**
			 * If a `hintText` prop is passed, the id generated from it will be set to the internal `hintTextId` state to match with the textarea `aria-describedBy` attribute.
			 */
			async componentDidLoad() {
				this.hintTextId = await this.hintTextRef?.getHintTextId();
			}
			componentWillLoad() {
				this.updateCaptionState(this.caption);
				this.elementId = this.elementId ?? v4();
				this.parseHintText();
				this.parseHintExpander();
				this.validateName(this.name);
				this.language = validateLanguage(this.language);
			}
			render() {
				const error = !!this.errorMessage;
				return hAsync(
					'div',
					{
						key: '0e8456b0840ae71541d3b201df095680d63650db',
						class: `ontario-form-group ${error ? 'ontario-textarea--error' : ''}`,
					},
					this.captionState.getCaption(this.getId(), !!this.internalHintExpander),
					this.internalHintText &&
						hAsync('ontario-hint-text', {
							key: '21c33eb1f306b8280dcfa1d0def3b3d6aa0baf4b',
							hint: this.internalHintText.hint,
							hintContentType: this.internalHintText.hintContentType,
							ref: (el) => (this.hintTextRef = el),
						}),
					hAsync(ErrorMessage, {
						key: 'd908a60fc99c09936564cb8d1f6652d2476f6e70',
						message: this.errorMessage,
						error: error,
					}),
					hAsync('textarea', {
						'key': '51d90ea63daf55f8c20b563551a7e20a5ece16f2',
						'aria-describedby': this.hintTextId,
						'class': this.getClass(),
						'id': this.getId(),
						'name': this.name,
						'value': this.getValue(),
						'onInput': (e) => this.handleEvent(e, EventType.Input),
						'onChange': (e) => this.handleEvent(e, EventType.Change),
						'onBlur': (e) => this.handleEvent(e, EventType.Blur),
						'onFocus': (e) => this.handleEvent(e, EventType.Focus),
						'required': !!this.required,
					}),
					this.internalHintExpander &&
						hAsync('ontario-hint-expander', {
							'key': 'db0a618f1c0296dd1a6dcd014153b00925371d97',
							'hint': this.internalHintExpander.hint,
							'content': this.internalHintExpander.content,
							'hintContentType': this.internalHintExpander.hintContentType,
							'input-exists': true,
						}),
				);
			}
			static get formAssociated() {
				return true;
			}
			static get watchers() {
				return {
					hintText: ['parseHintText'],
					hintExpander: ['parseHintExpander'],
					name: ['validateName'],
					caption: ['updateCaptionState'],
					language: ['updateLanguage'],
					errorMessage: ['broadcastInputErrorOccurredEvent'],
				};
			}
			static get style() {
				return ontarioTextareaCss;
			}
			static get cmpMeta() {
				return {
					$flags$: 73,
					$tagName$: 'ontario-textarea',
					$members$: {
						caption: [1],
						name: [1],
						elementId: [1025, 'element-id'],
						required: [4],
						value: [1025],
						hintText: [1, 'hint-text'],
						hintExpander: [1, 'hint-expander'],
						language: [1025],
						errorMessage: [1025, 'error-message'],
						customOnInput: [16, 'custom-on-input'],
						customOnChange: [16, 'custom-on-change'],
						customOnBlur: [16, 'custom-on-blur'],
						customOnFocus: [16, 'custom-on-focus'],
						hintTextId: [32],
						internalHintText: [32],
						internalHintExpander: [32],
						captionState: [32],
					},
					$listeners$: [
						[8, 'setAppLanguage', 'handleSetAppLanguage'],
						[8, 'headerLanguageToggled', 'handleHeaderLanguageToggled'],
					],
					$lazyBundleId$: '-',
					$attrsToReflect$: [],
				};
			}
		}

		registerComponents([
			OntarioAccordion,
			OntarioAside,
			OntarioBackToTop,
			OntarioBadge,
			OntarioBlockquote,
			OntarioButton,
			OntarioCallout,
			OntarioCard,
			OntarioCardCollection,
			OntarioCheckboxes,
			OntarioCriticalAlert,
			OntarioDateInput,
			OntarioDropdownList,
			OntarioFieldset,
			OntarioFooter,
			OntarioHeader,
			OntarioHintExpander,
			OntarioHintText,
			OntarioIconAccessibility,
			OntarioIconAccount,
			OntarioIconAdd,
			OntarioIconAddAlt,
			OntarioIconAlertError,
			OntarioIconAlertInformation,
			OntarioIconAlertSuccess,
			OntarioIconAlertWarning,
			OntarioIconArrowUp,
			OntarioIconAttach,
			OntarioIconBookmarkOff,
			OntarioIconBookmarkOn,
			OntarioIconCalendar,
			OntarioIconCamera,
			OntarioIconChevronDown,
			OntarioIconChevronLeft,
			OntarioIconChevronRight,
			OntarioIconChevronUp,
			OntarioIconClock,
			OntarioIconClose,
			OntarioIconCloseHeader,
			OntarioIconCloud,
			OntarioIconCollapse,
			OntarioIconCreditCard,
			OntarioIconCriticalAlertWarning,
			OntarioIconDelete,
			OntarioIconDocument,
			OntarioIconDownload,
			OntarioIconDropdownArrow,
			OntarioIconEdit,
			OntarioIconEmail,
			OntarioIconExpand,
			OntarioIconExport,
			OntarioIconFacebook,
			OntarioIconFacebookAlt,
			OntarioIconFavouriteOff,
			OntarioIconFavouriteOn,
			OntarioIconFilter,
			OntarioIconFlickr,
			OntarioIconGrid,
			OntarioIconHelp,
			OntarioIconInstagram,
			OntarioIconInteracEn,
			OntarioIconInteracEnAlt,
			OntarioIconInteracFr,
			OntarioIconInteracFrAlt,
			OntarioIconLinkedin,
			OntarioIconLinkedinAlt,
			OntarioIconList,
			OntarioIconLiveChat,
			OntarioIconLocationOff,
			OntarioIconLocationOn,
			OntarioIconLockOff,
			OntarioIconLockOn,
			OntarioIconMap,
			OntarioIconMastercard,
			OntarioIconMastercardAlt,
			OntarioIconMediaFastForward,
			OntarioIconMediaFastRewind,
			OntarioIconMediaPause,
			OntarioIconMediaPlay,
			OntarioIconMediaStop,
			OntarioIconMenu,
			OntarioIconMenuHeader,
			OntarioIconMicrophoneOff,
			OntarioIconMicrophoneOn,
			OntarioIconMoreVertical,
			OntarioIconNewWindow,
			OntarioIconNext,
			OntarioIconNotification,
			OntarioIconPasswordHide,
			OntarioIconPasswordShow,
			OntarioIconPhone,
			OntarioIconPhoto,
			OntarioIconPinLocationOff,
			OntarioIconPinLocationOn,
			OntarioIconPrevious,
			OntarioIconPrint,
			OntarioIconRemove,
			OntarioIconRemoveAlt,
			OntarioIconReplay,
			OntarioIconRssFeed,
			OntarioIconSave,
			OntarioIconSearch,
			OntarioIconSearchWhite,
			OntarioIconSentiment1,
			OntarioIconSentiment2,
			OntarioIconSentiment3,
			OntarioIconSentiment4,
			OntarioIconSentiment5,
			OntarioIconSettings,
			OntarioIconShare,
			OntarioIconSort,
			OntarioIconTag,
			OntarioIconTextMessage,
			OntarioIconTimer,
			OntarioIconTransportBicycle,
			OntarioIconTransportBus,
			OntarioIconTransportCar,
			OntarioIconTransportWalk,
			OntarioIconTty,
			OntarioIconTwitter,
			OntarioIconTwitterAlt,
			OntarioIconUpload,
			OntarioIconVideo,
			OntarioIconVisa,
			OntarioIconVoteDislike,
			OntarioIconVoteLike,
			OntarioIconVpnKey,
			OntarioIconWheelchair,
			OntarioIconWifi,
			OntarioIconYoutube,
			OntarioInput,
			OntarioLanguageToggle,
			OntarioLoadingIndicator,
			OntarioPageAlert,
			OntarioRadioButtons,
			OntarioSearchBox,
			OntarioStepIndicator,
			OntarioTable,
			OntarioTask,
			OntarioTaskList,
			OntarioTextarea,
		]);

		exports.hydrateApp = hydrateApp;

		/*hydrateAppClosure end*/
		hydrateApp(window, $stencilHydrateOpts, $stencilHydrateResults, $stencilAfterHydrate, $stencilHydrateResolve);
	}

	hydrateAppClosure($stencilWindow);
}

// src/app-data/index.ts
var BUILD = {
	allRenderFn: false,
	element: true,
	event: true,
	hasRenderFn: true,
	hostListener: true,
	hostListenerTargetWindow: true,
	hostListenerTargetDocument: true,
	hostListenerTargetBody: true,
	hostListenerTargetParent: false,
	hostListenerTarget: true,
	member: true,
	method: true,
	mode: true,
	observeAttribute: true,
	prop: true,
	propMutable: true,
	reflect: true,
	scoped: true,
	shadowDom: true,
	slot: true,
	cssAnnotations: true,
	state: true,
	style: true,
	formAssociated: false,
	svg: true,
	updatable: true,
	vdomAttribute: true,
	vdomXlink: true,
	vdomClass: true,
	vdomFunctional: true,
	vdomKey: true,
	vdomListener: true,
	vdomRef: true,
	vdomPropOrAttr: true,
	vdomRender: true,
	vdomStyle: true,
	vdomText: true,
	watchCallback: true,
	taskQueue: true,
	hotModuleReplacement: false,
	isDebug: false,
	isDev: false,
	isTesting: false,
	hydrateServerSide: false,
	hydrateClientSide: false,
	lifecycleDOMEvents: false,
	lazyLoad: false,
	profile: false,
	slotRelocation: true,
	// TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
	appendChildSlotFix: false,
	// TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
	cloneNodeFix: false,
	hydratedAttribute: false,
	hydratedClass: true,
	// TODO(STENCIL-1305): remove this option
	scriptDataOpts: false,
	// TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
	scopedSlotTextContentFix: false,
	// TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
	shadowDomShim: false,
	// TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
	slotChildNodesFix: false,
	invisiblePrehydration: true,
	propBoolean: true,
	propNumber: true,
	propString: true,
	constructableCSS: true,
	devTools: false,
	shadowDelegatesFocus: true,
	initializeNextTick: false,
	asyncLoading: true,
	asyncQueue: false,
	transformTagName: false,
	attachStyles: true,
	// TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
	experimentalSlotFixes: false,
};
var Env = {};
var NAMESPACE =
	/* default */
	'app';

/*
 Stencil Hydrate Runner v4.30.0 | MIT Licensed | https://stenciljs.com
 */
var __defProp = Object.defineProperty;
var __export = (target, all) => {
	for (var name in all) __defProp(target, name, { get: all[name], enumerable: true });
};

// src/runtime/runtime-constants.ts
var CONTENT_REF_ID = 'r';
var ORG_LOCATION_ID = 'o';
var SLOT_NODE_ID = 's';
var TEXT_NODE_ID = 't';
var HYDRATE_ID = 's-id';
var STENCIL_DOC_DATA = '_stencilDocData';
var XLINK_NS = 'http://www.w3.org/1999/xlink';

// src/mock-doc/attribute.ts
var attrHandler = {
	get(obj, prop) {
		if (prop in obj) {
			return obj[prop];
		}
		if (typeof prop !== 'symbol' && !isNaN(prop)) {
			return obj.__items[prop];
		}
		return void 0;
	},
};
var createAttributeProxy = (caseInsensitive) => new Proxy(new MockAttributeMap(caseInsensitive), attrHandler);
var MockAttributeMap = class {
	constructor(caseInsensitive = false) {
		this.caseInsensitive = caseInsensitive;
		this.__items = [];
	}
	get length() {
		return this.__items.length;
	}
	item(index) {
		return this.__items[index] || null;
	}
	setNamedItem(attr) {
		attr.namespaceURI = null;
		this.setNamedItemNS(attr);
	}
	setNamedItemNS(attr) {
		if (attr != null && attr.value != null) {
			attr.value = String(attr.value);
		}
		const existingAttr = this.__items.find((a) => a.name === attr.name && a.namespaceURI === attr.namespaceURI);
		if (existingAttr != null) {
			existingAttr.value = attr.value;
		} else {
			this.__items.push(attr);
		}
	}
	getNamedItem(attrName) {
		if (this.caseInsensitive) {
			attrName = attrName.toLowerCase();
		}
		return this.getNamedItemNS(null, attrName);
	}
	getNamedItemNS(namespaceURI, attrName) {
		namespaceURI = getNamespaceURI(namespaceURI);
		return (
			this.__items.find((attr) => attr.name === attrName && getNamespaceURI(attr.namespaceURI) === namespaceURI) || null
		);
	}
	removeNamedItem(attr) {
		this.removeNamedItemNS(attr);
	}
	removeNamedItemNS(attr) {
		for (let i = 0, ii = this.__items.length; i < ii; i++) {
			if (this.__items[i].name === attr.name && this.__items[i].namespaceURI === attr.namespaceURI) {
				this.__items.splice(i, 1);
				break;
			}
		}
	}
	[Symbol.iterator]() {
		let i = 0;
		return {
			next: () => ({
				done: i === this.length,
				value: this.item(i++),
			}),
		};
	}
	get [Symbol.toStringTag]() {
		return 'MockAttributeMap';
	}
};
function getNamespaceURI(namespaceURI) {
	return namespaceURI === XLINK_NS ? null : namespaceURI;
}
function cloneAttributes(srcAttrs, sortByName = false) {
	const dstAttrs = new MockAttributeMap(srcAttrs.caseInsensitive);
	if (srcAttrs != null) {
		const attrLen = srcAttrs.length;
		if (sortByName && attrLen > 1) {
			const sortedAttrs = [];
			for (let i = 0; i < attrLen; i++) {
				const srcAttr = srcAttrs.item(i);
				const dstAttr = new MockAttr(srcAttr.name, srcAttr.value, srcAttr.namespaceURI);
				sortedAttrs.push(dstAttr);
			}
			sortedAttrs.sort(sortAttributes).forEach((attr) => {
				dstAttrs.setNamedItemNS(attr);
			});
		} else {
			for (let i = 0; i < attrLen; i++) {
				const srcAttr = srcAttrs.item(i);
				const dstAttr = new MockAttr(srcAttr.name, srcAttr.value, srcAttr.namespaceURI);
				dstAttrs.setNamedItemNS(dstAttr);
			}
		}
	}
	return dstAttrs;
}
function sortAttributes(a, b) {
	if (a.name < b.name) return -1;
	if (a.name > b.name) return 1;
	return 0;
}
var MockAttr = class {
	constructor(attrName, attrValue, namespaceURI = null) {
		this._name = attrName;
		this._value = String(attrValue);
		this._namespaceURI = namespaceURI;
	}
	get name() {
		return this._name;
	}
	set name(value) {
		this._name = value;
	}
	get value() {
		return this._value;
	}
	set value(value) {
		this._value = String(value);
	}
	get nodeName() {
		return this._name;
	}
	set nodeName(value) {
		this._name = value;
	}
	get nodeValue() {
		return this._value;
	}
	set nodeValue(value) {
		this._value = String(value);
	}
	get namespaceURI() {
		return this._namespaceURI;
	}
	set namespaceURI(namespaceURI) {
		this._namespaceURI = namespaceURI;
	}
};

// src/mock-doc/class-list.ts
var MockClassList = class {
	constructor(elm) {
		this.elm = elm;
	}
	add(...classNames) {
		const clsNames = getItems(this.elm);
		let updated = false;
		classNames.forEach((className) => {
			className = String(className);
			validateClass(className);
			if (clsNames.includes(className) === false) {
				clsNames.push(className);
				updated = true;
			}
		});
		if (updated) {
			this.elm.setAttributeNS(null, 'class', clsNames.join(' '));
		}
	}
	remove(...classNames) {
		const clsNames = getItems(this.elm);
		let updated = false;
		classNames.forEach((className) => {
			className = String(className);
			validateClass(className);
			const index = clsNames.indexOf(className);
			if (index > -1) {
				clsNames.splice(index, 1);
				updated = true;
			}
		});
		if (updated) {
			this.elm.setAttributeNS(null, 'class', clsNames.filter((c) => c.length > 0).join(' '));
		}
	}
	contains(className) {
		className = String(className);
		return getItems(this.elm).includes(className);
	}
	toggle(className) {
		className = String(className);
		if (this.contains(className) === true) {
			this.remove(className);
		} else {
			this.add(className);
		}
	}
	get length() {
		return getItems(this.elm).length;
	}
	item(index) {
		return getItems(this.elm)[index];
	}
	toString() {
		return getItems(this.elm).join(' ');
	}
};
function validateClass(className) {
	if (className === '') {
		throw new Error('The token provided must not be empty.');
	}
	if (/\s/.test(className)) {
		throw new Error(
			`The token provided ('${className}') contains HTML space characters, which are not valid in tokens.`,
		);
	}
}
function getItems(elm) {
	const className = elm.getAttribute('class');
	if (typeof className === 'string' && className.length > 0) {
		return className
			.trim()
			.split(' ')
			.filter((c) => c.length > 0);
	}
	return [];
}

// src/mock-doc/css-style-declaration.ts
var MockCSSStyleDeclaration = class {
	constructor() {
		this._styles = /* @__PURE__ */ new Map();
	}
	setProperty(prop, value) {
		prop = jsCaseToCssCase(prop);
		if (value == null || value === '') {
			this._styles.delete(prop);
		} else {
			this._styles.set(prop, String(value));
		}
	}
	getPropertyValue(prop) {
		prop = jsCaseToCssCase(prop);
		return String(this._styles.get(prop) || '');
	}
	removeProperty(prop) {
		prop = jsCaseToCssCase(prop);
		this._styles.delete(prop);
	}
	get length() {
		return this._styles.size;
	}
	get cssText() {
		const cssText = [];
		this._styles.forEach((value, prop) => {
			cssText.push(`${prop}: ${value};`);
		});
		return cssText.join(' ').trim();
	}
	set cssText(cssText) {
		if (cssText == null || cssText === '') {
			this._styles.clear();
			return;
		}
		cssText.split(';').forEach((rule) => {
			rule = rule.trim();
			if (rule.length > 0) {
				const splt = rule.split(':');
				if (splt.length > 1) {
					const prop = splt[0].trim();
					const value = splt.slice(1).join(':').trim();
					if (prop !== '' && value !== '') {
						this._styles.set(jsCaseToCssCase(prop), value);
					}
				}
			}
		});
	}
};
function createCSSStyleDeclaration() {
	return new Proxy(new MockCSSStyleDeclaration(), cssProxyHandler);
}
var cssProxyHandler = {
	get(cssStyle, prop) {
		if (prop in cssStyle) {
			return cssStyle[prop];
		}
		prop = cssCaseToJsCase(prop);
		return cssStyle.getPropertyValue(prop);
	},
	set(cssStyle, prop, value) {
		if (prop in cssStyle) {
			cssStyle[prop] = value;
		} else {
			cssStyle.setProperty(prop, value);
		}
		return true;
	},
};
function cssCaseToJsCase(str) {
	if (str.length > 1 && str.includes('-') === true) {
		str = str
			.toLowerCase()
			.split('-')
			.map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))
			.join('');
		str = str.slice(0, 1).toLowerCase() + str.slice(1);
	}
	return str;
}
function jsCaseToCssCase(str) {
	if (str.length > 1 && str.includes('-') === false && /[A-Z]/.test(str) === true) {
		str = str
			.replace(/([A-Z])/g, (g) => ' ' + g[0])
			.trim()
			.replace(/ /g, '-')
			.toLowerCase();
	}
	return str;
}

// src/mock-doc/custom-element-registry.ts
var MockCustomElementRegistry = class {
	constructor(win2) {
		this.win = win2;
	}
	define(tagName, cstr, options) {
		if (tagName.toLowerCase() !== tagName) {
			throw new Error(
				`Failed to execute 'define' on 'CustomElementRegistry': "${tagName}" is not a valid custom element name`,
			);
		}
		if (this.__registry == null) {
			this.__registry = /* @__PURE__ */ new Map();
		}
		this.__registry.set(tagName, { cstr, options });
		if (this.__whenDefined != null) {
			const whenDefinedResolveFns = this.__whenDefined.get(tagName);
			if (whenDefinedResolveFns != null) {
				whenDefinedResolveFns.forEach((whenDefinedResolveFn) => {
					whenDefinedResolveFn();
				});
				whenDefinedResolveFns.length = 0;
				this.__whenDefined.delete(tagName);
			}
		}
		const doc = this.win.document;
		if (doc != null) {
			const hosts = doc.querySelectorAll(tagName);
			hosts.forEach((host) => {
				if (upgradedElements.has(host) === false) {
					tempDisableCallbacks.add(doc);
					const upgradedCmp = createCustomElement(this, doc, tagName);
					for (let i = 0; i < host.childNodes.length; i++) {
						const childNode = host.childNodes[i];
						childNode.remove();
						upgradedCmp.appendChild(childNode);
					}
					tempDisableCallbacks.delete(doc);
					if (proxyElements.has(host)) {
						proxyElements.set(host, upgradedCmp);
					}
				}
				fireConnectedCallback(host);
			});
		}
	}
	get(tagName) {
		if (this.__registry != null) {
			const def = this.__registry.get(tagName.toLowerCase());
			if (def != null) {
				return def.cstr;
			}
		}
		return void 0;
	}
	getName(cstr) {
		for (const [tagName, def] of this.__registry.entries()) {
			if (def.cstr === cstr) {
				return tagName;
			}
		}
		return void 0;
	}
	upgrade(_rootNode) {}
	clear() {
		if (this.__registry != null) {
			this.__registry.clear();
		}
		if (this.__whenDefined != null) {
			this.__whenDefined.clear();
		}
	}
	whenDefined(tagName) {
		tagName = tagName.toLowerCase();
		if (this.__registry != null && this.__registry.has(tagName) === true) {
			return Promise.resolve(this.__registry.get(tagName).cstr);
		}
		return new Promise((resolve) => {
			if (this.__whenDefined == null) {
				this.__whenDefined = /* @__PURE__ */ new Map();
			}
			let whenDefinedResolveFns = this.__whenDefined.get(tagName);
			if (whenDefinedResolveFns == null) {
				whenDefinedResolveFns = [];
				this.__whenDefined.set(tagName, whenDefinedResolveFns);
			}
			whenDefinedResolveFns.push(resolve);
		});
	}
};
function createCustomElement(customElements2, ownerDocument, tagName) {
	const Cstr = customElements2.get(tagName);
	if (Cstr != null) {
		const cmp = new Cstr(ownerDocument);
		cmp.nodeName = tagName.toUpperCase();
		upgradedElements.add(cmp);
		return cmp;
	}
	const host = new Proxy(
		{},
		{
			get(obj, prop) {
				const elm2 = proxyElements.get(host);
				if (elm2 != null) {
					return elm2[prop];
				}
				return obj[prop];
			},
			set(obj, prop, val) {
				const elm2 = proxyElements.get(host);
				if (elm2 != null) {
					elm2[prop] = val;
				} else {
					obj[prop] = val;
				}
				return true;
			},
			has(obj, prop) {
				const elm2 = proxyElements.get(host);
				if (prop in elm2) {
					return true;
				}
				if (prop in obj) {
					return true;
				}
				return false;
			},
		},
	);
	const elm = new MockHTMLElement(ownerDocument, tagName);
	proxyElements.set(host, elm);
	return host;
}
var proxyElements = /* @__PURE__ */ new WeakMap();
var upgradedElements = /* @__PURE__ */ new WeakSet();
function connectNode(ownerDocument, node) {
	node.ownerDocument = ownerDocument;
	if (node.nodeType === 1 /* ELEMENT_NODE */) {
		if (ownerDocument != null && node.nodeName.includes('-')) {
			const win2 = ownerDocument.defaultView;
			if (win2 != null && typeof node.connectedCallback === 'function' && node.isConnected) {
				fireConnectedCallback(node);
			}
			const shadowRoot = node.shadowRoot;
			if (shadowRoot != null) {
				shadowRoot.childNodes.forEach((childNode) => {
					connectNode(ownerDocument, childNode);
				});
			}
		}
		node.childNodes.forEach((childNode) => {
			connectNode(ownerDocument, childNode);
		});
	} else {
		node.childNodes.forEach((childNode) => {
			childNode.ownerDocument = ownerDocument;
		});
	}
}
function fireConnectedCallback(node) {
	if (typeof node.connectedCallback === 'function') {
		if (tempDisableCallbacks.has(node.ownerDocument) === false) {
			try {
				node.connectedCallback();
			} catch (e) {
				console.error(e);
			}
		}
	}
}
function disconnectNode(node) {
	if (node.nodeType === 1 /* ELEMENT_NODE */) {
		if (node.nodeName.includes('-') === true && typeof node.disconnectedCallback === 'function') {
			if (tempDisableCallbacks.has(node.ownerDocument) === false) {
				try {
					node.disconnectedCallback();
				} catch (e) {
					console.error(e);
				}
			}
		}
		node.childNodes.forEach(disconnectNode);
	}
}
function attributeChanged(node, attrName, oldValue, newValue) {
	attrName = attrName.toLowerCase();
	const observedAttributes = node.constructor.observedAttributes;
	if (
		Array.isArray(observedAttributes) === true &&
		observedAttributes.some((obs) => obs.toLowerCase() === attrName) === true
	) {
		try {
			node.attributeChangedCallback(attrName, oldValue, newValue);
		} catch (e) {
			console.error(e);
		}
	}
}
function checkAttributeChanged(node) {
	return node.nodeName.includes('-') === true && typeof node.attributeChangedCallback === 'function';
}
var tempDisableCallbacks = /* @__PURE__ */ new Set();

// src/mock-doc/dataset.ts
function dataset(elm) {
	const ds = {};
	const attributes = elm.attributes;
	const attrLen = attributes.length;
	for (let i = 0; i < attrLen; i++) {
		const attr = attributes.item(i);
		const nodeName = attr.nodeName;
		if (nodeName.startsWith('data-')) {
			ds[dashToPascalCase(nodeName)] = attr.nodeValue;
		}
	}
	return new Proxy(ds, {
		get(_obj, camelCaseProp) {
			return ds[camelCaseProp];
		},
		set(_obj, camelCaseProp, value) {
			const dataAttr = toDataAttribute(camelCaseProp);
			elm.setAttribute(dataAttr, value);
			return true;
		},
	});
}
function toDataAttribute(str) {
	return (
		'data-' +
		String(str)
			.replace(/([A-Z0-9])/g, (g) => ' ' + g[0])
			.trim()
			.replace(/ /g, '-')
			.toLowerCase()
	);
}
function dashToPascalCase(str) {
	str = String(str).slice(5);
	return str
		.split('-')
		.map((segment, index) => {
			if (index === 0) {
				return segment.charAt(0).toLowerCase() + segment.slice(1);
			}
			return segment.charAt(0).toUpperCase() + segment.slice(1);
		})
		.join('');
}

// src/mock-doc/event.ts
var MockEvent = class {
	constructor(type, eventInitDict) {
		this.bubbles = false;
		this.cancelBubble = false;
		this.cancelable = false;
		this.composed = false;
		this.currentTarget = null;
		this.defaultPrevented = false;
		this.srcElement = null;
		this.target = null;
		if (typeof type !== 'string') {
			throw new Error(`Event type required`);
		}
		this.type = type;
		this.timeStamp = Date.now();
		if (eventInitDict != null) {
			Object.assign(this, eventInitDict);
		}
	}
	preventDefault() {
		this.defaultPrevented = true;
	}
	stopPropagation() {
		this.cancelBubble = true;
	}
	stopImmediatePropagation() {
		this.cancelBubble = true;
	}
	/**
	 * @ref https://developer.mozilla.org/en-US/docs/Web/API/Event/composedPath
	 * @returns a composed path of the event
	 */
	composedPath() {
		const composedPath = [];
		let currentElement = this.target;
		while (currentElement) {
			composedPath.push(currentElement);
			if (!currentElement.parentElement && currentElement.nodeName === '#document' /* DOCUMENT_NODE */) {
				composedPath.push(currentElement.defaultView);
				break;
			}
			if (currentElement.parentElement == null && currentElement.tagName === 'HTML') {
				currentElement = currentElement.ownerDocument;
			} else {
				currentElement = currentElement.parentElement;
			}
		}
		return composedPath;
	}
};
var MockCustomEvent = class extends MockEvent {
	constructor(type, customEventInitDic) {
		super(type);
		this.detail = null;
		if (customEventInitDic != null) {
			Object.assign(this, customEventInitDic);
		}
	}
};
var MockKeyboardEvent = class extends MockEvent {
	constructor(type, keyboardEventInitDic) {
		super(type);
		this.code = '';
		this.key = '';
		this.altKey = false;
		this.ctrlKey = false;
		this.metaKey = false;
		this.shiftKey = false;
		this.location = 0;
		this.repeat = false;
		if (keyboardEventInitDic != null) {
			Object.assign(this, keyboardEventInitDic);
		}
	}
};
var MockMouseEvent = class extends MockEvent {
	constructor(type, mouseEventInitDic) {
		super(type);
		this.screenX = 0;
		this.screenY = 0;
		this.clientX = 0;
		this.clientY = 0;
		this.ctrlKey = false;
		this.shiftKey = false;
		this.altKey = false;
		this.metaKey = false;
		this.button = 0;
		this.buttons = 0;
		this.relatedTarget = null;
		if (mouseEventInitDic != null) {
			Object.assign(this, mouseEventInitDic);
		}
	}
};
var MockUIEvent = class extends MockEvent {
	constructor(type, uiEventInitDic) {
		super(type);
		this.detail = null;
		this.view = null;
		if (uiEventInitDic != null) {
			Object.assign(this, uiEventInitDic);
		}
	}
};
var MockFocusEvent = class extends MockUIEvent {
	constructor(type, focusEventInitDic) {
		super(type);
		this.relatedTarget = null;
		if (focusEventInitDic != null) {
			Object.assign(this, focusEventInitDic);
		}
	}
};
var MockEventListener = class {
	constructor(type, handler) {
		this.type = type;
		this.handler = handler;
	}
};
function addEventListener(elm, type, handler) {
	const target = elm;
	if (target.__listeners == null) {
		target.__listeners = [];
	}
	target.__listeners.push(new MockEventListener(type, handler));
}
function removeEventListener(elm, type, handler) {
	const target = elm;
	if (target != null && Array.isArray(target.__listeners) === true) {
		const elmListener = target.__listeners.find((e) => e.type === type && e.handler === handler);
		if (elmListener != null) {
			const index = target.__listeners.indexOf(elmListener);
			target.__listeners.splice(index, 1);
		}
	}
}
function resetEventListeners(target) {
	if (target != null && target.__listeners != null) {
		target.__listeners = null;
	}
}
function triggerEventListener(elm, ev) {
	if (elm == null || ev.cancelBubble === true) {
		return;
	}
	const target = elm;
	ev.currentTarget = elm;
	if (Array.isArray(target.__listeners) === true) {
		const listeners = target.__listeners.filter((e) => e.type === ev.type);
		listeners.forEach((listener) => {
			try {
				listener.handler.call(target, ev);
			} catch (err2) {
				console.error(err2);
			}
		});
	}
	if (ev.bubbles === false) {
		return;
	}
	if (elm.nodeName === '#document' /* DOCUMENT_NODE */) {
		triggerEventListener(elm.defaultView, ev);
	} else if (elm.parentElement == null && elm.tagName === 'HTML') {
		triggerEventListener(elm.ownerDocument, ev);
	} else {
		triggerEventListener(elm.parentElement, ev);
	}
}
function dispatchEvent(currentTarget, ev) {
	ev.target = currentTarget;
	triggerEventListener(currentTarget, ev);
	return true;
}

// node_modules/parse5/dist/common/unicode.js
var UNDEFINED_CODE_POINTS = /* @__PURE__ */ new Set([
	65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286,
	524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038,
	983039, 1048574, 1048575, 1114110, 1114111,
]);
var REPLACEMENT_CHARACTER = '\uFFFD';
var CODE_POINTS;
(function (CODE_POINTS2) {
	CODE_POINTS2[(CODE_POINTS2['EOF'] = -1)] = 'EOF';
	CODE_POINTS2[(CODE_POINTS2['NULL'] = 0)] = 'NULL';
	CODE_POINTS2[(CODE_POINTS2['TABULATION'] = 9)] = 'TABULATION';
	CODE_POINTS2[(CODE_POINTS2['CARRIAGE_RETURN'] = 13)] = 'CARRIAGE_RETURN';
	CODE_POINTS2[(CODE_POINTS2['LINE_FEED'] = 10)] = 'LINE_FEED';
	CODE_POINTS2[(CODE_POINTS2['FORM_FEED'] = 12)] = 'FORM_FEED';
	CODE_POINTS2[(CODE_POINTS2['SPACE'] = 32)] = 'SPACE';
	CODE_POINTS2[(CODE_POINTS2['EXCLAMATION_MARK'] = 33)] = 'EXCLAMATION_MARK';
	CODE_POINTS2[(CODE_POINTS2['QUOTATION_MARK'] = 34)] = 'QUOTATION_MARK';
	CODE_POINTS2[(CODE_POINTS2['AMPERSAND'] = 38)] = 'AMPERSAND';
	CODE_POINTS2[(CODE_POINTS2['APOSTROPHE'] = 39)] = 'APOSTROPHE';
	CODE_POINTS2[(CODE_POINTS2['HYPHEN_MINUS'] = 45)] = 'HYPHEN_MINUS';
	CODE_POINTS2[(CODE_POINTS2['SOLIDUS'] = 47)] = 'SOLIDUS';
	CODE_POINTS2[(CODE_POINTS2['DIGIT_0'] = 48)] = 'DIGIT_0';
	CODE_POINTS2[(CODE_POINTS2['DIGIT_9'] = 57)] = 'DIGIT_9';
	CODE_POINTS2[(CODE_POINTS2['SEMICOLON'] = 59)] = 'SEMICOLON';
	CODE_POINTS2[(CODE_POINTS2['LESS_THAN_SIGN'] = 60)] = 'LESS_THAN_SIGN';
	CODE_POINTS2[(CODE_POINTS2['EQUALS_SIGN'] = 61)] = 'EQUALS_SIGN';
	CODE_POINTS2[(CODE_POINTS2['GREATER_THAN_SIGN'] = 62)] = 'GREATER_THAN_SIGN';
	CODE_POINTS2[(CODE_POINTS2['QUESTION_MARK'] = 63)] = 'QUESTION_MARK';
	CODE_POINTS2[(CODE_POINTS2['LATIN_CAPITAL_A'] = 65)] = 'LATIN_CAPITAL_A';
	CODE_POINTS2[(CODE_POINTS2['LATIN_CAPITAL_Z'] = 90)] = 'LATIN_CAPITAL_Z';
	CODE_POINTS2[(CODE_POINTS2['RIGHT_SQUARE_BRACKET'] = 93)] = 'RIGHT_SQUARE_BRACKET';
	CODE_POINTS2[(CODE_POINTS2['GRAVE_ACCENT'] = 96)] = 'GRAVE_ACCENT';
	CODE_POINTS2[(CODE_POINTS2['LATIN_SMALL_A'] = 97)] = 'LATIN_SMALL_A';
	CODE_POINTS2[(CODE_POINTS2['LATIN_SMALL_Z'] = 122)] = 'LATIN_SMALL_Z';
})(CODE_POINTS || (CODE_POINTS = {}));
var SEQUENCES = {
	DASH_DASH: '--',
	CDATA_START: '[CDATA[',
	DOCTYPE: 'doctype',
	SCRIPT: 'script',
	PUBLIC: 'public',
	SYSTEM: 'system',
};
function isSurrogate(cp) {
	return cp >= 55296 && cp <= 57343;
}
function isSurrogatePair(cp) {
	return cp >= 56320 && cp <= 57343;
}
function getSurrogatePairCodePoint(cp1, cp2) {
	return (cp1 - 55296) * 1024 + 9216 + cp2;
}
function isControlCodePoint(cp) {
	return (
		(cp !== 32 && cp !== 10 && cp !== 13 && cp !== 9 && cp !== 12 && cp >= 1 && cp <= 31) || (cp >= 127 && cp <= 159)
	);
}
function isUndefinedCodePoint(cp) {
	return (cp >= 64976 && cp <= 65007) || UNDEFINED_CODE_POINTS.has(cp);
}

// node_modules/parse5/dist/common/error-codes.js
var ERR;
(function (ERR2) {
	ERR2['controlCharacterInInputStream'] = 'control-character-in-input-stream';
	ERR2['noncharacterInInputStream'] = 'noncharacter-in-input-stream';
	ERR2['surrogateInInputStream'] = 'surrogate-in-input-stream';
	ERR2['nonVoidHtmlElementStartTagWithTrailingSolidus'] = 'non-void-html-element-start-tag-with-trailing-solidus';
	ERR2['endTagWithAttributes'] = 'end-tag-with-attributes';
	ERR2['endTagWithTrailingSolidus'] = 'end-tag-with-trailing-solidus';
	ERR2['unexpectedSolidusInTag'] = 'unexpected-solidus-in-tag';
	ERR2['unexpectedNullCharacter'] = 'unexpected-null-character';
	ERR2['unexpectedQuestionMarkInsteadOfTagName'] = 'unexpected-question-mark-instead-of-tag-name';
	ERR2['invalidFirstCharacterOfTagName'] = 'invalid-first-character-of-tag-name';
	ERR2['unexpectedEqualsSignBeforeAttributeName'] = 'unexpected-equals-sign-before-attribute-name';
	ERR2['missingEndTagName'] = 'missing-end-tag-name';
	ERR2['unexpectedCharacterInAttributeName'] = 'unexpected-character-in-attribute-name';
	ERR2['unknownNamedCharacterReference'] = 'unknown-named-character-reference';
	ERR2['missingSemicolonAfterCharacterReference'] = 'missing-semicolon-after-character-reference';
	ERR2['unexpectedCharacterAfterDoctypeSystemIdentifier'] = 'unexpected-character-after-doctype-system-identifier';
	ERR2['unexpectedCharacterInUnquotedAttributeValue'] = 'unexpected-character-in-unquoted-attribute-value';
	ERR2['eofBeforeTagName'] = 'eof-before-tag-name';
	ERR2['eofInTag'] = 'eof-in-tag';
	ERR2['missingAttributeValue'] = 'missing-attribute-value';
	ERR2['missingWhitespaceBetweenAttributes'] = 'missing-whitespace-between-attributes';
	ERR2['missingWhitespaceAfterDoctypePublicKeyword'] = 'missing-whitespace-after-doctype-public-keyword';
	ERR2['missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers'] =
		'missing-whitespace-between-doctype-public-and-system-identifiers';
	ERR2['missingWhitespaceAfterDoctypeSystemKeyword'] = 'missing-whitespace-after-doctype-system-keyword';
	ERR2['missingQuoteBeforeDoctypePublicIdentifier'] = 'missing-quote-before-doctype-public-identifier';
	ERR2['missingQuoteBeforeDoctypeSystemIdentifier'] = 'missing-quote-before-doctype-system-identifier';
	ERR2['missingDoctypePublicIdentifier'] = 'missing-doctype-public-identifier';
	ERR2['missingDoctypeSystemIdentifier'] = 'missing-doctype-system-identifier';
	ERR2['abruptDoctypePublicIdentifier'] = 'abrupt-doctype-public-identifier';
	ERR2['abruptDoctypeSystemIdentifier'] = 'abrupt-doctype-system-identifier';
	ERR2['cdataInHtmlContent'] = 'cdata-in-html-content';
	ERR2['incorrectlyOpenedComment'] = 'incorrectly-opened-comment';
	ERR2['eofInScriptHtmlCommentLikeText'] = 'eof-in-script-html-comment-like-text';
	ERR2['eofInDoctype'] = 'eof-in-doctype';
	ERR2['nestedComment'] = 'nested-comment';
	ERR2['abruptClosingOfEmptyComment'] = 'abrupt-closing-of-empty-comment';
	ERR2['eofInComment'] = 'eof-in-comment';
	ERR2['incorrectlyClosedComment'] = 'incorrectly-closed-comment';
	ERR2['eofInCdata'] = 'eof-in-cdata';
	ERR2['absenceOfDigitsInNumericCharacterReference'] = 'absence-of-digits-in-numeric-character-reference';
	ERR2['nullCharacterReference'] = 'null-character-reference';
	ERR2['surrogateCharacterReference'] = 'surrogate-character-reference';
	ERR2['characterReferenceOutsideUnicodeRange'] = 'character-reference-outside-unicode-range';
	ERR2['controlCharacterReference'] = 'control-character-reference';
	ERR2['noncharacterCharacterReference'] = 'noncharacter-character-reference';
	ERR2['missingWhitespaceBeforeDoctypeName'] = 'missing-whitespace-before-doctype-name';
	ERR2['missingDoctypeName'] = 'missing-doctype-name';
	ERR2['invalidCharacterSequenceAfterDoctypeName'] = 'invalid-character-sequence-after-doctype-name';
	ERR2['duplicateAttribute'] = 'duplicate-attribute';
	ERR2['nonConformingDoctype'] = 'non-conforming-doctype';
	ERR2['missingDoctype'] = 'missing-doctype';
	ERR2['misplacedDoctype'] = 'misplaced-doctype';
	ERR2['endTagWithoutMatchingOpenElement'] = 'end-tag-without-matching-open-element';
	ERR2['closingOfElementWithOpenChildElements'] = 'closing-of-element-with-open-child-elements';
	ERR2['disallowedContentInNoscriptInHead'] = 'disallowed-content-in-noscript-in-head';
	ERR2['openElementsLeftAfterEof'] = 'open-elements-left-after-eof';
	ERR2['abandonedHeadElementChild'] = 'abandoned-head-element-child';
	ERR2['misplacedStartTagForHeadElement'] = 'misplaced-start-tag-for-head-element';
	ERR2['nestedNoscriptInHead'] = 'nested-noscript-in-head';
	ERR2['eofInElementThatCanContainOnlyText'] = 'eof-in-element-that-can-contain-only-text';
})(ERR || (ERR = {}));

// node_modules/parse5/dist/tokenizer/preprocessor.js
var DEFAULT_BUFFER_WATERLINE = 1 << 16;
var Preprocessor = class {
	constructor(handler) {
		this.handler = handler;
		this.html = '';
		this.pos = -1;
		this.lastGapPos = -2;
		this.gapStack = [];
		this.skipNextNewLine = false;
		this.lastChunkWritten = false;
		this.endOfChunkHit = false;
		this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
		this.isEol = false;
		this.lineStartPos = 0;
		this.droppedBufferSize = 0;
		this.line = 1;
		this.lastErrOffset = -1;
	}
	/** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
	get col() {
		return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);
	}
	get offset() {
		return this.droppedBufferSize + this.pos;
	}
	getError(code, cpOffset) {
		const { line, col, offset } = this;
		const startCol = col + cpOffset;
		const startOffset = offset + cpOffset;
		return {
			code,
			startLine: line,
			endLine: line,
			startCol,
			endCol: startCol,
			startOffset,
			endOffset: startOffset,
		};
	}
	_err(code) {
		if (this.handler.onParseError && this.lastErrOffset !== this.offset) {
			this.lastErrOffset = this.offset;
			this.handler.onParseError(this.getError(code, 0));
		}
	}
	_addGap() {
		this.gapStack.push(this.lastGapPos);
		this.lastGapPos = this.pos;
	}
	_processSurrogate(cp) {
		if (this.pos !== this.html.length - 1) {
			const nextCp = this.html.charCodeAt(this.pos + 1);
			if (isSurrogatePair(nextCp)) {
				this.pos++;
				this._addGap();
				return getSurrogatePairCodePoint(cp, nextCp);
			}
		} else if (!this.lastChunkWritten) {
			this.endOfChunkHit = true;
			return CODE_POINTS.EOF;
		}
		this._err(ERR.surrogateInInputStream);
		return cp;
	}
	willDropParsedChunk() {
		return this.pos > this.bufferWaterline;
	}
	dropParsedChunk() {
		if (this.willDropParsedChunk()) {
			this.html = this.html.substring(this.pos);
			this.lineStartPos -= this.pos;
			this.droppedBufferSize += this.pos;
			this.pos = 0;
			this.lastGapPos = -2;
			this.gapStack.length = 0;
		}
	}
	write(chunk, isLastChunk) {
		if (this.html.length > 0) {
			this.html += chunk;
		} else {
			this.html = chunk;
		}
		this.endOfChunkHit = false;
		this.lastChunkWritten = isLastChunk;
	}
	insertHtmlAtCurrentPos(chunk) {
		this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);
		this.endOfChunkHit = false;
	}
	startsWith(pattern, caseSensitive) {
		if (this.pos + pattern.length > this.html.length) {
			this.endOfChunkHit = !this.lastChunkWritten;
			return false;
		}
		if (caseSensitive) {
			return this.html.startsWith(pattern, this.pos);
		}
		for (let i = 0; i < pattern.length; i++) {
			const cp = this.html.charCodeAt(this.pos + i) | 32;
			if (cp !== pattern.charCodeAt(i)) {
				return false;
			}
		}
		return true;
	}
	peek(offset) {
		const pos = this.pos + offset;
		if (pos >= this.html.length) {
			this.endOfChunkHit = !this.lastChunkWritten;
			return CODE_POINTS.EOF;
		}
		const code = this.html.charCodeAt(pos);
		return code === CODE_POINTS.CARRIAGE_RETURN ? CODE_POINTS.LINE_FEED : code;
	}
	advance() {
		this.pos++;
		if (this.isEol) {
			this.isEol = false;
			this.line++;
			this.lineStartPos = this.pos;
		}
		if (this.pos >= this.html.length) {
			this.endOfChunkHit = !this.lastChunkWritten;
			return CODE_POINTS.EOF;
		}
		let cp = this.html.charCodeAt(this.pos);
		if (cp === CODE_POINTS.CARRIAGE_RETURN) {
			this.isEol = true;
			this.skipNextNewLine = true;
			return CODE_POINTS.LINE_FEED;
		}
		if (cp === CODE_POINTS.LINE_FEED) {
			this.isEol = true;
			if (this.skipNextNewLine) {
				this.line--;
				this.skipNextNewLine = false;
				this._addGap();
				return this.advance();
			}
		}
		this.skipNextNewLine = false;
		if (isSurrogate(cp)) {
			cp = this._processSurrogate(cp);
		}
		const isCommonValidRange =
			this.handler.onParseError === null ||
			(cp > 31 && cp < 127) ||
			cp === CODE_POINTS.LINE_FEED ||
			cp === CODE_POINTS.CARRIAGE_RETURN ||
			(cp > 159 && cp < 64976);
		if (!isCommonValidRange) {
			this._checkForProblematicCharacters(cp);
		}
		return cp;
	}
	_checkForProblematicCharacters(cp) {
		if (isControlCodePoint(cp)) {
			this._err(ERR.controlCharacterInInputStream);
		} else if (isUndefinedCodePoint(cp)) {
			this._err(ERR.noncharacterInInputStream);
		}
	}
	retreat(count) {
		this.pos -= count;
		while (this.pos < this.lastGapPos) {
			this.lastGapPos = this.gapStack.pop();
			this.pos--;
		}
		this.isEol = false;
	}
};

// node_modules/parse5/dist/common/token.js
var token_exports = {};
__export(token_exports, {
	TokenType: () => TokenType,
	getTokenAttr: () => getTokenAttr,
});
var TokenType;
(function (TokenType2) {
	TokenType2[(TokenType2['CHARACTER'] = 0)] = 'CHARACTER';
	TokenType2[(TokenType2['NULL_CHARACTER'] = 1)] = 'NULL_CHARACTER';
	TokenType2[(TokenType2['WHITESPACE_CHARACTER'] = 2)] = 'WHITESPACE_CHARACTER';
	TokenType2[(TokenType2['START_TAG'] = 3)] = 'START_TAG';
	TokenType2[(TokenType2['END_TAG'] = 4)] = 'END_TAG';
	TokenType2[(TokenType2['COMMENT'] = 5)] = 'COMMENT';
	TokenType2[(TokenType2['DOCTYPE'] = 6)] = 'DOCTYPE';
	TokenType2[(TokenType2['EOF'] = 7)] = 'EOF';
	TokenType2[(TokenType2['HIBERNATION'] = 8)] = 'HIBERNATION';
})(TokenType || (TokenType = {}));
function getTokenAttr(token, attrName) {
	for (let i = token.attrs.length - 1; i >= 0; i--) {
		if (token.attrs[i].name === attrName) {
			return token.attrs[i].value;
		}
	}
	return null;
}

// node_modules/entities/lib/esm/generated/decode-data-html.js
var decode_data_html_default = new Uint16Array(
	// prettier-ignore
	'\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((c) => c.charCodeAt(0)),
);

// node_modules/entities/lib/esm/generated/decode-data-xml.js
var decode_data_xml_default = new Uint16Array(
	// prettier-ignore
	"\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((c) => c.charCodeAt(0)),
);

// node_modules/entities/lib/esm/decode_codepoint.js
var _a;
var decodeMap = /* @__PURE__ */ new Map([
	[0, 65533],
	// C1 Unicode control character reference replacements
	[128, 8364],
	[130, 8218],
	[131, 402],
	[132, 8222],
	[133, 8230],
	[134, 8224],
	[135, 8225],
	[136, 710],
	[137, 8240],
	[138, 352],
	[139, 8249],
	[140, 338],
	[142, 381],
	[145, 8216],
	[146, 8217],
	[147, 8220],
	[148, 8221],
	[149, 8226],
	[150, 8211],
	[151, 8212],
	[152, 732],
	[153, 8482],
	[154, 353],
	[155, 8250],
	[156, 339],
	[158, 382],
	[159, 376],
]);
var fromCodePoint =
	// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
	(_a = String.fromCodePoint) !== null && _a !== void 0
		? _a
		: function (codePoint) {
				let output = '';
				if (codePoint > 65535) {
					codePoint -= 65536;
					output += String.fromCharCode(((codePoint >>> 10) & 1023) | 55296);
					codePoint = 56320 | (codePoint & 1023);
				}
				output += String.fromCharCode(codePoint);
				return output;
			};
function replaceCodePoint(codePoint) {
	var _a2;
	if ((codePoint >= 55296 && codePoint <= 57343) || codePoint > 1114111) {
		return 65533;
	}
	return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
}

// node_modules/entities/lib/esm/decode.js
var CharCodes;
(function (CharCodes2) {
	CharCodes2[(CharCodes2['NUM'] = 35)] = 'NUM';
	CharCodes2[(CharCodes2['SEMI'] = 59)] = 'SEMI';
	CharCodes2[(CharCodes2['EQUALS'] = 61)] = 'EQUALS';
	CharCodes2[(CharCodes2['ZERO'] = 48)] = 'ZERO';
	CharCodes2[(CharCodes2['NINE'] = 57)] = 'NINE';
	CharCodes2[(CharCodes2['LOWER_A'] = 97)] = 'LOWER_A';
	CharCodes2[(CharCodes2['LOWER_F'] = 102)] = 'LOWER_F';
	CharCodes2[(CharCodes2['LOWER_X'] = 120)] = 'LOWER_X';
	CharCodes2[(CharCodes2['LOWER_Z'] = 122)] = 'LOWER_Z';
	CharCodes2[(CharCodes2['UPPER_A'] = 65)] = 'UPPER_A';
	CharCodes2[(CharCodes2['UPPER_F'] = 70)] = 'UPPER_F';
	CharCodes2[(CharCodes2['UPPER_Z'] = 90)] = 'UPPER_Z';
})(CharCodes || (CharCodes = {}));
var TO_LOWER_BIT = 32;
var BinTrieFlags;
(function (BinTrieFlags2) {
	BinTrieFlags2[(BinTrieFlags2['VALUE_LENGTH'] = 49152)] = 'VALUE_LENGTH';
	BinTrieFlags2[(BinTrieFlags2['BRANCH_LENGTH'] = 16256)] = 'BRANCH_LENGTH';
	BinTrieFlags2[(BinTrieFlags2['JUMP_TABLE'] = 127)] = 'JUMP_TABLE';
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code) {
	return code >= CharCodes.ZERO && code <= CharCodes.NINE;
}
function isHexadecimalCharacter(code) {
	return (
		(code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F) || (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F)
	);
}
function isAsciiAlphaNumeric(code) {
	return (
		(code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z) ||
		(code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z) ||
		isNumber(code)
	);
}
function isEntityInAttributeInvalidEnd(code) {
	return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
}
var EntityDecoderState;
(function (EntityDecoderState2) {
	EntityDecoderState2[(EntityDecoderState2['EntityStart'] = 0)] = 'EntityStart';
	EntityDecoderState2[(EntityDecoderState2['NumericStart'] = 1)] = 'NumericStart';
	EntityDecoderState2[(EntityDecoderState2['NumericDecimal'] = 2)] = 'NumericDecimal';
	EntityDecoderState2[(EntityDecoderState2['NumericHex'] = 3)] = 'NumericHex';
	EntityDecoderState2[(EntityDecoderState2['NamedEntity'] = 4)] = 'NamedEntity';
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function (DecodingMode2) {
	DecodingMode2[(DecodingMode2['Legacy'] = 0)] = 'Legacy';
	DecodingMode2[(DecodingMode2['Strict'] = 1)] = 'Strict';
	DecodingMode2[(DecodingMode2['Attribute'] = 2)] = 'Attribute';
})(DecodingMode || (DecodingMode = {}));
var EntityDecoder = class {
	constructor(decodeTree, emitCodePoint, errors) {
		this.decodeTree = decodeTree;
		this.emitCodePoint = emitCodePoint;
		this.errors = errors;
		this.state = EntityDecoderState.EntityStart;
		this.consumed = 1;
		this.result = 0;
		this.treeIndex = 0;
		this.excess = 1;
		this.decodeMode = DecodingMode.Strict;
	}
	/** Resets the instance to make it reusable. */
	startEntity(decodeMode) {
		this.decodeMode = decodeMode;
		this.state = EntityDecoderState.EntityStart;
		this.result = 0;
		this.treeIndex = 0;
		this.excess = 1;
		this.consumed = 1;
	}
	/**
	 * Write an entity to the decoder. This can be called multiple times with partial entities.
	 * If the entity is incomplete, the decoder will return -1.
	 *
	 * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
	 * entity is incomplete, and resume when the next string is written.
	 *
	 * @param string The string containing the entity (or a continuation of the entity).
	 * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
	 * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
	 */
	write(str, offset) {
		switch (this.state) {
			case EntityDecoderState.EntityStart: {
				if (str.charCodeAt(offset) === CharCodes.NUM) {
					this.state = EntityDecoderState.NumericStart;
					this.consumed += 1;
					return this.stateNumericStart(str, offset + 1);
				}
				this.state = EntityDecoderState.NamedEntity;
				return this.stateNamedEntity(str, offset);
			}
			case EntityDecoderState.NumericStart: {
				return this.stateNumericStart(str, offset);
			}
			case EntityDecoderState.NumericDecimal: {
				return this.stateNumericDecimal(str, offset);
			}
			case EntityDecoderState.NumericHex: {
				return this.stateNumericHex(str, offset);
			}
			case EntityDecoderState.NamedEntity: {
				return this.stateNamedEntity(str, offset);
			}
		}
	}
	/**
	 * Switches between the numeric decimal and hexadecimal states.
	 *
	 * Equivalent to the `Numeric character reference state` in the HTML spec.
	 *
	 * @param str The string containing the entity (or a continuation of the entity).
	 * @param offset The current offset.
	 * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
	 */
	stateNumericStart(str, offset) {
		if (offset >= str.length) {
			return -1;
		}
		if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
			this.state = EntityDecoderState.NumericHex;
			this.consumed += 1;
			return this.stateNumericHex(str, offset + 1);
		}
		this.state = EntityDecoderState.NumericDecimal;
		return this.stateNumericDecimal(str, offset);
	}
	addToNumericResult(str, start, end, base) {
		if (start !== end) {
			const digitCount = end - start;
			this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
			this.consumed += digitCount;
		}
	}
	/**
	 * Parses a hexadecimal numeric entity.
	 *
	 * Equivalent to the `Hexademical character reference state` in the HTML spec.
	 *
	 * @param str The string containing the entity (or a continuation of the entity).
	 * @param offset The current offset.
	 * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
	 */
	stateNumericHex(str, offset) {
		const startIdx = offset;
		while (offset < str.length) {
			const char = str.charCodeAt(offset);
			if (isNumber(char) || isHexadecimalCharacter(char)) {
				offset += 1;
			} else {
				this.addToNumericResult(str, startIdx, offset, 16);
				return this.emitNumericEntity(char, 3);
			}
		}
		this.addToNumericResult(str, startIdx, offset, 16);
		return -1;
	}
	/**
	 * Parses a decimal numeric entity.
	 *
	 * Equivalent to the `Decimal character reference state` in the HTML spec.
	 *
	 * @param str The string containing the entity (or a continuation of the entity).
	 * @param offset The current offset.
	 * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
	 */
	stateNumericDecimal(str, offset) {
		const startIdx = offset;
		while (offset < str.length) {
			const char = str.charCodeAt(offset);
			if (isNumber(char)) {
				offset += 1;
			} else {
				this.addToNumericResult(str, startIdx, offset, 10);
				return this.emitNumericEntity(char, 2);
			}
		}
		this.addToNumericResult(str, startIdx, offset, 10);
		return -1;
	}
	/**
	 * Validate and emit a numeric entity.
	 *
	 * Implements the logic from the `Hexademical character reference start
	 * state` and `Numeric character reference end state` in the HTML spec.
	 *
	 * @param lastCp The last code point of the entity. Used to see if the
	 *               entity was terminated with a semicolon.
	 * @param expectedLength The minimum number of characters that should be
	 *                       consumed. Used to validate that at least one digit
	 *                       was consumed.
	 * @returns The number of characters that were consumed.
	 */
	emitNumericEntity(lastCp, expectedLength) {
		var _a2;
		if (this.consumed <= expectedLength) {
			(_a2 = this.errors) === null || _a2 === void 0
				? void 0
				: _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
			return 0;
		}
		if (lastCp === CharCodes.SEMI) {
			this.consumed += 1;
		} else if (this.decodeMode === DecodingMode.Strict) {
			return 0;
		}
		this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
		if (this.errors) {
			if (lastCp !== CharCodes.SEMI) {
				this.errors.missingSemicolonAfterCharacterReference();
			}
			this.errors.validateNumericCharacterReference(this.result);
		}
		return this.consumed;
	}
	/**
	 * Parses a named entity.
	 *
	 * Equivalent to the `Named character reference state` in the HTML spec.
	 *
	 * @param str The string containing the entity (or a continuation of the entity).
	 * @param offset The current offset.
	 * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
	 */
	stateNamedEntity(str, offset) {
		const { decodeTree } = this;
		let current = decodeTree[this.treeIndex];
		let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
		for (; offset < str.length; offset++, this.excess++) {
			const char = str.charCodeAt(offset);
			this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
			if (this.treeIndex < 0) {
				return this.result === 0 || // If we are parsing an attribute
					(this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
						(valueLength === 0 || // And there should be no invalid characters.
							isEntityInAttributeInvalidEnd(char)))
					? 0
					: this.emitNotTerminatedNamedEntity();
			}
			current = decodeTree[this.treeIndex];
			valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
			if (valueLength !== 0) {
				if (char === CharCodes.SEMI) {
					return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
				}
				if (this.decodeMode !== DecodingMode.Strict) {
					this.result = this.treeIndex;
					this.consumed += this.excess;
					this.excess = 0;
				}
			}
		}
		return -1;
	}
	/**
	 * Emit a named entity that was not terminated with a semicolon.
	 *
	 * @returns The number of characters consumed.
	 */
	emitNotTerminatedNamedEntity() {
		var _a2;
		const { result, decodeTree } = this;
		const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
		this.emitNamedEntityData(result, valueLength, this.consumed);
		(_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.missingSemicolonAfterCharacterReference();
		return this.consumed;
	}
	/**
	 * Emit a named entity.
	 *
	 * @param result The index of the entity in the decode tree.
	 * @param valueLength The number of bytes in the entity.
	 * @param consumed The number of characters consumed.
	 *
	 * @returns The number of characters consumed.
	 */
	emitNamedEntityData(result, valueLength, consumed) {
		const { decodeTree } = this;
		this.emitCodePoint(
			valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1],
			consumed,
		);
		if (valueLength === 3) {
			this.emitCodePoint(decodeTree[result + 2], consumed);
		}
		return consumed;
	}
	/**
	 * Signal to the parser that the end of the input was reached.
	 *
	 * Remaining data will be emitted and relevant errors will be produced.
	 *
	 * @returns The number of characters consumed.
	 */
	end() {
		var _a2;
		switch (this.state) {
			case EntityDecoderState.NamedEntity: {
				return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex)
					? this.emitNotTerminatedNamedEntity()
					: 0;
			}
			// Otherwise, emit a numeric entity if we have one.
			case EntityDecoderState.NumericDecimal: {
				return this.emitNumericEntity(0, 2);
			}
			case EntityDecoderState.NumericHex: {
				return this.emitNumericEntity(0, 3);
			}
			case EntityDecoderState.NumericStart: {
				(_a2 = this.errors) === null || _a2 === void 0
					? void 0
					: _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
				return 0;
			}
			case EntityDecoderState.EntityStart: {
				return 0;
			}
		}
	}
};
function getDecoder(decodeTree) {
	let ret = '';
	const decoder = new EntityDecoder(decodeTree, (str) => (ret += fromCodePoint(str)));
	return function decodeWithTrie(str, decodeMode) {
		let lastIndex = 0;
		let offset = 0;
		while ((offset = str.indexOf('&', offset)) >= 0) {
			ret += str.slice(lastIndex, offset);
			decoder.startEntity(decodeMode);
			const len = decoder.write(
				str,
				// Skip the "&"
				offset + 1,
			);
			if (len < 0) {
				lastIndex = offset + decoder.end();
				break;
			}
			lastIndex = offset + len;
			offset = len === 0 ? lastIndex + 1 : lastIndex;
		}
		const result = ret + str.slice(lastIndex);
		ret = '';
		return result;
	};
}
function determineBranch(decodeTree, current, nodeIdx, char) {
	const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
	const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
	if (branchCount === 0) {
		return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
	}
	if (jumpOffset) {
		const value = char - jumpOffset;
		return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
	}
	let lo = nodeIdx;
	let hi = lo + branchCount - 1;
	while (lo <= hi) {
		const mid = (lo + hi) >>> 1;
		const midVal = decodeTree[mid];
		if (midVal < char) {
			lo = mid + 1;
		} else if (midVal > char) {
			hi = mid - 1;
		} else {
			return decodeTree[mid + branchCount];
		}
	}
	return -1;
}
var htmlDecoder = getDecoder(decode_data_html_default);
var xmlDecoder = getDecoder(decode_data_xml_default);

// node_modules/parse5/dist/common/html.js
var html_exports = {};
__export(html_exports, {
	ATTRS: () => ATTRS,
	DOCUMENT_MODE: () => DOCUMENT_MODE,
	NS: () => NS,
	NUMBERED_HEADERS: () => NUMBERED_HEADERS,
	SPECIAL_ELEMENTS: () => SPECIAL_ELEMENTS,
	TAG_ID: () => TAG_ID,
	TAG_NAMES: () => TAG_NAMES,
	getTagID: () => getTagID,
	hasUnescapedText: () => hasUnescapedText,
});
var NS;
(function (NS2) {
	NS2['HTML'] = 'http://www.w3.org/1999/xhtml';
	NS2['MATHML'] = 'http://www.w3.org/1998/Math/MathML';
	NS2['SVG'] = 'http://www.w3.org/2000/svg';
	NS2['XLINK'] = 'http://www.w3.org/1999/xlink';
	NS2['XML'] = 'http://www.w3.org/XML/1998/namespace';
	NS2['XMLNS'] = 'http://www.w3.org/2000/xmlns/';
})(NS || (NS = {}));
var ATTRS;
(function (ATTRS2) {
	ATTRS2['TYPE'] = 'type';
	ATTRS2['ACTION'] = 'action';
	ATTRS2['ENCODING'] = 'encoding';
	ATTRS2['PROMPT'] = 'prompt';
	ATTRS2['NAME'] = 'name';
	ATTRS2['COLOR'] = 'color';
	ATTRS2['FACE'] = 'face';
	ATTRS2['SIZE'] = 'size';
})(ATTRS || (ATTRS = {}));
var DOCUMENT_MODE;
(function (DOCUMENT_MODE2) {
	DOCUMENT_MODE2['NO_QUIRKS'] = 'no-quirks';
	DOCUMENT_MODE2['QUIRKS'] = 'quirks';
	DOCUMENT_MODE2['LIMITED_QUIRKS'] = 'limited-quirks';
})(DOCUMENT_MODE || (DOCUMENT_MODE = {}));
var TAG_NAMES;
(function (TAG_NAMES2) {
	TAG_NAMES2['A'] = 'a';
	TAG_NAMES2['ADDRESS'] = 'address';
	TAG_NAMES2['ANNOTATION_XML'] = 'annotation-xml';
	TAG_NAMES2['APPLET'] = 'applet';
	TAG_NAMES2['AREA'] = 'area';
	TAG_NAMES2['ARTICLE'] = 'article';
	TAG_NAMES2['ASIDE'] = 'aside';
	TAG_NAMES2['B'] = 'b';
	TAG_NAMES2['BASE'] = 'base';
	TAG_NAMES2['BASEFONT'] = 'basefont';
	TAG_NAMES2['BGSOUND'] = 'bgsound';
	TAG_NAMES2['BIG'] = 'big';
	TAG_NAMES2['BLOCKQUOTE'] = 'blockquote';
	TAG_NAMES2['BODY'] = 'body';
	TAG_NAMES2['BR'] = 'br';
	TAG_NAMES2['BUTTON'] = 'button';
	TAG_NAMES2['CAPTION'] = 'caption';
	TAG_NAMES2['CENTER'] = 'center';
	TAG_NAMES2['CODE'] = 'code';
	TAG_NAMES2['COL'] = 'col';
	TAG_NAMES2['COLGROUP'] = 'colgroup';
	TAG_NAMES2['DD'] = 'dd';
	TAG_NAMES2['DESC'] = 'desc';
	TAG_NAMES2['DETAILS'] = 'details';
	TAG_NAMES2['DIALOG'] = 'dialog';
	TAG_NAMES2['DIR'] = 'dir';
	TAG_NAMES2['DIV'] = 'div';
	TAG_NAMES2['DL'] = 'dl';
	TAG_NAMES2['DT'] = 'dt';
	TAG_NAMES2['EM'] = 'em';
	TAG_NAMES2['EMBED'] = 'embed';
	TAG_NAMES2['FIELDSET'] = 'fieldset';
	TAG_NAMES2['FIGCAPTION'] = 'figcaption';
	TAG_NAMES2['FIGURE'] = 'figure';
	TAG_NAMES2['FONT'] = 'font';
	TAG_NAMES2['FOOTER'] = 'footer';
	TAG_NAMES2['FOREIGN_OBJECT'] = 'foreignObject';
	TAG_NAMES2['FORM'] = 'form';
	TAG_NAMES2['FRAME'] = 'frame';
	TAG_NAMES2['FRAMESET'] = 'frameset';
	TAG_NAMES2['H1'] = 'h1';
	TAG_NAMES2['H2'] = 'h2';
	TAG_NAMES2['H3'] = 'h3';
	TAG_NAMES2['H4'] = 'h4';
	TAG_NAMES2['H5'] = 'h5';
	TAG_NAMES2['H6'] = 'h6';
	TAG_NAMES2['HEAD'] = 'head';
	TAG_NAMES2['HEADER'] = 'header';
	TAG_NAMES2['HGROUP'] = 'hgroup';
	TAG_NAMES2['HR'] = 'hr';
	TAG_NAMES2['HTML'] = 'html';
	TAG_NAMES2['I'] = 'i';
	TAG_NAMES2['IMG'] = 'img';
	TAG_NAMES2['IMAGE'] = 'image';
	TAG_NAMES2['INPUT'] = 'input';
	TAG_NAMES2['IFRAME'] = 'iframe';
	TAG_NAMES2['KEYGEN'] = 'keygen';
	TAG_NAMES2['LABEL'] = 'label';
	TAG_NAMES2['LI'] = 'li';
	TAG_NAMES2['LINK'] = 'link';
	TAG_NAMES2['LISTING'] = 'listing';
	TAG_NAMES2['MAIN'] = 'main';
	TAG_NAMES2['MALIGNMARK'] = 'malignmark';
	TAG_NAMES2['MARQUEE'] = 'marquee';
	TAG_NAMES2['MATH'] = 'math';
	TAG_NAMES2['MENU'] = 'menu';
	TAG_NAMES2['META'] = 'meta';
	TAG_NAMES2['MGLYPH'] = 'mglyph';
	TAG_NAMES2['MI'] = 'mi';
	TAG_NAMES2['MO'] = 'mo';
	TAG_NAMES2['MN'] = 'mn';
	TAG_NAMES2['MS'] = 'ms';
	TAG_NAMES2['MTEXT'] = 'mtext';
	TAG_NAMES2['NAV'] = 'nav';
	TAG_NAMES2['NOBR'] = 'nobr';
	TAG_NAMES2['NOFRAMES'] = 'noframes';
	TAG_NAMES2['NOEMBED'] = 'noembed';
	TAG_NAMES2['NOSCRIPT'] = 'noscript';
	TAG_NAMES2['OBJECT'] = 'object';
	TAG_NAMES2['OL'] = 'ol';
	TAG_NAMES2['OPTGROUP'] = 'optgroup';
	TAG_NAMES2['OPTION'] = 'option';
	TAG_NAMES2['P'] = 'p';
	TAG_NAMES2['PARAM'] = 'param';
	TAG_NAMES2['PLAINTEXT'] = 'plaintext';
	TAG_NAMES2['PRE'] = 'pre';
	TAG_NAMES2['RB'] = 'rb';
	TAG_NAMES2['RP'] = 'rp';
	TAG_NAMES2['RT'] = 'rt';
	TAG_NAMES2['RTC'] = 'rtc';
	TAG_NAMES2['RUBY'] = 'ruby';
	TAG_NAMES2['S'] = 's';
	TAG_NAMES2['SCRIPT'] = 'script';
	TAG_NAMES2['SEARCH'] = 'search';
	TAG_NAMES2['SECTION'] = 'section';
	TAG_NAMES2['SELECT'] = 'select';
	TAG_NAMES2['SOURCE'] = 'source';
	TAG_NAMES2['SMALL'] = 'small';
	TAG_NAMES2['SPAN'] = 'span';
	TAG_NAMES2['STRIKE'] = 'strike';
	TAG_NAMES2['STRONG'] = 'strong';
	TAG_NAMES2['STYLE'] = 'style';
	TAG_NAMES2['SUB'] = 'sub';
	TAG_NAMES2['SUMMARY'] = 'summary';
	TAG_NAMES2['SUP'] = 'sup';
	TAG_NAMES2['TABLE'] = 'table';
	TAG_NAMES2['TBODY'] = 'tbody';
	TAG_NAMES2['TEMPLATE'] = 'template';
	TAG_NAMES2['TEXTAREA'] = 'textarea';
	TAG_NAMES2['TFOOT'] = 'tfoot';
	TAG_NAMES2['TD'] = 'td';
	TAG_NAMES2['TH'] = 'th';
	TAG_NAMES2['THEAD'] = 'thead';
	TAG_NAMES2['TITLE'] = 'title';
	TAG_NAMES2['TR'] = 'tr';
	TAG_NAMES2['TRACK'] = 'track';
	TAG_NAMES2['TT'] = 'tt';
	TAG_NAMES2['U'] = 'u';
	TAG_NAMES2['UL'] = 'ul';
	TAG_NAMES2['SVG'] = 'svg';
	TAG_NAMES2['VAR'] = 'var';
	TAG_NAMES2['WBR'] = 'wbr';
	TAG_NAMES2['XMP'] = 'xmp';
})(TAG_NAMES || (TAG_NAMES = {}));
var TAG_ID;
(function (TAG_ID2) {
	TAG_ID2[(TAG_ID2['UNKNOWN'] = 0)] = 'UNKNOWN';
	TAG_ID2[(TAG_ID2['A'] = 1)] = 'A';
	TAG_ID2[(TAG_ID2['ADDRESS'] = 2)] = 'ADDRESS';
	TAG_ID2[(TAG_ID2['ANNOTATION_XML'] = 3)] = 'ANNOTATION_XML';
	TAG_ID2[(TAG_ID2['APPLET'] = 4)] = 'APPLET';
	TAG_ID2[(TAG_ID2['AREA'] = 5)] = 'AREA';
	TAG_ID2[(TAG_ID2['ARTICLE'] = 6)] = 'ARTICLE';
	TAG_ID2[(TAG_ID2['ASIDE'] = 7)] = 'ASIDE';
	TAG_ID2[(TAG_ID2['B'] = 8)] = 'B';
	TAG_ID2[(TAG_ID2['BASE'] = 9)] = 'BASE';
	TAG_ID2[(TAG_ID2['BASEFONT'] = 10)] = 'BASEFONT';
	TAG_ID2[(TAG_ID2['BGSOUND'] = 11)] = 'BGSOUND';
	TAG_ID2[(TAG_ID2['BIG'] = 12)] = 'BIG';
	TAG_ID2[(TAG_ID2['BLOCKQUOTE'] = 13)] = 'BLOCKQUOTE';
	TAG_ID2[(TAG_ID2['BODY'] = 14)] = 'BODY';
	TAG_ID2[(TAG_ID2['BR'] = 15)] = 'BR';
	TAG_ID2[(TAG_ID2['BUTTON'] = 16)] = 'BUTTON';
	TAG_ID2[(TAG_ID2['CAPTION'] = 17)] = 'CAPTION';
	TAG_ID2[(TAG_ID2['CENTER'] = 18)] = 'CENTER';
	TAG_ID2[(TAG_ID2['CODE'] = 19)] = 'CODE';
	TAG_ID2[(TAG_ID2['COL'] = 20)] = 'COL';
	TAG_ID2[(TAG_ID2['COLGROUP'] = 21)] = 'COLGROUP';
	TAG_ID2[(TAG_ID2['DD'] = 22)] = 'DD';
	TAG_ID2[(TAG_ID2['DESC'] = 23)] = 'DESC';
	TAG_ID2[(TAG_ID2['DETAILS'] = 24)] = 'DETAILS';
	TAG_ID2[(TAG_ID2['DIALOG'] = 25)] = 'DIALOG';
	TAG_ID2[(TAG_ID2['DIR'] = 26)] = 'DIR';
	TAG_ID2[(TAG_ID2['DIV'] = 27)] = 'DIV';
	TAG_ID2[(TAG_ID2['DL'] = 28)] = 'DL';
	TAG_ID2[(TAG_ID2['DT'] = 29)] = 'DT';
	TAG_ID2[(TAG_ID2['EM'] = 30)] = 'EM';
	TAG_ID2[(TAG_ID2['EMBED'] = 31)] = 'EMBED';
	TAG_ID2[(TAG_ID2['FIELDSET'] = 32)] = 'FIELDSET';
	TAG_ID2[(TAG_ID2['FIGCAPTION'] = 33)] = 'FIGCAPTION';
	TAG_ID2[(TAG_ID2['FIGURE'] = 34)] = 'FIGURE';
	TAG_ID2[(TAG_ID2['FONT'] = 35)] = 'FONT';
	TAG_ID2[(TAG_ID2['FOOTER'] = 36)] = 'FOOTER';
	TAG_ID2[(TAG_ID2['FOREIGN_OBJECT'] = 37)] = 'FOREIGN_OBJECT';
	TAG_ID2[(TAG_ID2['FORM'] = 38)] = 'FORM';
	TAG_ID2[(TAG_ID2['FRAME'] = 39)] = 'FRAME';
	TAG_ID2[(TAG_ID2['FRAMESET'] = 40)] = 'FRAMESET';
	TAG_ID2[(TAG_ID2['H1'] = 41)] = 'H1';
	TAG_ID2[(TAG_ID2['H2'] = 42)] = 'H2';
	TAG_ID2[(TAG_ID2['H3'] = 43)] = 'H3';
	TAG_ID2[(TAG_ID2['H4'] = 44)] = 'H4';
	TAG_ID2[(TAG_ID2['H5'] = 45)] = 'H5';
	TAG_ID2[(TAG_ID2['H6'] = 46)] = 'H6';
	TAG_ID2[(TAG_ID2['HEAD'] = 47)] = 'HEAD';
	TAG_ID2[(TAG_ID2['HEADER'] = 48)] = 'HEADER';
	TAG_ID2[(TAG_ID2['HGROUP'] = 49)] = 'HGROUP';
	TAG_ID2[(TAG_ID2['HR'] = 50)] = 'HR';
	TAG_ID2[(TAG_ID2['HTML'] = 51)] = 'HTML';
	TAG_ID2[(TAG_ID2['I'] = 52)] = 'I';
	TAG_ID2[(TAG_ID2['IMG'] = 53)] = 'IMG';
	TAG_ID2[(TAG_ID2['IMAGE'] = 54)] = 'IMAGE';
	TAG_ID2[(TAG_ID2['INPUT'] = 55)] = 'INPUT';
	TAG_ID2[(TAG_ID2['IFRAME'] = 56)] = 'IFRAME';
	TAG_ID2[(TAG_ID2['KEYGEN'] = 57)] = 'KEYGEN';
	TAG_ID2[(TAG_ID2['LABEL'] = 58)] = 'LABEL';
	TAG_ID2[(TAG_ID2['LI'] = 59)] = 'LI';
	TAG_ID2[(TAG_ID2['LINK'] = 60)] = 'LINK';
	TAG_ID2[(TAG_ID2['LISTING'] = 61)] = 'LISTING';
	TAG_ID2[(TAG_ID2['MAIN'] = 62)] = 'MAIN';
	TAG_ID2[(TAG_ID2['MALIGNMARK'] = 63)] = 'MALIGNMARK';
	TAG_ID2[(TAG_ID2['MARQUEE'] = 64)] = 'MARQUEE';
	TAG_ID2[(TAG_ID2['MATH'] = 65)] = 'MATH';
	TAG_ID2[(TAG_ID2['MENU'] = 66)] = 'MENU';
	TAG_ID2[(TAG_ID2['META'] = 67)] = 'META';
	TAG_ID2[(TAG_ID2['MGLYPH'] = 68)] = 'MGLYPH';
	TAG_ID2[(TAG_ID2['MI'] = 69)] = 'MI';
	TAG_ID2[(TAG_ID2['MO'] = 70)] = 'MO';
	TAG_ID2[(TAG_ID2['MN'] = 71)] = 'MN';
	TAG_ID2[(TAG_ID2['MS'] = 72)] = 'MS';
	TAG_ID2[(TAG_ID2['MTEXT'] = 73)] = 'MTEXT';
	TAG_ID2[(TAG_ID2['NAV'] = 74)] = 'NAV';
	TAG_ID2[(TAG_ID2['NOBR'] = 75)] = 'NOBR';
	TAG_ID2[(TAG_ID2['NOFRAMES'] = 76)] = 'NOFRAMES';
	TAG_ID2[(TAG_ID2['NOEMBED'] = 77)] = 'NOEMBED';
	TAG_ID2[(TAG_ID2['NOSCRIPT'] = 78)] = 'NOSCRIPT';
	TAG_ID2[(TAG_ID2['OBJECT'] = 79)] = 'OBJECT';
	TAG_ID2[(TAG_ID2['OL'] = 80)] = 'OL';
	TAG_ID2[(TAG_ID2['OPTGROUP'] = 81)] = 'OPTGROUP';
	TAG_ID2[(TAG_ID2['OPTION'] = 82)] = 'OPTION';
	TAG_ID2[(TAG_ID2['P'] = 83)] = 'P';
	TAG_ID2[(TAG_ID2['PARAM'] = 84)] = 'PARAM';
	TAG_ID2[(TAG_ID2['PLAINTEXT'] = 85)] = 'PLAINTEXT';
	TAG_ID2[(TAG_ID2['PRE'] = 86)] = 'PRE';
	TAG_ID2[(TAG_ID2['RB'] = 87)] = 'RB';
	TAG_ID2[(TAG_ID2['RP'] = 88)] = 'RP';
	TAG_ID2[(TAG_ID2['RT'] = 89)] = 'RT';
	TAG_ID2[(TAG_ID2['RTC'] = 90)] = 'RTC';
	TAG_ID2[(TAG_ID2['RUBY'] = 91)] = 'RUBY';
	TAG_ID2[(TAG_ID2['S'] = 92)] = 'S';
	TAG_ID2[(TAG_ID2['SCRIPT'] = 93)] = 'SCRIPT';
	TAG_ID2[(TAG_ID2['SEARCH'] = 94)] = 'SEARCH';
	TAG_ID2[(TAG_ID2['SECTION'] = 95)] = 'SECTION';
	TAG_ID2[(TAG_ID2['SELECT'] = 96)] = 'SELECT';
	TAG_ID2[(TAG_ID2['SOURCE'] = 97)] = 'SOURCE';
	TAG_ID2[(TAG_ID2['SMALL'] = 98)] = 'SMALL';
	TAG_ID2[(TAG_ID2['SPAN'] = 99)] = 'SPAN';
	TAG_ID2[(TAG_ID2['STRIKE'] = 100)] = 'STRIKE';
	TAG_ID2[(TAG_ID2['STRONG'] = 101)] = 'STRONG';
	TAG_ID2[(TAG_ID2['STYLE'] = 102)] = 'STYLE';
	TAG_ID2[(TAG_ID2['SUB'] = 103)] = 'SUB';
	TAG_ID2[(TAG_ID2['SUMMARY'] = 104)] = 'SUMMARY';
	TAG_ID2[(TAG_ID2['SUP'] = 105)] = 'SUP';
	TAG_ID2[(TAG_ID2['TABLE'] = 106)] = 'TABLE';
	TAG_ID2[(TAG_ID2['TBODY'] = 107)] = 'TBODY';
	TAG_ID2[(TAG_ID2['TEMPLATE'] = 108)] = 'TEMPLATE';
	TAG_ID2[(TAG_ID2['TEXTAREA'] = 109)] = 'TEXTAREA';
	TAG_ID2[(TAG_ID2['TFOOT'] = 110)] = 'TFOOT';
	TAG_ID2[(TAG_ID2['TD'] = 111)] = 'TD';
	TAG_ID2[(TAG_ID2['TH'] = 112)] = 'TH';
	TAG_ID2[(TAG_ID2['THEAD'] = 113)] = 'THEAD';
	TAG_ID2[(TAG_ID2['TITLE'] = 114)] = 'TITLE';
	TAG_ID2[(TAG_ID2['TR'] = 115)] = 'TR';
	TAG_ID2[(TAG_ID2['TRACK'] = 116)] = 'TRACK';
	TAG_ID2[(TAG_ID2['TT'] = 117)] = 'TT';
	TAG_ID2[(TAG_ID2['U'] = 118)] = 'U';
	TAG_ID2[(TAG_ID2['UL'] = 119)] = 'UL';
	TAG_ID2[(TAG_ID2['SVG'] = 120)] = 'SVG';
	TAG_ID2[(TAG_ID2['VAR'] = 121)] = 'VAR';
	TAG_ID2[(TAG_ID2['WBR'] = 122)] = 'WBR';
	TAG_ID2[(TAG_ID2['XMP'] = 123)] = 'XMP';
})(TAG_ID || (TAG_ID = {}));
var TAG_NAME_TO_ID = /* @__PURE__ */ new Map([
	[TAG_NAMES.A, TAG_ID.A],
	[TAG_NAMES.ADDRESS, TAG_ID.ADDRESS],
	[TAG_NAMES.ANNOTATION_XML, TAG_ID.ANNOTATION_XML],
	[TAG_NAMES.APPLET, TAG_ID.APPLET],
	[TAG_NAMES.AREA, TAG_ID.AREA],
	[TAG_NAMES.ARTICLE, TAG_ID.ARTICLE],
	[TAG_NAMES.ASIDE, TAG_ID.ASIDE],
	[TAG_NAMES.B, TAG_ID.B],
	[TAG_NAMES.BASE, TAG_ID.BASE],
	[TAG_NAMES.BASEFONT, TAG_ID.BASEFONT],
	[TAG_NAMES.BGSOUND, TAG_ID.BGSOUND],
	[TAG_NAMES.BIG, TAG_ID.BIG],
	[TAG_NAMES.BLOCKQUOTE, TAG_ID.BLOCKQUOTE],
	[TAG_NAMES.BODY, TAG_ID.BODY],
	[TAG_NAMES.BR, TAG_ID.BR],
	[TAG_NAMES.BUTTON, TAG_ID.BUTTON],
	[TAG_NAMES.CAPTION, TAG_ID.CAPTION],
	[TAG_NAMES.CENTER, TAG_ID.CENTER],
	[TAG_NAMES.CODE, TAG_ID.CODE],
	[TAG_NAMES.COL, TAG_ID.COL],
	[TAG_NAMES.COLGROUP, TAG_ID.COLGROUP],
	[TAG_NAMES.DD, TAG_ID.DD],
	[TAG_NAMES.DESC, TAG_ID.DESC],
	[TAG_NAMES.DETAILS, TAG_ID.DETAILS],
	[TAG_NAMES.DIALOG, TAG_ID.DIALOG],
	[TAG_NAMES.DIR, TAG_ID.DIR],
	[TAG_NAMES.DIV, TAG_ID.DIV],
	[TAG_NAMES.DL, TAG_ID.DL],
	[TAG_NAMES.DT, TAG_ID.DT],
	[TAG_NAMES.EM, TAG_ID.EM],
	[TAG_NAMES.EMBED, TAG_ID.EMBED],
	[TAG_NAMES.FIELDSET, TAG_ID.FIELDSET],
	[TAG_NAMES.FIGCAPTION, TAG_ID.FIGCAPTION],
	[TAG_NAMES.FIGURE, TAG_ID.FIGURE],
	[TAG_NAMES.FONT, TAG_ID.FONT],
	[TAG_NAMES.FOOTER, TAG_ID.FOOTER],
	[TAG_NAMES.FOREIGN_OBJECT, TAG_ID.FOREIGN_OBJECT],
	[TAG_NAMES.FORM, TAG_ID.FORM],
	[TAG_NAMES.FRAME, TAG_ID.FRAME],
	[TAG_NAMES.FRAMESET, TAG_ID.FRAMESET],
	[TAG_NAMES.H1, TAG_ID.H1],
	[TAG_NAMES.H2, TAG_ID.H2],
	[TAG_NAMES.H3, TAG_ID.H3],
	[TAG_NAMES.H4, TAG_ID.H4],
	[TAG_NAMES.H5, TAG_ID.H5],
	[TAG_NAMES.H6, TAG_ID.H6],
	[TAG_NAMES.HEAD, TAG_ID.HEAD],
	[TAG_NAMES.HEADER, TAG_ID.HEADER],
	[TAG_NAMES.HGROUP, TAG_ID.HGROUP],
	[TAG_NAMES.HR, TAG_ID.HR],
	[TAG_NAMES.HTML, TAG_ID.HTML],
	[TAG_NAMES.I, TAG_ID.I],
	[TAG_NAMES.IMG, TAG_ID.IMG],
	[TAG_NAMES.IMAGE, TAG_ID.IMAGE],
	[TAG_NAMES.INPUT, TAG_ID.INPUT],
	[TAG_NAMES.IFRAME, TAG_ID.IFRAME],
	[TAG_NAMES.KEYGEN, TAG_ID.KEYGEN],
	[TAG_NAMES.LABEL, TAG_ID.LABEL],
	[TAG_NAMES.LI, TAG_ID.LI],
	[TAG_NAMES.LINK, TAG_ID.LINK],
	[TAG_NAMES.LISTING, TAG_ID.LISTING],
	[TAG_NAMES.MAIN, TAG_ID.MAIN],
	[TAG_NAMES.MALIGNMARK, TAG_ID.MALIGNMARK],
	[TAG_NAMES.MARQUEE, TAG_ID.MARQUEE],
	[TAG_NAMES.MATH, TAG_ID.MATH],
	[TAG_NAMES.MENU, TAG_ID.MENU],
	[TAG_NAMES.META, TAG_ID.META],
	[TAG_NAMES.MGLYPH, TAG_ID.MGLYPH],
	[TAG_NAMES.MI, TAG_ID.MI],
	[TAG_NAMES.MO, TAG_ID.MO],
	[TAG_NAMES.MN, TAG_ID.MN],
	[TAG_NAMES.MS, TAG_ID.MS],
	[TAG_NAMES.MTEXT, TAG_ID.MTEXT],
	[TAG_NAMES.NAV, TAG_ID.NAV],
	[TAG_NAMES.NOBR, TAG_ID.NOBR],
	[TAG_NAMES.NOFRAMES, TAG_ID.NOFRAMES],
	[TAG_NAMES.NOEMBED, TAG_ID.NOEMBED],
	[TAG_NAMES.NOSCRIPT, TAG_ID.NOSCRIPT],
	[TAG_NAMES.OBJECT, TAG_ID.OBJECT],
	[TAG_NAMES.OL, TAG_ID.OL],
	[TAG_NAMES.OPTGROUP, TAG_ID.OPTGROUP],
	[TAG_NAMES.OPTION, TAG_ID.OPTION],
	[TAG_NAMES.P, TAG_ID.P],
	[TAG_NAMES.PARAM, TAG_ID.PARAM],
	[TAG_NAMES.PLAINTEXT, TAG_ID.PLAINTEXT],
	[TAG_NAMES.PRE, TAG_ID.PRE],
	[TAG_NAMES.RB, TAG_ID.RB],
	[TAG_NAMES.RP, TAG_ID.RP],
	[TAG_NAMES.RT, TAG_ID.RT],
	[TAG_NAMES.RTC, TAG_ID.RTC],
	[TAG_NAMES.RUBY, TAG_ID.RUBY],
	[TAG_NAMES.S, TAG_ID.S],
	[TAG_NAMES.SCRIPT, TAG_ID.SCRIPT],
	[TAG_NAMES.SEARCH, TAG_ID.SEARCH],
	[TAG_NAMES.SECTION, TAG_ID.SECTION],
	[TAG_NAMES.SELECT, TAG_ID.SELECT],
	[TAG_NAMES.SOURCE, TAG_ID.SOURCE],
	[TAG_NAMES.SMALL, TAG_ID.SMALL],
	[TAG_NAMES.SPAN, TAG_ID.SPAN],
	[TAG_NAMES.STRIKE, TAG_ID.STRIKE],
	[TAG_NAMES.STRONG, TAG_ID.STRONG],
	[TAG_NAMES.STYLE, TAG_ID.STYLE],
	[TAG_NAMES.SUB, TAG_ID.SUB],
	[TAG_NAMES.SUMMARY, TAG_ID.SUMMARY],
	[TAG_NAMES.SUP, TAG_ID.SUP],
	[TAG_NAMES.TABLE, TAG_ID.TABLE],
	[TAG_NAMES.TBODY, TAG_ID.TBODY],
	[TAG_NAMES.TEMPLATE, TAG_ID.TEMPLATE],
	[TAG_NAMES.TEXTAREA, TAG_ID.TEXTAREA],
	[TAG_NAMES.TFOOT, TAG_ID.TFOOT],
	[TAG_NAMES.TD, TAG_ID.TD],
	[TAG_NAMES.TH, TAG_ID.TH],
	[TAG_NAMES.THEAD, TAG_ID.THEAD],
	[TAG_NAMES.TITLE, TAG_ID.TITLE],
	[TAG_NAMES.TR, TAG_ID.TR],
	[TAG_NAMES.TRACK, TAG_ID.TRACK],
	[TAG_NAMES.TT, TAG_ID.TT],
	[TAG_NAMES.U, TAG_ID.U],
	[TAG_NAMES.UL, TAG_ID.UL],
	[TAG_NAMES.SVG, TAG_ID.SVG],
	[TAG_NAMES.VAR, TAG_ID.VAR],
	[TAG_NAMES.WBR, TAG_ID.WBR],
	[TAG_NAMES.XMP, TAG_ID.XMP],
]);
function getTagID(tagName) {
	var _a2;
	return (_a2 = TAG_NAME_TO_ID.get(tagName)) !== null && _a2 !== void 0 ? _a2 : TAG_ID.UNKNOWN;
}
var $ = TAG_ID;
var SPECIAL_ELEMENTS = {
	[NS.HTML]: /* @__PURE__ */ new Set([
		$.ADDRESS,
		$.APPLET,
		$.AREA,
		$.ARTICLE,
		$.ASIDE,
		$.BASE,
		$.BASEFONT,
		$.BGSOUND,
		$.BLOCKQUOTE,
		$.BODY,
		$.BR,
		$.BUTTON,
		$.CAPTION,
		$.CENTER,
		$.COL,
		$.COLGROUP,
		$.DD,
		$.DETAILS,
		$.DIR,
		$.DIV,
		$.DL,
		$.DT,
		$.EMBED,
		$.FIELDSET,
		$.FIGCAPTION,
		$.FIGURE,
		$.FOOTER,
		$.FORM,
		$.FRAME,
		$.FRAMESET,
		$.H1,
		$.H2,
		$.H3,
		$.H4,
		$.H5,
		$.H6,
		$.HEAD,
		$.HEADER,
		$.HGROUP,
		$.HR,
		$.HTML,
		$.IFRAME,
		$.IMG,
		$.INPUT,
		$.LI,
		$.LINK,
		$.LISTING,
		$.MAIN,
		$.MARQUEE,
		$.MENU,
		$.META,
		$.NAV,
		$.NOEMBED,
		$.NOFRAMES,
		$.NOSCRIPT,
		$.OBJECT,
		$.OL,
		$.P,
		$.PARAM,
		$.PLAINTEXT,
		$.PRE,
		$.SCRIPT,
		$.SECTION,
		$.SELECT,
		$.SOURCE,
		$.STYLE,
		$.SUMMARY,
		$.TABLE,
		$.TBODY,
		$.TD,
		$.TEMPLATE,
		$.TEXTAREA,
		$.TFOOT,
		$.TH,
		$.THEAD,
		$.TITLE,
		$.TR,
		$.TRACK,
		$.UL,
		$.WBR,
		$.XMP,
	]),
	[NS.MATHML]: /* @__PURE__ */ new Set([$.MI, $.MO, $.MN, $.MS, $.MTEXT, $.ANNOTATION_XML]),
	[NS.SVG]: /* @__PURE__ */ new Set([$.TITLE, $.FOREIGN_OBJECT, $.DESC]),
	[NS.XLINK]: /* @__PURE__ */ new Set(),
	[NS.XML]: /* @__PURE__ */ new Set(),
	[NS.XMLNS]: /* @__PURE__ */ new Set(),
};
var NUMBERED_HEADERS = /* @__PURE__ */ new Set([$.H1, $.H2, $.H3, $.H4, $.H5, $.H6]);
var UNESCAPED_TEXT = /* @__PURE__ */ new Set([
	TAG_NAMES.STYLE,
	TAG_NAMES.SCRIPT,
	TAG_NAMES.XMP,
	TAG_NAMES.IFRAME,
	TAG_NAMES.NOEMBED,
	TAG_NAMES.NOFRAMES,
	TAG_NAMES.PLAINTEXT,
]);
function hasUnescapedText(tn, scriptingEnabled) {
	return UNESCAPED_TEXT.has(tn) || (scriptingEnabled && tn === TAG_NAMES.NOSCRIPT);
}

// node_modules/parse5/dist/tokenizer/index.js
var State;
(function (State2) {
	State2[(State2['DATA'] = 0)] = 'DATA';
	State2[(State2['RCDATA'] = 1)] = 'RCDATA';
	State2[(State2['RAWTEXT'] = 2)] = 'RAWTEXT';
	State2[(State2['SCRIPT_DATA'] = 3)] = 'SCRIPT_DATA';
	State2[(State2['PLAINTEXT'] = 4)] = 'PLAINTEXT';
	State2[(State2['TAG_OPEN'] = 5)] = 'TAG_OPEN';
	State2[(State2['END_TAG_OPEN'] = 6)] = 'END_TAG_OPEN';
	State2[(State2['TAG_NAME'] = 7)] = 'TAG_NAME';
	State2[(State2['RCDATA_LESS_THAN_SIGN'] = 8)] = 'RCDATA_LESS_THAN_SIGN';
	State2[(State2['RCDATA_END_TAG_OPEN'] = 9)] = 'RCDATA_END_TAG_OPEN';
	State2[(State2['RCDATA_END_TAG_NAME'] = 10)] = 'RCDATA_END_TAG_NAME';
	State2[(State2['RAWTEXT_LESS_THAN_SIGN'] = 11)] = 'RAWTEXT_LESS_THAN_SIGN';
	State2[(State2['RAWTEXT_END_TAG_OPEN'] = 12)] = 'RAWTEXT_END_TAG_OPEN';
	State2[(State2['RAWTEXT_END_TAG_NAME'] = 13)] = 'RAWTEXT_END_TAG_NAME';
	State2[(State2['SCRIPT_DATA_LESS_THAN_SIGN'] = 14)] = 'SCRIPT_DATA_LESS_THAN_SIGN';
	State2[(State2['SCRIPT_DATA_END_TAG_OPEN'] = 15)] = 'SCRIPT_DATA_END_TAG_OPEN';
	State2[(State2['SCRIPT_DATA_END_TAG_NAME'] = 16)] = 'SCRIPT_DATA_END_TAG_NAME';
	State2[(State2['SCRIPT_DATA_ESCAPE_START'] = 17)] = 'SCRIPT_DATA_ESCAPE_START';
	State2[(State2['SCRIPT_DATA_ESCAPE_START_DASH'] = 18)] = 'SCRIPT_DATA_ESCAPE_START_DASH';
	State2[(State2['SCRIPT_DATA_ESCAPED'] = 19)] = 'SCRIPT_DATA_ESCAPED';
	State2[(State2['SCRIPT_DATA_ESCAPED_DASH'] = 20)] = 'SCRIPT_DATA_ESCAPED_DASH';
	State2[(State2['SCRIPT_DATA_ESCAPED_DASH_DASH'] = 21)] = 'SCRIPT_DATA_ESCAPED_DASH_DASH';
	State2[(State2['SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN'] = 22)] = 'SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN';
	State2[(State2['SCRIPT_DATA_ESCAPED_END_TAG_OPEN'] = 23)] = 'SCRIPT_DATA_ESCAPED_END_TAG_OPEN';
	State2[(State2['SCRIPT_DATA_ESCAPED_END_TAG_NAME'] = 24)] = 'SCRIPT_DATA_ESCAPED_END_TAG_NAME';
	State2[(State2['SCRIPT_DATA_DOUBLE_ESCAPE_START'] = 25)] = 'SCRIPT_DATA_DOUBLE_ESCAPE_START';
	State2[(State2['SCRIPT_DATA_DOUBLE_ESCAPED'] = 26)] = 'SCRIPT_DATA_DOUBLE_ESCAPED';
	State2[(State2['SCRIPT_DATA_DOUBLE_ESCAPED_DASH'] = 27)] = 'SCRIPT_DATA_DOUBLE_ESCAPED_DASH';
	State2[(State2['SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH'] = 28)] = 'SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH';
	State2[(State2['SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN'] = 29)] = 'SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN';
	State2[(State2['SCRIPT_DATA_DOUBLE_ESCAPE_END'] = 30)] = 'SCRIPT_DATA_DOUBLE_ESCAPE_END';
	State2[(State2['BEFORE_ATTRIBUTE_NAME'] = 31)] = 'BEFORE_ATTRIBUTE_NAME';
	State2[(State2['ATTRIBUTE_NAME'] = 32)] = 'ATTRIBUTE_NAME';
	State2[(State2['AFTER_ATTRIBUTE_NAME'] = 33)] = 'AFTER_ATTRIBUTE_NAME';
	State2[(State2['BEFORE_ATTRIBUTE_VALUE'] = 34)] = 'BEFORE_ATTRIBUTE_VALUE';
	State2[(State2['ATTRIBUTE_VALUE_DOUBLE_QUOTED'] = 35)] = 'ATTRIBUTE_VALUE_DOUBLE_QUOTED';
	State2[(State2['ATTRIBUTE_VALUE_SINGLE_QUOTED'] = 36)] = 'ATTRIBUTE_VALUE_SINGLE_QUOTED';
	State2[(State2['ATTRIBUTE_VALUE_UNQUOTED'] = 37)] = 'ATTRIBUTE_VALUE_UNQUOTED';
	State2[(State2['AFTER_ATTRIBUTE_VALUE_QUOTED'] = 38)] = 'AFTER_ATTRIBUTE_VALUE_QUOTED';
	State2[(State2['SELF_CLOSING_START_TAG'] = 39)] = 'SELF_CLOSING_START_TAG';
	State2[(State2['BOGUS_COMMENT'] = 40)] = 'BOGUS_COMMENT';
	State2[(State2['MARKUP_DECLARATION_OPEN'] = 41)] = 'MARKUP_DECLARATION_OPEN';
	State2[(State2['COMMENT_START'] = 42)] = 'COMMENT_START';
	State2[(State2['COMMENT_START_DASH'] = 43)] = 'COMMENT_START_DASH';
	State2[(State2['COMMENT'] = 44)] = 'COMMENT';
	State2[(State2['COMMENT_LESS_THAN_SIGN'] = 45)] = 'COMMENT_LESS_THAN_SIGN';
	State2[(State2['COMMENT_LESS_THAN_SIGN_BANG'] = 46)] = 'COMMENT_LESS_THAN_SIGN_BANG';
	State2[(State2['COMMENT_LESS_THAN_SIGN_BANG_DASH'] = 47)] = 'COMMENT_LESS_THAN_SIGN_BANG_DASH';
	State2[(State2['COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH'] = 48)] = 'COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH';
	State2[(State2['COMMENT_END_DASH'] = 49)] = 'COMMENT_END_DASH';
	State2[(State2['COMMENT_END'] = 50)] = 'COMMENT_END';
	State2[(State2['COMMENT_END_BANG'] = 51)] = 'COMMENT_END_BANG';
	State2[(State2['DOCTYPE'] = 52)] = 'DOCTYPE';
	State2[(State2['BEFORE_DOCTYPE_NAME'] = 53)] = 'BEFORE_DOCTYPE_NAME';
	State2[(State2['DOCTYPE_NAME'] = 54)] = 'DOCTYPE_NAME';
	State2[(State2['AFTER_DOCTYPE_NAME'] = 55)] = 'AFTER_DOCTYPE_NAME';
	State2[(State2['AFTER_DOCTYPE_PUBLIC_KEYWORD'] = 56)] = 'AFTER_DOCTYPE_PUBLIC_KEYWORD';
	State2[(State2['BEFORE_DOCTYPE_PUBLIC_IDENTIFIER'] = 57)] = 'BEFORE_DOCTYPE_PUBLIC_IDENTIFIER';
	State2[(State2['DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED'] = 58)] = 'DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED';
	State2[(State2['DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED'] = 59)] = 'DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED';
	State2[(State2['AFTER_DOCTYPE_PUBLIC_IDENTIFIER'] = 60)] = 'AFTER_DOCTYPE_PUBLIC_IDENTIFIER';
	State2[(State2['BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS'] = 61)] =
		'BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS';
	State2[(State2['AFTER_DOCTYPE_SYSTEM_KEYWORD'] = 62)] = 'AFTER_DOCTYPE_SYSTEM_KEYWORD';
	State2[(State2['BEFORE_DOCTYPE_SYSTEM_IDENTIFIER'] = 63)] = 'BEFORE_DOCTYPE_SYSTEM_IDENTIFIER';
	State2[(State2['DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED'] = 64)] = 'DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED';
	State2[(State2['DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED'] = 65)] = 'DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED';
	State2[(State2['AFTER_DOCTYPE_SYSTEM_IDENTIFIER'] = 66)] = 'AFTER_DOCTYPE_SYSTEM_IDENTIFIER';
	State2[(State2['BOGUS_DOCTYPE'] = 67)] = 'BOGUS_DOCTYPE';
	State2[(State2['CDATA_SECTION'] = 68)] = 'CDATA_SECTION';
	State2[(State2['CDATA_SECTION_BRACKET'] = 69)] = 'CDATA_SECTION_BRACKET';
	State2[(State2['CDATA_SECTION_END'] = 70)] = 'CDATA_SECTION_END';
	State2[(State2['CHARACTER_REFERENCE'] = 71)] = 'CHARACTER_REFERENCE';
	State2[(State2['AMBIGUOUS_AMPERSAND'] = 72)] = 'AMBIGUOUS_AMPERSAND';
})(State || (State = {}));
var TokenizerMode = {
	DATA: State.DATA,
	RCDATA: State.RCDATA,
	RAWTEXT: State.RAWTEXT,
	SCRIPT_DATA: State.SCRIPT_DATA,
	PLAINTEXT: State.PLAINTEXT,
	CDATA_SECTION: State.CDATA_SECTION,
};
function isAsciiDigit(cp) {
	return cp >= CODE_POINTS.DIGIT_0 && cp <= CODE_POINTS.DIGIT_9;
}
function isAsciiUpper(cp) {
	return cp >= CODE_POINTS.LATIN_CAPITAL_A && cp <= CODE_POINTS.LATIN_CAPITAL_Z;
}
function isAsciiLower(cp) {
	return cp >= CODE_POINTS.LATIN_SMALL_A && cp <= CODE_POINTS.LATIN_SMALL_Z;
}
function isAsciiLetter(cp) {
	return isAsciiLower(cp) || isAsciiUpper(cp);
}
function isAsciiAlphaNumeric2(cp) {
	return isAsciiLetter(cp) || isAsciiDigit(cp);
}
function toAsciiLower(cp) {
	return cp + 32;
}
function isWhitespace(cp) {
	return (
		cp === CODE_POINTS.SPACE ||
		cp === CODE_POINTS.LINE_FEED ||
		cp === CODE_POINTS.TABULATION ||
		cp === CODE_POINTS.FORM_FEED
	);
}
function isScriptDataDoubleEscapeSequenceEnd(cp) {
	return isWhitespace(cp) || cp === CODE_POINTS.SOLIDUS || cp === CODE_POINTS.GREATER_THAN_SIGN;
}
function getErrorForNumericCharacterReference(code) {
	if (code === CODE_POINTS.NULL) {
		return ERR.nullCharacterReference;
	} else if (code > 1114111) {
		return ERR.characterReferenceOutsideUnicodeRange;
	} else if (isSurrogate(code)) {
		return ERR.surrogateCharacterReference;
	} else if (isUndefinedCodePoint(code)) {
		return ERR.noncharacterCharacterReference;
	} else if (isControlCodePoint(code) || code === CODE_POINTS.CARRIAGE_RETURN) {
		return ERR.controlCharacterReference;
	}
	return null;
}
var Tokenizer = class {
	constructor(options, handler) {
		this.options = options;
		this.handler = handler;
		this.paused = false;
		this.inLoop = false;
		this.inForeignNode = false;
		this.lastStartTagName = '';
		this.active = false;
		this.state = State.DATA;
		this.returnState = State.DATA;
		this.entityStartPos = 0;
		this.consumedAfterSnapshot = -1;
		this.currentCharacterToken = null;
		this.currentToken = null;
		this.currentAttr = { name: '', value: '' };
		this.preprocessor = new Preprocessor(handler);
		this.currentLocation = this.getCurrentLocation(-1);
		this.entityDecoder = new EntityDecoder(
			decode_data_html_default,
			(cp, consumed) => {
				this.preprocessor.pos = this.entityStartPos + consumed - 1;
				this._flushCodePointConsumedAsCharacterReference(cp);
			},
			handler.onParseError
				? {
						missingSemicolonAfterCharacterReference: () => {
							this._err(ERR.missingSemicolonAfterCharacterReference, 1);
						},
						absenceOfDigitsInNumericCharacterReference: (consumed) => {
							this._err(
								ERR.absenceOfDigitsInNumericCharacterReference,
								this.entityStartPos - this.preprocessor.pos + consumed,
							);
						},
						validateNumericCharacterReference: (code) => {
							const error = getErrorForNumericCharacterReference(code);
							if (error) this._err(error, 1);
						},
					}
				: void 0,
		);
	}
	//Errors
	_err(code, cpOffset = 0) {
		var _a2, _b;
		(_b = (_a2 = this.handler).onParseError) === null || _b === void 0
			? void 0
			: _b.call(_a2, this.preprocessor.getError(code, cpOffset));
	}
	// NOTE: `offset` may never run across line boundaries.
	getCurrentLocation(offset) {
		if (!this.options.sourceCodeLocationInfo) {
			return null;
		}
		return {
			startLine: this.preprocessor.line,
			startCol: this.preprocessor.col - offset,
			startOffset: this.preprocessor.offset - offset,
			endLine: -1,
			endCol: -1,
			endOffset: -1,
		};
	}
	_runParsingLoop() {
		if (this.inLoop) return;
		this.inLoop = true;
		while (this.active && !this.paused) {
			this.consumedAfterSnapshot = 0;
			const cp = this._consume();
			if (!this._ensureHibernation()) {
				this._callState(cp);
			}
		}
		this.inLoop = false;
	}
	//API
	pause() {
		this.paused = true;
	}
	resume(writeCallback) {
		if (!this.paused) {
			throw new Error('Parser was already resumed');
		}
		this.paused = false;
		if (this.inLoop) return;
		this._runParsingLoop();
		if (!this.paused) {
			writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
		}
	}
	write(chunk, isLastChunk, writeCallback) {
		this.active = true;
		this.preprocessor.write(chunk, isLastChunk);
		this._runParsingLoop();
		if (!this.paused) {
			writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
		}
	}
	insertHtmlAtCurrentPos(chunk) {
		this.active = true;
		this.preprocessor.insertHtmlAtCurrentPos(chunk);
		this._runParsingLoop();
	}
	//Hibernation
	_ensureHibernation() {
		if (this.preprocessor.endOfChunkHit) {
			this.preprocessor.retreat(this.consumedAfterSnapshot);
			this.consumedAfterSnapshot = 0;
			this.active = false;
			return true;
		}
		return false;
	}
	//Consumption
	_consume() {
		this.consumedAfterSnapshot++;
		return this.preprocessor.advance();
	}
	_advanceBy(count) {
		this.consumedAfterSnapshot += count;
		for (let i = 0; i < count; i++) {
			this.preprocessor.advance();
		}
	}
	_consumeSequenceIfMatch(pattern, caseSensitive) {
		if (this.preprocessor.startsWith(pattern, caseSensitive)) {
			this._advanceBy(pattern.length - 1);
			return true;
		}
		return false;
	}
	//Token creation
	_createStartTagToken() {
		this.currentToken = {
			type: TokenType.START_TAG,
			tagName: '',
			tagID: TAG_ID.UNKNOWN,
			selfClosing: false,
			ackSelfClosing: false,
			attrs: [],
			location: this.getCurrentLocation(1),
		};
	}
	_createEndTagToken() {
		this.currentToken = {
			type: TokenType.END_TAG,
			tagName: '',
			tagID: TAG_ID.UNKNOWN,
			selfClosing: false,
			ackSelfClosing: false,
			attrs: [],
			location: this.getCurrentLocation(2),
		};
	}
	_createCommentToken(offset) {
		this.currentToken = {
			type: TokenType.COMMENT,
			data: '',
			location: this.getCurrentLocation(offset),
		};
	}
	_createDoctypeToken(initialName) {
		this.currentToken = {
			type: TokenType.DOCTYPE,
			name: initialName,
			forceQuirks: false,
			publicId: null,
			systemId: null,
			location: this.currentLocation,
		};
	}
	_createCharacterToken(type, chars) {
		this.currentCharacterToken = {
			type,
			chars,
			location: this.currentLocation,
		};
	}
	//Tag attributes
	_createAttr(attrNameFirstCh) {
		this.currentAttr = {
			name: attrNameFirstCh,
			value: '',
		};
		this.currentLocation = this.getCurrentLocation(0);
	}
	_leaveAttrName() {
		var _a2;
		var _b;
		const token = this.currentToken;
		if (getTokenAttr(token, this.currentAttr.name) === null) {
			token.attrs.push(this.currentAttr);
			if (token.location && this.currentLocation) {
				const attrLocations =
					(_a2 = (_b = token.location).attrs) !== null && _a2 !== void 0
						? _a2
						: (_b.attrs = /* @__PURE__ */ Object.create(null));
				attrLocations[this.currentAttr.name] = this.currentLocation;
				this._leaveAttrValue();
			}
		} else {
			this._err(ERR.duplicateAttribute);
		}
	}
	_leaveAttrValue() {
		if (this.currentLocation) {
			this.currentLocation.endLine = this.preprocessor.line;
			this.currentLocation.endCol = this.preprocessor.col;
			this.currentLocation.endOffset = this.preprocessor.offset;
		}
	}
	//Token emission
	prepareToken(ct) {
		this._emitCurrentCharacterToken(ct.location);
		this.currentToken = null;
		if (ct.location) {
			ct.location.endLine = this.preprocessor.line;
			ct.location.endCol = this.preprocessor.col + 1;
			ct.location.endOffset = this.preprocessor.offset + 1;
		}
		this.currentLocation = this.getCurrentLocation(-1);
	}
	emitCurrentTagToken() {
		const ct = this.currentToken;
		this.prepareToken(ct);
		ct.tagID = getTagID(ct.tagName);
		if (ct.type === TokenType.START_TAG) {
			this.lastStartTagName = ct.tagName;
			this.handler.onStartTag(ct);
		} else {
			if (ct.attrs.length > 0) {
				this._err(ERR.endTagWithAttributes);
			}
			if (ct.selfClosing) {
				this._err(ERR.endTagWithTrailingSolidus);
			}
			this.handler.onEndTag(ct);
		}
		this.preprocessor.dropParsedChunk();
	}
	emitCurrentComment(ct) {
		this.prepareToken(ct);
		this.handler.onComment(ct);
		this.preprocessor.dropParsedChunk();
	}
	emitCurrentDoctype(ct) {
		this.prepareToken(ct);
		this.handler.onDoctype(ct);
		this.preprocessor.dropParsedChunk();
	}
	_emitCurrentCharacterToken(nextLocation) {
		if (this.currentCharacterToken) {
			if (nextLocation && this.currentCharacterToken.location) {
				this.currentCharacterToken.location.endLine = nextLocation.startLine;
				this.currentCharacterToken.location.endCol = nextLocation.startCol;
				this.currentCharacterToken.location.endOffset = nextLocation.startOffset;
			}
			switch (this.currentCharacterToken.type) {
				case TokenType.CHARACTER: {
					this.handler.onCharacter(this.currentCharacterToken);
					break;
				}
				case TokenType.NULL_CHARACTER: {
					this.handler.onNullCharacter(this.currentCharacterToken);
					break;
				}
				case TokenType.WHITESPACE_CHARACTER: {
					this.handler.onWhitespaceCharacter(this.currentCharacterToken);
					break;
				}
			}
			this.currentCharacterToken = null;
		}
	}
	_emitEOFToken() {
		const location2 = this.getCurrentLocation(0);
		if (location2) {
			location2.endLine = location2.startLine;
			location2.endCol = location2.startCol;
			location2.endOffset = location2.startOffset;
		}
		this._emitCurrentCharacterToken(location2);
		this.handler.onEof({ type: TokenType.EOF, location: location2 });
		this.active = false;
	}
	//Characters emission
	//OPTIMIZATION: The specification uses only one type of character token (one token per character).
	//This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
	//If we have a sequence of characters that belong to the same group, the parser can process it
	//as a single solid character token.
	//So, there are 3 types of character tokens in parse5:
	//1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
	//2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
	//3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
	_appendCharToCurrentCharacterToken(type, ch) {
		if (this.currentCharacterToken) {
			if (this.currentCharacterToken.type === type) {
				this.currentCharacterToken.chars += ch;
				return;
			} else {
				this.currentLocation = this.getCurrentLocation(0);
				this._emitCurrentCharacterToken(this.currentLocation);
				this.preprocessor.dropParsedChunk();
			}
		}
		this._createCharacterToken(type, ch);
	}
	_emitCodePoint(cp) {
		const type = isWhitespace(cp)
			? TokenType.WHITESPACE_CHARACTER
			: cp === CODE_POINTS.NULL
				? TokenType.NULL_CHARACTER
				: TokenType.CHARACTER;
		this._appendCharToCurrentCharacterToken(type, String.fromCodePoint(cp));
	}
	//NOTE: used when we emit characters explicitly.
	//This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
	_emitChars(ch) {
		this._appendCharToCurrentCharacterToken(TokenType.CHARACTER, ch);
	}
	// Character reference helpers
	_startCharacterReference() {
		this.returnState = this.state;
		this.state = State.CHARACTER_REFERENCE;
		this.entityStartPos = this.preprocessor.pos;
		this.entityDecoder.startEntity(
			this._isCharacterReferenceInAttribute() ? DecodingMode.Attribute : DecodingMode.Legacy,
		);
	}
	_isCharacterReferenceInAttribute() {
		return (
			this.returnState === State.ATTRIBUTE_VALUE_DOUBLE_QUOTED ||
			this.returnState === State.ATTRIBUTE_VALUE_SINGLE_QUOTED ||
			this.returnState === State.ATTRIBUTE_VALUE_UNQUOTED
		);
	}
	_flushCodePointConsumedAsCharacterReference(cp) {
		if (this._isCharacterReferenceInAttribute()) {
			this.currentAttr.value += String.fromCodePoint(cp);
		} else {
			this._emitCodePoint(cp);
		}
	}
	// Calling states this way turns out to be much faster than any other approach.
	_callState(cp) {
		switch (this.state) {
			case State.DATA: {
				this._stateData(cp);
				break;
			}
			case State.RCDATA: {
				this._stateRcdata(cp);
				break;
			}
			case State.RAWTEXT: {
				this._stateRawtext(cp);
				break;
			}
			case State.SCRIPT_DATA: {
				this._stateScriptData(cp);
				break;
			}
			case State.PLAINTEXT: {
				this._statePlaintext(cp);
				break;
			}
			case State.TAG_OPEN: {
				this._stateTagOpen(cp);
				break;
			}
			case State.END_TAG_OPEN: {
				this._stateEndTagOpen(cp);
				break;
			}
			case State.TAG_NAME: {
				this._stateTagName(cp);
				break;
			}
			case State.RCDATA_LESS_THAN_SIGN: {
				this._stateRcdataLessThanSign(cp);
				break;
			}
			case State.RCDATA_END_TAG_OPEN: {
				this._stateRcdataEndTagOpen(cp);
				break;
			}
			case State.RCDATA_END_TAG_NAME: {
				this._stateRcdataEndTagName(cp);
				break;
			}
			case State.RAWTEXT_LESS_THAN_SIGN: {
				this._stateRawtextLessThanSign(cp);
				break;
			}
			case State.RAWTEXT_END_TAG_OPEN: {
				this._stateRawtextEndTagOpen(cp);
				break;
			}
			case State.RAWTEXT_END_TAG_NAME: {
				this._stateRawtextEndTagName(cp);
				break;
			}
			case State.SCRIPT_DATA_LESS_THAN_SIGN: {
				this._stateScriptDataLessThanSign(cp);
				break;
			}
			case State.SCRIPT_DATA_END_TAG_OPEN: {
				this._stateScriptDataEndTagOpen(cp);
				break;
			}
			case State.SCRIPT_DATA_END_TAG_NAME: {
				this._stateScriptDataEndTagName(cp);
				break;
			}
			case State.SCRIPT_DATA_ESCAPE_START: {
				this._stateScriptDataEscapeStart(cp);
				break;
			}
			case State.SCRIPT_DATA_ESCAPE_START_DASH: {
				this._stateScriptDataEscapeStartDash(cp);
				break;
			}
			case State.SCRIPT_DATA_ESCAPED: {
				this._stateScriptDataEscaped(cp);
				break;
			}
			case State.SCRIPT_DATA_ESCAPED_DASH: {
				this._stateScriptDataEscapedDash(cp);
				break;
			}
			case State.SCRIPT_DATA_ESCAPED_DASH_DASH: {
				this._stateScriptDataEscapedDashDash(cp);
				break;
			}
			case State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
				this._stateScriptDataEscapedLessThanSign(cp);
				break;
			}
			case State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
				this._stateScriptDataEscapedEndTagOpen(cp);
				break;
			}
			case State.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
				this._stateScriptDataEscapedEndTagName(cp);
				break;
			}
			case State.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
				this._stateScriptDataDoubleEscapeStart(cp);
				break;
			}
			case State.SCRIPT_DATA_DOUBLE_ESCAPED: {
				this._stateScriptDataDoubleEscaped(cp);
				break;
			}
			case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
				this._stateScriptDataDoubleEscapedDash(cp);
				break;
			}
			case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
				this._stateScriptDataDoubleEscapedDashDash(cp);
				break;
			}
			case State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
				this._stateScriptDataDoubleEscapedLessThanSign(cp);
				break;
			}
			case State.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
				this._stateScriptDataDoubleEscapeEnd(cp);
				break;
			}
			case State.BEFORE_ATTRIBUTE_NAME: {
				this._stateBeforeAttributeName(cp);
				break;
			}
			case State.ATTRIBUTE_NAME: {
				this._stateAttributeName(cp);
				break;
			}
			case State.AFTER_ATTRIBUTE_NAME: {
				this._stateAfterAttributeName(cp);
				break;
			}
			case State.BEFORE_ATTRIBUTE_VALUE: {
				this._stateBeforeAttributeValue(cp);
				break;
			}
			case State.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
				this._stateAttributeValueDoubleQuoted(cp);
				break;
			}
			case State.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
				this._stateAttributeValueSingleQuoted(cp);
				break;
			}
			case State.ATTRIBUTE_VALUE_UNQUOTED: {
				this._stateAttributeValueUnquoted(cp);
				break;
			}
			case State.AFTER_ATTRIBUTE_VALUE_QUOTED: {
				this._stateAfterAttributeValueQuoted(cp);
				break;
			}
			case State.SELF_CLOSING_START_TAG: {
				this._stateSelfClosingStartTag(cp);
				break;
			}
			case State.BOGUS_COMMENT: {
				this._stateBogusComment(cp);
				break;
			}
			case State.MARKUP_DECLARATION_OPEN: {
				this._stateMarkupDeclarationOpen(cp);
				break;
			}
			case State.COMMENT_START: {
				this._stateCommentStart(cp);
				break;
			}
			case State.COMMENT_START_DASH: {
				this._stateCommentStartDash(cp);
				break;
			}
			case State.COMMENT: {
				this._stateComment(cp);
				break;
			}
			case State.COMMENT_LESS_THAN_SIGN: {
				this._stateCommentLessThanSign(cp);
				break;
			}
			case State.COMMENT_LESS_THAN_SIGN_BANG: {
				this._stateCommentLessThanSignBang(cp);
				break;
			}
			case State.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
				this._stateCommentLessThanSignBangDash(cp);
				break;
			}
			case State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
				this._stateCommentLessThanSignBangDashDash(cp);
				break;
			}
			case State.COMMENT_END_DASH: {
				this._stateCommentEndDash(cp);
				break;
			}
			case State.COMMENT_END: {
				this._stateCommentEnd(cp);
				break;
			}
			case State.COMMENT_END_BANG: {
				this._stateCommentEndBang(cp);
				break;
			}
			case State.DOCTYPE: {
				this._stateDoctype(cp);
				break;
			}
			case State.BEFORE_DOCTYPE_NAME: {
				this._stateBeforeDoctypeName(cp);
				break;
			}
			case State.DOCTYPE_NAME: {
				this._stateDoctypeName(cp);
				break;
			}
			case State.AFTER_DOCTYPE_NAME: {
				this._stateAfterDoctypeName(cp);
				break;
			}
			case State.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
				this._stateAfterDoctypePublicKeyword(cp);
				break;
			}
			case State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
				this._stateBeforeDoctypePublicIdentifier(cp);
				break;
			}
			case State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
				this._stateDoctypePublicIdentifierDoubleQuoted(cp);
				break;
			}
			case State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
				this._stateDoctypePublicIdentifierSingleQuoted(cp);
				break;
			}
			case State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
				this._stateAfterDoctypePublicIdentifier(cp);
				break;
			}
			case State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
				this._stateBetweenDoctypePublicAndSystemIdentifiers(cp);
				break;
			}
			case State.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
				this._stateAfterDoctypeSystemKeyword(cp);
				break;
			}
			case State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
				this._stateBeforeDoctypeSystemIdentifier(cp);
				break;
			}
			case State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
				this._stateDoctypeSystemIdentifierDoubleQuoted(cp);
				break;
			}
			case State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
				this._stateDoctypeSystemIdentifierSingleQuoted(cp);
				break;
			}
			case State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
				this._stateAfterDoctypeSystemIdentifier(cp);
				break;
			}
			case State.BOGUS_DOCTYPE: {
				this._stateBogusDoctype(cp);
				break;
			}
			case State.CDATA_SECTION: {
				this._stateCdataSection(cp);
				break;
			}
			case State.CDATA_SECTION_BRACKET: {
				this._stateCdataSectionBracket(cp);
				break;
			}
			case State.CDATA_SECTION_END: {
				this._stateCdataSectionEnd(cp);
				break;
			}
			case State.CHARACTER_REFERENCE: {
				this._stateCharacterReference();
				break;
			}
			case State.AMBIGUOUS_AMPERSAND: {
				this._stateAmbiguousAmpersand(cp);
				break;
			}
			default: {
				throw new Error('Unknown state');
			}
		}
	}
	// State machine
	// Data state
	//------------------------------------------------------------------
	_stateData(cp) {
		switch (cp) {
			case CODE_POINTS.LESS_THAN_SIGN: {
				this.state = State.TAG_OPEN;
				break;
			}
			case CODE_POINTS.AMPERSAND: {
				this._startCharacterReference();
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this._emitCodePoint(cp);
				break;
			}
			case CODE_POINTS.EOF: {
				this._emitEOFToken();
				break;
			}
			default: {
				this._emitCodePoint(cp);
			}
		}
	}
	//  RCDATA state
	//------------------------------------------------------------------
	_stateRcdata(cp) {
		switch (cp) {
			case CODE_POINTS.AMPERSAND: {
				this._startCharacterReference();
				break;
			}
			case CODE_POINTS.LESS_THAN_SIGN: {
				this.state = State.RCDATA_LESS_THAN_SIGN;
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this._emitChars(REPLACEMENT_CHARACTER);
				break;
			}
			case CODE_POINTS.EOF: {
				this._emitEOFToken();
				break;
			}
			default: {
				this._emitCodePoint(cp);
			}
		}
	}
	// RAWTEXT state
	//------------------------------------------------------------------
	_stateRawtext(cp) {
		switch (cp) {
			case CODE_POINTS.LESS_THAN_SIGN: {
				this.state = State.RAWTEXT_LESS_THAN_SIGN;
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this._emitChars(REPLACEMENT_CHARACTER);
				break;
			}
			case CODE_POINTS.EOF: {
				this._emitEOFToken();
				break;
			}
			default: {
				this._emitCodePoint(cp);
			}
		}
	}
	// Script data state
	//------------------------------------------------------------------
	_stateScriptData(cp) {
		switch (cp) {
			case CODE_POINTS.LESS_THAN_SIGN: {
				this.state = State.SCRIPT_DATA_LESS_THAN_SIGN;
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this._emitChars(REPLACEMENT_CHARACTER);
				break;
			}
			case CODE_POINTS.EOF: {
				this._emitEOFToken();
				break;
			}
			default: {
				this._emitCodePoint(cp);
			}
		}
	}
	// PLAINTEXT state
	//------------------------------------------------------------------
	_statePlaintext(cp) {
		switch (cp) {
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this._emitChars(REPLACEMENT_CHARACTER);
				break;
			}
			case CODE_POINTS.EOF: {
				this._emitEOFToken();
				break;
			}
			default: {
				this._emitCodePoint(cp);
			}
		}
	}
	// Tag open state
	//------------------------------------------------------------------
	_stateTagOpen(cp) {
		if (isAsciiLetter(cp)) {
			this._createStartTagToken();
			this.state = State.TAG_NAME;
			this._stateTagName(cp);
		} else
			switch (cp) {
				case CODE_POINTS.EXCLAMATION_MARK: {
					this.state = State.MARKUP_DECLARATION_OPEN;
					break;
				}
				case CODE_POINTS.SOLIDUS: {
					this.state = State.END_TAG_OPEN;
					break;
				}
				case CODE_POINTS.QUESTION_MARK: {
					this._err(ERR.unexpectedQuestionMarkInsteadOfTagName);
					this._createCommentToken(1);
					this.state = State.BOGUS_COMMENT;
					this._stateBogusComment(cp);
					break;
				}
				case CODE_POINTS.EOF: {
					this._err(ERR.eofBeforeTagName);
					this._emitChars('<');
					this._emitEOFToken();
					break;
				}
				default: {
					this._err(ERR.invalidFirstCharacterOfTagName);
					this._emitChars('<');
					this.state = State.DATA;
					this._stateData(cp);
				}
			}
	}
	// End tag open state
	//------------------------------------------------------------------
	_stateEndTagOpen(cp) {
		if (isAsciiLetter(cp)) {
			this._createEndTagToken();
			this.state = State.TAG_NAME;
			this._stateTagName(cp);
		} else
			switch (cp) {
				case CODE_POINTS.GREATER_THAN_SIGN: {
					this._err(ERR.missingEndTagName);
					this.state = State.DATA;
					break;
				}
				case CODE_POINTS.EOF: {
					this._err(ERR.eofBeforeTagName);
					this._emitChars('</');
					this._emitEOFToken();
					break;
				}
				default: {
					this._err(ERR.invalidFirstCharacterOfTagName);
					this._createCommentToken(2);
					this.state = State.BOGUS_COMMENT;
					this._stateBogusComment(cp);
				}
			}
	}
	// Tag name state
	//------------------------------------------------------------------
	_stateTagName(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: {
				this.state = State.BEFORE_ATTRIBUTE_NAME;
				break;
			}
			case CODE_POINTS.SOLIDUS: {
				this.state = State.SELF_CLOSING_START_TAG;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this.state = State.DATA;
				this.emitCurrentTagToken();
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				token.tagName += REPLACEMENT_CHARACTER;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInTag);
				this._emitEOFToken();
				break;
			}
			default: {
				token.tagName += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
			}
		}
	}
	// RCDATA less-than sign state
	//------------------------------------------------------------------
	_stateRcdataLessThanSign(cp) {
		if (cp === CODE_POINTS.SOLIDUS) {
			this.state = State.RCDATA_END_TAG_OPEN;
		} else {
			this._emitChars('<');
			this.state = State.RCDATA;
			this._stateRcdata(cp);
		}
	}
	// RCDATA end tag open state
	//------------------------------------------------------------------
	_stateRcdataEndTagOpen(cp) {
		if (isAsciiLetter(cp)) {
			this.state = State.RCDATA_END_TAG_NAME;
			this._stateRcdataEndTagName(cp);
		} else {
			this._emitChars('</');
			this.state = State.RCDATA;
			this._stateRcdata(cp);
		}
	}
	handleSpecialEndTag(_cp) {
		if (!this.preprocessor.startsWith(this.lastStartTagName, false)) {
			return !this._ensureHibernation();
		}
		this._createEndTagToken();
		const token = this.currentToken;
		token.tagName = this.lastStartTagName;
		const cp = this.preprocessor.peek(this.lastStartTagName.length);
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: {
				this._advanceBy(this.lastStartTagName.length);
				this.state = State.BEFORE_ATTRIBUTE_NAME;
				return false;
			}
			case CODE_POINTS.SOLIDUS: {
				this._advanceBy(this.lastStartTagName.length);
				this.state = State.SELF_CLOSING_START_TAG;
				return false;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._advanceBy(this.lastStartTagName.length);
				this.emitCurrentTagToken();
				this.state = State.DATA;
				return false;
			}
			default: {
				return !this._ensureHibernation();
			}
		}
	}
	// RCDATA end tag name state
	//------------------------------------------------------------------
	_stateRcdataEndTagName(cp) {
		if (this.handleSpecialEndTag(cp)) {
			this._emitChars('</');
			this.state = State.RCDATA;
			this._stateRcdata(cp);
		}
	}
	// RAWTEXT less-than sign state
	//------------------------------------------------------------------
	_stateRawtextLessThanSign(cp) {
		if (cp === CODE_POINTS.SOLIDUS) {
			this.state = State.RAWTEXT_END_TAG_OPEN;
		} else {
			this._emitChars('<');
			this.state = State.RAWTEXT;
			this._stateRawtext(cp);
		}
	}
	// RAWTEXT end tag open state
	//------------------------------------------------------------------
	_stateRawtextEndTagOpen(cp) {
		if (isAsciiLetter(cp)) {
			this.state = State.RAWTEXT_END_TAG_NAME;
			this._stateRawtextEndTagName(cp);
		} else {
			this._emitChars('</');
			this.state = State.RAWTEXT;
			this._stateRawtext(cp);
		}
	}
	// RAWTEXT end tag name state
	//------------------------------------------------------------------
	_stateRawtextEndTagName(cp) {
		if (this.handleSpecialEndTag(cp)) {
			this._emitChars('</');
			this.state = State.RAWTEXT;
			this._stateRawtext(cp);
		}
	}
	// Script data less-than sign state
	//------------------------------------------------------------------
	_stateScriptDataLessThanSign(cp) {
		switch (cp) {
			case CODE_POINTS.SOLIDUS: {
				this.state = State.SCRIPT_DATA_END_TAG_OPEN;
				break;
			}
			case CODE_POINTS.EXCLAMATION_MARK: {
				this.state = State.SCRIPT_DATA_ESCAPE_START;
				this._emitChars('<!');
				break;
			}
			default: {
				this._emitChars('<');
				this.state = State.SCRIPT_DATA;
				this._stateScriptData(cp);
			}
		}
	}
	// Script data end tag open state
	//------------------------------------------------------------------
	_stateScriptDataEndTagOpen(cp) {
		if (isAsciiLetter(cp)) {
			this.state = State.SCRIPT_DATA_END_TAG_NAME;
			this._stateScriptDataEndTagName(cp);
		} else {
			this._emitChars('</');
			this.state = State.SCRIPT_DATA;
			this._stateScriptData(cp);
		}
	}
	// Script data end tag name state
	//------------------------------------------------------------------
	_stateScriptDataEndTagName(cp) {
		if (this.handleSpecialEndTag(cp)) {
			this._emitChars('</');
			this.state = State.SCRIPT_DATA;
			this._stateScriptData(cp);
		}
	}
	// Script data escape start state
	//------------------------------------------------------------------
	_stateScriptDataEscapeStart(cp) {
		if (cp === CODE_POINTS.HYPHEN_MINUS) {
			this.state = State.SCRIPT_DATA_ESCAPE_START_DASH;
			this._emitChars('-');
		} else {
			this.state = State.SCRIPT_DATA;
			this._stateScriptData(cp);
		}
	}
	// Script data escape start dash state
	//------------------------------------------------------------------
	_stateScriptDataEscapeStartDash(cp) {
		if (cp === CODE_POINTS.HYPHEN_MINUS) {
			this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;
			this._emitChars('-');
		} else {
			this.state = State.SCRIPT_DATA;
			this._stateScriptData(cp);
		}
	}
	// Script data escaped state
	//------------------------------------------------------------------
	_stateScriptDataEscaped(cp) {
		switch (cp) {
			case CODE_POINTS.HYPHEN_MINUS: {
				this.state = State.SCRIPT_DATA_ESCAPED_DASH;
				this._emitChars('-');
				break;
			}
			case CODE_POINTS.LESS_THAN_SIGN: {
				this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this._emitChars(REPLACEMENT_CHARACTER);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInScriptHtmlCommentLikeText);
				this._emitEOFToken();
				break;
			}
			default: {
				this._emitCodePoint(cp);
			}
		}
	}
	// Script data escaped dash state
	//------------------------------------------------------------------
	_stateScriptDataEscapedDash(cp) {
		switch (cp) {
			case CODE_POINTS.HYPHEN_MINUS: {
				this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;
				this._emitChars('-');
				break;
			}
			case CODE_POINTS.LESS_THAN_SIGN: {
				this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this.state = State.SCRIPT_DATA_ESCAPED;
				this._emitChars(REPLACEMENT_CHARACTER);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInScriptHtmlCommentLikeText);
				this._emitEOFToken();
				break;
			}
			default: {
				this.state = State.SCRIPT_DATA_ESCAPED;
				this._emitCodePoint(cp);
			}
		}
	}
	// Script data escaped dash dash state
	//------------------------------------------------------------------
	_stateScriptDataEscapedDashDash(cp) {
		switch (cp) {
			case CODE_POINTS.HYPHEN_MINUS: {
				this._emitChars('-');
				break;
			}
			case CODE_POINTS.LESS_THAN_SIGN: {
				this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this.state = State.SCRIPT_DATA;
				this._emitChars('>');
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this.state = State.SCRIPT_DATA_ESCAPED;
				this._emitChars(REPLACEMENT_CHARACTER);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInScriptHtmlCommentLikeText);
				this._emitEOFToken();
				break;
			}
			default: {
				this.state = State.SCRIPT_DATA_ESCAPED;
				this._emitCodePoint(cp);
			}
		}
	}
	// Script data escaped less-than sign state
	//------------------------------------------------------------------
	_stateScriptDataEscapedLessThanSign(cp) {
		if (cp === CODE_POINTS.SOLIDUS) {
			this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN;
		} else if (isAsciiLetter(cp)) {
			this._emitChars('<');
			this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_START;
			this._stateScriptDataDoubleEscapeStart(cp);
		} else {
			this._emitChars('<');
			this.state = State.SCRIPT_DATA_ESCAPED;
			this._stateScriptDataEscaped(cp);
		}
	}
	// Script data escaped end tag open state
	//------------------------------------------------------------------
	_stateScriptDataEscapedEndTagOpen(cp) {
		if (isAsciiLetter(cp)) {
			this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_NAME;
			this._stateScriptDataEscapedEndTagName(cp);
		} else {
			this._emitChars('</');
			this.state = State.SCRIPT_DATA_ESCAPED;
			this._stateScriptDataEscaped(cp);
		}
	}
	// Script data escaped end tag name state
	//------------------------------------------------------------------
	_stateScriptDataEscapedEndTagName(cp) {
		if (this.handleSpecialEndTag(cp)) {
			this._emitChars('</');
			this.state = State.SCRIPT_DATA_ESCAPED;
			this._stateScriptDataEscaped(cp);
		}
	}
	// Script data double escape start state
	//------------------------------------------------------------------
	_stateScriptDataDoubleEscapeStart(cp) {
		if (
			this.preprocessor.startsWith(SEQUENCES.SCRIPT, false) &&
			isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(SEQUENCES.SCRIPT.length))
		) {
			this._emitCodePoint(cp);
			for (let i = 0; i < SEQUENCES.SCRIPT.length; i++) {
				this._emitCodePoint(this._consume());
			}
			this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
		} else if (!this._ensureHibernation()) {
			this.state = State.SCRIPT_DATA_ESCAPED;
			this._stateScriptDataEscaped(cp);
		}
	}
	// Script data double escaped state
	//------------------------------------------------------------------
	_stateScriptDataDoubleEscaped(cp) {
		switch (cp) {
			case CODE_POINTS.HYPHEN_MINUS: {
				this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH;
				this._emitChars('-');
				break;
			}
			case CODE_POINTS.LESS_THAN_SIGN: {
				this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
				this._emitChars('<');
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this._emitChars(REPLACEMENT_CHARACTER);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInScriptHtmlCommentLikeText);
				this._emitEOFToken();
				break;
			}
			default: {
				this._emitCodePoint(cp);
			}
		}
	}
	// Script data double escaped dash state
	//------------------------------------------------------------------
	_stateScriptDataDoubleEscapedDash(cp) {
		switch (cp) {
			case CODE_POINTS.HYPHEN_MINUS: {
				this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH;
				this._emitChars('-');
				break;
			}
			case CODE_POINTS.LESS_THAN_SIGN: {
				this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
				this._emitChars('<');
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
				this._emitChars(REPLACEMENT_CHARACTER);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInScriptHtmlCommentLikeText);
				this._emitEOFToken();
				break;
			}
			default: {
				this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
				this._emitCodePoint(cp);
			}
		}
	}
	// Script data double escaped dash dash state
	//------------------------------------------------------------------
	_stateScriptDataDoubleEscapedDashDash(cp) {
		switch (cp) {
			case CODE_POINTS.HYPHEN_MINUS: {
				this._emitChars('-');
				break;
			}
			case CODE_POINTS.LESS_THAN_SIGN: {
				this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
				this._emitChars('<');
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this.state = State.SCRIPT_DATA;
				this._emitChars('>');
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
				this._emitChars(REPLACEMENT_CHARACTER);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInScriptHtmlCommentLikeText);
				this._emitEOFToken();
				break;
			}
			default: {
				this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
				this._emitCodePoint(cp);
			}
		}
	}
	// Script data double escaped less-than sign state
	//------------------------------------------------------------------
	_stateScriptDataDoubleEscapedLessThanSign(cp) {
		if (cp === CODE_POINTS.SOLIDUS) {
			this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_END;
			this._emitChars('/');
		} else {
			this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
			this._stateScriptDataDoubleEscaped(cp);
		}
	}
	// Script data double escape end state
	//------------------------------------------------------------------
	_stateScriptDataDoubleEscapeEnd(cp) {
		if (
			this.preprocessor.startsWith(SEQUENCES.SCRIPT, false) &&
			isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(SEQUENCES.SCRIPT.length))
		) {
			this._emitCodePoint(cp);
			for (let i = 0; i < SEQUENCES.SCRIPT.length; i++) {
				this._emitCodePoint(this._consume());
			}
			this.state = State.SCRIPT_DATA_ESCAPED;
		} else if (!this._ensureHibernation()) {
			this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
			this._stateScriptDataDoubleEscaped(cp);
		}
	}
	// Before attribute name state
	//------------------------------------------------------------------
	_stateBeforeAttributeName(cp) {
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: {
				break;
			}
			case CODE_POINTS.SOLIDUS:
			case CODE_POINTS.GREATER_THAN_SIGN:
			case CODE_POINTS.EOF: {
				this.state = State.AFTER_ATTRIBUTE_NAME;
				this._stateAfterAttributeName(cp);
				break;
			}
			case CODE_POINTS.EQUALS_SIGN: {
				this._err(ERR.unexpectedEqualsSignBeforeAttributeName);
				this._createAttr('=');
				this.state = State.ATTRIBUTE_NAME;
				break;
			}
			default: {
				this._createAttr('');
				this.state = State.ATTRIBUTE_NAME;
				this._stateAttributeName(cp);
			}
		}
	}
	// Attribute name state
	//------------------------------------------------------------------
	_stateAttributeName(cp) {
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED:
			case CODE_POINTS.SOLIDUS:
			case CODE_POINTS.GREATER_THAN_SIGN:
			case CODE_POINTS.EOF: {
				this._leaveAttrName();
				this.state = State.AFTER_ATTRIBUTE_NAME;
				this._stateAfterAttributeName(cp);
				break;
			}
			case CODE_POINTS.EQUALS_SIGN: {
				this._leaveAttrName();
				this.state = State.BEFORE_ATTRIBUTE_VALUE;
				break;
			}
			case CODE_POINTS.QUOTATION_MARK:
			case CODE_POINTS.APOSTROPHE:
			case CODE_POINTS.LESS_THAN_SIGN: {
				this._err(ERR.unexpectedCharacterInAttributeName);
				this.currentAttr.name += String.fromCodePoint(cp);
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this.currentAttr.name += REPLACEMENT_CHARACTER;
				break;
			}
			default: {
				this.currentAttr.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
			}
		}
	}
	// After attribute name state
	//------------------------------------------------------------------
	_stateAfterAttributeName(cp) {
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: {
				break;
			}
			case CODE_POINTS.SOLIDUS: {
				this.state = State.SELF_CLOSING_START_TAG;
				break;
			}
			case CODE_POINTS.EQUALS_SIGN: {
				this.state = State.BEFORE_ATTRIBUTE_VALUE;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this.state = State.DATA;
				this.emitCurrentTagToken();
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInTag);
				this._emitEOFToken();
				break;
			}
			default: {
				this._createAttr('');
				this.state = State.ATTRIBUTE_NAME;
				this._stateAttributeName(cp);
			}
		}
	}
	// Before attribute value state
	//------------------------------------------------------------------
	_stateBeforeAttributeValue(cp) {
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: {
				break;
			}
			case CODE_POINTS.QUOTATION_MARK: {
				this.state = State.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
				break;
			}
			case CODE_POINTS.APOSTROPHE: {
				this.state = State.ATTRIBUTE_VALUE_SINGLE_QUOTED;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._err(ERR.missingAttributeValue);
				this.state = State.DATA;
				this.emitCurrentTagToken();
				break;
			}
			default: {
				this.state = State.ATTRIBUTE_VALUE_UNQUOTED;
				this._stateAttributeValueUnquoted(cp);
			}
		}
	}
	// Attribute value (double-quoted) state
	//------------------------------------------------------------------
	_stateAttributeValueDoubleQuoted(cp) {
		switch (cp) {
			case CODE_POINTS.QUOTATION_MARK: {
				this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
				break;
			}
			case CODE_POINTS.AMPERSAND: {
				this._startCharacterReference();
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this.currentAttr.value += REPLACEMENT_CHARACTER;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInTag);
				this._emitEOFToken();
				break;
			}
			default: {
				this.currentAttr.value += String.fromCodePoint(cp);
			}
		}
	}
	// Attribute value (single-quoted) state
	//------------------------------------------------------------------
	_stateAttributeValueSingleQuoted(cp) {
		switch (cp) {
			case CODE_POINTS.APOSTROPHE: {
				this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
				break;
			}
			case CODE_POINTS.AMPERSAND: {
				this._startCharacterReference();
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this.currentAttr.value += REPLACEMENT_CHARACTER;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInTag);
				this._emitEOFToken();
				break;
			}
			default: {
				this.currentAttr.value += String.fromCodePoint(cp);
			}
		}
	}
	// Attribute value (unquoted) state
	//------------------------------------------------------------------
	_stateAttributeValueUnquoted(cp) {
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: {
				this._leaveAttrValue();
				this.state = State.BEFORE_ATTRIBUTE_NAME;
				break;
			}
			case CODE_POINTS.AMPERSAND: {
				this._startCharacterReference();
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._leaveAttrValue();
				this.state = State.DATA;
				this.emitCurrentTagToken();
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this.currentAttr.value += REPLACEMENT_CHARACTER;
				break;
			}
			case CODE_POINTS.QUOTATION_MARK:
			case CODE_POINTS.APOSTROPHE:
			case CODE_POINTS.LESS_THAN_SIGN:
			case CODE_POINTS.EQUALS_SIGN:
			case CODE_POINTS.GRAVE_ACCENT: {
				this._err(ERR.unexpectedCharacterInUnquotedAttributeValue);
				this.currentAttr.value += String.fromCodePoint(cp);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInTag);
				this._emitEOFToken();
				break;
			}
			default: {
				this.currentAttr.value += String.fromCodePoint(cp);
			}
		}
	}
	// After attribute value (quoted) state
	//------------------------------------------------------------------
	_stateAfterAttributeValueQuoted(cp) {
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: {
				this._leaveAttrValue();
				this.state = State.BEFORE_ATTRIBUTE_NAME;
				break;
			}
			case CODE_POINTS.SOLIDUS: {
				this._leaveAttrValue();
				this.state = State.SELF_CLOSING_START_TAG;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._leaveAttrValue();
				this.state = State.DATA;
				this.emitCurrentTagToken();
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInTag);
				this._emitEOFToken();
				break;
			}
			default: {
				this._err(ERR.missingWhitespaceBetweenAttributes);
				this.state = State.BEFORE_ATTRIBUTE_NAME;
				this._stateBeforeAttributeName(cp);
			}
		}
	}
	// Self-closing start tag state
	//------------------------------------------------------------------
	_stateSelfClosingStartTag(cp) {
		switch (cp) {
			case CODE_POINTS.GREATER_THAN_SIGN: {
				const token = this.currentToken;
				token.selfClosing = true;
				this.state = State.DATA;
				this.emitCurrentTagToken();
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInTag);
				this._emitEOFToken();
				break;
			}
			default: {
				this._err(ERR.unexpectedSolidusInTag);
				this.state = State.BEFORE_ATTRIBUTE_NAME;
				this._stateBeforeAttributeName(cp);
			}
		}
	}
	// Bogus comment state
	//------------------------------------------------------------------
	_stateBogusComment(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this.state = State.DATA;
				this.emitCurrentComment(token);
				break;
			}
			case CODE_POINTS.EOF: {
				this.emitCurrentComment(token);
				this._emitEOFToken();
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				token.data += REPLACEMENT_CHARACTER;
				break;
			}
			default: {
				token.data += String.fromCodePoint(cp);
			}
		}
	}
	// Markup declaration open state
	//------------------------------------------------------------------
	_stateMarkupDeclarationOpen(cp) {
		if (this._consumeSequenceIfMatch(SEQUENCES.DASH_DASH, true)) {
			this._createCommentToken(SEQUENCES.DASH_DASH.length + 1);
			this.state = State.COMMENT_START;
		} else if (this._consumeSequenceIfMatch(SEQUENCES.DOCTYPE, false)) {
			this.currentLocation = this.getCurrentLocation(SEQUENCES.DOCTYPE.length + 1);
			this.state = State.DOCTYPE;
		} else if (this._consumeSequenceIfMatch(SEQUENCES.CDATA_START, true)) {
			if (this.inForeignNode) {
				this.state = State.CDATA_SECTION;
			} else {
				this._err(ERR.cdataInHtmlContent);
				this._createCommentToken(SEQUENCES.CDATA_START.length + 1);
				this.currentToken.data = '[CDATA[';
				this.state = State.BOGUS_COMMENT;
			}
		} else if (!this._ensureHibernation()) {
			this._err(ERR.incorrectlyOpenedComment);
			this._createCommentToken(2);
			this.state = State.BOGUS_COMMENT;
			this._stateBogusComment(cp);
		}
	}
	// Comment start state
	//------------------------------------------------------------------
	_stateCommentStart(cp) {
		switch (cp) {
			case CODE_POINTS.HYPHEN_MINUS: {
				this.state = State.COMMENT_START_DASH;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._err(ERR.abruptClosingOfEmptyComment);
				this.state = State.DATA;
				const token = this.currentToken;
				this.emitCurrentComment(token);
				break;
			}
			default: {
				this.state = State.COMMENT;
				this._stateComment(cp);
			}
		}
	}
	// Comment start dash state
	//------------------------------------------------------------------
	_stateCommentStartDash(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.HYPHEN_MINUS: {
				this.state = State.COMMENT_END;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._err(ERR.abruptClosingOfEmptyComment);
				this.state = State.DATA;
				this.emitCurrentComment(token);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInComment);
				this.emitCurrentComment(token);
				this._emitEOFToken();
				break;
			}
			default: {
				token.data += '-';
				this.state = State.COMMENT;
				this._stateComment(cp);
			}
		}
	}
	// Comment state
	//------------------------------------------------------------------
	_stateComment(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.HYPHEN_MINUS: {
				this.state = State.COMMENT_END_DASH;
				break;
			}
			case CODE_POINTS.LESS_THAN_SIGN: {
				token.data += '<';
				this.state = State.COMMENT_LESS_THAN_SIGN;
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				token.data += REPLACEMENT_CHARACTER;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInComment);
				this.emitCurrentComment(token);
				this._emitEOFToken();
				break;
			}
			default: {
				token.data += String.fromCodePoint(cp);
			}
		}
	}
	// Comment less-than sign state
	//------------------------------------------------------------------
	_stateCommentLessThanSign(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.EXCLAMATION_MARK: {
				token.data += '!';
				this.state = State.COMMENT_LESS_THAN_SIGN_BANG;
				break;
			}
			case CODE_POINTS.LESS_THAN_SIGN: {
				token.data += '<';
				break;
			}
			default: {
				this.state = State.COMMENT;
				this._stateComment(cp);
			}
		}
	}
	// Comment less-than sign bang state
	//------------------------------------------------------------------
	_stateCommentLessThanSignBang(cp) {
		if (cp === CODE_POINTS.HYPHEN_MINUS) {
			this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH;
		} else {
			this.state = State.COMMENT;
			this._stateComment(cp);
		}
	}
	// Comment less-than sign bang dash state
	//------------------------------------------------------------------
	_stateCommentLessThanSignBangDash(cp) {
		if (cp === CODE_POINTS.HYPHEN_MINUS) {
			this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH;
		} else {
			this.state = State.COMMENT_END_DASH;
			this._stateCommentEndDash(cp);
		}
	}
	// Comment less-than sign bang dash dash state
	//------------------------------------------------------------------
	_stateCommentLessThanSignBangDashDash(cp) {
		if (cp !== CODE_POINTS.GREATER_THAN_SIGN && cp !== CODE_POINTS.EOF) {
			this._err(ERR.nestedComment);
		}
		this.state = State.COMMENT_END;
		this._stateCommentEnd(cp);
	}
	// Comment end dash state
	//------------------------------------------------------------------
	_stateCommentEndDash(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.HYPHEN_MINUS: {
				this.state = State.COMMENT_END;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInComment);
				this.emitCurrentComment(token);
				this._emitEOFToken();
				break;
			}
			default: {
				token.data += '-';
				this.state = State.COMMENT;
				this._stateComment(cp);
			}
		}
	}
	// Comment end state
	//------------------------------------------------------------------
	_stateCommentEnd(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this.state = State.DATA;
				this.emitCurrentComment(token);
				break;
			}
			case CODE_POINTS.EXCLAMATION_MARK: {
				this.state = State.COMMENT_END_BANG;
				break;
			}
			case CODE_POINTS.HYPHEN_MINUS: {
				token.data += '-';
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInComment);
				this.emitCurrentComment(token);
				this._emitEOFToken();
				break;
			}
			default: {
				token.data += '--';
				this.state = State.COMMENT;
				this._stateComment(cp);
			}
		}
	}
	// Comment end bang state
	//------------------------------------------------------------------
	_stateCommentEndBang(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.HYPHEN_MINUS: {
				token.data += '--!';
				this.state = State.COMMENT_END_DASH;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._err(ERR.incorrectlyClosedComment);
				this.state = State.DATA;
				this.emitCurrentComment(token);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInComment);
				this.emitCurrentComment(token);
				this._emitEOFToken();
				break;
			}
			default: {
				token.data += '--!';
				this.state = State.COMMENT;
				this._stateComment(cp);
			}
		}
	}
	// DOCTYPE state
	//------------------------------------------------------------------
	_stateDoctype(cp) {
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: {
				this.state = State.BEFORE_DOCTYPE_NAME;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this.state = State.BEFORE_DOCTYPE_NAME;
				this._stateBeforeDoctypeName(cp);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				this._createDoctypeToken(null);
				const token = this.currentToken;
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: {
				this._err(ERR.missingWhitespaceBeforeDoctypeName);
				this.state = State.BEFORE_DOCTYPE_NAME;
				this._stateBeforeDoctypeName(cp);
			}
		}
	}
	// Before DOCTYPE name state
	//------------------------------------------------------------------
	_stateBeforeDoctypeName(cp) {
		if (isAsciiUpper(cp)) {
			this._createDoctypeToken(String.fromCharCode(toAsciiLower(cp)));
			this.state = State.DOCTYPE_NAME;
		} else
			switch (cp) {
				case CODE_POINTS.SPACE:
				case CODE_POINTS.LINE_FEED:
				case CODE_POINTS.TABULATION:
				case CODE_POINTS.FORM_FEED: {
					break;
				}
				case CODE_POINTS.NULL: {
					this._err(ERR.unexpectedNullCharacter);
					this._createDoctypeToken(REPLACEMENT_CHARACTER);
					this.state = State.DOCTYPE_NAME;
					break;
				}
				case CODE_POINTS.GREATER_THAN_SIGN: {
					this._err(ERR.missingDoctypeName);
					this._createDoctypeToken(null);
					const token = this.currentToken;
					token.forceQuirks = true;
					this.emitCurrentDoctype(token);
					this.state = State.DATA;
					break;
				}
				case CODE_POINTS.EOF: {
					this._err(ERR.eofInDoctype);
					this._createDoctypeToken(null);
					const token = this.currentToken;
					token.forceQuirks = true;
					this.emitCurrentDoctype(token);
					this._emitEOFToken();
					break;
				}
				default: {
					this._createDoctypeToken(String.fromCodePoint(cp));
					this.state = State.DOCTYPE_NAME;
				}
			}
	}
	// DOCTYPE name state
	//------------------------------------------------------------------
	_stateDoctypeName(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: {
				this.state = State.AFTER_DOCTYPE_NAME;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this.state = State.DATA;
				this.emitCurrentDoctype(token);
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				token.name += REPLACEMENT_CHARACTER;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: {
				token.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
			}
		}
	}
	// After DOCTYPE name state
	//------------------------------------------------------------------
	_stateAfterDoctypeName(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: {
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this.state = State.DATA;
				this.emitCurrentDoctype(token);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: {
				if (this._consumeSequenceIfMatch(SEQUENCES.PUBLIC, false)) {
					this.state = State.AFTER_DOCTYPE_PUBLIC_KEYWORD;
				} else if (this._consumeSequenceIfMatch(SEQUENCES.SYSTEM, false)) {
					this.state = State.AFTER_DOCTYPE_SYSTEM_KEYWORD;
				} else if (!this._ensureHibernation()) {
					this._err(ERR.invalidCharacterSequenceAfterDoctypeName);
					token.forceQuirks = true;
					this.state = State.BOGUS_DOCTYPE;
					this._stateBogusDoctype(cp);
				}
			}
		}
	}
	// After DOCTYPE public keyword state
	//------------------------------------------------------------------
	_stateAfterDoctypePublicKeyword(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: {
				this.state = State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
				break;
			}
			case CODE_POINTS.QUOTATION_MARK: {
				this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
				token.publicId = '';
				this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
				break;
			}
			case CODE_POINTS.APOSTROPHE: {
				this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
				token.publicId = '';
				this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._err(ERR.missingDoctypePublicIdentifier);
				token.forceQuirks = true;
				this.state = State.DATA;
				this.emitCurrentDoctype(token);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: {
				this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
				token.forceQuirks = true;
				this.state = State.BOGUS_DOCTYPE;
				this._stateBogusDoctype(cp);
			}
		}
	}
	// Before DOCTYPE public identifier state
	//------------------------------------------------------------------
	_stateBeforeDoctypePublicIdentifier(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: {
				break;
			}
			case CODE_POINTS.QUOTATION_MARK: {
				token.publicId = '';
				this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
				break;
			}
			case CODE_POINTS.APOSTROPHE: {
				token.publicId = '';
				this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._err(ERR.missingDoctypePublicIdentifier);
				token.forceQuirks = true;
				this.state = State.DATA;
				this.emitCurrentDoctype(token);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: {
				this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
				token.forceQuirks = true;
				this.state = State.BOGUS_DOCTYPE;
				this._stateBogusDoctype(cp);
			}
		}
	}
	// DOCTYPE public identifier (double-quoted) state
	//------------------------------------------------------------------
	_stateDoctypePublicIdentifierDoubleQuoted(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.QUOTATION_MARK: {
				this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				token.publicId += REPLACEMENT_CHARACTER;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._err(ERR.abruptDoctypePublicIdentifier);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this.state = State.DATA;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: {
				token.publicId += String.fromCodePoint(cp);
			}
		}
	}
	// DOCTYPE public identifier (single-quoted) state
	//------------------------------------------------------------------
	_stateDoctypePublicIdentifierSingleQuoted(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.APOSTROPHE: {
				this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				token.publicId += REPLACEMENT_CHARACTER;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._err(ERR.abruptDoctypePublicIdentifier);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this.state = State.DATA;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: {
				token.publicId += String.fromCodePoint(cp);
			}
		}
	}
	// After DOCTYPE public identifier state
	//------------------------------------------------------------------
	_stateAfterDoctypePublicIdentifier(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: {
				this.state = State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this.state = State.DATA;
				this.emitCurrentDoctype(token);
				break;
			}
			case CODE_POINTS.QUOTATION_MARK: {
				this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
				token.systemId = '';
				this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
				break;
			}
			case CODE_POINTS.APOSTROPHE: {
				this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
				token.systemId = '';
				this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: {
				this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
				token.forceQuirks = true;
				this.state = State.BOGUS_DOCTYPE;
				this._stateBogusDoctype(cp);
			}
		}
	}
	// Between DOCTYPE public and system identifiers state
	//------------------------------------------------------------------
	_stateBetweenDoctypePublicAndSystemIdentifiers(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: {
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this.emitCurrentDoctype(token);
				this.state = State.DATA;
				break;
			}
			case CODE_POINTS.QUOTATION_MARK: {
				token.systemId = '';
				this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
				break;
			}
			case CODE_POINTS.APOSTROPHE: {
				token.systemId = '';
				this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: {
				this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
				token.forceQuirks = true;
				this.state = State.BOGUS_DOCTYPE;
				this._stateBogusDoctype(cp);
			}
		}
	}
	// After DOCTYPE system keyword state
	//------------------------------------------------------------------
	_stateAfterDoctypeSystemKeyword(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: {
				this.state = State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
				break;
			}
			case CODE_POINTS.QUOTATION_MARK: {
				this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
				token.systemId = '';
				this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
				break;
			}
			case CODE_POINTS.APOSTROPHE: {
				this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
				token.systemId = '';
				this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._err(ERR.missingDoctypeSystemIdentifier);
				token.forceQuirks = true;
				this.state = State.DATA;
				this.emitCurrentDoctype(token);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: {
				this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
				token.forceQuirks = true;
				this.state = State.BOGUS_DOCTYPE;
				this._stateBogusDoctype(cp);
			}
		}
	}
	// Before DOCTYPE system identifier state
	//------------------------------------------------------------------
	_stateBeforeDoctypeSystemIdentifier(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: {
				break;
			}
			case CODE_POINTS.QUOTATION_MARK: {
				token.systemId = '';
				this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
				break;
			}
			case CODE_POINTS.APOSTROPHE: {
				token.systemId = '';
				this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._err(ERR.missingDoctypeSystemIdentifier);
				token.forceQuirks = true;
				this.state = State.DATA;
				this.emitCurrentDoctype(token);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: {
				this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
				token.forceQuirks = true;
				this.state = State.BOGUS_DOCTYPE;
				this._stateBogusDoctype(cp);
			}
		}
	}
	// DOCTYPE system identifier (double-quoted) state
	//------------------------------------------------------------------
	_stateDoctypeSystemIdentifierDoubleQuoted(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.QUOTATION_MARK: {
				this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				token.systemId += REPLACEMENT_CHARACTER;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._err(ERR.abruptDoctypeSystemIdentifier);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this.state = State.DATA;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: {
				token.systemId += String.fromCodePoint(cp);
			}
		}
	}
	// DOCTYPE system identifier (single-quoted) state
	//------------------------------------------------------------------
	_stateDoctypeSystemIdentifierSingleQuoted(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.APOSTROPHE: {
				this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				token.systemId += REPLACEMENT_CHARACTER;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._err(ERR.abruptDoctypeSystemIdentifier);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this.state = State.DATA;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: {
				token.systemId += String.fromCodePoint(cp);
			}
		}
	}
	// After DOCTYPE system identifier state
	//------------------------------------------------------------------
	_stateAfterDoctypeSystemIdentifier(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: {
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this.emitCurrentDoctype(token);
				this.state = State.DATA;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: {
				this._err(ERR.unexpectedCharacterAfterDoctypeSystemIdentifier);
				this.state = State.BOGUS_DOCTYPE;
				this._stateBogusDoctype(cp);
			}
		}
	}
	// Bogus DOCTYPE state
	//------------------------------------------------------------------
	_stateBogusDoctype(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this.emitCurrentDoctype(token);
				this.state = State.DATA;
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				break;
			}
			case CODE_POINTS.EOF: {
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default:
		}
	}
	// CDATA section state
	//------------------------------------------------------------------
	_stateCdataSection(cp) {
		switch (cp) {
			case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
				this.state = State.CDATA_SECTION_BRACKET;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInCdata);
				this._emitEOFToken();
				break;
			}
			default: {
				this._emitCodePoint(cp);
			}
		}
	}
	// CDATA section bracket state
	//------------------------------------------------------------------
	_stateCdataSectionBracket(cp) {
		if (cp === CODE_POINTS.RIGHT_SQUARE_BRACKET) {
			this.state = State.CDATA_SECTION_END;
		} else {
			this._emitChars(']');
			this.state = State.CDATA_SECTION;
			this._stateCdataSection(cp);
		}
	}
	// CDATA section end state
	//------------------------------------------------------------------
	_stateCdataSectionEnd(cp) {
		switch (cp) {
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this.state = State.DATA;
				break;
			}
			case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
				this._emitChars(']');
				break;
			}
			default: {
				this._emitChars(']]');
				this.state = State.CDATA_SECTION;
				this._stateCdataSection(cp);
			}
		}
	}
	// Character reference state
	//------------------------------------------------------------------
	_stateCharacterReference() {
		let length = this.entityDecoder.write(this.preprocessor.html, this.preprocessor.pos);
		if (length < 0) {
			if (this.preprocessor.lastChunkWritten) {
				length = this.entityDecoder.end();
			} else {
				this.active = false;
				this.preprocessor.pos = this.preprocessor.html.length - 1;
				this.consumedAfterSnapshot = 0;
				this.preprocessor.endOfChunkHit = true;
				return;
			}
		}
		if (length === 0) {
			this.preprocessor.pos = this.entityStartPos;
			this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
			this.state =
				!this._isCharacterReferenceInAttribute() && isAsciiAlphaNumeric2(this.preprocessor.peek(1))
					? State.AMBIGUOUS_AMPERSAND
					: this.returnState;
		} else {
			this.state = this.returnState;
		}
	}
	// Ambiguos ampersand state
	//------------------------------------------------------------------
	_stateAmbiguousAmpersand(cp) {
		if (isAsciiAlphaNumeric2(cp)) {
			this._flushCodePointConsumedAsCharacterReference(cp);
		} else {
			if (cp === CODE_POINTS.SEMICOLON) {
				this._err(ERR.unknownNamedCharacterReference);
			}
			this.state = this.returnState;
			this._callState(cp);
		}
	}
};

// node_modules/parse5/dist/parser/open-element-stack.js
var IMPLICIT_END_TAG_REQUIRED = /* @__PURE__ */ new Set([
	TAG_ID.DD,
	TAG_ID.DT,
	TAG_ID.LI,
	TAG_ID.OPTGROUP,
	TAG_ID.OPTION,
	TAG_ID.P,
	TAG_ID.RB,
	TAG_ID.RP,
	TAG_ID.RT,
	TAG_ID.RTC,
]);
var IMPLICIT_END_TAG_REQUIRED_THOROUGHLY = /* @__PURE__ */ new Set([
	...IMPLICIT_END_TAG_REQUIRED,
	TAG_ID.CAPTION,
	TAG_ID.COLGROUP,
	TAG_ID.TBODY,
	TAG_ID.TD,
	TAG_ID.TFOOT,
	TAG_ID.TH,
	TAG_ID.THEAD,
	TAG_ID.TR,
]);
var SCOPING_ELEMENTS_HTML = /* @__PURE__ */ new Set([
	TAG_ID.APPLET,
	TAG_ID.CAPTION,
	TAG_ID.HTML,
	TAG_ID.MARQUEE,
	TAG_ID.OBJECT,
	TAG_ID.TABLE,
	TAG_ID.TD,
	TAG_ID.TEMPLATE,
	TAG_ID.TH,
]);
var SCOPING_ELEMENTS_HTML_LIST = /* @__PURE__ */ new Set([...SCOPING_ELEMENTS_HTML, TAG_ID.OL, TAG_ID.UL]);
var SCOPING_ELEMENTS_HTML_BUTTON = /* @__PURE__ */ new Set([...SCOPING_ELEMENTS_HTML, TAG_ID.BUTTON]);
var SCOPING_ELEMENTS_MATHML = /* @__PURE__ */ new Set([
	TAG_ID.ANNOTATION_XML,
	TAG_ID.MI,
	TAG_ID.MN,
	TAG_ID.MO,
	TAG_ID.MS,
	TAG_ID.MTEXT,
]);
var SCOPING_ELEMENTS_SVG = /* @__PURE__ */ new Set([TAG_ID.DESC, TAG_ID.FOREIGN_OBJECT, TAG_ID.TITLE]);
var TABLE_ROW_CONTEXT = /* @__PURE__ */ new Set([TAG_ID.TR, TAG_ID.TEMPLATE, TAG_ID.HTML]);
var TABLE_BODY_CONTEXT = /* @__PURE__ */ new Set([
	TAG_ID.TBODY,
	TAG_ID.TFOOT,
	TAG_ID.THEAD,
	TAG_ID.TEMPLATE,
	TAG_ID.HTML,
]);
var TABLE_CONTEXT = /* @__PURE__ */ new Set([TAG_ID.TABLE, TAG_ID.TEMPLATE, TAG_ID.HTML]);
var TABLE_CELLS = /* @__PURE__ */ new Set([TAG_ID.TD, TAG_ID.TH]);
var OpenElementStack = class {
	get currentTmplContentOrNode() {
		return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
	}
	constructor(document2, treeAdapter, handler) {
		this.treeAdapter = treeAdapter;
		this.handler = handler;
		this.items = [];
		this.tagIDs = [];
		this.stackTop = -1;
		this.tmplCount = 0;
		this.currentTagId = TAG_ID.UNKNOWN;
		this.current = document2;
	}
	//Index of element
	_indexOf(element) {
		return this.items.lastIndexOf(element, this.stackTop);
	}
	//Update current element
	_isInTemplate() {
		return this.currentTagId === TAG_ID.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS.HTML;
	}
	_updateCurrentElement() {
		this.current = this.items[this.stackTop];
		this.currentTagId = this.tagIDs[this.stackTop];
	}
	//Mutations
	push(element, tagID) {
		this.stackTop++;
		this.items[this.stackTop] = element;
		this.current = element;
		this.tagIDs[this.stackTop] = tagID;
		this.currentTagId = tagID;
		if (this._isInTemplate()) {
			this.tmplCount++;
		}
		this.handler.onItemPush(element, tagID, true);
	}
	pop() {
		const popped = this.current;
		if (this.tmplCount > 0 && this._isInTemplate()) {
			this.tmplCount--;
		}
		this.stackTop--;
		this._updateCurrentElement();
		this.handler.onItemPop(popped, true);
	}
	replace(oldElement, newElement) {
		const idx = this._indexOf(oldElement);
		this.items[idx] = newElement;
		if (idx === this.stackTop) {
			this.current = newElement;
		}
	}
	insertAfter(referenceElement, newElement, newElementID) {
		const insertionIdx = this._indexOf(referenceElement) + 1;
		this.items.splice(insertionIdx, 0, newElement);
		this.tagIDs.splice(insertionIdx, 0, newElementID);
		this.stackTop++;
		if (insertionIdx === this.stackTop) {
			this._updateCurrentElement();
		}
		this.handler.onItemPush(this.current, this.currentTagId, insertionIdx === this.stackTop);
	}
	popUntilTagNamePopped(tagName) {
		let targetIdx = this.stackTop + 1;
		do {
			targetIdx = this.tagIDs.lastIndexOf(tagName, targetIdx - 1);
		} while (targetIdx > 0 && this.treeAdapter.getNamespaceURI(this.items[targetIdx]) !== NS.HTML);
		this.shortenToLength(targetIdx < 0 ? 0 : targetIdx);
	}
	shortenToLength(idx) {
		while (this.stackTop >= idx) {
			const popped = this.current;
			if (this.tmplCount > 0 && this._isInTemplate()) {
				this.tmplCount -= 1;
			}
			this.stackTop--;
			this._updateCurrentElement();
			this.handler.onItemPop(popped, this.stackTop < idx);
		}
	}
	popUntilElementPopped(element) {
		const idx = this._indexOf(element);
		this.shortenToLength(idx < 0 ? 0 : idx);
	}
	popUntilPopped(tagNames, targetNS) {
		const idx = this._indexOfTagNames(tagNames, targetNS);
		this.shortenToLength(idx < 0 ? 0 : idx);
	}
	popUntilNumberedHeaderPopped() {
		this.popUntilPopped(NUMBERED_HEADERS, NS.HTML);
	}
	popUntilTableCellPopped() {
		this.popUntilPopped(TABLE_CELLS, NS.HTML);
	}
	popAllUpToHtmlElement() {
		this.tmplCount = 0;
		this.shortenToLength(1);
	}
	_indexOfTagNames(tagNames, namespace) {
		for (let i = this.stackTop; i >= 0; i--) {
			if (tagNames.has(this.tagIDs[i]) && this.treeAdapter.getNamespaceURI(this.items[i]) === namespace) {
				return i;
			}
		}
		return -1;
	}
	clearBackTo(tagNames, targetNS) {
		const idx = this._indexOfTagNames(tagNames, targetNS);
		this.shortenToLength(idx + 1);
	}
	clearBackToTableContext() {
		this.clearBackTo(TABLE_CONTEXT, NS.HTML);
	}
	clearBackToTableBodyContext() {
		this.clearBackTo(TABLE_BODY_CONTEXT, NS.HTML);
	}
	clearBackToTableRowContext() {
		this.clearBackTo(TABLE_ROW_CONTEXT, NS.HTML);
	}
	remove(element) {
		const idx = this._indexOf(element);
		if (idx >= 0) {
			if (idx === this.stackTop) {
				this.pop();
			} else {
				this.items.splice(idx, 1);
				this.tagIDs.splice(idx, 1);
				this.stackTop--;
				this._updateCurrentElement();
				this.handler.onItemPop(element, false);
			}
		}
	}
	//Search
	tryPeekProperlyNestedBodyElement() {
		return this.stackTop >= 1 && this.tagIDs[1] === TAG_ID.BODY ? this.items[1] : null;
	}
	contains(element) {
		return this._indexOf(element) > -1;
	}
	getCommonAncestor(element) {
		const elementIdx = this._indexOf(element) - 1;
		return elementIdx >= 0 ? this.items[elementIdx] : null;
	}
	isRootHtmlElementCurrent() {
		return this.stackTop === 0 && this.tagIDs[0] === TAG_ID.HTML;
	}
	//Element in scope
	hasInDynamicScope(tagName, htmlScope) {
		for (let i = this.stackTop; i >= 0; i--) {
			const tn = this.tagIDs[i];
			switch (this.treeAdapter.getNamespaceURI(this.items[i])) {
				case NS.HTML: {
					if (tn === tagName) return true;
					if (htmlScope.has(tn)) return false;
					break;
				}
				case NS.SVG: {
					if (SCOPING_ELEMENTS_SVG.has(tn)) return false;
					break;
				}
				case NS.MATHML: {
					if (SCOPING_ELEMENTS_MATHML.has(tn)) return false;
					break;
				}
			}
		}
		return true;
	}
	hasInScope(tagName) {
		return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML);
	}
	hasInListItemScope(tagName) {
		return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML_LIST);
	}
	hasInButtonScope(tagName) {
		return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML_BUTTON);
	}
	hasNumberedHeaderInScope() {
		for (let i = this.stackTop; i >= 0; i--) {
			const tn = this.tagIDs[i];
			switch (this.treeAdapter.getNamespaceURI(this.items[i])) {
				case NS.HTML: {
					if (NUMBERED_HEADERS.has(tn)) return true;
					if (SCOPING_ELEMENTS_HTML.has(tn)) return false;
					break;
				}
				case NS.SVG: {
					if (SCOPING_ELEMENTS_SVG.has(tn)) return false;
					break;
				}
				case NS.MATHML: {
					if (SCOPING_ELEMENTS_MATHML.has(tn)) return false;
					break;
				}
			}
		}
		return true;
	}
	hasInTableScope(tagName) {
		for (let i = this.stackTop; i >= 0; i--) {
			if (this.treeAdapter.getNamespaceURI(this.items[i]) !== NS.HTML) {
				continue;
			}
			switch (this.tagIDs[i]) {
				case tagName: {
					return true;
				}
				case TAG_ID.TABLE:
				case TAG_ID.HTML: {
					return false;
				}
			}
		}
		return true;
	}
	hasTableBodyContextInTableScope() {
		for (let i = this.stackTop; i >= 0; i--) {
			if (this.treeAdapter.getNamespaceURI(this.items[i]) !== NS.HTML) {
				continue;
			}
			switch (this.tagIDs[i]) {
				case TAG_ID.TBODY:
				case TAG_ID.THEAD:
				case TAG_ID.TFOOT: {
					return true;
				}
				case TAG_ID.TABLE:
				case TAG_ID.HTML: {
					return false;
				}
			}
		}
		return true;
	}
	hasInSelectScope(tagName) {
		for (let i = this.stackTop; i >= 0; i--) {
			if (this.treeAdapter.getNamespaceURI(this.items[i]) !== NS.HTML) {
				continue;
			}
			switch (this.tagIDs[i]) {
				case tagName: {
					return true;
				}
				case TAG_ID.OPTION:
				case TAG_ID.OPTGROUP: {
					break;
				}
				default: {
					return false;
				}
			}
		}
		return true;
	}
	//Implied end tags
	generateImpliedEndTags() {
		while (IMPLICIT_END_TAG_REQUIRED.has(this.currentTagId)) {
			this.pop();
		}
	}
	generateImpliedEndTagsThoroughly() {
		while (IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
			this.pop();
		}
	}
	generateImpliedEndTagsWithExclusion(exclusionId) {
		while (this.currentTagId !== exclusionId && IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
			this.pop();
		}
	}
};

// node_modules/parse5/dist/parser/formatting-element-list.js
var NOAH_ARK_CAPACITY = 3;
var EntryType;
(function (EntryType2) {
	EntryType2[(EntryType2['Marker'] = 0)] = 'Marker';
	EntryType2[(EntryType2['Element'] = 1)] = 'Element';
})(EntryType || (EntryType = {}));
var MARKER = { type: EntryType.Marker };
var FormattingElementList = class {
	constructor(treeAdapter) {
		this.treeAdapter = treeAdapter;
		this.entries = [];
		this.bookmark = null;
	}
	//Noah Ark's condition
	//OPTIMIZATION: at first we try to find possible candidates for exclusion using
	//lightweight heuristics without thorough attributes check.
	_getNoahArkConditionCandidates(newElement, neAttrs) {
		const candidates = [];
		const neAttrsLength = neAttrs.length;
		const neTagName = this.treeAdapter.getTagName(newElement);
		const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);
		for (let i = 0; i < this.entries.length; i++) {
			const entry = this.entries[i];
			if (entry.type === EntryType.Marker) {
				break;
			}
			const { element } = entry;
			if (
				this.treeAdapter.getTagName(element) === neTagName &&
				this.treeAdapter.getNamespaceURI(element) === neNamespaceURI
			) {
				const elementAttrs = this.treeAdapter.getAttrList(element);
				if (elementAttrs.length === neAttrsLength) {
					candidates.push({ idx: i, attrs: elementAttrs });
				}
			}
		}
		return candidates;
	}
	_ensureNoahArkCondition(newElement) {
		if (this.entries.length < NOAH_ARK_CAPACITY) return;
		const neAttrs = this.treeAdapter.getAttrList(newElement);
		const candidates = this._getNoahArkConditionCandidates(newElement, neAttrs);
		if (candidates.length < NOAH_ARK_CAPACITY) return;
		const neAttrsMap = new Map(neAttrs.map((neAttr) => [neAttr.name, neAttr.value]));
		let validCandidates = 0;
		for (let i = 0; i < candidates.length; i++) {
			const candidate = candidates[i];
			if (candidate.attrs.every((cAttr) => neAttrsMap.get(cAttr.name) === cAttr.value)) {
				validCandidates += 1;
				if (validCandidates >= NOAH_ARK_CAPACITY) {
					this.entries.splice(candidate.idx, 1);
				}
			}
		}
	}
	//Mutations
	insertMarker() {
		this.entries.unshift(MARKER);
	}
	pushElement(element, token) {
		this._ensureNoahArkCondition(element);
		this.entries.unshift({
			type: EntryType.Element,
			element,
			token,
		});
	}
	insertElementAfterBookmark(element, token) {
		const bookmarkIdx = this.entries.indexOf(this.bookmark);
		this.entries.splice(bookmarkIdx, 0, {
			type: EntryType.Element,
			element,
			token,
		});
	}
	removeEntry(entry) {
		const entryIndex = this.entries.indexOf(entry);
		if (entryIndex >= 0) {
			this.entries.splice(entryIndex, 1);
		}
	}
	/**
	 * Clears the list of formatting elements up to the last marker.
	 *
	 * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
	 */
	clearToLastMarker() {
		const markerIdx = this.entries.indexOf(MARKER);
		if (markerIdx >= 0) {
			this.entries.splice(0, markerIdx + 1);
		} else {
			this.entries.length = 0;
		}
	}
	//Search
	getElementEntryInScopeWithTagName(tagName) {
		const entry = this.entries.find(
			(entry2) => entry2.type === EntryType.Marker || this.treeAdapter.getTagName(entry2.element) === tagName,
		);
		return entry && entry.type === EntryType.Element ? entry : null;
	}
	getElementEntry(element) {
		return this.entries.find((entry) => entry.type === EntryType.Element && entry.element === element);
	}
};

// node_modules/parse5/dist/tree-adapters/default.js
var defaultTreeAdapter = {
	//Node construction
	createDocument() {
		return {
			nodeName: '#document',
			mode: DOCUMENT_MODE.NO_QUIRKS,
			childNodes: [],
		};
	},
	createDocumentFragment() {
		return {
			nodeName: '#document-fragment',
			childNodes: [],
		};
	},
	createElement(tagName, namespaceURI, attrs) {
		return {
			nodeName: tagName,
			tagName,
			attrs,
			namespaceURI,
			childNodes: [],
			parentNode: null,
		};
	},
	createCommentNode(data) {
		return {
			nodeName: '#comment',
			data,
			parentNode: null,
		};
	},
	createTextNode(value) {
		return {
			nodeName: '#text',
			value,
			parentNode: null,
		};
	},
	//Tree mutation
	appendChild(parentNode, newNode) {
		parentNode.childNodes.push(newNode);
		newNode.parentNode = parentNode;
	},
	insertBefore(parentNode, newNode, referenceNode) {
		const insertionIdx = parentNode.childNodes.indexOf(referenceNode);
		parentNode.childNodes.splice(insertionIdx, 0, newNode);
		newNode.parentNode = parentNode;
	},
	setTemplateContent(templateElement, contentElement) {
		templateElement.content = contentElement;
	},
	getTemplateContent(templateElement) {
		return templateElement.content;
	},
	setDocumentType(document2, name, publicId, systemId) {
		const doctypeNode = document2.childNodes.find((node) => node.nodeName === '#documentType');
		if (doctypeNode) {
			doctypeNode.name = name;
			doctypeNode.publicId = publicId;
			doctypeNode.systemId = systemId;
		} else {
			const node = {
				nodeName: '#documentType',
				name,
				publicId,
				systemId,
				parentNode: null,
			};
			defaultTreeAdapter.appendChild(document2, node);
		}
	},
	setDocumentMode(document2, mode) {
		document2.mode = mode;
	},
	getDocumentMode(document2) {
		return document2.mode;
	},
	detachNode(node) {
		if (node.parentNode) {
			const idx = node.parentNode.childNodes.indexOf(node);
			node.parentNode.childNodes.splice(idx, 1);
			node.parentNode = null;
		}
	},
	insertText(parentNode, text) {
		if (parentNode.childNodes.length > 0) {
			const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];
			if (defaultTreeAdapter.isTextNode(prevNode)) {
				prevNode.value += text;
				return;
			}
		}
		defaultTreeAdapter.appendChild(parentNode, defaultTreeAdapter.createTextNode(text));
	},
	insertTextBefore(parentNode, text, referenceNode) {
		const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
		if (prevNode && defaultTreeAdapter.isTextNode(prevNode)) {
			prevNode.value += text;
		} else {
			defaultTreeAdapter.insertBefore(parentNode, defaultTreeAdapter.createTextNode(text), referenceNode);
		}
	},
	adoptAttributes(recipient, attrs) {
		const recipientAttrsMap = new Set(recipient.attrs.map((attr) => attr.name));
		for (let j = 0; j < attrs.length; j++) {
			if (!recipientAttrsMap.has(attrs[j].name)) {
				recipient.attrs.push(attrs[j]);
			}
		}
	},
	//Tree traversing
	getFirstChild(node) {
		return node.childNodes[0];
	},
	getChildNodes(node) {
		return node.childNodes;
	},
	getParentNode(node) {
		return node.parentNode;
	},
	getAttrList(element) {
		return element.attrs;
	},
	//Node data
	getTagName(element) {
		return element.tagName;
	},
	getNamespaceURI(element) {
		return element.namespaceURI;
	},
	getTextNodeContent(textNode) {
		return textNode.value;
	},
	getCommentNodeContent(commentNode) {
		return commentNode.data;
	},
	getDocumentTypeNodeName(doctypeNode) {
		return doctypeNode.name;
	},
	getDocumentTypeNodePublicId(doctypeNode) {
		return doctypeNode.publicId;
	},
	getDocumentTypeNodeSystemId(doctypeNode) {
		return doctypeNode.systemId;
	},
	//Node types
	isTextNode(node) {
		return node.nodeName === '#text';
	},
	isCommentNode(node) {
		return node.nodeName === '#comment';
	},
	isDocumentTypeNode(node) {
		return node.nodeName === '#documentType';
	},
	isElementNode(node) {
		return Object.prototype.hasOwnProperty.call(node, 'tagName');
	},
	// Source code location
	setNodeSourceCodeLocation(node, location2) {
		node.sourceCodeLocation = location2;
	},
	getNodeSourceCodeLocation(node) {
		return node.sourceCodeLocation;
	},
	updateNodeSourceCodeLocation(node, endLocation) {
		node.sourceCodeLocation = { ...node.sourceCodeLocation, ...endLocation };
	},
};

// node_modules/parse5/dist/common/doctype.js
var VALID_DOCTYPE_NAME = 'html';
var VALID_SYSTEM_ID = 'about:legacy-compat';
var QUIRKS_MODE_SYSTEM_ID = 'http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd';
var QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
	'+//silmaril//dtd html pro v0r11 19970101//',
	'-//as//dtd html 3.0 aswedit + extensions//',
	'-//advasoft ltd//dtd html 3.0 aswedit + extensions//',
	'-//ietf//dtd html 2.0 level 1//',
	'-//ietf//dtd html 2.0 level 2//',
	'-//ietf//dtd html 2.0 strict level 1//',
	'-//ietf//dtd html 2.0 strict level 2//',
	'-//ietf//dtd html 2.0 strict//',
	'-//ietf//dtd html 2.0//',
	'-//ietf//dtd html 2.1e//',
	'-//ietf//dtd html 3.0//',
	'-//ietf//dtd html 3.2 final//',
	'-//ietf//dtd html 3.2//',
	'-//ietf//dtd html 3//',
	'-//ietf//dtd html level 0//',
	'-//ietf//dtd html level 1//',
	'-//ietf//dtd html level 2//',
	'-//ietf//dtd html level 3//',
	'-//ietf//dtd html strict level 0//',
	'-//ietf//dtd html strict level 1//',
	'-//ietf//dtd html strict level 2//',
	'-//ietf//dtd html strict level 3//',
	'-//ietf//dtd html strict//',
	'-//ietf//dtd html//',
	'-//metrius//dtd metrius presentational//',
	'-//microsoft//dtd internet explorer 2.0 html strict//',
	'-//microsoft//dtd internet explorer 2.0 html//',
	'-//microsoft//dtd internet explorer 2.0 tables//',
	'-//microsoft//dtd internet explorer 3.0 html strict//',
	'-//microsoft//dtd internet explorer 3.0 html//',
	'-//microsoft//dtd internet explorer 3.0 tables//',
	'-//netscape comm. corp.//dtd html//',
	'-//netscape comm. corp.//dtd strict html//',
	"-//o'reilly and associates//dtd html 2.0//",
	"-//o'reilly and associates//dtd html extended 1.0//",
	"-//o'reilly and associates//dtd html extended relaxed 1.0//",
	'-//sq//dtd html 2.0 hotmetal + extensions//',
	'-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//',
	'-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//',
	'-//spyglass//dtd html 2.0 extended//',
	'-//sun microsystems corp.//dtd hotjava html//',
	'-//sun microsystems corp.//dtd hotjava strict html//',
	'-//w3c//dtd html 3 1995-03-24//',
	'-//w3c//dtd html 3.2 draft//',
	'-//w3c//dtd html 3.2 final//',
	'-//w3c//dtd html 3.2//',
	'-//w3c//dtd html 3.2s draft//',
	'-//w3c//dtd html 4.0 frameset//',
	'-//w3c//dtd html 4.0 transitional//',
	'-//w3c//dtd html experimental 19960712//',
	'-//w3c//dtd html experimental 970421//',
	'-//w3c//dtd w3 html//',
	'-//w3o//dtd w3 html 3.0//',
	'-//webtechs//dtd mozilla html 2.0//',
	'-//webtechs//dtd mozilla html//',
];
var QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
	...QUIRKS_MODE_PUBLIC_ID_PREFIXES,
	'-//w3c//dtd html 4.01 frameset//',
	'-//w3c//dtd html 4.01 transitional//',
];
var QUIRKS_MODE_PUBLIC_IDS = /* @__PURE__ */ new Set([
	'-//w3o//dtd w3 html strict 3.0//en//',
	'-/w3c/dtd html 4.0 transitional/en',
	'html',
]);
var LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = ['-//w3c//dtd xhtml 1.0 frameset//', '-//w3c//dtd xhtml 1.0 transitional//'];
var LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
	...LIMITED_QUIRKS_PUBLIC_ID_PREFIXES,
	'-//w3c//dtd html 4.01 frameset//',
	'-//w3c//dtd html 4.01 transitional//',
];
function hasPrefix(publicId, prefixes) {
	return prefixes.some((prefix) => publicId.startsWith(prefix));
}
function isConforming(token) {
	return (
		token.name === VALID_DOCTYPE_NAME &&
		token.publicId === null &&
		(token.systemId === null || token.systemId === VALID_SYSTEM_ID)
	);
}
function getDocumentMode(token) {
	if (token.name !== VALID_DOCTYPE_NAME) {
		return DOCUMENT_MODE.QUIRKS;
	}
	const { systemId } = token;
	if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {
		return DOCUMENT_MODE.QUIRKS;
	}
	let { publicId } = token;
	if (publicId !== null) {
		publicId = publicId.toLowerCase();
		if (QUIRKS_MODE_PUBLIC_IDS.has(publicId)) {
			return DOCUMENT_MODE.QUIRKS;
		}
		let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;
		if (hasPrefix(publicId, prefixes)) {
			return DOCUMENT_MODE.QUIRKS;
		}
		prefixes = systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;
		if (hasPrefix(publicId, prefixes)) {
			return DOCUMENT_MODE.LIMITED_QUIRKS;
		}
	}
	return DOCUMENT_MODE.NO_QUIRKS;
}

// node_modules/parse5/dist/common/foreign-content.js
var foreign_content_exports = {};
__export(foreign_content_exports, {
	SVG_TAG_NAMES_ADJUSTMENT_MAP: () => SVG_TAG_NAMES_ADJUSTMENT_MAP,
	adjustTokenMathMLAttrs: () => adjustTokenMathMLAttrs,
	adjustTokenSVGAttrs: () => adjustTokenSVGAttrs,
	adjustTokenSVGTagName: () => adjustTokenSVGTagName,
	adjustTokenXMLAttrs: () => adjustTokenXMLAttrs,
	causesExit: () => causesExit,
	isIntegrationPoint: () => isIntegrationPoint,
});
var MIME_TYPES = {
	TEXT_HTML: 'text/html',
	APPLICATION_XML: 'application/xhtml+xml',
};
var DEFINITION_URL_ATTR = 'definitionurl';
var ADJUSTED_DEFINITION_URL_ATTR = 'definitionURL';
var SVG_ATTRS_ADJUSTMENT_MAP = new Map(
	[
		'attributeName',
		'attributeType',
		'baseFrequency',
		'baseProfile',
		'calcMode',
		'clipPathUnits',
		'diffuseConstant',
		'edgeMode',
		'filterUnits',
		'glyphRef',
		'gradientTransform',
		'gradientUnits',
		'kernelMatrix',
		'kernelUnitLength',
		'keyPoints',
		'keySplines',
		'keyTimes',
		'lengthAdjust',
		'limitingConeAngle',
		'markerHeight',
		'markerUnits',
		'markerWidth',
		'maskContentUnits',
		'maskUnits',
		'numOctaves',
		'pathLength',
		'patternContentUnits',
		'patternTransform',
		'patternUnits',
		'pointsAtX',
		'pointsAtY',
		'pointsAtZ',
		'preserveAlpha',
		'preserveAspectRatio',
		'primitiveUnits',
		'refX',
		'refY',
		'repeatCount',
		'repeatDur',
		'requiredExtensions',
		'requiredFeatures',
		'specularConstant',
		'specularExponent',
		'spreadMethod',
		'startOffset',
		'stdDeviation',
		'stitchTiles',
		'surfaceScale',
		'systemLanguage',
		'tableValues',
		'targetX',
		'targetY',
		'textLength',
		'viewBox',
		'viewTarget',
		'xChannelSelector',
		'yChannelSelector',
		'zoomAndPan',
	].map((attr) => [attr.toLowerCase(), attr]),
);
var XML_ATTRS_ADJUSTMENT_MAP = /* @__PURE__ */ new Map([
	['xlink:actuate', { prefix: 'xlink', name: 'actuate', namespace: NS.XLINK }],
	['xlink:arcrole', { prefix: 'xlink', name: 'arcrole', namespace: NS.XLINK }],
	['xlink:href', { prefix: 'xlink', name: 'href', namespace: NS.XLINK }],
	['xlink:role', { prefix: 'xlink', name: 'role', namespace: NS.XLINK }],
	['xlink:show', { prefix: 'xlink', name: 'show', namespace: NS.XLINK }],
	['xlink:title', { prefix: 'xlink', name: 'title', namespace: NS.XLINK }],
	['xlink:type', { prefix: 'xlink', name: 'type', namespace: NS.XLINK }],
	['xml:lang', { prefix: 'xml', name: 'lang', namespace: NS.XML }],
	['xml:space', { prefix: 'xml', name: 'space', namespace: NS.XML }],
	['xmlns', { prefix: '', name: 'xmlns', namespace: NS.XMLNS }],
	['xmlns:xlink', { prefix: 'xmlns', name: 'xlink', namespace: NS.XMLNS }],
]);
var SVG_TAG_NAMES_ADJUSTMENT_MAP = new Map(
	[
		'altGlyph',
		'altGlyphDef',
		'altGlyphItem',
		'animateColor',
		'animateMotion',
		'animateTransform',
		'clipPath',
		'feBlend',
		'feColorMatrix',
		'feComponentTransfer',
		'feComposite',
		'feConvolveMatrix',
		'feDiffuseLighting',
		'feDisplacementMap',
		'feDistantLight',
		'feFlood',
		'feFuncA',
		'feFuncB',
		'feFuncG',
		'feFuncR',
		'feGaussianBlur',
		'feImage',
		'feMerge',
		'feMergeNode',
		'feMorphology',
		'feOffset',
		'fePointLight',
		'feSpecularLighting',
		'feSpotLight',
		'feTile',
		'feTurbulence',
		'foreignObject',
		'glyphRef',
		'linearGradient',
		'radialGradient',
		'textPath',
	].map((tn) => [tn.toLowerCase(), tn]),
);
var EXITS_FOREIGN_CONTENT = /* @__PURE__ */ new Set([
	TAG_ID.B,
	TAG_ID.BIG,
	TAG_ID.BLOCKQUOTE,
	TAG_ID.BODY,
	TAG_ID.BR,
	TAG_ID.CENTER,
	TAG_ID.CODE,
	TAG_ID.DD,
	TAG_ID.DIV,
	TAG_ID.DL,
	TAG_ID.DT,
	TAG_ID.EM,
	TAG_ID.EMBED,
	TAG_ID.H1,
	TAG_ID.H2,
	TAG_ID.H3,
	TAG_ID.H4,
	TAG_ID.H5,
	TAG_ID.H6,
	TAG_ID.HEAD,
	TAG_ID.HR,
	TAG_ID.I,
	TAG_ID.IMG,
	TAG_ID.LI,
	TAG_ID.LISTING,
	TAG_ID.MENU,
	TAG_ID.META,
	TAG_ID.NOBR,
	TAG_ID.OL,
	TAG_ID.P,
	TAG_ID.PRE,
	TAG_ID.RUBY,
	TAG_ID.S,
	TAG_ID.SMALL,
	TAG_ID.SPAN,
	TAG_ID.STRONG,
	TAG_ID.STRIKE,
	TAG_ID.SUB,
	TAG_ID.SUP,
	TAG_ID.TABLE,
	TAG_ID.TT,
	TAG_ID.U,
	TAG_ID.UL,
	TAG_ID.VAR,
]);
function causesExit(startTagToken) {
	const tn = startTagToken.tagID;
	const isFontWithAttrs =
		tn === TAG_ID.FONT &&
		startTagToken.attrs.some(({ name }) => name === ATTRS.COLOR || name === ATTRS.SIZE || name === ATTRS.FACE);
	return isFontWithAttrs || EXITS_FOREIGN_CONTENT.has(tn);
}
function adjustTokenMathMLAttrs(token) {
	for (let i = 0; i < token.attrs.length; i++) {
		if (token.attrs[i].name === DEFINITION_URL_ATTR) {
			token.attrs[i].name = ADJUSTED_DEFINITION_URL_ATTR;
			break;
		}
	}
}
function adjustTokenSVGAttrs(token) {
	for (let i = 0; i < token.attrs.length; i++) {
		const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i].name);
		if (adjustedAttrName != null) {
			token.attrs[i].name = adjustedAttrName;
		}
	}
}
function adjustTokenXMLAttrs(token) {
	for (let i = 0; i < token.attrs.length; i++) {
		const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i].name);
		if (adjustedAttrEntry) {
			token.attrs[i].prefix = adjustedAttrEntry.prefix;
			token.attrs[i].name = adjustedAttrEntry.name;
			token.attrs[i].namespace = adjustedAttrEntry.namespace;
		}
	}
}
function adjustTokenSVGTagName(token) {
	const adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP.get(token.tagName);
	if (adjustedTagName != null) {
		token.tagName = adjustedTagName;
		token.tagID = getTagID(token.tagName);
	}
}
function isMathMLTextIntegrationPoint(tn, ns) {
	return (
		ns === NS.MATHML &&
		(tn === TAG_ID.MI || tn === TAG_ID.MO || tn === TAG_ID.MN || tn === TAG_ID.MS || tn === TAG_ID.MTEXT)
	);
}
function isHtmlIntegrationPoint(tn, ns, attrs) {
	if (ns === NS.MATHML && tn === TAG_ID.ANNOTATION_XML) {
		for (let i = 0; i < attrs.length; i++) {
			if (attrs[i].name === ATTRS.ENCODING) {
				const value = attrs[i].value.toLowerCase();
				return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;
			}
		}
	}
	return ns === NS.SVG && (tn === TAG_ID.FOREIGN_OBJECT || tn === TAG_ID.DESC || tn === TAG_ID.TITLE);
}
function isIntegrationPoint(tn, ns, attrs, foreignNS) {
	return (
		((!foreignNS || foreignNS === NS.HTML) && isHtmlIntegrationPoint(tn, ns, attrs)) ||
		((!foreignNS || foreignNS === NS.MATHML) && isMathMLTextIntegrationPoint(tn, ns))
	);
}

// node_modules/parse5/dist/parser/index.js
var HIDDEN_INPUT_TYPE = 'hidden';
var AA_OUTER_LOOP_ITER = 8;
var AA_INNER_LOOP_ITER = 3;
var InsertionMode;
(function (InsertionMode2) {
	InsertionMode2[(InsertionMode2['INITIAL'] = 0)] = 'INITIAL';
	InsertionMode2[(InsertionMode2['BEFORE_HTML'] = 1)] = 'BEFORE_HTML';
	InsertionMode2[(InsertionMode2['BEFORE_HEAD'] = 2)] = 'BEFORE_HEAD';
	InsertionMode2[(InsertionMode2['IN_HEAD'] = 3)] = 'IN_HEAD';
	InsertionMode2[(InsertionMode2['IN_HEAD_NO_SCRIPT'] = 4)] = 'IN_HEAD_NO_SCRIPT';
	InsertionMode2[(InsertionMode2['AFTER_HEAD'] = 5)] = 'AFTER_HEAD';
	InsertionMode2[(InsertionMode2['IN_BODY'] = 6)] = 'IN_BODY';
	InsertionMode2[(InsertionMode2['TEXT'] = 7)] = 'TEXT';
	InsertionMode2[(InsertionMode2['IN_TABLE'] = 8)] = 'IN_TABLE';
	InsertionMode2[(InsertionMode2['IN_TABLE_TEXT'] = 9)] = 'IN_TABLE_TEXT';
	InsertionMode2[(InsertionMode2['IN_CAPTION'] = 10)] = 'IN_CAPTION';
	InsertionMode2[(InsertionMode2['IN_COLUMN_GROUP'] = 11)] = 'IN_COLUMN_GROUP';
	InsertionMode2[(InsertionMode2['IN_TABLE_BODY'] = 12)] = 'IN_TABLE_BODY';
	InsertionMode2[(InsertionMode2['IN_ROW'] = 13)] = 'IN_ROW';
	InsertionMode2[(InsertionMode2['IN_CELL'] = 14)] = 'IN_CELL';
	InsertionMode2[(InsertionMode2['IN_SELECT'] = 15)] = 'IN_SELECT';
	InsertionMode2[(InsertionMode2['IN_SELECT_IN_TABLE'] = 16)] = 'IN_SELECT_IN_TABLE';
	InsertionMode2[(InsertionMode2['IN_TEMPLATE'] = 17)] = 'IN_TEMPLATE';
	InsertionMode2[(InsertionMode2['AFTER_BODY'] = 18)] = 'AFTER_BODY';
	InsertionMode2[(InsertionMode2['IN_FRAMESET'] = 19)] = 'IN_FRAMESET';
	InsertionMode2[(InsertionMode2['AFTER_FRAMESET'] = 20)] = 'AFTER_FRAMESET';
	InsertionMode2[(InsertionMode2['AFTER_AFTER_BODY'] = 21)] = 'AFTER_AFTER_BODY';
	InsertionMode2[(InsertionMode2['AFTER_AFTER_FRAMESET'] = 22)] = 'AFTER_AFTER_FRAMESET';
})(InsertionMode || (InsertionMode = {}));
var BASE_LOC = {
	startLine: -1,
	startCol: -1,
	startOffset: -1,
	endLine: -1,
	endCol: -1,
	endOffset: -1,
};
var TABLE_STRUCTURE_TAGS = /* @__PURE__ */ new Set([TAG_ID.TABLE, TAG_ID.TBODY, TAG_ID.TFOOT, TAG_ID.THEAD, TAG_ID.TR]);
var defaultParserOptions = {
	scriptingEnabled: true,
	sourceCodeLocationInfo: false,
	treeAdapter: defaultTreeAdapter,
	onParseError: null,
};
var Parser = class {
	constructor(options, document2, fragmentContext = null, scriptHandler = null) {
		this.fragmentContext = fragmentContext;
		this.scriptHandler = scriptHandler;
		this.currentToken = null;
		this.stopped = false;
		this.insertionMode = InsertionMode.INITIAL;
		this.originalInsertionMode = InsertionMode.INITIAL;
		this.headElement = null;
		this.formElement = null;
		this.currentNotInHTML = false;
		this.tmplInsertionModeStack = [];
		this.pendingCharacterTokens = [];
		this.hasNonWhitespacePendingCharacterToken = false;
		this.framesetOk = true;
		this.skipNextNewLine = false;
		this.fosterParentingEnabled = false;
		this.options = {
			...defaultParserOptions,
			...options,
		};
		this.treeAdapter = this.options.treeAdapter;
		this.onParseError = this.options.onParseError;
		if (this.onParseError) {
			this.options.sourceCodeLocationInfo = true;
		}
		this.document = document2 !== null && document2 !== void 0 ? document2 : this.treeAdapter.createDocument();
		this.tokenizer = new Tokenizer(this.options, this);
		this.activeFormattingElements = new FormattingElementList(this.treeAdapter);
		this.fragmentContextID = fragmentContext ? getTagID(this.treeAdapter.getTagName(fragmentContext)) : TAG_ID.UNKNOWN;
		this._setContextModes(
			fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : this.document,
			this.fragmentContextID,
		);
		this.openElements = new OpenElementStack(this.document, this.treeAdapter, this);
	}
	// API
	static parse(html, options) {
		const parser = new this(options);
		parser.tokenizer.write(html, true);
		return parser.document;
	}
	static getFragmentParser(fragmentContext, options) {
		const opts = {
			...defaultParserOptions,
			...options,
		};
		fragmentContext !== null && fragmentContext !== void 0
			? fragmentContext
			: (fragmentContext = opts.treeAdapter.createElement(TAG_NAMES.TEMPLATE, NS.HTML, []));
		const documentMock = opts.treeAdapter.createElement('documentmock', NS.HTML, []);
		const parser = new this(opts, documentMock, fragmentContext);
		if (parser.fragmentContextID === TAG_ID.TEMPLATE) {
			parser.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
		}
		parser._initTokenizerForFragmentParsing();
		parser._insertFakeRootElement();
		parser._resetInsertionMode();
		parser._findFormInFragmentContext();
		return parser;
	}
	getFragment() {
		const rootElement = this.treeAdapter.getFirstChild(this.document);
		const fragment = this.treeAdapter.createDocumentFragment();
		this._adoptNodes(rootElement, fragment);
		return fragment;
	}
	//Errors
	/** @internal */
	_err(token, code, beforeToken) {
		var _a2;
		if (!this.onParseError) return;
		const loc = (_a2 = token.location) !== null && _a2 !== void 0 ? _a2 : BASE_LOC;
		const err2 = {
			code,
			startLine: loc.startLine,
			startCol: loc.startCol,
			startOffset: loc.startOffset,
			endLine: beforeToken ? loc.startLine : loc.endLine,
			endCol: beforeToken ? loc.startCol : loc.endCol,
			endOffset: beforeToken ? loc.startOffset : loc.endOffset,
		};
		this.onParseError(err2);
	}
	//Stack events
	/** @internal */
	onItemPush(node, tid, isTop) {
		var _a2, _b;
		(_b = (_a2 = this.treeAdapter).onItemPush) === null || _b === void 0 ? void 0 : _b.call(_a2, node);
		if (isTop && this.openElements.stackTop > 0) this._setContextModes(node, tid);
	}
	/** @internal */
	onItemPop(node, isTop) {
		var _a2, _b;
		if (this.options.sourceCodeLocationInfo) {
			this._setEndLocation(node, this.currentToken);
		}
		(_b = (_a2 = this.treeAdapter).onItemPop) === null || _b === void 0
			? void 0
			: _b.call(_a2, node, this.openElements.current);
		if (isTop) {
			let current;
			let currentTagId;
			if (this.openElements.stackTop === 0 && this.fragmentContext) {
				current = this.fragmentContext;
				currentTagId = this.fragmentContextID;
			} else {
				({ current, currentTagId } = this.openElements);
			}
			this._setContextModes(current, currentTagId);
		}
	}
	_setContextModes(current, tid) {
		const isHTML = current === this.document || this.treeAdapter.getNamespaceURI(current) === NS.HTML;
		this.currentNotInHTML = !isHTML;
		this.tokenizer.inForeignNode = !isHTML && !this._isIntegrationPoint(tid, current);
	}
	/** @protected */
	_switchToTextParsing(currentToken, nextTokenizerState) {
		this._insertElement(currentToken, NS.HTML);
		this.tokenizer.state = nextTokenizerState;
		this.originalInsertionMode = this.insertionMode;
		this.insertionMode = InsertionMode.TEXT;
	}
	switchToPlaintextParsing() {
		this.insertionMode = InsertionMode.TEXT;
		this.originalInsertionMode = InsertionMode.IN_BODY;
		this.tokenizer.state = TokenizerMode.PLAINTEXT;
	}
	//Fragment parsing
	/** @protected */
	_getAdjustedCurrentElement() {
		return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
	}
	/** @protected */
	_findFormInFragmentContext() {
		let node = this.fragmentContext;
		while (node) {
			if (this.treeAdapter.getTagName(node) === TAG_NAMES.FORM) {
				this.formElement = node;
				break;
			}
			node = this.treeAdapter.getParentNode(node);
		}
	}
	_initTokenizerForFragmentParsing() {
		if (!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== NS.HTML) {
			return;
		}
		switch (this.fragmentContextID) {
			case TAG_ID.TITLE:
			case TAG_ID.TEXTAREA: {
				this.tokenizer.state = TokenizerMode.RCDATA;
				break;
			}
			case TAG_ID.STYLE:
			case TAG_ID.XMP:
			case TAG_ID.IFRAME:
			case TAG_ID.NOEMBED:
			case TAG_ID.NOFRAMES:
			case TAG_ID.NOSCRIPT: {
				this.tokenizer.state = TokenizerMode.RAWTEXT;
				break;
			}
			case TAG_ID.SCRIPT: {
				this.tokenizer.state = TokenizerMode.SCRIPT_DATA;
				break;
			}
			case TAG_ID.PLAINTEXT: {
				this.tokenizer.state = TokenizerMode.PLAINTEXT;
				break;
			}
			default:
		}
	}
	//Tree mutation
	/** @protected */
	_setDocumentType(token) {
		const name = token.name || '';
		const publicId = token.publicId || '';
		const systemId = token.systemId || '';
		this.treeAdapter.setDocumentType(this.document, name, publicId, systemId);
		if (token.location) {
			const documentChildren = this.treeAdapter.getChildNodes(this.document);
			const docTypeNode = documentChildren.find((node) => this.treeAdapter.isDocumentTypeNode(node));
			if (docTypeNode) {
				this.treeAdapter.setNodeSourceCodeLocation(docTypeNode, token.location);
			}
		}
	}
	/** @protected */
	_attachElementToTree(element, location2) {
		if (this.options.sourceCodeLocationInfo) {
			const loc = location2 && {
				...location2,
				startTag: location2,
			};
			this.treeAdapter.setNodeSourceCodeLocation(element, loc);
		}
		if (this._shouldFosterParentOnInsertion()) {
			this._fosterParentElement(element);
		} else {
			const parent = this.openElements.currentTmplContentOrNode;
			this.treeAdapter.appendChild(parent, element);
		}
	}
	/**
	 * For self-closing tags. Add an element to the tree, but skip adding it
	 * to the stack.
	 */
	/** @protected */
	_appendElement(token, namespaceURI) {
		const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
		this._attachElementToTree(element, token.location);
	}
	/** @protected */
	_insertElement(token, namespaceURI) {
		const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
		this._attachElementToTree(element, token.location);
		this.openElements.push(element, token.tagID);
	}
	/** @protected */
	_insertFakeElement(tagName, tagID) {
		const element = this.treeAdapter.createElement(tagName, NS.HTML, []);
		this._attachElementToTree(element, null);
		this.openElements.push(element, tagID);
	}
	/** @protected */
	_insertTemplate(token) {
		const tmpl = this.treeAdapter.createElement(token.tagName, NS.HTML, token.attrs);
		const content = this.treeAdapter.createDocumentFragment();
		this.treeAdapter.setTemplateContent(tmpl, content);
		this._attachElementToTree(tmpl, token.location);
		this.openElements.push(tmpl, token.tagID);
		if (this.options.sourceCodeLocationInfo) this.treeAdapter.setNodeSourceCodeLocation(content, null);
	}
	/** @protected */
	_insertFakeRootElement() {
		const element = this.treeAdapter.createElement(TAG_NAMES.HTML, NS.HTML, []);
		if (this.options.sourceCodeLocationInfo) this.treeAdapter.setNodeSourceCodeLocation(element, null);
		this.treeAdapter.appendChild(this.openElements.current, element);
		this.openElements.push(element, TAG_ID.HTML);
	}
	/** @protected */
	_appendCommentNode(token, parent) {
		const commentNode = this.treeAdapter.createCommentNode(token.data);
		this.treeAdapter.appendChild(parent, commentNode);
		if (this.options.sourceCodeLocationInfo) {
			this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
		}
	}
	/** @protected */
	_insertCharacters(token) {
		let parent;
		let beforeElement;
		if (this._shouldFosterParentOnInsertion()) {
			({ parent, beforeElement } = this._findFosterParentingLocation());
			if (beforeElement) {
				this.treeAdapter.insertTextBefore(parent, token.chars, beforeElement);
			} else {
				this.treeAdapter.insertText(parent, token.chars);
			}
		} else {
			parent = this.openElements.currentTmplContentOrNode;
			this.treeAdapter.insertText(parent, token.chars);
		}
		if (!token.location) return;
		const siblings = this.treeAdapter.getChildNodes(parent);
		const textNodeIdx = beforeElement ? siblings.lastIndexOf(beforeElement) : siblings.length;
		const textNode = siblings[textNodeIdx - 1];
		const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);
		if (tnLoc) {
			const { endLine, endCol, endOffset } = token.location;
			this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });
		} else if (this.options.sourceCodeLocationInfo) {
			this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
		}
	}
	/** @protected */
	_adoptNodes(donor, recipient) {
		for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {
			this.treeAdapter.detachNode(child);
			this.treeAdapter.appendChild(recipient, child);
		}
	}
	/** @protected */
	_setEndLocation(element, closingToken) {
		if (this.treeAdapter.getNodeSourceCodeLocation(element) && closingToken.location) {
			const ctLoc = closingToken.location;
			const tn = this.treeAdapter.getTagName(element);
			const endLoc =
				// NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
				// tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
				closingToken.type === TokenType.END_TAG && tn === closingToken.tagName
					? {
							endTag: { ...ctLoc },
							endLine: ctLoc.endLine,
							endCol: ctLoc.endCol,
							endOffset: ctLoc.endOffset,
						}
					: {
							endLine: ctLoc.startLine,
							endCol: ctLoc.startCol,
							endOffset: ctLoc.startOffset,
						};
			this.treeAdapter.updateNodeSourceCodeLocation(element, endLoc);
		}
	}
	//Token processing
	shouldProcessStartTagTokenInForeignContent(token) {
		if (!this.currentNotInHTML) return false;
		let current;
		let currentTagId;
		if (this.openElements.stackTop === 0 && this.fragmentContext) {
			current = this.fragmentContext;
			currentTagId = this.fragmentContextID;
		} else {
			({ current, currentTagId } = this.openElements);
		}
		if (
			token.tagID === TAG_ID.SVG &&
			this.treeAdapter.getTagName(current) === TAG_NAMES.ANNOTATION_XML &&
			this.treeAdapter.getNamespaceURI(current) === NS.MATHML
		) {
			return false;
		}
		return (
			// Check that `current` is not an integration point for HTML or MathML elements.
			this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
			// integration point.
			((token.tagID === TAG_ID.MGLYPH || token.tagID === TAG_ID.MALIGNMARK) &&
				!this._isIntegrationPoint(currentTagId, current, NS.HTML))
		);
	}
	/** @protected */
	_processToken(token) {
		switch (token.type) {
			case TokenType.CHARACTER: {
				this.onCharacter(token);
				break;
			}
			case TokenType.NULL_CHARACTER: {
				this.onNullCharacter(token);
				break;
			}
			case TokenType.COMMENT: {
				this.onComment(token);
				break;
			}
			case TokenType.DOCTYPE: {
				this.onDoctype(token);
				break;
			}
			case TokenType.START_TAG: {
				this._processStartTag(token);
				break;
			}
			case TokenType.END_TAG: {
				this.onEndTag(token);
				break;
			}
			case TokenType.EOF: {
				this.onEof(token);
				break;
			}
			case TokenType.WHITESPACE_CHARACTER: {
				this.onWhitespaceCharacter(token);
				break;
			}
		}
	}
	//Integration points
	/** @protected */
	_isIntegrationPoint(tid, element, foreignNS) {
		const ns = this.treeAdapter.getNamespaceURI(element);
		const attrs = this.treeAdapter.getAttrList(element);
		return isIntegrationPoint(tid, ns, attrs, foreignNS);
	}
	//Active formatting elements reconstruction
	/** @protected */
	_reconstructActiveFormattingElements() {
		const listLength = this.activeFormattingElements.entries.length;
		if (listLength) {
			const endIndex = this.activeFormattingElements.entries.findIndex(
				(entry) => entry.type === EntryType.Marker || this.openElements.contains(entry.element),
			);
			const unopenIdx = endIndex < 0 ? listLength - 1 : endIndex - 1;
			for (let i = unopenIdx; i >= 0; i--) {
				const entry = this.activeFormattingElements.entries[i];
				this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
				entry.element = this.openElements.current;
			}
		}
	}
	//Close elements
	/** @protected */
	_closeTableCell() {
		this.openElements.generateImpliedEndTags();
		this.openElements.popUntilTableCellPopped();
		this.activeFormattingElements.clearToLastMarker();
		this.insertionMode = InsertionMode.IN_ROW;
	}
	/** @protected */
	_closePElement() {
		this.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.P);
		this.openElements.popUntilTagNamePopped(TAG_ID.P);
	}
	//Insertion modes
	/** @protected */
	_resetInsertionMode() {
		for (let i = this.openElements.stackTop; i >= 0; i--) {
			switch (i === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[i]) {
				case TAG_ID.TR: {
					this.insertionMode = InsertionMode.IN_ROW;
					return;
				}
				case TAG_ID.TBODY:
				case TAG_ID.THEAD:
				case TAG_ID.TFOOT: {
					this.insertionMode = InsertionMode.IN_TABLE_BODY;
					return;
				}
				case TAG_ID.CAPTION: {
					this.insertionMode = InsertionMode.IN_CAPTION;
					return;
				}
				case TAG_ID.COLGROUP: {
					this.insertionMode = InsertionMode.IN_COLUMN_GROUP;
					return;
				}
				case TAG_ID.TABLE: {
					this.insertionMode = InsertionMode.IN_TABLE;
					return;
				}
				case TAG_ID.BODY: {
					this.insertionMode = InsertionMode.IN_BODY;
					return;
				}
				case TAG_ID.FRAMESET: {
					this.insertionMode = InsertionMode.IN_FRAMESET;
					return;
				}
				case TAG_ID.SELECT: {
					this._resetInsertionModeForSelect(i);
					return;
				}
				case TAG_ID.TEMPLATE: {
					this.insertionMode = this.tmplInsertionModeStack[0];
					return;
				}
				case TAG_ID.HTML: {
					this.insertionMode = this.headElement ? InsertionMode.AFTER_HEAD : InsertionMode.BEFORE_HEAD;
					return;
				}
				case TAG_ID.TD:
				case TAG_ID.TH: {
					if (i > 0) {
						this.insertionMode = InsertionMode.IN_CELL;
						return;
					}
					break;
				}
				case TAG_ID.HEAD: {
					if (i > 0) {
						this.insertionMode = InsertionMode.IN_HEAD;
						return;
					}
					break;
				}
			}
		}
		this.insertionMode = InsertionMode.IN_BODY;
	}
	/** @protected */
	_resetInsertionModeForSelect(selectIdx) {
		if (selectIdx > 0) {
			for (let i = selectIdx - 1; i > 0; i--) {
				const tn = this.openElements.tagIDs[i];
				if (tn === TAG_ID.TEMPLATE) {
					break;
				} else if (tn === TAG_ID.TABLE) {
					this.insertionMode = InsertionMode.IN_SELECT_IN_TABLE;
					return;
				}
			}
		}
		this.insertionMode = InsertionMode.IN_SELECT;
	}
	//Foster parenting
	/** @protected */
	_isElementCausesFosterParenting(tn) {
		return TABLE_STRUCTURE_TAGS.has(tn);
	}
	/** @protected */
	_shouldFosterParentOnInsertion() {
		return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.currentTagId);
	}
	/** @protected */
	_findFosterParentingLocation() {
		for (let i = this.openElements.stackTop; i >= 0; i--) {
			const openElement = this.openElements.items[i];
			switch (this.openElements.tagIDs[i]) {
				case TAG_ID.TEMPLATE: {
					if (this.treeAdapter.getNamespaceURI(openElement) === NS.HTML) {
						return { parent: this.treeAdapter.getTemplateContent(openElement), beforeElement: null };
					}
					break;
				}
				case TAG_ID.TABLE: {
					const parent = this.treeAdapter.getParentNode(openElement);
					if (parent) {
						return { parent, beforeElement: openElement };
					}
					return { parent: this.openElements.items[i - 1], beforeElement: null };
				}
				default:
			}
		}
		return { parent: this.openElements.items[0], beforeElement: null };
	}
	/** @protected */
	_fosterParentElement(element) {
		const location2 = this._findFosterParentingLocation();
		if (location2.beforeElement) {
			this.treeAdapter.insertBefore(location2.parent, element, location2.beforeElement);
		} else {
			this.treeAdapter.appendChild(location2.parent, element);
		}
	}
	//Special elements
	/** @protected */
	_isSpecialElement(element, id) {
		const ns = this.treeAdapter.getNamespaceURI(element);
		return SPECIAL_ELEMENTS[ns].has(id);
	}
	/** @internal */
	onCharacter(token) {
		this.skipNextNewLine = false;
		if (this.tokenizer.inForeignNode) {
			characterInForeignContent(this, token);
			return;
		}
		switch (this.insertionMode) {
			case InsertionMode.INITIAL: {
				tokenInInitialMode(this, token);
				break;
			}
			case InsertionMode.BEFORE_HTML: {
				tokenBeforeHtml(this, token);
				break;
			}
			case InsertionMode.BEFORE_HEAD: {
				tokenBeforeHead(this, token);
				break;
			}
			case InsertionMode.IN_HEAD: {
				tokenInHead(this, token);
				break;
			}
			case InsertionMode.IN_HEAD_NO_SCRIPT: {
				tokenInHeadNoScript(this, token);
				break;
			}
			case InsertionMode.AFTER_HEAD: {
				tokenAfterHead(this, token);
				break;
			}
			case InsertionMode.IN_BODY:
			case InsertionMode.IN_CAPTION:
			case InsertionMode.IN_CELL:
			case InsertionMode.IN_TEMPLATE: {
				characterInBody(this, token);
				break;
			}
			case InsertionMode.TEXT:
			case InsertionMode.IN_SELECT:
			case InsertionMode.IN_SELECT_IN_TABLE: {
				this._insertCharacters(token);
				break;
			}
			case InsertionMode.IN_TABLE:
			case InsertionMode.IN_TABLE_BODY:
			case InsertionMode.IN_ROW: {
				characterInTable(this, token);
				break;
			}
			case InsertionMode.IN_TABLE_TEXT: {
				characterInTableText(this, token);
				break;
			}
			case InsertionMode.IN_COLUMN_GROUP: {
				tokenInColumnGroup(this, token);
				break;
			}
			case InsertionMode.AFTER_BODY: {
				tokenAfterBody(this, token);
				break;
			}
			case InsertionMode.AFTER_AFTER_BODY: {
				tokenAfterAfterBody(this, token);
				break;
			}
			default:
		}
	}
	/** @internal */
	onNullCharacter(token) {
		this.skipNextNewLine = false;
		if (this.tokenizer.inForeignNode) {
			nullCharacterInForeignContent(this, token);
			return;
		}
		switch (this.insertionMode) {
			case InsertionMode.INITIAL: {
				tokenInInitialMode(this, token);
				break;
			}
			case InsertionMode.BEFORE_HTML: {
				tokenBeforeHtml(this, token);
				break;
			}
			case InsertionMode.BEFORE_HEAD: {
				tokenBeforeHead(this, token);
				break;
			}
			case InsertionMode.IN_HEAD: {
				tokenInHead(this, token);
				break;
			}
			case InsertionMode.IN_HEAD_NO_SCRIPT: {
				tokenInHeadNoScript(this, token);
				break;
			}
			case InsertionMode.AFTER_HEAD: {
				tokenAfterHead(this, token);
				break;
			}
			case InsertionMode.TEXT: {
				this._insertCharacters(token);
				break;
			}
			case InsertionMode.IN_TABLE:
			case InsertionMode.IN_TABLE_BODY:
			case InsertionMode.IN_ROW: {
				characterInTable(this, token);
				break;
			}
			case InsertionMode.IN_COLUMN_GROUP: {
				tokenInColumnGroup(this, token);
				break;
			}
			case InsertionMode.AFTER_BODY: {
				tokenAfterBody(this, token);
				break;
			}
			case InsertionMode.AFTER_AFTER_BODY: {
				tokenAfterAfterBody(this, token);
				break;
			}
			default:
		}
	}
	/** @internal */
	onComment(token) {
		this.skipNextNewLine = false;
		if (this.currentNotInHTML) {
			appendComment(this, token);
			return;
		}
		switch (this.insertionMode) {
			case InsertionMode.INITIAL:
			case InsertionMode.BEFORE_HTML:
			case InsertionMode.BEFORE_HEAD:
			case InsertionMode.IN_HEAD:
			case InsertionMode.IN_HEAD_NO_SCRIPT:
			case InsertionMode.AFTER_HEAD:
			case InsertionMode.IN_BODY:
			case InsertionMode.IN_TABLE:
			case InsertionMode.IN_CAPTION:
			case InsertionMode.IN_COLUMN_GROUP:
			case InsertionMode.IN_TABLE_BODY:
			case InsertionMode.IN_ROW:
			case InsertionMode.IN_CELL:
			case InsertionMode.IN_SELECT:
			case InsertionMode.IN_SELECT_IN_TABLE:
			case InsertionMode.IN_TEMPLATE:
			case InsertionMode.IN_FRAMESET:
			case InsertionMode.AFTER_FRAMESET: {
				appendComment(this, token);
				break;
			}
			case InsertionMode.IN_TABLE_TEXT: {
				tokenInTableText(this, token);
				break;
			}
			case InsertionMode.AFTER_BODY: {
				appendCommentToRootHtmlElement(this, token);
				break;
			}
			case InsertionMode.AFTER_AFTER_BODY:
			case InsertionMode.AFTER_AFTER_FRAMESET: {
				appendCommentToDocument(this, token);
				break;
			}
			default:
		}
	}
	/** @internal */
	onDoctype(token) {
		this.skipNextNewLine = false;
		switch (this.insertionMode) {
			case InsertionMode.INITIAL: {
				doctypeInInitialMode(this, token);
				break;
			}
			case InsertionMode.BEFORE_HEAD:
			case InsertionMode.IN_HEAD:
			case InsertionMode.IN_HEAD_NO_SCRIPT:
			case InsertionMode.AFTER_HEAD: {
				this._err(token, ERR.misplacedDoctype);
				break;
			}
			case InsertionMode.IN_TABLE_TEXT: {
				tokenInTableText(this, token);
				break;
			}
			default:
		}
	}
	/** @internal */
	onStartTag(token) {
		this.skipNextNewLine = false;
		this.currentToken = token;
		this._processStartTag(token);
		if (token.selfClosing && !token.ackSelfClosing) {
			this._err(token, ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
		}
	}
	/**
	 * Processes a given start tag.
	 *
	 * `onStartTag` checks if a self-closing tag was recognized. When a token
	 * is moved inbetween multiple insertion modes, this check for self-closing
	 * could lead to false positives. To avoid this, `_processStartTag` is used
	 * for nested calls.
	 *
	 * @param token The token to process.
	 * @protected
	 */
	_processStartTag(token) {
		if (this.shouldProcessStartTagTokenInForeignContent(token)) {
			startTagInForeignContent(this, token);
		} else {
			this._startTagOutsideForeignContent(token);
		}
	}
	/** @protected */
	_startTagOutsideForeignContent(token) {
		switch (this.insertionMode) {
			case InsertionMode.INITIAL: {
				tokenInInitialMode(this, token);
				break;
			}
			case InsertionMode.BEFORE_HTML: {
				startTagBeforeHtml(this, token);
				break;
			}
			case InsertionMode.BEFORE_HEAD: {
				startTagBeforeHead(this, token);
				break;
			}
			case InsertionMode.IN_HEAD: {
				startTagInHead(this, token);
				break;
			}
			case InsertionMode.IN_HEAD_NO_SCRIPT: {
				startTagInHeadNoScript(this, token);
				break;
			}
			case InsertionMode.AFTER_HEAD: {
				startTagAfterHead(this, token);
				break;
			}
			case InsertionMode.IN_BODY: {
				startTagInBody(this, token);
				break;
			}
			case InsertionMode.IN_TABLE: {
				startTagInTable(this, token);
				break;
			}
			case InsertionMode.IN_TABLE_TEXT: {
				tokenInTableText(this, token);
				break;
			}
			case InsertionMode.IN_CAPTION: {
				startTagInCaption(this, token);
				break;
			}
			case InsertionMode.IN_COLUMN_GROUP: {
				startTagInColumnGroup(this, token);
				break;
			}
			case InsertionMode.IN_TABLE_BODY: {
				startTagInTableBody(this, token);
				break;
			}
			case InsertionMode.IN_ROW: {
				startTagInRow(this, token);
				break;
			}
			case InsertionMode.IN_CELL: {
				startTagInCell(this, token);
				break;
			}
			case InsertionMode.IN_SELECT: {
				startTagInSelect(this, token);
				break;
			}
			case InsertionMode.IN_SELECT_IN_TABLE: {
				startTagInSelectInTable(this, token);
				break;
			}
			case InsertionMode.IN_TEMPLATE: {
				startTagInTemplate(this, token);
				break;
			}
			case InsertionMode.AFTER_BODY: {
				startTagAfterBody(this, token);
				break;
			}
			case InsertionMode.IN_FRAMESET: {
				startTagInFrameset(this, token);
				break;
			}
			case InsertionMode.AFTER_FRAMESET: {
				startTagAfterFrameset(this, token);
				break;
			}
			case InsertionMode.AFTER_AFTER_BODY: {
				startTagAfterAfterBody(this, token);
				break;
			}
			case InsertionMode.AFTER_AFTER_FRAMESET: {
				startTagAfterAfterFrameset(this, token);
				break;
			}
			default:
		}
	}
	/** @internal */
	onEndTag(token) {
		this.skipNextNewLine = false;
		this.currentToken = token;
		if (this.currentNotInHTML) {
			endTagInForeignContent(this, token);
		} else {
			this._endTagOutsideForeignContent(token);
		}
	}
	/** @protected */
	_endTagOutsideForeignContent(token) {
		switch (this.insertionMode) {
			case InsertionMode.INITIAL: {
				tokenInInitialMode(this, token);
				break;
			}
			case InsertionMode.BEFORE_HTML: {
				endTagBeforeHtml(this, token);
				break;
			}
			case InsertionMode.BEFORE_HEAD: {
				endTagBeforeHead(this, token);
				break;
			}
			case InsertionMode.IN_HEAD: {
				endTagInHead(this, token);
				break;
			}
			case InsertionMode.IN_HEAD_NO_SCRIPT: {
				endTagInHeadNoScript(this, token);
				break;
			}
			case InsertionMode.AFTER_HEAD: {
				endTagAfterHead(this, token);
				break;
			}
			case InsertionMode.IN_BODY: {
				endTagInBody(this, token);
				break;
			}
			case InsertionMode.TEXT: {
				endTagInText(this, token);
				break;
			}
			case InsertionMode.IN_TABLE: {
				endTagInTable(this, token);
				break;
			}
			case InsertionMode.IN_TABLE_TEXT: {
				tokenInTableText(this, token);
				break;
			}
			case InsertionMode.IN_CAPTION: {
				endTagInCaption(this, token);
				break;
			}
			case InsertionMode.IN_COLUMN_GROUP: {
				endTagInColumnGroup(this, token);
				break;
			}
			case InsertionMode.IN_TABLE_BODY: {
				endTagInTableBody(this, token);
				break;
			}
			case InsertionMode.IN_ROW: {
				endTagInRow(this, token);
				break;
			}
			case InsertionMode.IN_CELL: {
				endTagInCell(this, token);
				break;
			}
			case InsertionMode.IN_SELECT: {
				endTagInSelect(this, token);
				break;
			}
			case InsertionMode.IN_SELECT_IN_TABLE: {
				endTagInSelectInTable(this, token);
				break;
			}
			case InsertionMode.IN_TEMPLATE: {
				endTagInTemplate(this, token);
				break;
			}
			case InsertionMode.AFTER_BODY: {
				endTagAfterBody(this, token);
				break;
			}
			case InsertionMode.IN_FRAMESET: {
				endTagInFrameset(this, token);
				break;
			}
			case InsertionMode.AFTER_FRAMESET: {
				endTagAfterFrameset(this, token);
				break;
			}
			case InsertionMode.AFTER_AFTER_BODY: {
				tokenAfterAfterBody(this, token);
				break;
			}
			default:
		}
	}
	/** @internal */
	onEof(token) {
		switch (this.insertionMode) {
			case InsertionMode.INITIAL: {
				tokenInInitialMode(this, token);
				break;
			}
			case InsertionMode.BEFORE_HTML: {
				tokenBeforeHtml(this, token);
				break;
			}
			case InsertionMode.BEFORE_HEAD: {
				tokenBeforeHead(this, token);
				break;
			}
			case InsertionMode.IN_HEAD: {
				tokenInHead(this, token);
				break;
			}
			case InsertionMode.IN_HEAD_NO_SCRIPT: {
				tokenInHeadNoScript(this, token);
				break;
			}
			case InsertionMode.AFTER_HEAD: {
				tokenAfterHead(this, token);
				break;
			}
			case InsertionMode.IN_BODY:
			case InsertionMode.IN_TABLE:
			case InsertionMode.IN_CAPTION:
			case InsertionMode.IN_COLUMN_GROUP:
			case InsertionMode.IN_TABLE_BODY:
			case InsertionMode.IN_ROW:
			case InsertionMode.IN_CELL:
			case InsertionMode.IN_SELECT:
			case InsertionMode.IN_SELECT_IN_TABLE: {
				eofInBody(this, token);
				break;
			}
			case InsertionMode.TEXT: {
				eofInText(this, token);
				break;
			}
			case InsertionMode.IN_TABLE_TEXT: {
				tokenInTableText(this, token);
				break;
			}
			case InsertionMode.IN_TEMPLATE: {
				eofInTemplate(this, token);
				break;
			}
			case InsertionMode.AFTER_BODY:
			case InsertionMode.IN_FRAMESET:
			case InsertionMode.AFTER_FRAMESET:
			case InsertionMode.AFTER_AFTER_BODY:
			case InsertionMode.AFTER_AFTER_FRAMESET: {
				stopParsing(this, token);
				break;
			}
			default:
		}
	}
	/** @internal */
	onWhitespaceCharacter(token) {
		if (this.skipNextNewLine) {
			this.skipNextNewLine = false;
			if (token.chars.charCodeAt(0) === CODE_POINTS.LINE_FEED) {
				if (token.chars.length === 1) {
					return;
				}
				token.chars = token.chars.substr(1);
			}
		}
		if (this.tokenizer.inForeignNode) {
			this._insertCharacters(token);
			return;
		}
		switch (this.insertionMode) {
			case InsertionMode.IN_HEAD:
			case InsertionMode.IN_HEAD_NO_SCRIPT:
			case InsertionMode.AFTER_HEAD:
			case InsertionMode.TEXT:
			case InsertionMode.IN_COLUMN_GROUP:
			case InsertionMode.IN_SELECT:
			case InsertionMode.IN_SELECT_IN_TABLE:
			case InsertionMode.IN_FRAMESET:
			case InsertionMode.AFTER_FRAMESET: {
				this._insertCharacters(token);
				break;
			}
			case InsertionMode.IN_BODY:
			case InsertionMode.IN_CAPTION:
			case InsertionMode.IN_CELL:
			case InsertionMode.IN_TEMPLATE:
			case InsertionMode.AFTER_BODY:
			case InsertionMode.AFTER_AFTER_BODY:
			case InsertionMode.AFTER_AFTER_FRAMESET: {
				whitespaceCharacterInBody(this, token);
				break;
			}
			case InsertionMode.IN_TABLE:
			case InsertionMode.IN_TABLE_BODY:
			case InsertionMode.IN_ROW: {
				characterInTable(this, token);
				break;
			}
			case InsertionMode.IN_TABLE_TEXT: {
				whitespaceCharacterInTableText(this, token);
				break;
			}
			default:
		}
	}
};
function aaObtainFormattingElementEntry(p, token) {
	let formattingElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);
	if (formattingElementEntry) {
		if (!p.openElements.contains(formattingElementEntry.element)) {
			p.activeFormattingElements.removeEntry(formattingElementEntry);
			formattingElementEntry = null;
		} else if (!p.openElements.hasInScope(token.tagID)) {
			formattingElementEntry = null;
		}
	} else {
		genericEndTagInBody(p, token);
	}
	return formattingElementEntry;
}
function aaObtainFurthestBlock(p, formattingElementEntry) {
	let furthestBlock = null;
	let idx = p.openElements.stackTop;
	for (; idx >= 0; idx--) {
		const element = p.openElements.items[idx];
		if (element === formattingElementEntry.element) {
			break;
		}
		if (p._isSpecialElement(element, p.openElements.tagIDs[idx])) {
			furthestBlock = element;
		}
	}
	if (!furthestBlock) {
		p.openElements.shortenToLength(idx < 0 ? 0 : idx);
		p.activeFormattingElements.removeEntry(formattingElementEntry);
	}
	return furthestBlock;
}
function aaInnerLoop(p, furthestBlock, formattingElement) {
	let lastElement = furthestBlock;
	let nextElement = p.openElements.getCommonAncestor(furthestBlock);
	for (let i = 0, element = nextElement; element !== formattingElement; i++, element = nextElement) {
		nextElement = p.openElements.getCommonAncestor(element);
		const elementEntry = p.activeFormattingElements.getElementEntry(element);
		const counterOverflow = elementEntry && i >= AA_INNER_LOOP_ITER;
		const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;
		if (shouldRemoveFromOpenElements) {
			if (counterOverflow) {
				p.activeFormattingElements.removeEntry(elementEntry);
			}
			p.openElements.remove(element);
		} else {
			element = aaRecreateElementFromEntry(p, elementEntry);
			if (lastElement === furthestBlock) {
				p.activeFormattingElements.bookmark = elementEntry;
			}
			p.treeAdapter.detachNode(lastElement);
			p.treeAdapter.appendChild(element, lastElement);
			lastElement = element;
		}
	}
	return lastElement;
}
function aaRecreateElementFromEntry(p, elementEntry) {
	const ns = p.treeAdapter.getNamespaceURI(elementEntry.element);
	const newElement = p.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);
	p.openElements.replace(elementEntry.element, newElement);
	elementEntry.element = newElement;
	return newElement;
}
function aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement) {
	const tn = p.treeAdapter.getTagName(commonAncestor);
	const tid = getTagID(tn);
	if (p._isElementCausesFosterParenting(tid)) {
		p._fosterParentElement(lastElement);
	} else {
		const ns = p.treeAdapter.getNamespaceURI(commonAncestor);
		if (tid === TAG_ID.TEMPLATE && ns === NS.HTML) {
			commonAncestor = p.treeAdapter.getTemplateContent(commonAncestor);
		}
		p.treeAdapter.appendChild(commonAncestor, lastElement);
	}
}
function aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry) {
	const ns = p.treeAdapter.getNamespaceURI(formattingElementEntry.element);
	const { token } = formattingElementEntry;
	const newElement = p.treeAdapter.createElement(token.tagName, ns, token.attrs);
	p._adoptNodes(furthestBlock, newElement);
	p.treeAdapter.appendChild(furthestBlock, newElement);
	p.activeFormattingElements.insertElementAfterBookmark(newElement, token);
	p.activeFormattingElements.removeEntry(formattingElementEntry);
	p.openElements.remove(formattingElementEntry.element);
	p.openElements.insertAfter(furthestBlock, newElement, token.tagID);
}
function callAdoptionAgency(p, token) {
	for (let i = 0; i < AA_OUTER_LOOP_ITER; i++) {
		const formattingElementEntry = aaObtainFormattingElementEntry(p, token);
		if (!formattingElementEntry) {
			break;
		}
		const furthestBlock = aaObtainFurthestBlock(p, formattingElementEntry);
		if (!furthestBlock) {
			break;
		}
		p.activeFormattingElements.bookmark = formattingElementEntry;
		const lastElement = aaInnerLoop(p, furthestBlock, formattingElementEntry.element);
		const commonAncestor = p.openElements.getCommonAncestor(formattingElementEntry.element);
		p.treeAdapter.detachNode(lastElement);
		if (commonAncestor) aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement);
		aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry);
	}
}
function appendComment(p, token) {
	p._appendCommentNode(token, p.openElements.currentTmplContentOrNode);
}
function appendCommentToRootHtmlElement(p, token) {
	p._appendCommentNode(token, p.openElements.items[0]);
}
function appendCommentToDocument(p, token) {
	p._appendCommentNode(token, p.document);
}
function stopParsing(p, token) {
	p.stopped = true;
	if (token.location) {
		const target = p.fragmentContext ? 0 : 2;
		for (let i = p.openElements.stackTop; i >= target; i--) {
			p._setEndLocation(p.openElements.items[i], token);
		}
		if (!p.fragmentContext && p.openElements.stackTop >= 0) {
			const htmlElement = p.openElements.items[0];
			const htmlLocation = p.treeAdapter.getNodeSourceCodeLocation(htmlElement);
			if (htmlLocation && !htmlLocation.endTag) {
				p._setEndLocation(htmlElement, token);
				if (p.openElements.stackTop >= 1) {
					const bodyElement = p.openElements.items[1];
					const bodyLocation = p.treeAdapter.getNodeSourceCodeLocation(bodyElement);
					if (bodyLocation && !bodyLocation.endTag) {
						p._setEndLocation(bodyElement, token);
					}
				}
			}
		}
	}
}
function doctypeInInitialMode(p, token) {
	p._setDocumentType(token);
	const mode = token.forceQuirks ? DOCUMENT_MODE.QUIRKS : getDocumentMode(token);
	if (!isConforming(token)) {
		p._err(token, ERR.nonConformingDoctype);
	}
	p.treeAdapter.setDocumentMode(p.document, mode);
	p.insertionMode = InsertionMode.BEFORE_HTML;
}
function tokenInInitialMode(p, token) {
	p._err(token, ERR.missingDoctype, true);
	p.treeAdapter.setDocumentMode(p.document, DOCUMENT_MODE.QUIRKS);
	p.insertionMode = InsertionMode.BEFORE_HTML;
	p._processToken(token);
}
function startTagBeforeHtml(p, token) {
	if (token.tagID === TAG_ID.HTML) {
		p._insertElement(token, NS.HTML);
		p.insertionMode = InsertionMode.BEFORE_HEAD;
	} else {
		tokenBeforeHtml(p, token);
	}
}
function endTagBeforeHtml(p, token) {
	const tn = token.tagID;
	if (tn === TAG_ID.HTML || tn === TAG_ID.HEAD || tn === TAG_ID.BODY || tn === TAG_ID.BR) {
		tokenBeforeHtml(p, token);
	}
}
function tokenBeforeHtml(p, token) {
	p._insertFakeRootElement();
	p.insertionMode = InsertionMode.BEFORE_HEAD;
	p._processToken(token);
}
function startTagBeforeHead(p, token) {
	switch (token.tagID) {
		case TAG_ID.HTML: {
			startTagInBody(p, token);
			break;
		}
		case TAG_ID.HEAD: {
			p._insertElement(token, NS.HTML);
			p.headElement = p.openElements.current;
			p.insertionMode = InsertionMode.IN_HEAD;
			break;
		}
		default: {
			tokenBeforeHead(p, token);
		}
	}
}
function endTagBeforeHead(p, token) {
	const tn = token.tagID;
	if (tn === TAG_ID.HEAD || tn === TAG_ID.BODY || tn === TAG_ID.HTML || tn === TAG_ID.BR) {
		tokenBeforeHead(p, token);
	} else {
		p._err(token, ERR.endTagWithoutMatchingOpenElement);
	}
}
function tokenBeforeHead(p, token) {
	p._insertFakeElement(TAG_NAMES.HEAD, TAG_ID.HEAD);
	p.headElement = p.openElements.current;
	p.insertionMode = InsertionMode.IN_HEAD;
	p._processToken(token);
}
function startTagInHead(p, token) {
	switch (token.tagID) {
		case TAG_ID.HTML: {
			startTagInBody(p, token);
			break;
		}
		case TAG_ID.BASE:
		case TAG_ID.BASEFONT:
		case TAG_ID.BGSOUND:
		case TAG_ID.LINK:
		case TAG_ID.META: {
			p._appendElement(token, NS.HTML);
			token.ackSelfClosing = true;
			break;
		}
		case TAG_ID.TITLE: {
			p._switchToTextParsing(token, TokenizerMode.RCDATA);
			break;
		}
		case TAG_ID.NOSCRIPT: {
			if (p.options.scriptingEnabled) {
				p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
			} else {
				p._insertElement(token, NS.HTML);
				p.insertionMode = InsertionMode.IN_HEAD_NO_SCRIPT;
			}
			break;
		}
		case TAG_ID.NOFRAMES:
		case TAG_ID.STYLE: {
			p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
			break;
		}
		case TAG_ID.SCRIPT: {
			p._switchToTextParsing(token, TokenizerMode.SCRIPT_DATA);
			break;
		}
		case TAG_ID.TEMPLATE: {
			p._insertTemplate(token);
			p.activeFormattingElements.insertMarker();
			p.framesetOk = false;
			p.insertionMode = InsertionMode.IN_TEMPLATE;
			p.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
			break;
		}
		case TAG_ID.HEAD: {
			p._err(token, ERR.misplacedStartTagForHeadElement);
			break;
		}
		default: {
			tokenInHead(p, token);
		}
	}
}
function endTagInHead(p, token) {
	switch (token.tagID) {
		case TAG_ID.HEAD: {
			p.openElements.pop();
			p.insertionMode = InsertionMode.AFTER_HEAD;
			break;
		}
		case TAG_ID.BODY:
		case TAG_ID.BR:
		case TAG_ID.HTML: {
			tokenInHead(p, token);
			break;
		}
		case TAG_ID.TEMPLATE: {
			templateEndTagInHead(p, token);
			break;
		}
		default: {
			p._err(token, ERR.endTagWithoutMatchingOpenElement);
		}
	}
}
function templateEndTagInHead(p, token) {
	if (p.openElements.tmplCount > 0) {
		p.openElements.generateImpliedEndTagsThoroughly();
		if (p.openElements.currentTagId !== TAG_ID.TEMPLATE) {
			p._err(token, ERR.closingOfElementWithOpenChildElements);
		}
		p.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE);
		p.activeFormattingElements.clearToLastMarker();
		p.tmplInsertionModeStack.shift();
		p._resetInsertionMode();
	} else {
		p._err(token, ERR.endTagWithoutMatchingOpenElement);
	}
}
function tokenInHead(p, token) {
	p.openElements.pop();
	p.insertionMode = InsertionMode.AFTER_HEAD;
	p._processToken(token);
}
function startTagInHeadNoScript(p, token) {
	switch (token.tagID) {
		case TAG_ID.HTML: {
			startTagInBody(p, token);
			break;
		}
		case TAG_ID.BASEFONT:
		case TAG_ID.BGSOUND:
		case TAG_ID.HEAD:
		case TAG_ID.LINK:
		case TAG_ID.META:
		case TAG_ID.NOFRAMES:
		case TAG_ID.STYLE: {
			startTagInHead(p, token);
			break;
		}
		case TAG_ID.NOSCRIPT: {
			p._err(token, ERR.nestedNoscriptInHead);
			break;
		}
		default: {
			tokenInHeadNoScript(p, token);
		}
	}
}
function endTagInHeadNoScript(p, token) {
	switch (token.tagID) {
		case TAG_ID.NOSCRIPT: {
			p.openElements.pop();
			p.insertionMode = InsertionMode.IN_HEAD;
			break;
		}
		case TAG_ID.BR: {
			tokenInHeadNoScript(p, token);
			break;
		}
		default: {
			p._err(token, ERR.endTagWithoutMatchingOpenElement);
		}
	}
}
function tokenInHeadNoScript(p, token) {
	const errCode = token.type === TokenType.EOF ? ERR.openElementsLeftAfterEof : ERR.disallowedContentInNoscriptInHead;
	p._err(token, errCode);
	p.openElements.pop();
	p.insertionMode = InsertionMode.IN_HEAD;
	p._processToken(token);
}
function startTagAfterHead(p, token) {
	switch (token.tagID) {
		case TAG_ID.HTML: {
			startTagInBody(p, token);
			break;
		}
		case TAG_ID.BODY: {
			p._insertElement(token, NS.HTML);
			p.framesetOk = false;
			p.insertionMode = InsertionMode.IN_BODY;
			break;
		}
		case TAG_ID.FRAMESET: {
			p._insertElement(token, NS.HTML);
			p.insertionMode = InsertionMode.IN_FRAMESET;
			break;
		}
		case TAG_ID.BASE:
		case TAG_ID.BASEFONT:
		case TAG_ID.BGSOUND:
		case TAG_ID.LINK:
		case TAG_ID.META:
		case TAG_ID.NOFRAMES:
		case TAG_ID.SCRIPT:
		case TAG_ID.STYLE:
		case TAG_ID.TEMPLATE:
		case TAG_ID.TITLE: {
			p._err(token, ERR.abandonedHeadElementChild);
			p.openElements.push(p.headElement, TAG_ID.HEAD);
			startTagInHead(p, token);
			p.openElements.remove(p.headElement);
			break;
		}
		case TAG_ID.HEAD: {
			p._err(token, ERR.misplacedStartTagForHeadElement);
			break;
		}
		default: {
			tokenAfterHead(p, token);
		}
	}
}
function endTagAfterHead(p, token) {
	switch (token.tagID) {
		case TAG_ID.BODY:
		case TAG_ID.HTML:
		case TAG_ID.BR: {
			tokenAfterHead(p, token);
			break;
		}
		case TAG_ID.TEMPLATE: {
			templateEndTagInHead(p, token);
			break;
		}
		default: {
			p._err(token, ERR.endTagWithoutMatchingOpenElement);
		}
	}
}
function tokenAfterHead(p, token) {
	p._insertFakeElement(TAG_NAMES.BODY, TAG_ID.BODY);
	p.insertionMode = InsertionMode.IN_BODY;
	modeInBody(p, token);
}
function modeInBody(p, token) {
	switch (token.type) {
		case TokenType.CHARACTER: {
			characterInBody(p, token);
			break;
		}
		case TokenType.WHITESPACE_CHARACTER: {
			whitespaceCharacterInBody(p, token);
			break;
		}
		case TokenType.COMMENT: {
			appendComment(p, token);
			break;
		}
		case TokenType.START_TAG: {
			startTagInBody(p, token);
			break;
		}
		case TokenType.END_TAG: {
			endTagInBody(p, token);
			break;
		}
		case TokenType.EOF: {
			eofInBody(p, token);
			break;
		}
		default:
	}
}
function whitespaceCharacterInBody(p, token) {
	p._reconstructActiveFormattingElements();
	p._insertCharacters(token);
}
function characterInBody(p, token) {
	p._reconstructActiveFormattingElements();
	p._insertCharacters(token);
	p.framesetOk = false;
}
function htmlStartTagInBody(p, token) {
	if (p.openElements.tmplCount === 0) {
		p.treeAdapter.adoptAttributes(p.openElements.items[0], token.attrs);
	}
}
function bodyStartTagInBody(p, token) {
	const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
	if (bodyElement && p.openElements.tmplCount === 0) {
		p.framesetOk = false;
		p.treeAdapter.adoptAttributes(bodyElement, token.attrs);
	}
}
function framesetStartTagInBody(p, token) {
	const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
	if (p.framesetOk && bodyElement) {
		p.treeAdapter.detachNode(bodyElement);
		p.openElements.popAllUpToHtmlElement();
		p._insertElement(token, NS.HTML);
		p.insertionMode = InsertionMode.IN_FRAMESET;
	}
}
function addressStartTagInBody(p, token) {
	if (p.openElements.hasInButtonScope(TAG_ID.P)) {
		p._closePElement();
	}
	p._insertElement(token, NS.HTML);
}
function numberedHeaderStartTagInBody(p, token) {
	if (p.openElements.hasInButtonScope(TAG_ID.P)) {
		p._closePElement();
	}
	if (NUMBERED_HEADERS.has(p.openElements.currentTagId)) {
		p.openElements.pop();
	}
	p._insertElement(token, NS.HTML);
}
function preStartTagInBody(p, token) {
	if (p.openElements.hasInButtonScope(TAG_ID.P)) {
		p._closePElement();
	}
	p._insertElement(token, NS.HTML);
	p.skipNextNewLine = true;
	p.framesetOk = false;
}
function formStartTagInBody(p, token) {
	const inTemplate = p.openElements.tmplCount > 0;
	if (!p.formElement || inTemplate) {
		if (p.openElements.hasInButtonScope(TAG_ID.P)) {
			p._closePElement();
		}
		p._insertElement(token, NS.HTML);
		if (!inTemplate) {
			p.formElement = p.openElements.current;
		}
	}
}
function listItemStartTagInBody(p, token) {
	p.framesetOk = false;
	const tn = token.tagID;
	for (let i = p.openElements.stackTop; i >= 0; i--) {
		const elementId = p.openElements.tagIDs[i];
		if (
			(tn === TAG_ID.LI && elementId === TAG_ID.LI) ||
			((tn === TAG_ID.DD || tn === TAG_ID.DT) && (elementId === TAG_ID.DD || elementId === TAG_ID.DT))
		) {
			p.openElements.generateImpliedEndTagsWithExclusion(elementId);
			p.openElements.popUntilTagNamePopped(elementId);
			break;
		}
		if (
			elementId !== TAG_ID.ADDRESS &&
			elementId !== TAG_ID.DIV &&
			elementId !== TAG_ID.P &&
			p._isSpecialElement(p.openElements.items[i], elementId)
		) {
			break;
		}
	}
	if (p.openElements.hasInButtonScope(TAG_ID.P)) {
		p._closePElement();
	}
	p._insertElement(token, NS.HTML);
}
function plaintextStartTagInBody(p, token) {
	if (p.openElements.hasInButtonScope(TAG_ID.P)) {
		p._closePElement();
	}
	p._insertElement(token, NS.HTML);
	p.tokenizer.state = TokenizerMode.PLAINTEXT;
}
function buttonStartTagInBody(p, token) {
	if (p.openElements.hasInScope(TAG_ID.BUTTON)) {
		p.openElements.generateImpliedEndTags();
		p.openElements.popUntilTagNamePopped(TAG_ID.BUTTON);
	}
	p._reconstructActiveFormattingElements();
	p._insertElement(token, NS.HTML);
	p.framesetOk = false;
}
function aStartTagInBody(p, token) {
	const activeElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(TAG_NAMES.A);
	if (activeElementEntry) {
		callAdoptionAgency(p, token);
		p.openElements.remove(activeElementEntry.element);
		p.activeFormattingElements.removeEntry(activeElementEntry);
	}
	p._reconstructActiveFormattingElements();
	p._insertElement(token, NS.HTML);
	p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function bStartTagInBody(p, token) {
	p._reconstructActiveFormattingElements();
	p._insertElement(token, NS.HTML);
	p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function nobrStartTagInBody(p, token) {
	p._reconstructActiveFormattingElements();
	if (p.openElements.hasInScope(TAG_ID.NOBR)) {
		callAdoptionAgency(p, token);
		p._reconstructActiveFormattingElements();
	}
	p._insertElement(token, NS.HTML);
	p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function appletStartTagInBody(p, token) {
	p._reconstructActiveFormattingElements();
	p._insertElement(token, NS.HTML);
	p.activeFormattingElements.insertMarker();
	p.framesetOk = false;
}
function tableStartTagInBody(p, token) {
	if (p.treeAdapter.getDocumentMode(p.document) !== DOCUMENT_MODE.QUIRKS && p.openElements.hasInButtonScope(TAG_ID.P)) {
		p._closePElement();
	}
	p._insertElement(token, NS.HTML);
	p.framesetOk = false;
	p.insertionMode = InsertionMode.IN_TABLE;
}
function areaStartTagInBody(p, token) {
	p._reconstructActiveFormattingElements();
	p._appendElement(token, NS.HTML);
	p.framesetOk = false;
	token.ackSelfClosing = true;
}
function isHiddenInput(token) {
	const inputType = getTokenAttr(token, ATTRS.TYPE);
	return inputType != null && inputType.toLowerCase() === HIDDEN_INPUT_TYPE;
}
function inputStartTagInBody(p, token) {
	p._reconstructActiveFormattingElements();
	p._appendElement(token, NS.HTML);
	if (!isHiddenInput(token)) {
		p.framesetOk = false;
	}
	token.ackSelfClosing = true;
}
function paramStartTagInBody(p, token) {
	p._appendElement(token, NS.HTML);
	token.ackSelfClosing = true;
}
function hrStartTagInBody(p, token) {
	if (p.openElements.hasInButtonScope(TAG_ID.P)) {
		p._closePElement();
	}
	p._appendElement(token, NS.HTML);
	p.framesetOk = false;
	token.ackSelfClosing = true;
}
function imageStartTagInBody(p, token) {
	token.tagName = TAG_NAMES.IMG;
	token.tagID = TAG_ID.IMG;
	areaStartTagInBody(p, token);
}
function textareaStartTagInBody(p, token) {
	p._insertElement(token, NS.HTML);
	p.skipNextNewLine = true;
	p.tokenizer.state = TokenizerMode.RCDATA;
	p.originalInsertionMode = p.insertionMode;
	p.framesetOk = false;
	p.insertionMode = InsertionMode.TEXT;
}
function xmpStartTagInBody(p, token) {
	if (p.openElements.hasInButtonScope(TAG_ID.P)) {
		p._closePElement();
	}
	p._reconstructActiveFormattingElements();
	p.framesetOk = false;
	p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function iframeStartTagInBody(p, token) {
	p.framesetOk = false;
	p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function rawTextStartTagInBody(p, token) {
	p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function selectStartTagInBody(p, token) {
	p._reconstructActiveFormattingElements();
	p._insertElement(token, NS.HTML);
	p.framesetOk = false;
	p.insertionMode =
		p.insertionMode === InsertionMode.IN_TABLE ||
		p.insertionMode === InsertionMode.IN_CAPTION ||
		p.insertionMode === InsertionMode.IN_TABLE_BODY ||
		p.insertionMode === InsertionMode.IN_ROW ||
		p.insertionMode === InsertionMode.IN_CELL
			? InsertionMode.IN_SELECT_IN_TABLE
			: InsertionMode.IN_SELECT;
}
function optgroupStartTagInBody(p, token) {
	if (p.openElements.currentTagId === TAG_ID.OPTION) {
		p.openElements.pop();
	}
	p._reconstructActiveFormattingElements();
	p._insertElement(token, NS.HTML);
}
function rbStartTagInBody(p, token) {
	if (p.openElements.hasInScope(TAG_ID.RUBY)) {
		p.openElements.generateImpliedEndTags();
	}
	p._insertElement(token, NS.HTML);
}
function rtStartTagInBody(p, token) {
	if (p.openElements.hasInScope(TAG_ID.RUBY)) {
		p.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.RTC);
	}
	p._insertElement(token, NS.HTML);
}
function mathStartTagInBody(p, token) {
	p._reconstructActiveFormattingElements();
	adjustTokenMathMLAttrs(token);
	adjustTokenXMLAttrs(token);
	if (token.selfClosing) {
		p._appendElement(token, NS.MATHML);
	} else {
		p._insertElement(token, NS.MATHML);
	}
	token.ackSelfClosing = true;
}
function svgStartTagInBody(p, token) {
	p._reconstructActiveFormattingElements();
	adjustTokenSVGAttrs(token);
	adjustTokenXMLAttrs(token);
	if (token.selfClosing) {
		p._appendElement(token, NS.SVG);
	} else {
		p._insertElement(token, NS.SVG);
	}
	token.ackSelfClosing = true;
}
function genericStartTagInBody(p, token) {
	p._reconstructActiveFormattingElements();
	p._insertElement(token, NS.HTML);
}
function startTagInBody(p, token) {
	switch (token.tagID) {
		case TAG_ID.I:
		case TAG_ID.S:
		case TAG_ID.B:
		case TAG_ID.U:
		case TAG_ID.EM:
		case TAG_ID.TT:
		case TAG_ID.BIG:
		case TAG_ID.CODE:
		case TAG_ID.FONT:
		case TAG_ID.SMALL:
		case TAG_ID.STRIKE:
		case TAG_ID.STRONG: {
			bStartTagInBody(p, token);
			break;
		}
		case TAG_ID.A: {
			aStartTagInBody(p, token);
			break;
		}
		case TAG_ID.H1:
		case TAG_ID.H2:
		case TAG_ID.H3:
		case TAG_ID.H4:
		case TAG_ID.H5:
		case TAG_ID.H6: {
			numberedHeaderStartTagInBody(p, token);
			break;
		}
		case TAG_ID.P:
		case TAG_ID.DL:
		case TAG_ID.OL:
		case TAG_ID.UL:
		case TAG_ID.DIV:
		case TAG_ID.DIR:
		case TAG_ID.NAV:
		case TAG_ID.MAIN:
		case TAG_ID.MENU:
		case TAG_ID.ASIDE:
		case TAG_ID.CENTER:
		case TAG_ID.FIGURE:
		case TAG_ID.FOOTER:
		case TAG_ID.HEADER:
		case TAG_ID.HGROUP:
		case TAG_ID.DIALOG:
		case TAG_ID.DETAILS:
		case TAG_ID.ADDRESS:
		case TAG_ID.ARTICLE:
		case TAG_ID.SEARCH:
		case TAG_ID.SECTION:
		case TAG_ID.SUMMARY:
		case TAG_ID.FIELDSET:
		case TAG_ID.BLOCKQUOTE:
		case TAG_ID.FIGCAPTION: {
			addressStartTagInBody(p, token);
			break;
		}
		case TAG_ID.LI:
		case TAG_ID.DD:
		case TAG_ID.DT: {
			listItemStartTagInBody(p, token);
			break;
		}
		case TAG_ID.BR:
		case TAG_ID.IMG:
		case TAG_ID.WBR:
		case TAG_ID.AREA:
		case TAG_ID.EMBED:
		case TAG_ID.KEYGEN: {
			areaStartTagInBody(p, token);
			break;
		}
		case TAG_ID.HR: {
			hrStartTagInBody(p, token);
			break;
		}
		case TAG_ID.RB:
		case TAG_ID.RTC: {
			rbStartTagInBody(p, token);
			break;
		}
		case TAG_ID.RT:
		case TAG_ID.RP: {
			rtStartTagInBody(p, token);
			break;
		}
		case TAG_ID.PRE:
		case TAG_ID.LISTING: {
			preStartTagInBody(p, token);
			break;
		}
		case TAG_ID.XMP: {
			xmpStartTagInBody(p, token);
			break;
		}
		case TAG_ID.SVG: {
			svgStartTagInBody(p, token);
			break;
		}
		case TAG_ID.HTML: {
			htmlStartTagInBody(p, token);
			break;
		}
		case TAG_ID.BASE:
		case TAG_ID.LINK:
		case TAG_ID.META:
		case TAG_ID.STYLE:
		case TAG_ID.TITLE:
		case TAG_ID.SCRIPT:
		case TAG_ID.BGSOUND:
		case TAG_ID.BASEFONT:
		case TAG_ID.TEMPLATE: {
			startTagInHead(p, token);
			break;
		}
		case TAG_ID.BODY: {
			bodyStartTagInBody(p, token);
			break;
		}
		case TAG_ID.FORM: {
			formStartTagInBody(p, token);
			break;
		}
		case TAG_ID.NOBR: {
			nobrStartTagInBody(p, token);
			break;
		}
		case TAG_ID.MATH: {
			mathStartTagInBody(p, token);
			break;
		}
		case TAG_ID.TABLE: {
			tableStartTagInBody(p, token);
			break;
		}
		case TAG_ID.INPUT: {
			inputStartTagInBody(p, token);
			break;
		}
		case TAG_ID.PARAM:
		case TAG_ID.TRACK:
		case TAG_ID.SOURCE: {
			paramStartTagInBody(p, token);
			break;
		}
		case TAG_ID.IMAGE: {
			imageStartTagInBody(p, token);
			break;
		}
		case TAG_ID.BUTTON: {
			buttonStartTagInBody(p, token);
			break;
		}
		case TAG_ID.APPLET:
		case TAG_ID.OBJECT:
		case TAG_ID.MARQUEE: {
			appletStartTagInBody(p, token);
			break;
		}
		case TAG_ID.IFRAME: {
			iframeStartTagInBody(p, token);
			break;
		}
		case TAG_ID.SELECT: {
			selectStartTagInBody(p, token);
			break;
		}
		case TAG_ID.OPTION:
		case TAG_ID.OPTGROUP: {
			optgroupStartTagInBody(p, token);
			break;
		}
		case TAG_ID.NOEMBED:
		case TAG_ID.NOFRAMES: {
			rawTextStartTagInBody(p, token);
			break;
		}
		case TAG_ID.FRAMESET: {
			framesetStartTagInBody(p, token);
			break;
		}
		case TAG_ID.TEXTAREA: {
			textareaStartTagInBody(p, token);
			break;
		}
		case TAG_ID.NOSCRIPT: {
			if (p.options.scriptingEnabled) {
				rawTextStartTagInBody(p, token);
			} else {
				genericStartTagInBody(p, token);
			}
			break;
		}
		case TAG_ID.PLAINTEXT: {
			plaintextStartTagInBody(p, token);
			break;
		}
		case TAG_ID.COL:
		case TAG_ID.TH:
		case TAG_ID.TD:
		case TAG_ID.TR:
		case TAG_ID.HEAD:
		case TAG_ID.FRAME:
		case TAG_ID.TBODY:
		case TAG_ID.TFOOT:
		case TAG_ID.THEAD:
		case TAG_ID.CAPTION:
		case TAG_ID.COLGROUP: {
			break;
		}
		default: {
			genericStartTagInBody(p, token);
		}
	}
}
function bodyEndTagInBody(p, token) {
	if (p.openElements.hasInScope(TAG_ID.BODY)) {
		p.insertionMode = InsertionMode.AFTER_BODY;
		if (p.options.sourceCodeLocationInfo) {
			const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
			if (bodyElement) {
				p._setEndLocation(bodyElement, token);
			}
		}
	}
}
function htmlEndTagInBody(p, token) {
	if (p.openElements.hasInScope(TAG_ID.BODY)) {
		p.insertionMode = InsertionMode.AFTER_BODY;
		endTagAfterBody(p, token);
	}
}
function addressEndTagInBody(p, token) {
	const tn = token.tagID;
	if (p.openElements.hasInScope(tn)) {
		p.openElements.generateImpliedEndTags();
		p.openElements.popUntilTagNamePopped(tn);
	}
}
function formEndTagInBody(p) {
	const inTemplate = p.openElements.tmplCount > 0;
	const { formElement } = p;
	if (!inTemplate) {
		p.formElement = null;
	}
	if ((formElement || inTemplate) && p.openElements.hasInScope(TAG_ID.FORM)) {
		p.openElements.generateImpliedEndTags();
		if (inTemplate) {
			p.openElements.popUntilTagNamePopped(TAG_ID.FORM);
		} else if (formElement) {
			p.openElements.remove(formElement);
		}
	}
}
function pEndTagInBody(p) {
	if (!p.openElements.hasInButtonScope(TAG_ID.P)) {
		p._insertFakeElement(TAG_NAMES.P, TAG_ID.P);
	}
	p._closePElement();
}
function liEndTagInBody(p) {
	if (p.openElements.hasInListItemScope(TAG_ID.LI)) {
		p.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.LI);
		p.openElements.popUntilTagNamePopped(TAG_ID.LI);
	}
}
function ddEndTagInBody(p, token) {
	const tn = token.tagID;
	if (p.openElements.hasInScope(tn)) {
		p.openElements.generateImpliedEndTagsWithExclusion(tn);
		p.openElements.popUntilTagNamePopped(tn);
	}
}
function numberedHeaderEndTagInBody(p) {
	if (p.openElements.hasNumberedHeaderInScope()) {
		p.openElements.generateImpliedEndTags();
		p.openElements.popUntilNumberedHeaderPopped();
	}
}
function appletEndTagInBody(p, token) {
	const tn = token.tagID;
	if (p.openElements.hasInScope(tn)) {
		p.openElements.generateImpliedEndTags();
		p.openElements.popUntilTagNamePopped(tn);
		p.activeFormattingElements.clearToLastMarker();
	}
}
function brEndTagInBody(p) {
	p._reconstructActiveFormattingElements();
	p._insertFakeElement(TAG_NAMES.BR, TAG_ID.BR);
	p.openElements.pop();
	p.framesetOk = false;
}
function genericEndTagInBody(p, token) {
	const tn = token.tagName;
	const tid = token.tagID;
	for (let i = p.openElements.stackTop; i > 0; i--) {
		const element = p.openElements.items[i];
		const elementId = p.openElements.tagIDs[i];
		if (tid === elementId && (tid !== TAG_ID.UNKNOWN || p.treeAdapter.getTagName(element) === tn)) {
			p.openElements.generateImpliedEndTagsWithExclusion(tid);
			if (p.openElements.stackTop >= i) p.openElements.shortenToLength(i);
			break;
		}
		if (p._isSpecialElement(element, elementId)) {
			break;
		}
	}
}
function endTagInBody(p, token) {
	switch (token.tagID) {
		case TAG_ID.A:
		case TAG_ID.B:
		case TAG_ID.I:
		case TAG_ID.S:
		case TAG_ID.U:
		case TAG_ID.EM:
		case TAG_ID.TT:
		case TAG_ID.BIG:
		case TAG_ID.CODE:
		case TAG_ID.FONT:
		case TAG_ID.NOBR:
		case TAG_ID.SMALL:
		case TAG_ID.STRIKE:
		case TAG_ID.STRONG: {
			callAdoptionAgency(p, token);
			break;
		}
		case TAG_ID.P: {
			pEndTagInBody(p);
			break;
		}
		case TAG_ID.DL:
		case TAG_ID.UL:
		case TAG_ID.OL:
		case TAG_ID.DIR:
		case TAG_ID.DIV:
		case TAG_ID.NAV:
		case TAG_ID.PRE:
		case TAG_ID.MAIN:
		case TAG_ID.MENU:
		case TAG_ID.ASIDE:
		case TAG_ID.BUTTON:
		case TAG_ID.CENTER:
		case TAG_ID.FIGURE:
		case TAG_ID.FOOTER:
		case TAG_ID.HEADER:
		case TAG_ID.HGROUP:
		case TAG_ID.DIALOG:
		case TAG_ID.ADDRESS:
		case TAG_ID.ARTICLE:
		case TAG_ID.DETAILS:
		case TAG_ID.SEARCH:
		case TAG_ID.SECTION:
		case TAG_ID.SUMMARY:
		case TAG_ID.LISTING:
		case TAG_ID.FIELDSET:
		case TAG_ID.BLOCKQUOTE:
		case TAG_ID.FIGCAPTION: {
			addressEndTagInBody(p, token);
			break;
		}
		case TAG_ID.LI: {
			liEndTagInBody(p);
			break;
		}
		case TAG_ID.DD:
		case TAG_ID.DT: {
			ddEndTagInBody(p, token);
			break;
		}
		case TAG_ID.H1:
		case TAG_ID.H2:
		case TAG_ID.H3:
		case TAG_ID.H4:
		case TAG_ID.H5:
		case TAG_ID.H6: {
			numberedHeaderEndTagInBody(p);
			break;
		}
		case TAG_ID.BR: {
			brEndTagInBody(p);
			break;
		}
		case TAG_ID.BODY: {
			bodyEndTagInBody(p, token);
			break;
		}
		case TAG_ID.HTML: {
			htmlEndTagInBody(p, token);
			break;
		}
		case TAG_ID.FORM: {
			formEndTagInBody(p);
			break;
		}
		case TAG_ID.APPLET:
		case TAG_ID.OBJECT:
		case TAG_ID.MARQUEE: {
			appletEndTagInBody(p, token);
			break;
		}
		case TAG_ID.TEMPLATE: {
			templateEndTagInHead(p, token);
			break;
		}
		default: {
			genericEndTagInBody(p, token);
		}
	}
}
function eofInBody(p, token) {
	if (p.tmplInsertionModeStack.length > 0) {
		eofInTemplate(p, token);
	} else {
		stopParsing(p, token);
	}
}
function endTagInText(p, token) {
	var _a2;
	if (token.tagID === TAG_ID.SCRIPT) {
		(_a2 = p.scriptHandler) === null || _a2 === void 0 ? void 0 : _a2.call(p, p.openElements.current);
	}
	p.openElements.pop();
	p.insertionMode = p.originalInsertionMode;
}
function eofInText(p, token) {
	p._err(token, ERR.eofInElementThatCanContainOnlyText);
	p.openElements.pop();
	p.insertionMode = p.originalInsertionMode;
	p.onEof(token);
}
function characterInTable(p, token) {
	if (TABLE_STRUCTURE_TAGS.has(p.openElements.currentTagId)) {
		p.pendingCharacterTokens.length = 0;
		p.hasNonWhitespacePendingCharacterToken = false;
		p.originalInsertionMode = p.insertionMode;
		p.insertionMode = InsertionMode.IN_TABLE_TEXT;
		switch (token.type) {
			case TokenType.CHARACTER: {
				characterInTableText(p, token);
				break;
			}
			case TokenType.WHITESPACE_CHARACTER: {
				whitespaceCharacterInTableText(p, token);
				break;
			}
		}
	} else {
		tokenInTable(p, token);
	}
}
function captionStartTagInTable(p, token) {
	p.openElements.clearBackToTableContext();
	p.activeFormattingElements.insertMarker();
	p._insertElement(token, NS.HTML);
	p.insertionMode = InsertionMode.IN_CAPTION;
}
function colgroupStartTagInTable(p, token) {
	p.openElements.clearBackToTableContext();
	p._insertElement(token, NS.HTML);
	p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
}
function colStartTagInTable(p, token) {
	p.openElements.clearBackToTableContext();
	p._insertFakeElement(TAG_NAMES.COLGROUP, TAG_ID.COLGROUP);
	p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
	startTagInColumnGroup(p, token);
}
function tbodyStartTagInTable(p, token) {
	p.openElements.clearBackToTableContext();
	p._insertElement(token, NS.HTML);
	p.insertionMode = InsertionMode.IN_TABLE_BODY;
}
function tdStartTagInTable(p, token) {
	p.openElements.clearBackToTableContext();
	p._insertFakeElement(TAG_NAMES.TBODY, TAG_ID.TBODY);
	p.insertionMode = InsertionMode.IN_TABLE_BODY;
	startTagInTableBody(p, token);
}
function tableStartTagInTable(p, token) {
	if (p.openElements.hasInTableScope(TAG_ID.TABLE)) {
		p.openElements.popUntilTagNamePopped(TAG_ID.TABLE);
		p._resetInsertionMode();
		p._processStartTag(token);
	}
}
function inputStartTagInTable(p, token) {
	if (isHiddenInput(token)) {
		p._appendElement(token, NS.HTML);
	} else {
		tokenInTable(p, token);
	}
	token.ackSelfClosing = true;
}
function formStartTagInTable(p, token) {
	if (!p.formElement && p.openElements.tmplCount === 0) {
		p._insertElement(token, NS.HTML);
		p.formElement = p.openElements.current;
		p.openElements.pop();
	}
}
function startTagInTable(p, token) {
	switch (token.tagID) {
		case TAG_ID.TD:
		case TAG_ID.TH:
		case TAG_ID.TR: {
			tdStartTagInTable(p, token);
			break;
		}
		case TAG_ID.STYLE:
		case TAG_ID.SCRIPT:
		case TAG_ID.TEMPLATE: {
			startTagInHead(p, token);
			break;
		}
		case TAG_ID.COL: {
			colStartTagInTable(p, token);
			break;
		}
		case TAG_ID.FORM: {
			formStartTagInTable(p, token);
			break;
		}
		case TAG_ID.TABLE: {
			tableStartTagInTable(p, token);
			break;
		}
		case TAG_ID.TBODY:
		case TAG_ID.TFOOT:
		case TAG_ID.THEAD: {
			tbodyStartTagInTable(p, token);
			break;
		}
		case TAG_ID.INPUT: {
			inputStartTagInTable(p, token);
			break;
		}
		case TAG_ID.CAPTION: {
			captionStartTagInTable(p, token);
			break;
		}
		case TAG_ID.COLGROUP: {
			colgroupStartTagInTable(p, token);
			break;
		}
		default: {
			tokenInTable(p, token);
		}
	}
}
function endTagInTable(p, token) {
	switch (token.tagID) {
		case TAG_ID.TABLE: {
			if (p.openElements.hasInTableScope(TAG_ID.TABLE)) {
				p.openElements.popUntilTagNamePopped(TAG_ID.TABLE);
				p._resetInsertionMode();
			}
			break;
		}
		case TAG_ID.TEMPLATE: {
			templateEndTagInHead(p, token);
			break;
		}
		case TAG_ID.BODY:
		case TAG_ID.CAPTION:
		case TAG_ID.COL:
		case TAG_ID.COLGROUP:
		case TAG_ID.HTML:
		case TAG_ID.TBODY:
		case TAG_ID.TD:
		case TAG_ID.TFOOT:
		case TAG_ID.TH:
		case TAG_ID.THEAD:
		case TAG_ID.TR: {
			break;
		}
		default: {
			tokenInTable(p, token);
		}
	}
}
function tokenInTable(p, token) {
	const savedFosterParentingState = p.fosterParentingEnabled;
	p.fosterParentingEnabled = true;
	modeInBody(p, token);
	p.fosterParentingEnabled = savedFosterParentingState;
}
function whitespaceCharacterInTableText(p, token) {
	p.pendingCharacterTokens.push(token);
}
function characterInTableText(p, token) {
	p.pendingCharacterTokens.push(token);
	p.hasNonWhitespacePendingCharacterToken = true;
}
function tokenInTableText(p, token) {
	let i = 0;
	if (p.hasNonWhitespacePendingCharacterToken) {
		for (; i < p.pendingCharacterTokens.length; i++) {
			tokenInTable(p, p.pendingCharacterTokens[i]);
		}
	} else {
		for (; i < p.pendingCharacterTokens.length; i++) {
			p._insertCharacters(p.pendingCharacterTokens[i]);
		}
	}
	p.insertionMode = p.originalInsertionMode;
	p._processToken(token);
}
var TABLE_VOID_ELEMENTS = /* @__PURE__ */ new Set([
	TAG_ID.CAPTION,
	TAG_ID.COL,
	TAG_ID.COLGROUP,
	TAG_ID.TBODY,
	TAG_ID.TD,
	TAG_ID.TFOOT,
	TAG_ID.TH,
	TAG_ID.THEAD,
	TAG_ID.TR,
]);
function startTagInCaption(p, token) {
	const tn = token.tagID;
	if (TABLE_VOID_ELEMENTS.has(tn)) {
		if (p.openElements.hasInTableScope(TAG_ID.CAPTION)) {
			p.openElements.generateImpliedEndTags();
			p.openElements.popUntilTagNamePopped(TAG_ID.CAPTION);
			p.activeFormattingElements.clearToLastMarker();
			p.insertionMode = InsertionMode.IN_TABLE;
			startTagInTable(p, token);
		}
	} else {
		startTagInBody(p, token);
	}
}
function endTagInCaption(p, token) {
	const tn = token.tagID;
	switch (tn) {
		case TAG_ID.CAPTION:
		case TAG_ID.TABLE: {
			if (p.openElements.hasInTableScope(TAG_ID.CAPTION)) {
				p.openElements.generateImpliedEndTags();
				p.openElements.popUntilTagNamePopped(TAG_ID.CAPTION);
				p.activeFormattingElements.clearToLastMarker();
				p.insertionMode = InsertionMode.IN_TABLE;
				if (tn === TAG_ID.TABLE) {
					endTagInTable(p, token);
				}
			}
			break;
		}
		case TAG_ID.BODY:
		case TAG_ID.COL:
		case TAG_ID.COLGROUP:
		case TAG_ID.HTML:
		case TAG_ID.TBODY:
		case TAG_ID.TD:
		case TAG_ID.TFOOT:
		case TAG_ID.TH:
		case TAG_ID.THEAD:
		case TAG_ID.TR: {
			break;
		}
		default: {
			endTagInBody(p, token);
		}
	}
}
function startTagInColumnGroup(p, token) {
	switch (token.tagID) {
		case TAG_ID.HTML: {
			startTagInBody(p, token);
			break;
		}
		case TAG_ID.COL: {
			p._appendElement(token, NS.HTML);
			token.ackSelfClosing = true;
			break;
		}
		case TAG_ID.TEMPLATE: {
			startTagInHead(p, token);
			break;
		}
		default: {
			tokenInColumnGroup(p, token);
		}
	}
}
function endTagInColumnGroup(p, token) {
	switch (token.tagID) {
		case TAG_ID.COLGROUP: {
			if (p.openElements.currentTagId === TAG_ID.COLGROUP) {
				p.openElements.pop();
				p.insertionMode = InsertionMode.IN_TABLE;
			}
			break;
		}
		case TAG_ID.TEMPLATE: {
			templateEndTagInHead(p, token);
			break;
		}
		case TAG_ID.COL: {
			break;
		}
		default: {
			tokenInColumnGroup(p, token);
		}
	}
}
function tokenInColumnGroup(p, token) {
	if (p.openElements.currentTagId === TAG_ID.COLGROUP) {
		p.openElements.pop();
		p.insertionMode = InsertionMode.IN_TABLE;
		p._processToken(token);
	}
}
function startTagInTableBody(p, token) {
	switch (token.tagID) {
		case TAG_ID.TR: {
			p.openElements.clearBackToTableBodyContext();
			p._insertElement(token, NS.HTML);
			p.insertionMode = InsertionMode.IN_ROW;
			break;
		}
		case TAG_ID.TH:
		case TAG_ID.TD: {
			p.openElements.clearBackToTableBodyContext();
			p._insertFakeElement(TAG_NAMES.TR, TAG_ID.TR);
			p.insertionMode = InsertionMode.IN_ROW;
			startTagInRow(p, token);
			break;
		}
		case TAG_ID.CAPTION:
		case TAG_ID.COL:
		case TAG_ID.COLGROUP:
		case TAG_ID.TBODY:
		case TAG_ID.TFOOT:
		case TAG_ID.THEAD: {
			if (p.openElements.hasTableBodyContextInTableScope()) {
				p.openElements.clearBackToTableBodyContext();
				p.openElements.pop();
				p.insertionMode = InsertionMode.IN_TABLE;
				startTagInTable(p, token);
			}
			break;
		}
		default: {
			startTagInTable(p, token);
		}
	}
}
function endTagInTableBody(p, token) {
	const tn = token.tagID;
	switch (token.tagID) {
		case TAG_ID.TBODY:
		case TAG_ID.TFOOT:
		case TAG_ID.THEAD: {
			if (p.openElements.hasInTableScope(tn)) {
				p.openElements.clearBackToTableBodyContext();
				p.openElements.pop();
				p.insertionMode = InsertionMode.IN_TABLE;
			}
			break;
		}
		case TAG_ID.TABLE: {
			if (p.openElements.hasTableBodyContextInTableScope()) {
				p.openElements.clearBackToTableBodyContext();
				p.openElements.pop();
				p.insertionMode = InsertionMode.IN_TABLE;
				endTagInTable(p, token);
			}
			break;
		}
		case TAG_ID.BODY:
		case TAG_ID.CAPTION:
		case TAG_ID.COL:
		case TAG_ID.COLGROUP:
		case TAG_ID.HTML:
		case TAG_ID.TD:
		case TAG_ID.TH:
		case TAG_ID.TR: {
			break;
		}
		default: {
			endTagInTable(p, token);
		}
	}
}
function startTagInRow(p, token) {
	switch (token.tagID) {
		case TAG_ID.TH:
		case TAG_ID.TD: {
			p.openElements.clearBackToTableRowContext();
			p._insertElement(token, NS.HTML);
			p.insertionMode = InsertionMode.IN_CELL;
			p.activeFormattingElements.insertMarker();
			break;
		}
		case TAG_ID.CAPTION:
		case TAG_ID.COL:
		case TAG_ID.COLGROUP:
		case TAG_ID.TBODY:
		case TAG_ID.TFOOT:
		case TAG_ID.THEAD:
		case TAG_ID.TR: {
			if (p.openElements.hasInTableScope(TAG_ID.TR)) {
				p.openElements.clearBackToTableRowContext();
				p.openElements.pop();
				p.insertionMode = InsertionMode.IN_TABLE_BODY;
				startTagInTableBody(p, token);
			}
			break;
		}
		default: {
			startTagInTable(p, token);
		}
	}
}
function endTagInRow(p, token) {
	switch (token.tagID) {
		case TAG_ID.TR: {
			if (p.openElements.hasInTableScope(TAG_ID.TR)) {
				p.openElements.clearBackToTableRowContext();
				p.openElements.pop();
				p.insertionMode = InsertionMode.IN_TABLE_BODY;
			}
			break;
		}
		case TAG_ID.TABLE: {
			if (p.openElements.hasInTableScope(TAG_ID.TR)) {
				p.openElements.clearBackToTableRowContext();
				p.openElements.pop();
				p.insertionMode = InsertionMode.IN_TABLE_BODY;
				endTagInTableBody(p, token);
			}
			break;
		}
		case TAG_ID.TBODY:
		case TAG_ID.TFOOT:
		case TAG_ID.THEAD: {
			if (p.openElements.hasInTableScope(token.tagID) || p.openElements.hasInTableScope(TAG_ID.TR)) {
				p.openElements.clearBackToTableRowContext();
				p.openElements.pop();
				p.insertionMode = InsertionMode.IN_TABLE_BODY;
				endTagInTableBody(p, token);
			}
			break;
		}
		case TAG_ID.BODY:
		case TAG_ID.CAPTION:
		case TAG_ID.COL:
		case TAG_ID.COLGROUP:
		case TAG_ID.HTML:
		case TAG_ID.TD:
		case TAG_ID.TH: {
			break;
		}
		default: {
			endTagInTable(p, token);
		}
	}
}
function startTagInCell(p, token) {
	const tn = token.tagID;
	if (TABLE_VOID_ELEMENTS.has(tn)) {
		if (p.openElements.hasInTableScope(TAG_ID.TD) || p.openElements.hasInTableScope(TAG_ID.TH)) {
			p._closeTableCell();
			startTagInRow(p, token);
		}
	} else {
		startTagInBody(p, token);
	}
}
function endTagInCell(p, token) {
	const tn = token.tagID;
	switch (tn) {
		case TAG_ID.TD:
		case TAG_ID.TH: {
			if (p.openElements.hasInTableScope(tn)) {
				p.openElements.generateImpliedEndTags();
				p.openElements.popUntilTagNamePopped(tn);
				p.activeFormattingElements.clearToLastMarker();
				p.insertionMode = InsertionMode.IN_ROW;
			}
			break;
		}
		case TAG_ID.TABLE:
		case TAG_ID.TBODY:
		case TAG_ID.TFOOT:
		case TAG_ID.THEAD:
		case TAG_ID.TR: {
			if (p.openElements.hasInTableScope(tn)) {
				p._closeTableCell();
				endTagInRow(p, token);
			}
			break;
		}
		case TAG_ID.BODY:
		case TAG_ID.CAPTION:
		case TAG_ID.COL:
		case TAG_ID.COLGROUP:
		case TAG_ID.HTML: {
			break;
		}
		default: {
			endTagInBody(p, token);
		}
	}
}
function startTagInSelect(p, token) {
	switch (token.tagID) {
		case TAG_ID.HTML: {
			startTagInBody(p, token);
			break;
		}
		case TAG_ID.OPTION: {
			if (p.openElements.currentTagId === TAG_ID.OPTION) {
				p.openElements.pop();
			}
			p._insertElement(token, NS.HTML);
			break;
		}
		case TAG_ID.OPTGROUP: {
			if (p.openElements.currentTagId === TAG_ID.OPTION) {
				p.openElements.pop();
			}
			if (p.openElements.currentTagId === TAG_ID.OPTGROUP) {
				p.openElements.pop();
			}
			p._insertElement(token, NS.HTML);
			break;
		}
		case TAG_ID.HR: {
			if (p.openElements.currentTagId === TAG_ID.OPTION) {
				p.openElements.pop();
			}
			if (p.openElements.currentTagId === TAG_ID.OPTGROUP) {
				p.openElements.pop();
			}
			p._appendElement(token, NS.HTML);
			token.ackSelfClosing = true;
			break;
		}
		case TAG_ID.INPUT:
		case TAG_ID.KEYGEN:
		case TAG_ID.TEXTAREA:
		case TAG_ID.SELECT: {
			if (p.openElements.hasInSelectScope(TAG_ID.SELECT)) {
				p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
				p._resetInsertionMode();
				if (token.tagID !== TAG_ID.SELECT) {
					p._processStartTag(token);
				}
			}
			break;
		}
		case TAG_ID.SCRIPT:
		case TAG_ID.TEMPLATE: {
			startTagInHead(p, token);
			break;
		}
		default:
	}
}
function endTagInSelect(p, token) {
	switch (token.tagID) {
		case TAG_ID.OPTGROUP: {
			if (
				p.openElements.stackTop > 0 &&
				p.openElements.currentTagId === TAG_ID.OPTION &&
				p.openElements.tagIDs[p.openElements.stackTop - 1] === TAG_ID.OPTGROUP
			) {
				p.openElements.pop();
			}
			if (p.openElements.currentTagId === TAG_ID.OPTGROUP) {
				p.openElements.pop();
			}
			break;
		}
		case TAG_ID.OPTION: {
			if (p.openElements.currentTagId === TAG_ID.OPTION) {
				p.openElements.pop();
			}
			break;
		}
		case TAG_ID.SELECT: {
			if (p.openElements.hasInSelectScope(TAG_ID.SELECT)) {
				p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
				p._resetInsertionMode();
			}
			break;
		}
		case TAG_ID.TEMPLATE: {
			templateEndTagInHead(p, token);
			break;
		}
		default:
	}
}
function startTagInSelectInTable(p, token) {
	const tn = token.tagID;
	if (
		tn === TAG_ID.CAPTION ||
		tn === TAG_ID.TABLE ||
		tn === TAG_ID.TBODY ||
		tn === TAG_ID.TFOOT ||
		tn === TAG_ID.THEAD ||
		tn === TAG_ID.TR ||
		tn === TAG_ID.TD ||
		tn === TAG_ID.TH
	) {
		p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
		p._resetInsertionMode();
		p._processStartTag(token);
	} else {
		startTagInSelect(p, token);
	}
}
function endTagInSelectInTable(p, token) {
	const tn = token.tagID;
	if (
		tn === TAG_ID.CAPTION ||
		tn === TAG_ID.TABLE ||
		tn === TAG_ID.TBODY ||
		tn === TAG_ID.TFOOT ||
		tn === TAG_ID.THEAD ||
		tn === TAG_ID.TR ||
		tn === TAG_ID.TD ||
		tn === TAG_ID.TH
	) {
		if (p.openElements.hasInTableScope(tn)) {
			p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
			p._resetInsertionMode();
			p.onEndTag(token);
		}
	} else {
		endTagInSelect(p, token);
	}
}
function startTagInTemplate(p, token) {
	switch (token.tagID) {
		// First, handle tags that can start without a mode change
		case TAG_ID.BASE:
		case TAG_ID.BASEFONT:
		case TAG_ID.BGSOUND:
		case TAG_ID.LINK:
		case TAG_ID.META:
		case TAG_ID.NOFRAMES:
		case TAG_ID.SCRIPT:
		case TAG_ID.STYLE:
		case TAG_ID.TEMPLATE:
		case TAG_ID.TITLE: {
			startTagInHead(p, token);
			break;
		}
		// Re-process the token in the appropriate mode
		case TAG_ID.CAPTION:
		case TAG_ID.COLGROUP:
		case TAG_ID.TBODY:
		case TAG_ID.TFOOT:
		case TAG_ID.THEAD: {
			p.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE;
			p.insertionMode = InsertionMode.IN_TABLE;
			startTagInTable(p, token);
			break;
		}
		case TAG_ID.COL: {
			p.tmplInsertionModeStack[0] = InsertionMode.IN_COLUMN_GROUP;
			p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
			startTagInColumnGroup(p, token);
			break;
		}
		case TAG_ID.TR: {
			p.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE_BODY;
			p.insertionMode = InsertionMode.IN_TABLE_BODY;
			startTagInTableBody(p, token);
			break;
		}
		case TAG_ID.TD:
		case TAG_ID.TH: {
			p.tmplInsertionModeStack[0] = InsertionMode.IN_ROW;
			p.insertionMode = InsertionMode.IN_ROW;
			startTagInRow(p, token);
			break;
		}
		default: {
			p.tmplInsertionModeStack[0] = InsertionMode.IN_BODY;
			p.insertionMode = InsertionMode.IN_BODY;
			startTagInBody(p, token);
		}
	}
}
function endTagInTemplate(p, token) {
	if (token.tagID === TAG_ID.TEMPLATE) {
		templateEndTagInHead(p, token);
	}
}
function eofInTemplate(p, token) {
	if (p.openElements.tmplCount > 0) {
		p.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE);
		p.activeFormattingElements.clearToLastMarker();
		p.tmplInsertionModeStack.shift();
		p._resetInsertionMode();
		p.onEof(token);
	} else {
		stopParsing(p, token);
	}
}
function startTagAfterBody(p, token) {
	if (token.tagID === TAG_ID.HTML) {
		startTagInBody(p, token);
	} else {
		tokenAfterBody(p, token);
	}
}
function endTagAfterBody(p, token) {
	var _a2;
	if (token.tagID === TAG_ID.HTML) {
		if (!p.fragmentContext) {
			p.insertionMode = InsertionMode.AFTER_AFTER_BODY;
		}
		if (p.options.sourceCodeLocationInfo && p.openElements.tagIDs[0] === TAG_ID.HTML) {
			p._setEndLocation(p.openElements.items[0], token);
			const bodyElement = p.openElements.items[1];
			if (
				bodyElement &&
				!((_a2 = p.treeAdapter.getNodeSourceCodeLocation(bodyElement)) === null || _a2 === void 0 ? void 0 : _a2.endTag)
			) {
				p._setEndLocation(bodyElement, token);
			}
		}
	} else {
		tokenAfterBody(p, token);
	}
}
function tokenAfterBody(p, token) {
	p.insertionMode = InsertionMode.IN_BODY;
	modeInBody(p, token);
}
function startTagInFrameset(p, token) {
	switch (token.tagID) {
		case TAG_ID.HTML: {
			startTagInBody(p, token);
			break;
		}
		case TAG_ID.FRAMESET: {
			p._insertElement(token, NS.HTML);
			break;
		}
		case TAG_ID.FRAME: {
			p._appendElement(token, NS.HTML);
			token.ackSelfClosing = true;
			break;
		}
		case TAG_ID.NOFRAMES: {
			startTagInHead(p, token);
			break;
		}
		default:
	}
}
function endTagInFrameset(p, token) {
	if (token.tagID === TAG_ID.FRAMESET && !p.openElements.isRootHtmlElementCurrent()) {
		p.openElements.pop();
		if (!p.fragmentContext && p.openElements.currentTagId !== TAG_ID.FRAMESET) {
			p.insertionMode = InsertionMode.AFTER_FRAMESET;
		}
	}
}
function startTagAfterFrameset(p, token) {
	switch (token.tagID) {
		case TAG_ID.HTML: {
			startTagInBody(p, token);
			break;
		}
		case TAG_ID.NOFRAMES: {
			startTagInHead(p, token);
			break;
		}
		default:
	}
}
function endTagAfterFrameset(p, token) {
	if (token.tagID === TAG_ID.HTML) {
		p.insertionMode = InsertionMode.AFTER_AFTER_FRAMESET;
	}
}
function startTagAfterAfterBody(p, token) {
	if (token.tagID === TAG_ID.HTML) {
		startTagInBody(p, token);
	} else {
		tokenAfterAfterBody(p, token);
	}
}
function tokenAfterAfterBody(p, token) {
	p.insertionMode = InsertionMode.IN_BODY;
	modeInBody(p, token);
}
function startTagAfterAfterFrameset(p, token) {
	switch (token.tagID) {
		case TAG_ID.HTML: {
			startTagInBody(p, token);
			break;
		}
		case TAG_ID.NOFRAMES: {
			startTagInHead(p, token);
			break;
		}
		default:
	}
}
function nullCharacterInForeignContent(p, token) {
	token.chars = REPLACEMENT_CHARACTER;
	p._insertCharacters(token);
}
function characterInForeignContent(p, token) {
	p._insertCharacters(token);
	p.framesetOk = false;
}
function popUntilHtmlOrIntegrationPoint(p) {
	while (
		p.treeAdapter.getNamespaceURI(p.openElements.current) !== NS.HTML &&
		!p._isIntegrationPoint(p.openElements.currentTagId, p.openElements.current)
	) {
		p.openElements.pop();
	}
}
function startTagInForeignContent(p, token) {
	if (causesExit(token)) {
		popUntilHtmlOrIntegrationPoint(p);
		p._startTagOutsideForeignContent(token);
	} else {
		const current = p._getAdjustedCurrentElement();
		const currentNs = p.treeAdapter.getNamespaceURI(current);
		if (currentNs === NS.MATHML) {
			adjustTokenMathMLAttrs(token);
		} else if (currentNs === NS.SVG) {
			adjustTokenSVGTagName(token);
			adjustTokenSVGAttrs(token);
		}
		adjustTokenXMLAttrs(token);
		if (token.selfClosing) {
			p._appendElement(token, currentNs);
		} else {
			p._insertElement(token, currentNs);
		}
		token.ackSelfClosing = true;
	}
}
function endTagInForeignContent(p, token) {
	if (token.tagID === TAG_ID.P || token.tagID === TAG_ID.BR) {
		popUntilHtmlOrIntegrationPoint(p);
		p._endTagOutsideForeignContent(token);
		return;
	}
	for (let i = p.openElements.stackTop; i > 0; i--) {
		const element = p.openElements.items[i];
		if (p.treeAdapter.getNamespaceURI(element) === NS.HTML) {
			p._endTagOutsideForeignContent(token);
			break;
		}
		const tagName = p.treeAdapter.getTagName(element);
		if (tagName.toLowerCase() === token.tagName) {
			token.tagName = tagName;
			p.openElements.shortenToLength(i);
			break;
		}
	}
}

// node_modules/entities/lib/esm/escape.js
var xmlCodeMap = /* @__PURE__ */ new Map([
	[34, '&quot;'],
	[38, '&amp;'],
	[39, '&apos;'],
	[60, '&lt;'],
	[62, '&gt;'],
]);
var getCodePoint =
	// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
	String.prototype.codePointAt != null
		? (str, index) => str.codePointAt(index)
		: // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
			(c, index) =>
				(c.charCodeAt(index) & 64512) === 55296
					? (c.charCodeAt(index) - 55296) * 1024 + c.charCodeAt(index + 1) - 56320 + 65536
					: c.charCodeAt(index);
function getEscaper(regex, map2) {
	return function escape(data) {
		let match;
		let lastIdx = 0;
		let result = '';
		while ((match = regex.exec(data))) {
			if (lastIdx !== match.index) {
				result += data.substring(lastIdx, match.index);
			}
			result += map2.get(match[0].charCodeAt(0));
			lastIdx = match.index + 1;
		}
		return result + data.substring(lastIdx);
	};
}
var escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
var escapeAttribute = getEscaper(
	/["&\u00A0]/g,
	/* @__PURE__ */ new Map([
		[34, '&quot;'],
		[38, '&amp;'],
		[160, '&nbsp;'],
	]),
);
var escapeText = getEscaper(
	/[&<>\u00A0]/g,
	/* @__PURE__ */ new Map([
		[38, '&amp;'],
		[60, '&lt;'],
		[62, '&gt;'],
		[160, '&nbsp;'],
	]),
);

// node_modules/parse5/dist/serializer/index.js
var VOID_ELEMENTS = /* @__PURE__ */ new Set([
	TAG_NAMES.AREA,
	TAG_NAMES.BASE,
	TAG_NAMES.BASEFONT,
	TAG_NAMES.BGSOUND,
	TAG_NAMES.BR,
	TAG_NAMES.COL,
	TAG_NAMES.EMBED,
	TAG_NAMES.FRAME,
	TAG_NAMES.HR,
	TAG_NAMES.IMG,
	TAG_NAMES.INPUT,
	TAG_NAMES.KEYGEN,
	TAG_NAMES.LINK,
	TAG_NAMES.META,
	TAG_NAMES.PARAM,
	TAG_NAMES.SOURCE,
	TAG_NAMES.TRACK,
	TAG_NAMES.WBR,
]);

// node_modules/parse5/dist/index.js
function parse(html, options) {
	return Parser.parse(html, options);
}
function parseFragment(fragmentContext, html, options) {
	if (typeof fragmentContext === 'string') {
		options = html;
		html = fragmentContext;
		fragmentContext = null;
	}
	const parser = Parser.getFragmentParser(fragmentContext, options);
	parser.tokenizer.write(html, true);
	return parser.getFragment();
}

// src/mock-doc/parse-util.ts
var docParser = /* @__PURE__ */ new WeakMap();
function parseDocumentUtil(ownerDocument, html) {
	const doc = parse(html.trim(), getParser(ownerDocument));
	doc.documentElement = doc.firstElementChild;
	doc.head = doc.documentElement.firstElementChild;
	doc.body = doc.head.nextElementSibling;
	return doc;
}
function parseFragmentUtil(ownerDocument, html) {
	if (typeof html === 'string') {
		html = html.trim();
	} else {
		html = '';
	}
	const frag = parseFragment(html, getParser(ownerDocument));
	return frag;
}
function getParser(ownerDocument) {
	let parseOptions = docParser.get(ownerDocument);
	if (parseOptions != null) {
		return parseOptions;
	}
	const treeAdapter = {
		createDocument() {
			const doc = ownerDocument.createElement('#document' /* DOCUMENT_NODE */);
			doc['x-mode'] = 'no-quirks';
			return doc;
		},
		setNodeSourceCodeLocation(node, location2) {
			node.sourceCodeLocation = location2;
		},
		getNodeSourceCodeLocation(node) {
			return node.sourceCodeLocation;
		},
		createDocumentFragment() {
			return ownerDocument.createDocumentFragment();
		},
		createElement(tagName, namespaceURI, attrs) {
			const elm = ownerDocument.createElementNS(namespaceURI, tagName);
			for (let i = 0; i < attrs.length; i++) {
				const attr = attrs[i];
				if (attr.namespace == null || attr.namespace === 'http://www.w3.org/1999/xhtml') {
					elm.setAttribute(attr.name, attr.value);
				} else {
					elm.setAttributeNS(attr.namespace, attr.name, attr.value);
				}
			}
			return elm;
		},
		createCommentNode(data) {
			return ownerDocument.createComment(data);
		},
		appendChild(parentNode, newNode) {
			parentNode.appendChild(newNode);
		},
		insertBefore(parentNode, newNode, referenceNode) {
			parentNode.insertBefore(newNode, referenceNode);
		},
		setTemplateContent(templateElement, contentElement) {
			templateElement.content = contentElement;
		},
		getTemplateContent(templateElement) {
			return templateElement.content;
		},
		setDocumentType(doc, name, publicId, systemId) {
			let doctypeNode = doc.childNodes.find((n) => n.nodeType === 10 /* DOCUMENT_TYPE_NODE */);
			if (doctypeNode == null) {
				doctypeNode = ownerDocument.createDocumentTypeNode();
				doc.insertBefore(doctypeNode, doc.firstChild);
			}
			doctypeNode.nodeValue = '!DOCTYPE';
			doctypeNode['x-name'] = name;
			doctypeNode['x-publicId'] = publicId;
			doctypeNode['x-systemId'] = systemId;
		},
		setDocumentMode(doc, mode) {
			doc['x-mode'] = mode;
		},
		getDocumentMode(doc) {
			return doc['x-mode'];
		},
		detachNode(node) {
			node.remove();
		},
		insertText(parentNode, text) {
			const lastChild = parentNode.lastChild;
			if (lastChild != null && lastChild.nodeType === 3 /* TEXT_NODE */) {
				lastChild.nodeValue += text;
			} else {
				parentNode.appendChild(ownerDocument.createTextNode(text));
			}
		},
		insertTextBefore(parentNode, text, referenceNode) {
			const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
			if (prevNode != null && prevNode.nodeType === 3 /* TEXT_NODE */) {
				prevNode.nodeValue += text;
			} else {
				parentNode.insertBefore(ownerDocument.createTextNode(text), referenceNode);
			}
		},
		adoptAttributes(recipient, attrs) {
			for (let i = 0; i < attrs.length; i++) {
				const attr = attrs[i];
				if (recipient.hasAttributeNS(attr.namespace, attr.name) === false) {
					recipient.setAttributeNS(attr.namespace, attr.name, attr.value);
				}
			}
		},
		getFirstChild(node) {
			return node.childNodes[0];
		},
		getChildNodes(node) {
			return node.childNodes;
		},
		getParentNode(node) {
			return node.parentNode;
		},
		getAttrList(element) {
			const attrs = element.attributes.__items.map((attr) => {
				return {
					name: attr.name,
					value: attr.value,
					namespace: attr.namespaceURI,
					prefix: null,
				};
			});
			return attrs;
		},
		getTagName(element) {
			if (element.namespaceURI === 'http://www.w3.org/1999/xhtml') {
				return element.nodeName.toLowerCase();
			} else {
				return element.nodeName;
			}
		},
		getNamespaceURI(element) {
			return element.namespaceURI;
		},
		getTextNodeContent(textNode) {
			return textNode.nodeValue;
		},
		getCommentNodeContent(commentNode) {
			return commentNode.nodeValue;
		},
		getDocumentTypeNodeName(doctypeNode) {
			return doctypeNode['x-name'];
		},
		getDocumentTypeNodePublicId(doctypeNode) {
			return doctypeNode['x-publicId'];
		},
		getDocumentTypeNodeSystemId(doctypeNode) {
			return doctypeNode['x-systemId'];
		},
		// @ts-ignore - a `MockNode` will never be assignable to a `TreeAdapterTypeMap['text']`. As a result, we cannot
		// complete this function signature
		isTextNode(node) {
			return node.nodeType === 3 /* TEXT_NODE */;
		},
		// @ts-ignore - a `MockNode` will never be assignable to a `TreeAdapterTypeMap['comment']`. As a result, we cannot
		// complete this function signature (which requires its return type to be a type predicate)
		isCommentNode(node) {
			return node.nodeType === 8 /* COMMENT_NODE */;
		},
		// @ts-ignore - a `MockNode` will never be assignable to a `TreeAdapterTypeMap['document']`. As a result, we cannot
		// complete this function signature (which requires its return type to be a type predicate)
		isDocumentTypeNode(node) {
			return node.nodeType === 10 /* DOCUMENT_TYPE_NODE */;
		},
		// @ts-ignore - a `MockNode` will never be assignable to a `TreeAdapterTypeMap['element']`. As a result, we cannot
		// complete this function signature (which requires its return type to be a type predicate)
		isElementNode(node) {
			return node.nodeType === 1 /* ELEMENT_NODE */;
		},
	};
	parseOptions = {
		treeAdapter,
	};
	docParser.set(ownerDocument, parseOptions);
	return parseOptions;
}

// src/mock-doc/third-party/jquery.ts
var jquery_default =
	/*!
	 * jQuery JavaScript Library v4.0.0-pre+9352011a7.dirty +selector
	 * https://jquery.com/
	 *
	 * Copyright OpenJS Foundation and other contributors
	 * Released under the MIT license
	 * https://jquery.org/license
	 *
	 * Date: 2023-12-11T17:55Z
	 */
	(function (global2, factory) {
		'use strict';
		if (true) {
			return factory(global2, true);
		} else {
			factory(global2);
		}
	})(
		{
			document: {
				createElement() {
					return {};
				},
				nodeType: 9,
				documentElement: {
					nodeType: 1,
					nodeName: 'HTML',
				},
			},
		},
		function (window2, noGlobal) {
			'use strict';
			if (!window2.document) {
				throw new Error('jQuery requires a window with a document');
			}
			var arr = [];
			var getProto = Object.getPrototypeOf;
			var slice = arr.slice;
			var flat = arr.flat
				? function (array) {
						return arr.flat.call(array);
					}
				: function (array) {
						return arr.concat.apply([], array);
					};
			var push = arr.push;
			var indexOf = arr.indexOf;
			var class2type = {};
			var toString = class2type.toString;
			var hasOwn = class2type.hasOwnProperty;
			var fnToString = hasOwn.toString;
			var ObjectFunctionString = fnToString.call(Object);
			var support = {};
			function toType(obj) {
				if (obj == null) {
					return obj + '';
				}
				return typeof obj === 'object' ? class2type[toString.call(obj)] || 'object' : typeof obj;
			}
			function isWindow(obj) {
				return obj != null && obj === obj.window;
			}
			function isArrayLike(obj) {
				var length = !!obj && obj.length,
					type = toType(obj);
				if (typeof obj === 'function' || isWindow(obj)) {
					return false;
				}
				return type === 'array' || length === 0 || (typeof length === 'number' && length > 0 && length - 1 in obj);
			}
			var document2 = window2.document;
			var preservedScriptAttributes = {
				type: true,
				src: true,
				nonce: true,
				noModule: true,
			};
			function DOMEval(code, node, doc) {
				doc = doc || document2;
				var i2,
					script = doc.createElement('script');
				script.text = code;
				if (node) {
					for (i2 in preservedScriptAttributes) {
						if (node[i2]) {
							script[i2] = node[i2];
						}
					}
				}
				doc.head.appendChild(script).parentNode.removeChild(script);
			}
			const jQuery = {};
			var version = '4.0.0-pre+9352011a7.dirty +selector',
				rhtmlSuffix = /HTML$/i,
				jQueryOrig = function (selector, context) {
					return new jQuery.fn.init(selector, context);
				};
			jQuery.fn = jQuery.prototype = {
				// The current version of jQuery being used
				jquery: version,
				constructor: jQuery,
				// The default length of a jQuery object is 0
				length: 0,
				toArray: function () {
					return slice.call(this);
				},
				// Get the Nth element in the matched element set OR
				// Get the whole matched element set as a clean array
				get: function (num) {
					if (num == null) {
						return slice.call(this);
					}
					return num < 0 ? this[num + this.length] : this[num];
				},
				// Take an array of elements and push it onto the stack
				// (returning the new matched element set)
				pushStack: function (elems) {
					var ret = jQuery.merge(this.constructor(), elems);
					ret.prevObject = this;
					return ret;
				},
				// Execute a callback for every element in the matched set.
				each: function (callback) {
					return jQuery.each(this, callback);
				},
				map: function (callback) {
					return this.pushStack(
						jQuery.map(this, function (elem, i2) {
							return callback.call(elem, i2, elem);
						}),
					);
				},
				slice: function () {
					return this.pushStack(slice.apply(this, arguments));
				},
				first: function () {
					return this.eq(0);
				},
				last: function () {
					return this.eq(-1);
				},
				even: function () {
					return this.pushStack(
						jQuery.grep(this, function (_elem, i2) {
							return (i2 + 1) % 2;
						}),
					);
				},
				odd: function () {
					return this.pushStack(
						jQuery.grep(this, function (_elem, i2) {
							return i2 % 2;
						}),
					);
				},
				eq: function (i2) {
					var len = this.length,
						j = +i2 + (i2 < 0 ? len : 0);
					return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
				},
				end: function () {
					return this.prevObject || this.constructor();
				},
			};
			jQuery.extend = jQuery.fn.extend = function () {
				var options,
					name,
					src,
					copy,
					copyIsArray,
					clone,
					target = arguments[0] || {},
					i2 = 1,
					length = arguments.length,
					deep = false;
				if (typeof target === 'boolean') {
					deep = target;
					target = arguments[i2] || {};
					i2++;
				}
				if (typeof target !== 'object' && typeof target !== 'function') {
					target = {};
				}
				if (i2 === length) {
					target = this;
					i2--;
				}
				for (; i2 < length; i2++) {
					if ((options = arguments[i2]) != null) {
						for (name in options) {
							copy = options[name];
							if (name === '__proto__' || target === copy) {
								continue;
							}
							if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
								src = target[name];
								if (copyIsArray && !Array.isArray(src)) {
									clone = [];
								} else if (!copyIsArray && !jQuery.isPlainObject(src)) {
									clone = {};
								} else {
									clone = src;
								}
								copyIsArray = false;
								target[name] = jQuery.extend(deep, clone, copy);
							} else if (copy !== void 0) {
								target[name] = copy;
							}
						}
					}
				}
				return target;
			};
			jQuery.extend({
				// Unique for each copy of jQuery on the page
				expando: 'jQuery' + (version + Math.random()).replace(/\D/g, ''),
				// Assume jQuery is ready without the ready module
				isReady: true,
				error: function (msg) {
					throw new Error(msg);
				},
				noop: function () {},
				isPlainObject: function (obj) {
					var proto, Ctor;
					if (!obj || toString.call(obj) !== '[object Object]') {
						return false;
					}
					proto = getProto(obj);
					if (!proto) {
						return true;
					}
					Ctor = hasOwn.call(proto, 'constructor') && proto.constructor;
					return typeof Ctor === 'function' && fnToString.call(Ctor) === ObjectFunctionString;
				},
				isEmptyObject: function (obj) {
					var name;
					for (name in obj) {
						return false;
					}
					return true;
				},
				// Evaluates a script in a provided context; falls back to the global one
				// if not specified.
				globalEval: function (code, options, doc) {
					DOMEval(code, { nonce: options && options.nonce }, doc);
				},
				each: function (obj, callback) {
					var length,
						i2 = 0;
					if (isArrayLike(obj)) {
						length = obj.length;
						for (; i2 < length; i2++) {
							if (callback.call(obj[i2], i2, obj[i2]) === false) {
								break;
							}
						}
					} else {
						for (i2 in obj) {
							if (callback.call(obj[i2], i2, obj[i2]) === false) {
								break;
							}
						}
					}
					return obj;
				},
				// Retrieve the text value of an array of DOM nodes
				text: function (elem) {
					var node,
						ret = '',
						i2 = 0,
						nodeType = elem.nodeType;
					if (!nodeType) {
						while ((node = elem[i2++])) {
							ret += jQuery.text(node);
						}
					}
					if (nodeType === 1 || nodeType === 11) {
						return elem.textContent;
					}
					if (nodeType === 9) {
						return elem.documentElement.textContent;
					}
					if (nodeType === 3 || nodeType === 4) {
						return elem.nodeValue;
					}
					return ret;
				},
				// results is for internal usage only
				makeArray: function (arr2, results) {
					var ret = results || [];
					if (arr2 != null) {
						if (isArrayLike(Object(arr2))) {
							jQuery.merge(ret, typeof arr2 === 'string' ? [arr2] : arr2);
						} else {
							push.call(ret, arr2);
						}
					}
					return ret;
				},
				inArray: function (elem, arr2, i2) {
					return arr2 == null ? -1 : indexOf.call(arr2, elem, i2);
				},
				isXMLDoc: function (elem) {
					var namespace = elem && elem.namespaceURI,
						docElem = elem && (elem.ownerDocument || elem).documentElement;
					return !rhtmlSuffix.test(namespace || (docElem && docElem.nodeName) || 'HTML');
				},
				// Note: an element does not contain itself
				contains: function (a, b) {
					var bup = b && b.parentNode;
					return (
						a === bup ||
						!!(
							bup &&
							bup.nodeType === 1 && // Support: IE 9 - 11+
							// IE doesn't have `contains` on SVG.
							(a.contains ? a.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16)
						)
					);
				},
				merge: function (first, second) {
					var len = +second.length,
						j = 0,
						i2 = first.length;
					for (; j < len; j++) {
						first[i2++] = second[j];
					}
					first.length = i2;
					return first;
				},
				grep: function (elems, callback, invert) {
					var callbackInverse,
						matches3 = [],
						i2 = 0,
						length = elems.length,
						callbackExpect = !invert;
					for (; i2 < length; i2++) {
						callbackInverse = !callback(elems[i2], i2);
						if (callbackInverse !== callbackExpect) {
							matches3.push(elems[i2]);
						}
					}
					return matches3;
				},
				// arg is for internal usage only
				map: function (elems, callback, arg) {
					var length,
						value,
						i2 = 0,
						ret = [];
					if (isArrayLike(elems)) {
						length = elems.length;
						for (; i2 < length; i2++) {
							value = callback(elems[i2], i2, arg);
							if (value != null) {
								ret.push(value);
							}
						}
					} else {
						for (i2 in elems) {
							value = callback(elems[i2], i2, arg);
							if (value != null) {
								ret.push(value);
							}
						}
					}
					return flat(ret);
				},
				// A global GUID counter for objects
				guid: 1,
				// jQuery.support is not used in Core but other projects attach their
				// properties to it so it needs to exist.
				support,
			});
			if (typeof Symbol === 'function') {
				jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
			}
			jQuery.each(
				'Boolean Number String Function Array Date RegExp Object Error Symbol'.split(' '),
				function (_i, name) {
					class2type['[object ' + name + ']'] = name.toLowerCase();
				},
			);
			function nodeName(elem, name) {
				return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
			}
			var pop = arr.pop;
			var whitespace = '[\\x20\\t\\r\\n\\f]';
			var isIE = document2.documentMode;
			try {
				document2.querySelector(':has(*,:jqfake)');
				support.cssHas = false;
			} catch (e) {
				support.cssHas = true;
			}
			var rbuggyQSA = [];
			if (isIE) {
				rbuggyQSA.push(
					// Support: IE 9 - 11+
					// IE's :disabled selector does not pick up the children of disabled fieldsets
					':enabled',
					':disabled',
					// Support: IE 11+
					// IE 11 doesn't find elements on a `[name='']` query in some cases.
					// Adding a temporary attribute to the document before the selection works
					// around the issue.
					'\\[' + whitespace + '*name' + whitespace + '*=' + whitespace + `*(?:''|"")`,
				);
			}
			if (!support.cssHas) {
				rbuggyQSA.push(':has');
			}
			rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
			var rtrimCSS = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g');
			var identifier = '(?:\\\\[\\da-fA-F]{1,6}' + whitespace + '?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+';
			var booleans =
				'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped';
			var rleadingCombinator = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*');
			var rdescend = new RegExp(whitespace + '|>');
			var rsibling = /[+~]/;
			var documentElement = document2.documentElement;
			var matches2 = documentElement.matches || documentElement.msMatchesSelector;
			function createCache() {
				var keys = [];
				function cache(key, value) {
					if (keys.push(key + ' ') > jQuery.expr.cacheLength) {
						delete cache[keys.shift()];
					}
					return (cache[key + ' '] = value);
				}
				return cache;
			}
			function testContext(context) {
				return context && typeof context.getElementsByTagName !== 'undefined' && context;
			}
			var attributes =
				'\\[' +
				whitespace +
				'*(' +
				identifier +
				')(?:' +
				whitespace + // Operator (capture 2)
				'*([*^$|!~]?=)' +
				whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
				`*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` +
				identifier +
				'))|)' +
				whitespace +
				'*\\]';
			var pseudos =
				':(' +
				identifier +
				`)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` +
				attributes +
				')*)|.*)\\)|)';
			var filterMatchExpr = {
				ID: new RegExp('^#(' + identifier + ')'),
				CLASS: new RegExp('^\\.(' + identifier + ')'),
				TAG: new RegExp('^(' + identifier + '|[*])'),
				ATTR: new RegExp('^' + attributes),
				PSEUDO: new RegExp('^' + pseudos),
				CHILD: new RegExp(
					'^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' +
						whitespace +
						'*(even|odd|(([+-]|)(\\d*)n|)' +
						whitespace +
						'*(?:([+-]|)' +
						whitespace +
						'*(\\d+)|))' +
						whitespace +
						'*\\)|)',
					'i',
				),
			};
			var rpseudo = new RegExp(pseudos);
			var runescape = new RegExp('\\\\[\\da-fA-F]{1,6}' + whitespace + '?|\\\\([^\\r\\n\\f])', 'g'),
				funescape = function (escape, nonHex) {
					var high = '0x' + escape.slice(1) - 65536;
					if (nonHex) {
						return nonHex;
					}
					return high < 0
						? String.fromCharCode(high + 65536)
						: String.fromCharCode((high >> 10) | 55296, (high & 1023) | 56320);
				};
			function unescapeSelector(sel) {
				return sel.replace(runescape, funescape);
			}
			function selectorError(msg) {
				jQuery.error('Syntax error, unrecognized expression: ' + msg);
			}
			var rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*');
			var tokenCache = createCache();
			function tokenize(selector, parseOnly) {
				var matched,
					match,
					tokens,
					type,
					soFar,
					groups,
					preFilters,
					cached = tokenCache[selector + ' '];
				if (cached) {
					return parseOnly ? 0 : cached.slice(0);
				}
				soFar = selector;
				groups = [];
				preFilters = jQuery.expr.preFilter;
				while (soFar) {
					if (!matched || (match = rcomma.exec(soFar))) {
						if (match) {
							soFar = soFar.slice(match[0].length) || soFar;
						}
						groups.push((tokens = []));
					}
					matched = false;
					if ((match = rleadingCombinator.exec(soFar))) {
						matched = match.shift();
						tokens.push({
							value: matched,
							// Cast descendant combinators to space
							type: match[0].replace(rtrimCSS, ' '),
						});
						soFar = soFar.slice(matched.length);
					}
					for (type in filterMatchExpr) {
						if (
							(match = jQuery.expr.match[type].exec(soFar)) &&
							(!preFilters[type] || (match = preFilters[type](match)))
						) {
							matched = match.shift();
							tokens.push({
								value: matched,
								type,
								matches: match,
							});
							soFar = soFar.slice(matched.length);
						}
					}
					if (!matched) {
						break;
					}
				}
				if (parseOnly) {
					return soFar.length;
				}
				return soFar
					? selectorError(selector)
					: // Cache the tokens
						tokenCache(selector, groups).slice(0);
			}
			var preFilter = {
				ATTR: function (match) {
					match[1] = unescapeSelector(match[1]);
					match[3] = unescapeSelector(match[3] || match[4] || match[5] || '');
					if (match[2] === '~=') {
						match[3] = ' ' + match[3] + ' ';
					}
					return match.slice(0, 4);
				},
				CHILD: function (match) {
					match[1] = match[1].toLowerCase();
					if (match[1].slice(0, 3) === 'nth') {
						if (!match[3]) {
							selectorError(match[0]);
						}
						match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
						match[5] = +(match[7] + match[8] || match[3] === 'odd');
					} else if (match[3]) {
						selectorError(match[0]);
					}
					return match;
				},
				PSEUDO: function (match) {
					var excess,
						unquoted = !match[6] && match[2];
					if (filterMatchExpr.CHILD.test(match[0])) {
						return null;
					}
					if (match[3]) {
						match[2] = match[4] || match[5] || '';
					} else if (
						unquoted &&
						rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
						(excess = tokenize(unquoted, true)) && // advance to the next closing parenthesis
						(excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)
					) {
						match[0] = match[0].slice(0, excess);
						match[2] = unquoted.slice(0, excess);
					}
					return match.slice(0, 3);
				},
			};
			function toSelector(tokens) {
				var i2 = 0,
					len = tokens.length,
					selector = '';
				for (; i2 < len; i2++) {
					selector += tokens[i2].value;
				}
				return selector;
			}
			var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
			function fcssescape(ch, asCodePoint) {
				if (asCodePoint) {
					if (ch === '\0') {
						return '\uFFFD';
					}
					return ch.slice(0, -1) + '\\' + ch.charCodeAt(ch.length - 1).toString(16) + ' ';
				}
				return '\\' + ch;
			}
			jQuery.escapeSelector = function (sel) {
				return (sel + '').replace(rcssescape, fcssescape);
			};
			var sort = arr.sort;
			var splice = arr.splice;
			var hasDuplicate;
			function sortOrder(a, b) {
				if (a === b) {
					hasDuplicate = true;
					return 0;
				}
				var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
				if (compare) {
					return compare;
				}
				compare =
					(a.ownerDocument || a) == (b.ownerDocument || b)
						? a.compareDocumentPosition(b)
						: // Otherwise we know they are disconnected
							1;
				if (compare & 1) {
					if (a == document2 || (a.ownerDocument == document2 && jQuery.contains(document2, a))) {
						return -1;
					}
					if (b == document2 || (b.ownerDocument == document2 && jQuery.contains(document2, b))) {
						return 1;
					}
					return 0;
				}
				return compare & 4 ? -1 : 1;
			}
			jQuery.uniqueSort = function (results) {
				var elem,
					duplicates = [],
					j = 0,
					i2 = 0;
				hasDuplicate = false;
				sort.call(results, sortOrder);
				if (hasDuplicate) {
					while ((elem = results[i2++])) {
						if (elem === results[i2]) {
							j = duplicates.push(i2);
						}
					}
					while (j--) {
						splice.call(results, duplicates[j], 1);
					}
				}
				return results;
			};
			jQuery.fn.uniqueSort = function () {
				return this.pushStack(jQuery.uniqueSort(slice.apply(this)));
			};
			var i,
				outermostContext,
				document$1,
				documentElement$1,
				documentIsHTML,
				dirruns = 0,
				done = 0,
				classCache = createCache(),
				compilerCache = createCache(),
				nonnativeSelectorCache = createCache(),
				rwhitespace = new RegExp(whitespace + '+', 'g'),
				ridentifier = new RegExp('^' + identifier + '$'),
				matchExpr = jQuery.extend(
					{
						bool: new RegExp('^(?:' + booleans + ')$', 'i'),
						// For use in libraries implementing .is()
						// We use this for POS matching in `select`
						needsContext: new RegExp(
							'^' +
								whitespace +
								'*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' +
								whitespace +
								'*((?:-\\d)?\\d*)' +
								whitespace +
								'*\\)|)(?=[^-]|$)',
							'i',
						),
					},
					filterMatchExpr,
				),
				rinputs = /^(?:input|select|textarea|button)$/i,
				rheader = /^h\d$/i,
				rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
				unloadHandler = function () {
					setDocument();
				},
				inDisabledFieldset = addCombinator(
					function (elem) {
						return elem.disabled === true && nodeName(elem, 'fieldset');
					},
					{ dir: 'parentNode', next: 'legend' },
				);
			function find(selector, context, results, seed) {
				var m,
					i2,
					elem,
					nid,
					match,
					groups,
					newSelector,
					newContext = context && context.ownerDocument,
					nodeType = context ? context.nodeType : 9;
				results = results || [];
				if (typeof selector !== 'string' || !selector || (nodeType !== 1 && nodeType !== 9 && nodeType !== 11)) {
					return results;
				}
				if (false) {
					setDocument(context);
					context = context || document$1;
					if (documentIsHTML) {
						if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
							if ((m = match[1])) {
								if (nodeType === 9) {
									if ((elem = context.getElementById(m))) {
										push.call(results, elem);
									}
									return results;
								} else {
									if (newContext && (elem = newContext.getElementById(m)) && jQuery.contains(context, elem)) {
										push.call(results, elem);
										return results;
									}
								}
							} else if (match[2]) {
								push.apply(results, context.getElementsByTagName(selector));
								return results;
							} else if ((m = match[3]) && context.getElementsByClassName) {
								push.apply(results, context.getElementsByClassName(m));
								return results;
							}
						}
						if (!nonnativeSelectorCache[selector + ' '] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
							newSelector = selector;
							newContext = context;
							if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {
								newContext = (rsibling.test(selector) && testContext(context.parentNode)) || context;
								if (newContext != context || isIE) {
									if ((nid = context.getAttribute('id'))) {
										nid = jQuery.escapeSelector(nid);
									} else {
										context.setAttribute('id', (nid = jQuery.expando));
									}
								}
								groups = tokenize(selector);
								i2 = groups.length;
								while (i2--) {
									groups[i2] = (nid ? '#' + nid : ':scope') + ' ' + toSelector(groups[i2]);
								}
								newSelector = groups.join(',');
							}
							try {
								push.apply(results, newContext.querySelectorAll(newSelector));
								return results;
							} catch (qsaError) {
								nonnativeSelectorCache(selector, true);
							} finally {
								if (nid === jQuery.expando) {
									context.removeAttribute('id');
								}
							}
						}
					}
				}
				return select(selector.replace(rtrimCSS, '$1'), context, results, seed);
			}
			function markFunction(fn) {
				fn[jQuery.expando] = true;
				return fn;
			}
			function createInputPseudo(type) {
				return function (elem) {
					return nodeName(elem, 'input') && elem.type === type;
				};
			}
			function createButtonPseudo(type) {
				return function (elem) {
					return (nodeName(elem, 'input') || nodeName(elem, 'button')) && elem.type === type;
				};
			}
			function createDisabledPseudo(disabled) {
				return function (elem) {
					if ('form' in elem) {
						if (elem.parentNode && elem.disabled === false) {
							if ('label' in elem) {
								if ('label' in elem.parentNode) {
									return elem.parentNode.disabled === disabled;
								} else {
									return elem.disabled === disabled;
								}
							}
							return (
								elem.isDisabled === disabled || // Where there is no isDisabled, check manually
								(elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled)
							);
						}
						return elem.disabled === disabled;
					} else if ('label' in elem) {
						return elem.disabled === disabled;
					}
					return false;
				};
			}
			function createPositionalPseudo(fn) {
				return markFunction(function (argument) {
					argument = +argument;
					return markFunction(function (seed, matches3) {
						var j,
							matchIndexes = fn([], seed.length, argument),
							i2 = matchIndexes.length;
						while (i2--) {
							if (seed[(j = matchIndexes[i2])]) {
								seed[j] = !(matches3[j] = seed[j]);
							}
						}
					});
				});
			}
			function setDocument(node) {
				var subWindow,
					doc = node ? node.ownerDocument || node : document2;
				if (doc == document$1 || doc.nodeType !== 9) {
					return;
				}
				document$1 = doc;
				documentElement$1 = document$1.documentElement;
				documentIsHTML = !jQuery.isXMLDoc(document$1);
				if (isIE && document2 != document$1 && (subWindow = document$1.defaultView) && subWindow.top !== subWindow) {
					subWindow.addEventListener('unload', unloadHandler);
				}
			}
			find.matches = function (expr, elements) {
				return find(expr, null, null, elements);
			};
			find.matchesSelector = function (elem, expr) {
				setDocument(elem);
				if (documentIsHTML && !nonnativeSelectorCache[expr + ' '] && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
					try {
						return matches2.call(elem, expr);
					} catch (e) {
						nonnativeSelectorCache(expr, true);
					}
				}
				return find(expr, document$1, null, [elem]).length > 0;
			};
			jQuery.expr = {
				// Can be adjusted by the user
				cacheLength: 50,
				createPseudo: markFunction,
				match: matchExpr,
				find: {
					ID: function (id, context) {
						if (typeof context.getElementById !== 'undefined' && documentIsHTML) {
							var elem = context.getElementById(id);
							return elem ? [elem] : [];
						}
					},
					TAG: function (tag, context) {
						if (typeof context.getElementsByTagName !== 'undefined') {
							return context.getElementsByTagName(tag);
						} else {
							return context.querySelectorAll(tag);
						}
					},
					CLASS: function (className, context) {
						if (typeof context.getElementsByClassName !== 'undefined' && documentIsHTML) {
							return context.getElementsByClassName(className);
						}
					},
				},
				relative: {
					'>': { dir: 'parentNode', first: true },
					' ': { dir: 'parentNode' },
					'+': { dir: 'previousSibling', first: true },
					'~': { dir: 'previousSibling' },
				},
				preFilter,
				filter: {
					ID: function (id) {
						var attrId = unescapeSelector(id);
						return function (elem) {
							return elem.getAttribute('id') === attrId;
						};
					},
					TAG: function (nodeNameSelector) {
						var expectedNodeName = unescapeSelector(nodeNameSelector).toLowerCase();
						return nodeNameSelector === '*'
							? function () {
									return true;
								}
							: function (elem) {
									return nodeName(elem, expectedNodeName);
								};
					},
					CLASS: function (className) {
						var pattern = classCache[className + ' '];
						return (
							pattern ||
							((pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) &&
								classCache(className, function (elem) {
									return pattern.test(
										(typeof elem.className === 'string' && elem.className) ||
											(typeof elem.getAttribute !== 'undefined' && elem.getAttribute('class')) ||
											'',
									);
								}))
						);
					},
					ATTR: function (name, operator, check) {
						return function (elem) {
							var result = elem.getAttribute(name);
							if (result == null) {
								return operator === '!=';
							}
							if (!operator) {
								return true;
							}
							result += '';
							if (operator === '=') {
								return result === check;
							}
							if (operator === '!=') {
								return result !== check;
							}
							if (operator === '^=') {
								return check && result.indexOf(check) === 0;
							}
							if (operator === '*=') {
								return check && result.indexOf(check) > -1;
							}
							if (operator === '$=') {
								return check && result.slice(-check.length) === check;
							}
							if (operator === '~=') {
								return (' ' + result.replace(rwhitespace, ' ') + ' ').indexOf(check) > -1;
							}
							if (operator === '|=') {
								return result === check || result.slice(0, check.length + 1) === check + '-';
							}
							return false;
						};
					},
					CHILD: function (type, what, _argument, first, last) {
						var simple = type.slice(0, 3) !== 'nth',
							forward = type.slice(-4) !== 'last',
							ofType = what === 'of-type';
						return first === 1 && last === 0
							? // Shortcut for :nth-*(n)
								function (elem) {
									return !!elem.parentNode;
								}
							: function (elem, _context, xml) {
									var cache,
										outerCache,
										node,
										nodeIndex,
										start,
										dir = simple !== forward ? 'nextSibling' : 'previousSibling',
										parent = elem.parentNode,
										name = ofType && elem.nodeName.toLowerCase(),
										useCache = !xml && !ofType,
										diff = false;
									if (parent) {
										if (simple) {
											while (dir) {
												node = elem;
												while ((node = node[dir])) {
													if (ofType ? nodeName(node, name) : node.nodeType === 1) {
														return false;
													}
												}
												start = dir = type === 'only' && !start && 'nextSibling';
											}
											return true;
										}
										start = [forward ? parent.firstChild : parent.lastChild];
										if (forward && useCache) {
											outerCache = parent[jQuery.expando] || (parent[jQuery.expando] = {});
											cache = outerCache[type] || [];
											nodeIndex = cache[0] === dirruns && cache[1];
											diff = nodeIndex && cache[2];
											node = nodeIndex && parent.childNodes[nodeIndex];
											while (
												(node =
													(++nodeIndex && node && node[dir]) || // Fallback to seeking `elem` from the start
													(diff = nodeIndex = 0) ||
													start.pop())
											) {
												if (node.nodeType === 1 && ++diff && node === elem) {
													outerCache[type] = [dirruns, nodeIndex, diff];
													break;
												}
											}
										} else {
											if (useCache) {
												outerCache = elem[jQuery.expando] || (elem[jQuery.expando] = {});
												cache = outerCache[type] || [];
												nodeIndex = cache[0] === dirruns && cache[1];
												diff = nodeIndex;
											}
											if (diff === false) {
												while ((node = (++nodeIndex && node && node[dir]) || (diff = nodeIndex = 0) || start.pop())) {
													if ((ofType ? nodeName(node, name) : node.nodeType === 1) && ++diff) {
														if (useCache) {
															outerCache = node[jQuery.expando] || (node[jQuery.expando] = {});
															outerCache[type] = [dirruns, diff];
														}
														if (node === elem) {
															break;
														}
													}
												}
											}
										}
										diff -= last;
										return diff === first || (diff % first === 0 && diff / first >= 0);
									}
								};
					},
					PSEUDO: function (pseudo, argument) {
						var fn =
							jQuery.expr.pseudos[pseudo] ||
							jQuery.expr.setFilters[pseudo.toLowerCase()] ||
							selectorError('unsupported pseudo: ' + pseudo);
						if (fn[jQuery.expando]) {
							return fn(argument);
						}
						return fn;
					},
				},
				pseudos: {
					// Potentially complex pseudos
					not: markFunction(function (selector) {
						var input = [],
							results = [],
							matcher = compile(selector.replace(rtrimCSS, '$1'));
						return matcher[jQuery.expando]
							? markFunction(function (seed, matches3, _context, xml) {
									var elem,
										unmatched = matcher(seed, null, xml, []),
										i2 = seed.length;
									while (i2--) {
										if ((elem = unmatched[i2])) {
											seed[i2] = !(matches3[i2] = elem);
										}
									}
								})
							: function (elem, _context, xml) {
									input[0] = elem;
									matcher(input, null, xml, results);
									input[0] = null;
									return !results.pop();
								};
					}),
					has: markFunction(function (selector) {
						return function (elem) {
							return find(selector, elem).length > 0;
						};
					}),
					contains: markFunction(function (text) {
						text = unescapeSelector(text);
						return function (elem) {
							return (elem.textContent || jQuery.text(elem)).indexOf(text) > -1;
						};
					}),
					// "Whether an element is represented by a :lang() selector
					// is based solely on the element's language value
					// being equal to the identifier C,
					// or beginning with the identifier C immediately followed by "-".
					// The matching of C against the element's language value is performed case-insensitively.
					// The identifier C does not have to be a valid language name."
					// https://www.w3.org/TR/selectors/#lang-pseudo
					lang: markFunction(function (lang) {
						if (!ridentifier.test(lang || '')) {
							selectorError('unsupported lang: ' + lang);
						}
						lang = unescapeSelector(lang).toLowerCase();
						return function (elem) {
							var elemLang;
							do {
								if (
									(elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang'))
								) {
									elemLang = elemLang.toLowerCase();
									return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
								}
							} while ((elem = elem.parentNode) && elem.nodeType === 1);
							return false;
						};
					}),
					// Miscellaneous
					target: function (elem) {
						var hash = window2.location && window2.location.hash;
						return hash && hash.slice(1) === elem.id;
					},
					root: function (elem) {
						return elem === documentElement$1;
					},
					focus: function (elem) {
						return (
							elem === document$1.activeElement && document$1.hasFocus() && !!(elem.type || elem.href || ~elem.tabIndex)
						);
					},
					// Boolean properties
					enabled: createDisabledPseudo(false),
					disabled: createDisabledPseudo(true),
					checked: function (elem) {
						return (nodeName(elem, 'input') && !!elem.checked) || (nodeName(elem, 'option') && !!elem.selected);
					},
					selected: function (elem) {
						if (isIE && elem.parentNode) {
							elem.parentNode.selectedIndex;
						}
						return elem.selected === true;
					},
					// Contents
					empty: function (elem) {
						for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
							if (elem.nodeType < 6) {
								return false;
							}
						}
						return true;
					},
					parent: function (elem) {
						return !jQuery.expr.pseudos.empty(elem);
					},
					// Element/input types
					header: function (elem) {
						return rheader.test(elem.nodeName);
					},
					input: function (elem) {
						return rinputs.test(elem.nodeName);
					},
					button: function (elem) {
						return (nodeName(elem, 'input') && elem.type === 'button') || nodeName(elem, 'button');
					},
					text: function (elem) {
						return nodeName(elem, 'input') && elem.type === 'text';
					},
					// Position-in-collection
					first: createPositionalPseudo(function () {
						return [0];
					}),
					last: createPositionalPseudo(function (_matchIndexes, length) {
						return [length - 1];
					}),
					eq: createPositionalPseudo(function (_matchIndexes, length, argument) {
						return [argument < 0 ? argument + length : argument];
					}),
					even: createPositionalPseudo(function (matchIndexes, length) {
						var i2 = 0;
						for (; i2 < length; i2 += 2) {
							matchIndexes.push(i2);
						}
						return matchIndexes;
					}),
					odd: createPositionalPseudo(function (matchIndexes, length) {
						var i2 = 1;
						for (; i2 < length; i2 += 2) {
							matchIndexes.push(i2);
						}
						return matchIndexes;
					}),
					lt: createPositionalPseudo(function (matchIndexes, length, argument) {
						var i2;
						if (argument < 0) {
							i2 = argument + length;
						} else if (argument > length) {
							i2 = length;
						} else {
							i2 = argument;
						}
						for (; --i2 >= 0; ) {
							matchIndexes.push(i2);
						}
						return matchIndexes;
					}),
					gt: createPositionalPseudo(function (matchIndexes, length, argument) {
						var i2 = argument < 0 ? argument + length : argument;
						for (; ++i2 < length; ) {
							matchIndexes.push(i2);
						}
						return matchIndexes;
					}),
				},
			};
			jQuery.expr.pseudos.nth = jQuery.expr.pseudos.eq;
			for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
				jQuery.expr.pseudos[i] = createInputPseudo(i);
			}
			for (i in { submit: true, reset: true }) {
				jQuery.expr.pseudos[i] = createButtonPseudo(i);
			}
			function setFilters() {}
			setFilters.prototype = jQuery.expr.filters = jQuery.expr.pseudos;
			jQuery.expr.setFilters = new setFilters();
			function addCombinator(matcher, combinator, base) {
				var dir = combinator.dir,
					skip = combinator.next,
					key = skip || dir,
					checkNonElements = base && key === 'parentNode',
					doneName = done++;
				return combinator.first
					? // Check against closest ancestor/preceding element
						function (elem, context, xml) {
							while ((elem = elem[dir])) {
								if (elem.nodeType === 1 || checkNonElements) {
									return matcher(elem, context, xml);
								}
							}
							return false;
						}
					: // Check against all ancestor/preceding elements
						function (elem, context, xml) {
							var oldCache,
								outerCache,
								newCache = [dirruns, doneName];
							if (xml) {
								while ((elem = elem[dir])) {
									if (elem.nodeType === 1 || checkNonElements) {
										if (matcher(elem, context, xml)) {
											return true;
										}
									}
								}
							} else {
								while ((elem = elem[dir])) {
									if (elem.nodeType === 1 || checkNonElements) {
										outerCache = elem[jQuery.expando] || (elem[jQuery.expando] = {});
										if (skip && nodeName(elem, skip)) {
											elem = elem[dir] || elem;
										} else if ((oldCache = outerCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
											return (newCache[2] = oldCache[2]);
										} else {
											outerCache[key] = newCache;
											if ((newCache[2] = matcher(elem, context, xml))) {
												return true;
											}
										}
									}
								}
							}
							return false;
						};
			}
			function elementMatcher(matchers) {
				return matchers.length > 1
					? function (elem, context, xml) {
							var i2 = matchers.length;
							while (i2--) {
								if (!matchers[i2](elem, context, xml)) {
									return false;
								}
							}
							return true;
						}
					: matchers[0];
			}
			function multipleContexts(selector, contexts, results) {
				var i2 = 0,
					len = contexts.length;
				for (; i2 < len; i2++) {
					find(selector, contexts[i2], results);
				}
				return results;
			}
			function condense(unmatched, map2, filter, context, xml) {
				var elem,
					newUnmatched = [],
					i2 = 0,
					len = unmatched.length,
					mapped = map2 != null;
				for (; i2 < len; i2++) {
					if ((elem = unmatched[i2])) {
						if (!filter || filter(elem, context, xml)) {
							newUnmatched.push(elem);
							if (mapped) {
								map2.push(i2);
							}
						}
					}
				}
				return newUnmatched;
			}
			function setMatcher(preFilter2, selector, matcher, postFilter, postFinder, postSelector) {
				if (postFilter && !postFilter[jQuery.expando]) {
					postFilter = setMatcher(postFilter);
				}
				if (postFinder && !postFinder[jQuery.expando]) {
					postFinder = setMatcher(postFinder, postSelector);
				}
				return markFunction(function (seed, results, context, xml) {
					var temp,
						i2,
						elem,
						matcherOut,
						preMap = [],
						postMap = [],
						preexisting = results.length,
						elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []),
						matcherIn = preFilter2 && (seed || !selector) ? condense(elems, preMap, preFilter2, context, xml) : elems;
					if (matcher) {
						matcherOut =
							postFinder || (seed ? preFilter2 : preexisting || postFilter)
								? // ...intermediate processing is necessary
									[]
								: // ...otherwise use results directly
									results;
						matcher(matcherIn, matcherOut, context, xml);
					} else {
						matcherOut = matcherIn;
					}
					if (postFilter) {
						temp = condense(matcherOut, postMap);
						postFilter(temp, [], context, xml);
						i2 = temp.length;
						while (i2--) {
							if ((elem = temp[i2])) {
								matcherOut[postMap[i2]] = !(matcherIn[postMap[i2]] = elem);
							}
						}
					}
					if (seed) {
						if (postFinder || preFilter2) {
							if (postFinder) {
								temp = [];
								i2 = matcherOut.length;
								while (i2--) {
									if ((elem = matcherOut[i2])) {
										temp.push((matcherIn[i2] = elem));
									}
								}
								postFinder(null, (matcherOut = []), temp, xml);
							}
							i2 = matcherOut.length;
							while (i2--) {
								if ((elem = matcherOut[i2]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i2]) > -1) {
									seed[temp] = !(results[temp] = elem);
								}
							}
						}
					} else {
						matcherOut = condense(
							matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut,
						);
						if (postFinder) {
							postFinder(null, results, matcherOut, xml);
						} else {
							push.apply(results, matcherOut);
						}
					}
				});
			}
			function matcherFromTokens(tokens) {
				var checkContext,
					matcher,
					j,
					len = tokens.length,
					leadingRelative = jQuery.expr.relative[tokens[0].type],
					implicitRelative = leadingRelative || jQuery.expr.relative[' '],
					i2 = leadingRelative ? 1 : 0,
					matchContext = addCombinator(
						function (elem) {
							return elem === checkContext;
						},
						implicitRelative,
						true,
					),
					matchAnyContext = addCombinator(
						function (elem) {
							return indexOf.call(checkContext, elem) > -1;
						},
						implicitRelative,
						true,
					),
					matchers = [
						function (elem, context, xml) {
							var ret =
								(!leadingRelative && (xml || context != outermostContext)) ||
								((checkContext = context).nodeType
									? matchContext(elem, context, xml)
									: matchAnyContext(elem, context, xml));
							checkContext = null;
							return ret;
						},
					];
				for (; i2 < len; i2++) {
					if ((matcher = jQuery.expr.relative[tokens[i2].type])) {
						matchers = [addCombinator(elementMatcher(matchers), matcher)];
					} else {
						matcher = jQuery.expr.filter[tokens[i2].type].apply(null, tokens[i2].matches);
						if (matcher[jQuery.expando]) {
							j = ++i2;
							for (; j < len; j++) {
								if (jQuery.expr.relative[tokens[j].type]) {
									break;
								}
							}
							return setMatcher(
								i2 > 1 && elementMatcher(matchers),
								i2 > 1 &&
									toSelector(
										// If the preceding token was a descendant combinator, insert an implicit any-element `*`
										tokens.slice(0, i2 - 1).concat({ value: tokens[i2 - 2].type === ' ' ? '*' : '' }),
									).replace(rtrimCSS, '$1'),
								matcher,
								i2 < j && matcherFromTokens(tokens.slice(i2, j)),
								j < len && matcherFromTokens((tokens = tokens.slice(j))),
								j < len && toSelector(tokens),
							);
						}
						matchers.push(matcher);
					}
				}
				return elementMatcher(matchers);
			}
			function matcherFromGroupMatchers(elementMatchers, setMatchers) {
				var bySet = setMatchers.length > 0,
					byElement = elementMatchers.length > 0,
					superMatcher = function (seed, context, xml, results, outermost) {
						var elem,
							j,
							matcher,
							matchedCount = 0,
							i2 = '0',
							unmatched = seed && [],
							setMatched = [],
							contextBackup = outermostContext,
							elems = seed || (byElement && jQuery.expr.find.TAG('*', outermost)),
							dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1);
						if (outermost) {
							outermostContext = context == document$1 || context || outermost;
						}
						for (; (elem = elems[i2]) != null; i2++) {
							if (byElement && elem) {
								j = 0;
								if (!context && elem.ownerDocument != document$1) {
									setDocument(elem);
									xml = !documentIsHTML;
								}
								while ((matcher = elementMatchers[j++])) {
									if (matcher(elem, context || document$1, xml)) {
										push.call(results, elem);
										break;
									}
								}
								if (outermost) {
									dirruns = dirrunsUnique;
								}
							}
							if (bySet) {
								if ((elem = !matcher && elem)) {
									matchedCount--;
								}
								if (seed) {
									unmatched.push(elem);
								}
							}
						}
						matchedCount += i2;
						if (bySet && i2 !== matchedCount) {
							j = 0;
							while ((matcher = setMatchers[j++])) {
								matcher(unmatched, setMatched, context, xml);
							}
							if (seed) {
								if (matchedCount > 0) {
									while (i2--) {
										if (!(unmatched[i2] || setMatched[i2])) {
											setMatched[i2] = pop.call(results);
										}
									}
								}
								setMatched = condense(setMatched);
							}
							push.apply(results, setMatched);
							if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
								jQuery.uniqueSort(results);
							}
						}
						if (outermost) {
							dirruns = dirrunsUnique;
							outermostContext = contextBackup;
						}
						return unmatched;
					};
				return bySet ? markFunction(superMatcher) : superMatcher;
			}
			function compile(selector, match) {
				var i2,
					setMatchers = [],
					elementMatchers = [],
					cached = compilerCache[selector + ' '];
				if (!cached) {
					if (!match) {
						match = tokenize(selector);
					}
					i2 = match.length;
					while (i2--) {
						cached = matcherFromTokens(match[i2]);
						if (cached[jQuery.expando]) {
							setMatchers.push(cached);
						} else {
							elementMatchers.push(cached);
						}
					}
					cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
					cached.selector = selector;
				}
				return cached;
			}
			function select(selector, context, results, seed) {
				var i2,
					tokens,
					token,
					type,
					find2,
					compiled = typeof selector === 'function' && selector,
					match = !seed && tokenize((selector = compiled.selector || selector));
				results = results || [];
				if (match.length === 1) {
					tokens = match[0] = match[0].slice(0);
					if (
						tokens.length > 2 &&
						(token = tokens[0]).type === 'ID' &&
						context.nodeType === 9 &&
						documentIsHTML &&
						jQuery.expr.relative[tokens[1].type]
					) {
						context = (jQuery.expr.find.ID(unescapeSelector(token.matches[0]), context) || [])[0];
						if (!context) {
							return results;
						} else if (compiled) {
							context = context.parentNode;
						}
						selector = selector.slice(tokens.shift().value.length);
					}
					i2 = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
					while (i2--) {
						token = tokens[i2];
						if (jQuery.expr.relative[(type = token.type)]) {
							break;
						}
						if ((find2 = jQuery.expr.find[type])) {
							if (
								(seed = find2(
									unescapeSelector(token.matches[0]),
									(rsibling.test(tokens[0].type) && testContext(context.parentNode)) || context,
								))
							) {
								tokens.splice(i2, 1);
								selector = seed.length && toSelector(tokens);
								if (!selector) {
									push.apply(results, seed);
									return results;
								}
								break;
							}
						}
					}
				}
				(compiled || compile(selector, match))(
					seed,
					context,
					!documentIsHTML,
					results,
					!context || (rsibling.test(selector) && testContext(context.parentNode)) || context,
				);
				return results;
			}
			setDocument();
			jQuery.find = find;
			find.compile = compile;
			find.select = select;
			find.setDocument = setDocument;
			find.tokenize = tokenize;
			return jQuery;
		},
	);

// src/mock-doc/selector.ts
function matches(selector, elm) {
	try {
		const r = jquery_default.find(selector, void 0, void 0, [elm]);
		return r.length > 0;
	} catch (e) {
		updateSelectorError(selector, e);
		throw e;
	}
}
function selectOne(selector, elm) {
	try {
		const r = jquery_default.find(selector, elm, void 0, void 0);
		return r[0] || null;
	} catch (e) {
		updateSelectorError(selector, e);
		throw e;
	}
}
function selectAll(selector, elm) {
	try {
		return jquery_default.find(selector, elm, void 0, void 0);
	} catch (e) {
		updateSelectorError(selector, e);
		throw e;
	}
}
var PROBLEMATIC_SELECTORS = [':scope', ':where', ':is'];
function updateSelectorError(selector, e) {
	const selectorsPresent = PROBLEMATIC_SELECTORS.filter((s) => selector.includes(s));
	if (selectorsPresent.length > 0 && e.message) {
		e.message =
			`At present jQuery does not support the ${humanReadableList(selectorsPresent)} ${selectorsPresent.length === 1 ? 'selector' : 'selectors'}.
If you need this in your test, consider writing an end-to-end test instead.
` + e.message;
	}
}
function humanReadableList(items) {
	if (items.length <= 1) {
		return items.join('');
	}
	return `${items.slice(0, items.length - 1).join(', ')} and ${items[items.length - 1]}`;
}

// src/mock-doc/serialize-node.ts
function normalizeSerializationOptions(opts = {}) {
	return {
		...opts,
		outerHtml: typeof opts.outerHtml !== 'boolean' ? false : opts.outerHtml,
		...(opts.prettyHtml
			? {
					indentSpaces: typeof opts.indentSpaces !== 'number' ? 2 : opts.indentSpaces,
					newLines: typeof opts.newLines !== 'boolean' ? true : opts.newLines,
				}
			: {
					prettyHtml: false,
					indentSpaces: typeof opts.indentSpaces !== 'number' ? 0 : opts.indentSpaces,
					newLines: typeof opts.newLines !== 'boolean' ? false : opts.newLines,
				}),
		approximateLineWidth: typeof opts.approximateLineWidth !== 'number' ? -1 : opts.approximateLineWidth,
		removeEmptyAttributes: typeof opts.removeEmptyAttributes !== 'boolean' ? true : opts.removeEmptyAttributes,
		removeAttributeQuotes: typeof opts.removeAttributeQuotes !== 'boolean' ? false : opts.removeAttributeQuotes,
		removeBooleanAttributeQuotes:
			typeof opts.removeBooleanAttributeQuotes !== 'boolean' ? false : opts.removeBooleanAttributeQuotes,
		removeHtmlComments: typeof opts.removeHtmlComments !== 'boolean' ? false : opts.removeHtmlComments,
		serializeShadowRoot:
			typeof opts.serializeShadowRoot === 'undefined' ? 'declarative-shadow-dom' : opts.serializeShadowRoot,
		fullDocument: typeof opts.fullDocument !== 'boolean' ? true : opts.fullDocument,
	};
}
function serializeNodeToHtml(elm, serializationOptions = {}) {
	const opts = normalizeSerializationOptions(serializationOptions);
	const output = {
		currentLineWidth: 0,
		indent: 0,
		isWithinBody: false,
		text: [],
	};
	let renderedNode = '';
	const children =
		!opts.fullDocument && elm.body
			? Array.from(elm.body.childNodes)
			: opts.outerHtml
				? [elm]
				: Array.from(getChildNodes(elm));
	for (let i = 0, ii = children.length; i < ii; i++) {
		const child = children[i];
		const chunks = Array.from(streamToHtml(child, opts, output));
		renderedNode += chunks.join('');
	}
	return renderedNode.trim();
}
var shadowRootTag = 'mock:shadow-root';
function* streamToHtml(node, opts, output) {
	var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
	const isShadowRoot = node.nodeType === 11; /* DOCUMENT_FRAGMENT_NODE */
	if (node.nodeType === 1 /* ELEMENT_NODE */ || isShadowRoot) {
		const tagName = isShadowRoot ? shadowRootTag : getTagName(node);
		if (tagName === 'body') {
			output.isWithinBody = true;
		}
		const ignoreTag = opts.excludeTags != null && opts.excludeTags.includes(tagName);
		if (ignoreTag === false) {
			const isWithinWhitespaceSensitiveNode =
				opts.newLines || ((_a2 = opts.indentSpaces) != null ? _a2 : 0) > 0 ? isWithinWhitespaceSensitive(node) : false;
			if (opts.newLines && !isWithinWhitespaceSensitiveNode) {
				yield '\n';
				output.currentLineWidth = 0;
			}
			if (((_b = opts.indentSpaces) != null ? _b : 0) > 0 && !isWithinWhitespaceSensitiveNode) {
				for (let i = 0; i < output.indent; i++) {
					yield ' ';
				}
				output.currentLineWidth += output.indent;
			}
			const tag = tagName === shadowRootTag ? 'template' : tagName;
			yield '<' + tag;
			output.currentLineWidth += tag.length + 1;
			if (
				tag === 'template' &&
				(!node.getAttribute || !node.getAttribute('shadowrootmode')) /**
				 * If the node is a shadow root, we want to add the `shadowrootmode` attribute
				 */ &&
				('host' in node || node.nodeName.toLocaleLowerCase() === shadowRootTag)
			) {
				const mode = ` shadowrootmode="open"`;
				yield mode;
				output.currentLineWidth += mode.length;
			}
			const attrsLength = node.attributes.length;
			const attributes = opts.prettyHtml && attrsLength > 1 ? cloneAttributes(node.attributes, true) : node.attributes;
			for (let i = 0; i < attrsLength; i++) {
				const attr = attributes.item(i);
				const attrName = attr.name;
				if (attrName === 'style') {
					continue;
				}
				let attrValue = attr.value;
				if (opts.removeEmptyAttributes && attrValue === '' && REMOVE_EMPTY_ATTR.has(attrName)) {
					continue;
				}
				const attrNamespaceURI = attr.namespaceURI;
				if (attrNamespaceURI == null) {
					output.currentLineWidth += attrName.length + 1;
					if (
						opts.approximateLineWidth &&
						opts.approximateLineWidth > 0 &&
						output.currentLineWidth > opts.approximateLineWidth
					) {
						yield '\n' + attrName;
						output.currentLineWidth = 0;
					} else {
						yield ' ' + attrName;
					}
				} else if (attrNamespaceURI === 'http://www.w3.org/XML/1998/namespace') {
					yield ' xml:' + attrName;
					output.currentLineWidth += attrName.length + 5;
				} else if (attrNamespaceURI === 'http://www.w3.org/2000/xmlns/') {
					if (attrName !== 'xmlns') {
						yield ' xmlns:' + attrName;
						output.currentLineWidth += attrName.length + 7;
					} else {
						yield ' ' + attrName;
						output.currentLineWidth += attrName.length + 1;
					}
				} else if (attrNamespaceURI === XLINK_NS) {
					yield ' xlink:' + attrName;
					output.currentLineWidth += attrName.length + 7;
				} else {
					yield ' ' + attrNamespaceURI + ':' + attrName;
					output.currentLineWidth += attrNamespaceURI.length + attrName.length + 2;
				}
				if (opts.prettyHtml && attrName === 'class') {
					attrValue = attr.value = attrValue
						.split(' ')
						.filter((t) => t !== '')
						.sort()
						.join(' ')
						.trim();
				}
				if (attrValue === '') {
					if (opts.removeBooleanAttributeQuotes && BOOLEAN_ATTR.has(attrName)) {
						continue;
					}
					if (opts.removeEmptyAttributes && attrName.startsWith('data-')) {
						continue;
					}
				}
				if (opts.removeAttributeQuotes && CAN_REMOVE_ATTR_QUOTES.test(attrValue)) {
					yield '=' + escapeString(attrValue, true);
					output.currentLineWidth += attrValue.length + 1;
				} else {
					yield '="' + escapeString(attrValue, true) + '"';
					output.currentLineWidth += attrValue.length + 3;
				}
			}
			if (node.hasAttribute('style')) {
				const cssText = node.style.cssText;
				if (
					opts.approximateLineWidth &&
					opts.approximateLineWidth > 0 &&
					output.currentLineWidth + cssText.length + 10 > opts.approximateLineWidth
				) {
					yield `
style="${cssText}">`;
					output.currentLineWidth = 0;
				} else {
					yield ` style="${cssText}">`;
					output.currentLineWidth += cssText.length + 10;
				}
			} else {
				yield '>';
				output.currentLineWidth += 1;
			}
		}
		if (EMPTY_ELEMENTS.has(tagName) === false) {
			const shadowRoot = node.shadowRoot;
			if (shadowRoot != null && opts.serializeShadowRoot !== false) {
				output.indent = output.indent + ((_c = opts.indentSpaces) != null ? _c : 0);
				yield* streamToHtml(shadowRoot, opts, output);
				output.indent = output.indent - ((_d = opts.indentSpaces) != null ? _d : 0);
				const childNodes = getChildNodes(node);
				if (
					opts.newLines &&
					(childNodes.length === 0 ||
						(childNodes.length === 1 &&
							childNodes[0].nodeType === 3 /* TEXT_NODE */ &&
							((_e = childNodes[0].nodeValue) == null ? void 0 : _e.trim()) === ''))
				) {
					yield '\n';
					output.currentLineWidth = 0;
					for (let i = 0; i < output.indent; i++) {
						yield ' ';
					}
					output.currentLineWidth += output.indent;
				}
			}
			if (opts.excludeTagContent == null || opts.excludeTagContent.includes(tagName) === false) {
				const tag = tagName === shadowRootTag ? 'template' : tagName;
				const childNodes = tagName === 'template' ? node.content.childNodes : getChildNodes(node);
				const childNodeLength = childNodes.length;
				if (childNodeLength > 0) {
					if (
						childNodeLength === 1 &&
						childNodes[0].nodeType === 3 /* TEXT_NODE */ &&
						(typeof childNodes[0].nodeValue !== 'string' || childNodes[0].nodeValue.trim() === '')
					) {
					} else {
						const isWithinWhitespaceSensitiveNode =
							opts.newLines || ((_f = opts.indentSpaces) != null ? _f : 0) > 0
								? isWithinWhitespaceSensitive(node)
								: false;
						if (
							!isWithinWhitespaceSensitiveNode &&
							((_g = opts.indentSpaces) != null ? _g : 0) > 0 &&
							ignoreTag === false
						) {
							output.indent = output.indent + ((_h = opts.indentSpaces) != null ? _h : 0);
						}
						for (let i = 0; i < childNodeLength; i++) {
							const sId = node.attributes.getNamedItem(HYDRATE_ID);
							const isStencilDeclarativeShadowDOM = childNodes[i].nodeName.toLowerCase() === 'template' && sId;
							if (isStencilDeclarativeShadowDOM) {
								yield `
${' '.repeat(output.indent)}<!--r.${sId.value}-->`;
								continue;
							}
							yield* streamToHtml(childNodes[i], opts, output);
						}
						if (ignoreTag === false) {
							if (opts.newLines && !isWithinWhitespaceSensitiveNode) {
								yield '\n';
								output.currentLineWidth = 0;
							}
							if (((_i = opts.indentSpaces) != null ? _i : 0) > 0 && !isWithinWhitespaceSensitiveNode) {
								output.indent = output.indent - ((_j = opts.indentSpaces) != null ? _j : 0);
								for (let i = 0; i < output.indent; i++) {
									yield ' ';
								}
								output.currentLineWidth += output.indent;
							}
						}
					}
				}
				if (ignoreTag === false) {
					yield '</' + tag + '>';
					output.currentLineWidth += tag.length + 3;
				}
			}
		}
		if (((_k = opts.approximateLineWidth) != null ? _k : 0) > 0 && STRUCTURE_ELEMENTS.has(tagName)) {
			yield '\n';
			output.currentLineWidth = 0;
		}
		if (tagName === 'body') {
			output.isWithinBody = false;
		}
	} else if (node.nodeType === 3 /* TEXT_NODE */) {
		let textContent = node.nodeValue;
		if (typeof textContent === 'string') {
			const trimmedTextContent = textContent.trim();
			if (trimmedTextContent === '') {
				if (isWithinWhitespaceSensitive(node)) {
					yield textContent;
					output.currentLineWidth += textContent.length;
				} else if (((_l = opts.approximateLineWidth) != null ? _l : 0) > 0 && !output.isWithinBody) {
				} else if (!opts.prettyHtml) {
					output.currentLineWidth += 1;
					if (
						opts.approximateLineWidth &&
						opts.approximateLineWidth > 0 &&
						output.currentLineWidth > opts.approximateLineWidth
					) {
						yield '\n';
						output.currentLineWidth = 0;
					} else {
						yield ' ';
					}
				}
			} else {
				const isWithinWhitespaceSensitiveNode =
					opts.newLines || ((_m = opts.indentSpaces) != null ? _m : 0) > 0 || opts.prettyHtml
						? isWithinWhitespaceSensitive(node)
						: false;
				if (opts.newLines && !isWithinWhitespaceSensitiveNode) {
					yield '\n';
					output.currentLineWidth = 0;
				}
				if (((_n = opts.indentSpaces) != null ? _n : 0) > 0 && !isWithinWhitespaceSensitiveNode) {
					for (let i = 0; i < output.indent; i++) {
						yield ' ';
					}
					output.currentLineWidth += output.indent;
				}
				let textContentLength = textContent.length;
				if (textContentLength > 0) {
					const parentTagName =
						node.parentNode != null && node.parentNode.nodeType === 1 /* ELEMENT_NODE */
							? node.parentNode.nodeName
							: null;
					if (typeof parentTagName === 'string' && NON_ESCAPABLE_CONTENT.has(parentTagName)) {
						if (isWithinWhitespaceSensitive(node)) {
							yield textContent;
						} else {
							yield trimmedTextContent;
							textContentLength = trimmedTextContent.length;
						}
						output.currentLineWidth += textContentLength;
					} else {
						if (opts.prettyHtml && !isWithinWhitespaceSensitiveNode) {
							yield escapeString(textContent.replace(/\s\s+/g, ' ').trim(), false);
							output.currentLineWidth += textContentLength;
						} else {
							if (isWithinWhitespaceSensitive(node)) {
								output.currentLineWidth += textContentLength;
							} else {
								if (/\s/.test(textContent.charAt(0))) {
									textContent = ' ' + textContent.trimLeft();
								}
								textContentLength = textContent.length;
								if (textContentLength > 1) {
									if (/\s/.test(textContent.charAt(textContentLength - 1))) {
										if (
											opts.approximateLineWidth &&
											opts.approximateLineWidth > 0 &&
											output.currentLineWidth + textContentLength > opts.approximateLineWidth
										) {
											textContent = textContent.trimRight() + '\n';
											output.currentLineWidth = 0;
										} else {
											textContent = textContent.trimRight() + ' ';
										}
									}
								}
								output.currentLineWidth += textContentLength;
							}
							yield escapeString(textContent, false);
						}
					}
				}
			}
		}
	} else if (node.nodeType === 8 /* COMMENT_NODE */) {
		const nodeValue = node.nodeValue;
		const isHydrateAnnotation =
			(nodeValue == null ? void 0 : nodeValue.startsWith(CONTENT_REF_ID + '.')) ||
			(nodeValue == null ? void 0 : nodeValue.startsWith(ORG_LOCATION_ID + '.')) ||
			(nodeValue == null ? void 0 : nodeValue.startsWith(SLOT_NODE_ID + '.')) ||
			(nodeValue == null ? void 0 : nodeValue.startsWith(TEXT_NODE_ID + '.'));
		if (opts.removeHtmlComments && !isHydrateAnnotation) {
			return;
		}
		const isWithinWhitespaceSensitiveNode =
			opts.newLines || ((_o = opts.indentSpaces) != null ? _o : 0) > 0 ? isWithinWhitespaceSensitive(node) : false;
		if (opts.newLines && !isWithinWhitespaceSensitiveNode) {
			yield '\n';
			output.currentLineWidth = 0;
		}
		if (((_p = opts.indentSpaces) != null ? _p : 0) > 0 && !isWithinWhitespaceSensitiveNode) {
			for (let i = 0; i < output.indent; i++) {
				yield ' ';
			}
			output.currentLineWidth += output.indent;
		}
		yield '<!--' + nodeValue + '-->';
		if (nodeValue) {
			output.currentLineWidth += nodeValue.length + 7;
		}
	} else if (node.nodeType === 10 /* DOCUMENT_TYPE_NODE */) {
		yield '<!doctype html>';
	}
}
var AMP_REGEX = /&/g;
var NBSP_REGEX = /\u00a0/g;
var DOUBLE_QUOTE_REGEX = /"/g;
var LT_REGEX = /</g;
var GT_REGEX = />/g;
var CAN_REMOVE_ATTR_QUOTES = /^[^ \t\n\f\r"'`=<>\/\\-]+$/;
function getTagName(element) {
	if (element.namespaceURI === 'http://www.w3.org/1999/xhtml') {
		return element.nodeName.toLowerCase();
	} else {
		return element.nodeName;
	}
}
function escapeString(str, attrMode) {
	str = str.replace(AMP_REGEX, '&amp;').replace(NBSP_REGEX, '&nbsp;');
	if (attrMode) {
		return str.replace(DOUBLE_QUOTE_REGEX, '&quot;');
	}
	return str.replace(LT_REGEX, '&lt;').replace(GT_REGEX, '&gt;');
}
function isWithinWhitespaceSensitive(node) {
	let _node = node;
	while (_node == null ? void 0 : _node.nodeName) {
		if (WHITESPACE_SENSITIVE.has(_node.nodeName)) {
			return true;
		}
		_node = _node.parentNode;
	}
	return false;
}
function getChildNodes(node) {
	return node.__childNodes || node.childNodes;
}
var NON_ESCAPABLE_CONTENT = /* @__PURE__ */ new Set([
	'STYLE',
	'SCRIPT',
	'IFRAME',
	'NOSCRIPT',
	'XMP',
	'NOEMBED',
	'NOFRAMES',
	'PLAINTEXT',
]);
var WHITESPACE_SENSITIVE = /* @__PURE__ */ new Set([
	'CODE',
	'OUTPUT',
	'PLAINTEXT',
	'PRE',
	'SCRIPT',
	'TEMPLATE',
	'TEXTAREA',
]);
var EMPTY_ELEMENTS = /* @__PURE__ */ new Set([
	'area',
	'base',
	'basefont',
	'bgsound',
	'br',
	'col',
	'embed',
	'frame',
	'hr',
	'img',
	'input',
	'keygen',
	'link',
	'meta',
	'param',
	'source',
	'trace',
	'track',
	'wbr',
]);
var REMOVE_EMPTY_ATTR = /* @__PURE__ */ new Set(['class', 'dir', 'id', 'lang', 'name', 'title']);
var BOOLEAN_ATTR = /* @__PURE__ */ new Set([
	'allowfullscreen',
	'async',
	'autofocus',
	'autoplay',
	'checked',
	'compact',
	'controls',
	'declare',
	'default',
	'defaultchecked',
	'defaultmuted',
	'defaultselected',
	'defer',
	'disabled',
	'enabled',
	'formnovalidate',
	'hidden',
	'indeterminate',
	'inert',
	'ismap',
	'itemscope',
	'loop',
	'multiple',
	'muted',
	'nohref',
	'nomodule',
	'noresize',
	'noshade',
	'novalidate',
	'nowrap',
	'open',
	'pauseonexit',
	'readonly',
	'required',
	'reversed',
	'scoped',
	'seamless',
	'selected',
	'sortable',
	'truespeed',
	'typemustmatch',
	'visible',
]);
var STRUCTURE_ELEMENTS = /* @__PURE__ */ new Set([
	'html',
	'body',
	'head',
	'iframe',
	'meta',
	'link',
	'base',
	'title',
	'script',
	'style',
]);

// src/mock-doc/node.ts
var MockNode2 = class {
	constructor(ownerDocument, nodeType, nodeName, nodeValue) {
		this.ownerDocument = ownerDocument;
		this.nodeType = nodeType;
		this.nodeName = nodeName;
		this._nodeValue = nodeValue;
		this.parentNode = null;
		this.childNodes = [];
	}
	appendChild(newNode) {
		if (newNode.nodeType === 11 /* DOCUMENT_FRAGMENT_NODE */) {
			const nodes = newNode.childNodes.slice();
			for (const child of nodes) {
				this.appendChild(child);
			}
		} else {
			newNode.remove();
			newNode.parentNode = this;
			this.childNodes.push(newNode);
			connectNode(this.ownerDocument, newNode);
		}
		return newNode;
	}
	append(...items) {
		items.forEach((item) => {
			const isNode = typeof item === 'object' && item !== null && 'nodeType' in item;
			this.appendChild(isNode ? item : this.ownerDocument.createTextNode(String(item)));
		});
	}
	prepend(...items) {
		const firstChild = this.firstChild;
		items.forEach((item) => {
			const isNode = typeof item === 'object' && item !== null && 'nodeType' in item;
			if (firstChild) {
				this.insertBefore(isNode ? item : this.ownerDocument.createTextNode(String(item)), firstChild);
			}
		});
	}
	cloneNode(deep) {
		throw new Error(`invalid node type to clone: ${this.nodeType}, deep: ${deep}`);
	}
	compareDocumentPosition(_other) {
		return -1;
	}
	get firstChild() {
		return this.childNodes[0] || null;
	}
	insertBefore(newNode, referenceNode) {
		if (newNode.nodeType === 11 /* DOCUMENT_FRAGMENT_NODE */) {
			for (let i = 0, ii = newNode.childNodes.length; i < ii; i++) {
				insertBefore(this, newNode.childNodes[i], referenceNode);
			}
		} else {
			insertBefore(this, newNode, referenceNode);
		}
		return newNode;
	}
	get isConnected() {
		let node = this;
		while (node != null) {
			if (node.nodeType === 9 /* DOCUMENT_NODE */) {
				return true;
			}
			node = node.parentNode;
			if (node != null && node.nodeType === 11 /* DOCUMENT_FRAGMENT_NODE */) {
				node = node.host;
			}
		}
		return false;
	}
	isSameNode(node) {
		return this === node;
	}
	get lastChild() {
		return this.childNodes[this.childNodes.length - 1] || null;
	}
	get nextSibling() {
		if (this.parentNode != null) {
			const index = this.parentNode.childNodes.indexOf(this) + 1;
			return this.parentNode.childNodes[index] || null;
		}
		return null;
	}
	get nodeValue() {
		var _a2;
		return (_a2 = this._nodeValue) != null ? _a2 : '';
	}
	set nodeValue(value) {
		this._nodeValue = value;
	}
	get parentElement() {
		return this.parentNode || null;
	}
	set parentElement(value) {
		this.parentNode = value;
	}
	get previousSibling() {
		if (this.parentNode != null) {
			const index = this.parentNode.childNodes.indexOf(this) - 1;
			return this.parentNode.childNodes[index] || null;
		}
		return null;
	}
	contains(otherNode) {
		if (otherNode === this) {
			return true;
		}
		const childNodes = Array.from(this.childNodes);
		if (childNodes.includes(otherNode)) {
			return true;
		}
		return childNodes.some((node) => this.contains.bind(node)(otherNode));
	}
	removeChild(childNode) {
		const index = this.childNodes.indexOf(childNode);
		if (index > -1) {
			this.childNodes.splice(index, 1);
			if (this.nodeType === 1 /* ELEMENT_NODE */) {
				const wasConnected = this.isConnected;
				childNode.parentNode = null;
				if (wasConnected === true) {
					disconnectNode(childNode);
				}
			} else {
				childNode.parentNode = null;
			}
		} else {
			throw new Error(`node not found within childNodes during removeChild`);
		}
		return childNode;
	}
	remove() {
		if (this.parentNode != null) {
			this.__parentNode ? this.__parentNode.removeChild(this) : this.parentNode.removeChild(this);
		}
	}
	replaceChild(newChild, oldChild) {
		if (oldChild.parentNode === this) {
			this.insertBefore(newChild, oldChild);
			oldChild.remove();
			return newChild;
		}
		return null;
	}
	get textContent() {
		var _a2;
		return (_a2 = this._nodeValue) != null ? _a2 : '';
	}
	set textContent(value) {
		this._nodeValue = String(value);
	}
};
MockNode2.ELEMENT_NODE = 1;
MockNode2.TEXT_NODE = 3;
MockNode2.PROCESSING_INSTRUCTION_NODE = 7;
MockNode2.COMMENT_NODE = 8;
MockNode2.DOCUMENT_NODE = 9;
MockNode2.DOCUMENT_TYPE_NODE = 10;
MockNode2.DOCUMENT_FRAGMENT_NODE = 11;
var MockNodeList = class {
	constructor(ownerDocument, childNodes, length) {
		this.ownerDocument = ownerDocument;
		this.childNodes = childNodes;
		this.length = length;
	}
};
var MockElement = class extends MockNode2 {
	attachInternals() {
		return new Proxy(
			{},
			{
				get: function (_target, prop, _receiver) {
					if ('process' in globalThis && globalThis.process.env.__STENCIL_SPEC_TESTS__) {
						console.error(
							`NOTE: Property ${String(prop)} was accessed on ElementInternals, but this property is not implemented.
  Testing components with ElementInternals is fully supported in e2e tests.`,
						);
					}
				},
			},
		);
	}
	constructor(ownerDocument, nodeName, namespaceURI = null) {
		super(ownerDocument, 1 /* ELEMENT_NODE */, typeof nodeName === 'string' ? nodeName : null, null);
		this.__namespaceURI = namespaceURI;
		this.__shadowRoot = null;
		this.__attributeMap = null;
	}
	addEventListener(type, handler) {
		addEventListener(this, type, handler);
	}
	attachShadow(_opts) {
		const shadowRoot = this.ownerDocument.createDocumentFragment();
		this.shadowRoot = shadowRoot;
		return shadowRoot;
	}
	blur() {
		dispatchEvent(
			this,
			new MockFocusEvent('blur', { relatedTarget: null, bubbles: true, cancelable: true, composed: true }),
		);
	}
	get localName() {
		if (!this.nodeName) {
			throw new Error(`Can't compute elements localName without nodeName`);
		}
		return this.nodeName.toLocaleLowerCase();
	}
	get namespaceURI() {
		return this.__namespaceURI;
	}
	get shadowRoot() {
		return this.__shadowRoot || null;
	}
	/**
	 * Set shadow root for element
	 * @param shadowRoot - ShadowRoot to set
	 */
	set shadowRoot(shadowRoot) {
		if (shadowRoot != null) {
			shadowRoot.host = this;
			this.__shadowRoot = shadowRoot;
		} else {
			delete this.__shadowRoot;
		}
	}
	get attributes() {
		if (this.__attributeMap == null) {
			const attrMap = createAttributeProxy(false);
			this.__attributeMap = attrMap;
			return attrMap;
		}
		return this.__attributeMap;
	}
	set attributes(attrs) {
		this.__attributeMap = attrs;
	}
	get children() {
		return this.childNodes.filter((n) => n.nodeType === 1 /* ELEMENT_NODE */);
	}
	get childElementCount() {
		return this.childNodes.filter((n) => n.nodeType === 1 /* ELEMENT_NODE */).length;
	}
	get className() {
		return this.getAttributeNS(null, 'class') || '';
	}
	set className(value) {
		this.setAttributeNS(null, 'class', value);
	}
	get classList() {
		return new MockClassList(this);
	}
	click() {
		dispatchEvent(this, new MockEvent('click', { bubbles: true, cancelable: true, composed: true }));
	}
	cloneNode(_deep) {
		return null;
	}
	closest(selector) {
		let elm = this;
		while (elm != null) {
			if (elm.matches(selector)) {
				return elm;
			}
			elm = elm.parentNode;
		}
		return null;
	}
	get dataset() {
		return dataset(this);
	}
	get dir() {
		return this.getAttributeNS(null, 'dir') || '';
	}
	set dir(value) {
		this.setAttributeNS(null, 'dir', value);
	}
	dispatchEvent(ev) {
		return dispatchEvent(this, ev);
	}
	get firstElementChild() {
		return this.children[0] || null;
	}
	focus(_options) {
		dispatchEvent(
			this,
			new MockFocusEvent('focus', { relatedTarget: null, bubbles: true, cancelable: true, composed: true }),
		);
	}
	getAttribute(attrName) {
		if (attrName === 'style') {
			if (this.__style != null && this.__style.length > 0) {
				return this.style.cssText;
			}
			return null;
		}
		const attr = this.attributes.getNamedItem(attrName);
		if (attr != null) {
			return attr.value;
		}
		return null;
	}
	getAttributeNS(namespaceURI, attrName) {
		const attr = this.attributes.getNamedItemNS(namespaceURI, attrName);
		if (attr != null) {
			return attr.value;
		}
		return null;
	}
	getAttributeNode(attrName) {
		if (!this.hasAttribute(attrName)) {
			return null;
		}
		return new MockAttr(attrName, this.getAttribute(attrName));
	}
	getBoundingClientRect() {
		return { bottom: 0, height: 0, left: 0, right: 0, top: 0, width: 0, x: 0, y: 0 };
	}
	getRootNode(opts) {
		const isComposed = opts != null && opts.composed === true;
		let node = this;
		while (node.parentNode != null) {
			node = node.parentNode;
			if (isComposed === true && node.parentNode == null && node.host != null) {
				node = node.host;
			}
		}
		return node;
	}
	get draggable() {
		return this.getAttributeNS(null, 'draggable') === 'true';
	}
	set draggable(value) {
		this.setAttributeNS(null, 'draggable', value);
	}
	hasChildNodes() {
		return this.childNodes.length > 0;
	}
	get id() {
		return this.getAttributeNS(null, 'id') || '';
	}
	set id(value) {
		this.setAttributeNS(null, 'id', value);
	}
	get innerHTML() {
		if (this.childNodes.length === 0) {
			return '';
		}
		return serializeNodeToHtml(this, {
			newLines: false,
			indentSpaces: 0,
		});
	}
	set innerHTML(html) {
		var _a2;
		if (NON_ESCAPABLE_CONTENT.has((_a2 = this.nodeName) != null ? _a2 : '') === true) {
			setTextContent(this, html);
		} else {
			for (let i = this.childNodes.length - 1; i >= 0; i--) {
				this.removeChild(this.childNodes[i]);
			}
			if (typeof html === 'string') {
				const frag = parseFragmentUtil(this.ownerDocument, html);
				while (frag.childNodes.length > 0) {
					this.appendChild(frag.childNodes[0]);
				}
			}
		}
	}
	get innerText() {
		const text = [];
		getTextContent(this.childNodes, text);
		return text.join('');
	}
	set innerText(value) {
		setTextContent(this, value);
	}
	insertAdjacentElement(position, elm) {
		if (position === 'beforebegin' && this.parentNode) {
			insertBefore(this.parentNode, elm, this);
		} else if (position === 'afterbegin') {
			this.prepend(elm);
		} else if (position === 'beforeend') {
			this.appendChild(elm);
		} else if (position === 'afterend' && this.parentNode) {
			insertBefore(this.parentNode, elm, this.nextSibling);
		}
		return elm;
	}
	insertAdjacentHTML(position, html) {
		const frag = parseFragmentUtil(this.ownerDocument, html);
		if (position === 'beforebegin') {
			while (frag.childNodes.length > 0) {
				if (this.parentNode) {
					insertBefore(this.parentNode, frag.childNodes[0], this);
				}
			}
		} else if (position === 'afterbegin') {
			while (frag.childNodes.length > 0) {
				this.prepend(frag.childNodes[frag.childNodes.length - 1]);
			}
		} else if (position === 'beforeend') {
			while (frag.childNodes.length > 0) {
				this.appendChild(frag.childNodes[0]);
			}
		} else if (position === 'afterend') {
			while (frag.childNodes.length > 0) {
				if (this.parentNode) {
					insertBefore(this.parentNode, frag.childNodes[frag.childNodes.length - 1], this.nextSibling);
				}
			}
		}
	}
	insertAdjacentText(position, text) {
		const elm = this.ownerDocument.createTextNode(text);
		if (position === 'beforebegin' && this.parentNode) {
			insertBefore(this.parentNode, elm, this);
		} else if (position === 'afterbegin') {
			this.prepend(elm);
		} else if (position === 'beforeend') {
			this.appendChild(elm);
		} else if (position === 'afterend' && this.parentNode) {
			insertBefore(this.parentNode, elm, this.nextSibling);
		}
	}
	hasAttribute(attrName) {
		if (attrName === 'style') {
			return this.__style != null && this.__style.length > 0;
		}
		return this.getAttribute(attrName) !== null;
	}
	hasAttributeNS(namespaceURI, name) {
		return this.getAttributeNS(namespaceURI, name) !== null;
	}
	get hidden() {
		return this.hasAttributeNS(null, 'hidden');
	}
	set hidden(isHidden) {
		if (isHidden === true) {
			this.setAttributeNS(null, 'hidden', '');
		} else {
			this.removeAttributeNS(null, 'hidden');
		}
	}
	get lang() {
		return this.getAttributeNS(null, 'lang') || '';
	}
	set lang(value) {
		this.setAttributeNS(null, 'lang', value);
	}
	get lastElementChild() {
		const children = this.children;
		return children[children.length - 1] || null;
	}
	matches(selector) {
		return matches(selector, this);
	}
	get nextElementSibling() {
		const parentElement = this.parentElement;
		if (
			parentElement != null &&
			(parentElement.nodeType === 1 /* ELEMENT_NODE */ ||
				parentElement.nodeType === 11 /* DOCUMENT_FRAGMENT_NODE */ ||
				parentElement.nodeType === 9) /* DOCUMENT_NODE */
		) {
			const children = parentElement.children;
			const index = children.indexOf(this) + 1;
			return parentElement.children[index] || null;
		}
		return null;
	}
	get outerHTML() {
		return serializeNodeToHtml(this, {
			newLines: false,
			outerHtml: true,
			indentSpaces: 0,
		});
	}
	get previousElementSibling() {
		const parentElement = this.parentElement;
		if (
			parentElement != null &&
			(parentElement.nodeType === 1 /* ELEMENT_NODE */ ||
				parentElement.nodeType === 11 /* DOCUMENT_FRAGMENT_NODE */ ||
				parentElement.nodeType === 9) /* DOCUMENT_NODE */
		) {
			const children = parentElement.children;
			const index = children.indexOf(this) - 1;
			return parentElement.children[index] || null;
		}
		return null;
	}
	getElementsByClassName(classNames) {
		const classes = classNames
			.trim()
			.split(' ')
			.filter((c) => c.length > 0);
		const results = [];
		getElementsByClassName(this, classes, results);
		return results;
	}
	getElementsByTagName(tagName) {
		const results = [];
		getElementsByTagName(this, tagName.toLowerCase(), results);
		return results;
	}
	querySelector(selector) {
		return selectOne(selector, this);
	}
	querySelectorAll(selector) {
		return selectAll(selector, this);
	}
	removeAttribute(attrName) {
		if (attrName === 'style') {
			delete this.__style;
		} else {
			const attr = this.attributes.getNamedItem(attrName);
			if (attr != null) {
				this.attributes.removeNamedItemNS(attr);
				if (checkAttributeChanged(this) === true) {
					attributeChanged(this, attrName, attr.value, null);
				}
			}
		}
	}
	removeAttributeNS(namespaceURI, attrName) {
		const attr = this.attributes.getNamedItemNS(namespaceURI, attrName);
		if (attr != null) {
			this.attributes.removeNamedItemNS(attr);
			if (checkAttributeChanged(this) === true) {
				attributeChanged(this, attrName, attr.value, null);
			}
		}
	}
	removeEventListener(type, handler) {
		removeEventListener(this, type, handler);
	}
	setAttribute(attrName, value) {
		if (attrName === 'style') {
			this.style = value;
		} else {
			const attributes = this.attributes;
			let attr = attributes.getNamedItem(attrName);
			const checkAttrChanged = checkAttributeChanged(this);
			if (attr != null) {
				if (checkAttrChanged === true) {
					const oldValue = attr.value;
					attr.value = value;
					if (oldValue !== attr.value) {
						attributeChanged(this, attr.name, oldValue, attr.value);
					}
				} else {
					attr.value = value;
				}
			} else {
				if (attributes.caseInsensitive) {
					attrName = attrName.toLowerCase();
				}
				attr = new MockAttr(attrName, value);
				attributes.__items.push(attr);
				if (checkAttrChanged === true) {
					attributeChanged(this, attrName, null, attr.value);
				}
			}
		}
	}
	setAttributeNS(namespaceURI, attrName, value) {
		const attributes = this.attributes;
		let attr = attributes.getNamedItemNS(namespaceURI, attrName);
		const checkAttrChanged = checkAttributeChanged(this);
		if (attr != null) {
			if (checkAttrChanged === true) {
				const oldValue = attr.value;
				attr.value = value;
				if (oldValue !== attr.value) {
					attributeChanged(this, attr.name, oldValue, attr.value);
				}
			} else {
				attr.value = value;
			}
		} else {
			attr = new MockAttr(attrName, value, namespaceURI);
			attributes.__items.push(attr);
			if (checkAttrChanged === true) {
				attributeChanged(this, attrName, null, attr.value);
			}
		}
	}
	get style() {
		if (this.__style == null) {
			this.__style = createCSSStyleDeclaration();
		}
		return this.__style;
	}
	set style(val) {
		if (typeof val === 'string') {
			if (this.__style == null) {
				this.__style = createCSSStyleDeclaration();
			}
			this.__style.cssText = val;
		} else {
			this.__style = val;
		}
	}
	get tabIndex() {
		return parseInt(this.getAttributeNS(null, 'tabindex') || '-1', 10);
	}
	set tabIndex(value) {
		this.setAttributeNS(null, 'tabindex', value);
	}
	get tagName() {
		var _a2;
		return (_a2 = this.nodeName) != null ? _a2 : '';
	}
	set tagName(value) {
		this.nodeName = value;
	}
	get textContent() {
		const text = [];
		getTextContent(this.childNodes, text);
		return text.join('');
	}
	set textContent(value) {
		setTextContent(this, value);
	}
	get title() {
		return this.getAttributeNS(null, 'title') || '';
	}
	set title(value) {
		this.setAttributeNS(null, 'title', value);
	}
	animate() {}
	onanimationstart() {}
	onanimationend() {}
	onanimationiteration() {}
	onabort() {}
	onauxclick() {}
	onbeforecopy() {}
	onbeforecut() {}
	onbeforepaste() {}
	onblur() {}
	oncancel() {}
	oncanplay() {}
	oncanplaythrough() {}
	onchange() {}
	onclick() {}
	onclose() {}
	oncontextmenu() {}
	oncopy() {}
	oncuechange() {}
	oncut() {}
	ondblclick() {}
	ondrag() {}
	ondragend() {}
	ondragenter() {}
	ondragleave() {}
	ondragover() {}
	ondragstart() {}
	ondrop() {}
	ondurationchange() {}
	onemptied() {}
	onended() {}
	onerror() {}
	onfocus() {}
	onfocusin() {}
	onfocusout() {}
	onformdata() {}
	onfullscreenchange() {}
	onfullscreenerror() {}
	ongotpointercapture() {}
	oninput() {}
	oninvalid() {}
	onkeydown() {}
	onkeypress() {}
	onkeyup() {}
	onload() {}
	onloadeddata() {}
	onloadedmetadata() {}
	onloadstart() {}
	onlostpointercapture() {}
	onmousedown() {}
	onmouseenter() {}
	onmouseleave() {}
	onmousemove() {}
	onmouseout() {}
	onmouseover() {}
	onmouseup() {}
	onmousewheel() {}
	onpaste() {}
	onpause() {}
	onplay() {}
	onplaying() {}
	onpointercancel() {}
	onpointerdown() {}
	onpointerenter() {}
	onpointerleave() {}
	onpointermove() {}
	onpointerout() {}
	onpointerover() {}
	onpointerup() {}
	onprogress() {}
	onratechange() {}
	onreset() {}
	onresize() {}
	onscroll() {}
	onsearch() {}
	onseeked() {}
	onseeking() {}
	onselect() {}
	onselectstart() {}
	onstalled() {}
	onsubmit() {}
	onsuspend() {}
	ontimeupdate() {}
	ontoggle() {}
	onvolumechange() {}
	onwaiting() {}
	onwebkitfullscreenchange() {}
	onwebkitfullscreenerror() {}
	onwheel() {}
	requestFullscreen() {}
	scrollBy() {}
	scrollTo() {}
	scrollIntoView() {}
	toString(opts) {
		return serializeNodeToHtml(this, opts);
	}
};
function getElementsByClassName(elm, classNames, foundElms) {
	const children = elm.children;
	for (let i = 0, ii = children.length; i < ii; i++) {
		const childElm = children[i];
		for (let j = 0, jj = classNames.length; j < jj; j++) {
			if (childElm.classList.contains(classNames[j])) {
				foundElms.push(childElm);
			}
		}
		getElementsByClassName(childElm, classNames, foundElms);
	}
}
function getElementsByTagName(elm, tagName, foundElms) {
	var _a2;
	const children = elm.children;
	for (let i = 0, ii = children.length; i < ii; i++) {
		const childElm = children[i];
		if (tagName === '*' || ((_a2 = childElm.nodeName) != null ? _a2 : '').toLowerCase() === tagName) {
			foundElms.push(childElm);
		}
		getElementsByTagName(childElm, tagName, foundElms);
	}
}
function resetElement(elm) {
	resetEventListeners(elm);
	delete elm.__attributeMap;
	delete elm.__shadowRoot;
	delete elm.__style;
}
function insertBefore(parentNode, newNode, referenceNode) {
	if (newNode !== referenceNode) {
		newNode.remove();
		newNode.parentNode = parentNode;
		newNode.ownerDocument = parentNode.ownerDocument;
		if (referenceNode != null) {
			const index = parentNode.childNodes.indexOf(referenceNode);
			if (index > -1) {
				parentNode.childNodes.splice(index, 0, newNode);
			} else {
				throw new Error(`referenceNode not found in parentNode.childNodes`);
			}
		} else {
			parentNode.childNodes.push(newNode);
		}
		connectNode(parentNode.ownerDocument, newNode);
	}
	return newNode;
}
var MockHTMLElement = class extends MockElement {
	constructor(ownerDocument, nodeName) {
		super(ownerDocument, typeof nodeName === 'string' ? nodeName.toUpperCase() : null);
		this.__namespaceURI = 'http://www.w3.org/1999/xhtml';
	}
	get tagName() {
		var _a2;
		return (_a2 = this.nodeName) != null ? _a2 : '';
	}
	set tagName(value) {
		this.nodeName = value;
	}
	/**
	 * A nodes parent of type Element is known as its parent element.
	 * If the node has a parent of a different type, its parent element
	 * is null.
	 * @returns MockElement
	 */
	get parentElement() {
		if (this.nodeName === 'HTML') {
			return null;
		}
		return super.parentElement;
	}
	get attributes() {
		if (this.__attributeMap == null) {
			const attrMap = createAttributeProxy(true);
			this.__attributeMap = attrMap;
			return attrMap;
		}
		return this.__attributeMap;
	}
	set attributes(attrs) {
		this.__attributeMap = attrs;
	}
};
var MockTextNode = class _MockTextNode extends MockNode2 {
	constructor(ownerDocument, text) {
		super(ownerDocument, 3 /* TEXT_NODE */, '#text' /* TEXT_NODE */, text);
	}
	cloneNode(_deep) {
		return new _MockTextNode(null, this.nodeValue);
	}
	get textContent() {
		return this.nodeValue;
	}
	set textContent(text) {
		this.nodeValue = text;
	}
	get data() {
		return this.nodeValue;
	}
	set data(text) {
		this.nodeValue = text;
	}
	get wholeText() {
		if (this.parentNode != null) {
			const text = [];
			for (let i = 0, ii = this.parentNode.childNodes.length; i < ii; i++) {
				const childNode = this.parentNode.childNodes[i];
				if (childNode.nodeType === 3 /* TEXT_NODE */) {
					text.push(childNode.nodeValue);
				}
			}
			return text.join('');
		}
		return this.nodeValue;
	}
};
function getTextContent(childNodes, text) {
	for (let i = 0, ii = childNodes.length; i < ii; i++) {
		const childNode = childNodes[i];
		if (childNode.nodeType === 3 /* TEXT_NODE */) {
			text.push(childNode.nodeValue);
		} else if (childNode.nodeType === 1 /* ELEMENT_NODE */) {
			getTextContent(childNode.childNodes, text);
		}
	}
}
function setTextContent(elm, text) {
	for (let i = elm.childNodes.length - 1; i >= 0; i--) {
		elm.removeChild(elm.childNodes[i]);
	}
	const textNode = new MockTextNode(elm.ownerDocument, text);
	elm.appendChild(textNode);
}

// src/mock-doc/comment-node.ts
var MockComment = class _MockComment extends MockNode2 {
	constructor(ownerDocument, data) {
		super(ownerDocument, 8 /* COMMENT_NODE */, '#comment' /* COMMENT_NODE */, data);
	}
	cloneNode(_deep) {
		return new _MockComment(null, this.nodeValue);
	}
	get textContent() {
		return this.nodeValue;
	}
	set textContent(text) {
		this.nodeValue = text;
	}
};

// src/mock-doc/document-fragment.ts
var MockDocumentFragment = class _MockDocumentFragment extends MockHTMLElement {
	constructor(ownerDocument) {
		super(ownerDocument, null);
		this.nodeName = '#document-fragment' /* DOCUMENT_FRAGMENT_NODE */;
		this.nodeType = 11 /* DOCUMENT_FRAGMENT_NODE */;
	}
	getElementById(id) {
		return getElementById(this, id);
	}
	cloneNode(deep) {
		const cloned = new _MockDocumentFragment(null);
		if (deep) {
			for (let i = 0, ii = this.childNodes.length; i < ii; i++) {
				const childNode = this.childNodes[i];
				if (
					childNode.nodeType === 1 /* ELEMENT_NODE */ ||
					childNode.nodeType === 3 /* TEXT_NODE */ ||
					childNode.nodeType === 8 /* COMMENT_NODE */
				) {
					const clonedChildNode = this.childNodes[i].cloneNode(true);
					cloned.appendChild(clonedChildNode);
				}
			}
		}
		return cloned;
	}
};

// src/mock-doc/document-type-node.ts
var MockDocumentTypeNode = class extends MockHTMLElement {
	constructor(ownerDocument) {
		super(ownerDocument, '!DOCTYPE');
		this.nodeType = 10 /* DOCUMENT_TYPE_NODE */;
		this.setAttribute('html', '');
	}
};

// src/mock-doc/css-style-sheet.ts
var MockCSSRule = class {
	constructor(parentStyleSheet) {
		this.parentStyleSheet = parentStyleSheet;
		this.cssText = '';
		this.type = 0;
	}
};
var MockCSSStyleSheet = class {
	constructor(ownerNode) {
		this.type = 'text/css';
		this.parentStyleSheet = null;
		this.cssRules = [];
		this.ownerNode = ownerNode;
	}
	get rules() {
		return this.cssRules;
	}
	set rules(rules) {
		this.cssRules = rules;
	}
	deleteRule(index) {
		if (index >= 0 && index < this.cssRules.length) {
			this.cssRules.splice(index, 1);
			updateStyleTextNode(this.ownerNode);
		}
	}
	insertRule(rule, index = 0) {
		if (typeof index !== 'number') {
			index = 0;
		}
		if (index < 0) {
			index = 0;
		}
		if (index > this.cssRules.length) {
			index = this.cssRules.length;
		}
		const cssRule = new MockCSSRule(this);
		cssRule.cssText = rule;
		this.cssRules.splice(index, 0, cssRule);
		updateStyleTextNode(this.ownerNode);
		return index;
	}
};
function getStyleElementText(styleElm) {
	const output = [];
	for (let i = 0; i < styleElm.childNodes.length; i++) {
		output.push(styleElm.childNodes[i].nodeValue);
	}
	return output.join('');
}
function setStyleElementText(styleElm, text) {
	const sheet = styleElm.sheet;
	sheet.cssRules.length = 0;
	sheet.insertRule(text);
	updateStyleTextNode(styleElm);
}
function updateStyleTextNode(styleElm) {
	const childNodeLen = styleElm.childNodes.length;
	if (childNodeLen > 1) {
		for (let i = childNodeLen - 1; i >= 1; i--) {
			styleElm.removeChild(styleElm.childNodes[i]);
		}
	} else if (childNodeLen < 1) {
		styleElm.appendChild(styleElm.ownerDocument.createTextNode(''));
	}
	const textNode = styleElm.childNodes[0];
	textNode.nodeValue = styleElm.sheet.cssRules.map((r) => r.cssText).join('\n');
}

// src/mock-doc/element.ts
function createElement(ownerDocument, tagName) {
	if (typeof tagName !== 'string' || tagName === '' || !/^[a-z0-9-_:]+$/i.test(tagName)) {
		throw new Error(`The tag name provided (${tagName}) is not a valid name.`);
	}
	tagName = tagName.toLowerCase();
	switch (tagName) {
		case 'a':
			return new MockAnchorElement(ownerDocument);
		case 'base':
			return new MockBaseElement(ownerDocument);
		case 'button':
			return new MockButtonElement(ownerDocument);
		case 'canvas':
			return new MockCanvasElement(ownerDocument);
		case 'form':
			return new MockFormElement(ownerDocument);
		case 'img':
			return new MockImageElement(ownerDocument);
		case 'input':
			return new MockInputElement(ownerDocument);
		case 'link':
			return new MockLinkElement(ownerDocument);
		case 'meta':
			return new MockMetaElement(ownerDocument);
		case 'script':
			return new MockScriptElement(ownerDocument);
		case 'slot':
			return new MockSlotElement(ownerDocument);
		case 'slot-fb':
			return new MockHTMLElement(ownerDocument, tagName);
		case 'style':
			return new MockStyleElement(ownerDocument);
		case 'template':
			return new MockTemplateElement(ownerDocument);
		case 'title':
			return new MockTitleElement(ownerDocument);
		case 'ul':
			return new MockUListElement(ownerDocument);
	}
	if (ownerDocument != null && tagName.includes('-')) {
		const win2 = ownerDocument.defaultView;
		if (win2 != null && win2.customElements != null) {
			return createCustomElement(win2.customElements, ownerDocument, tagName);
		}
	}
	return new MockHTMLElement(ownerDocument, tagName);
}
function createElementNS(ownerDocument, namespaceURI, tagName) {
	if (namespaceURI === 'http://www.w3.org/1999/xhtml') {
		return createElement(ownerDocument, tagName);
	} else if (namespaceURI === 'http://www.w3.org/2000/svg') {
		switch (tagName.toLowerCase()) {
			case 'text':
			case 'tspan':
			case 'tref':
			case 'altglyph':
			case 'textpath':
				return new MockSVGTextContentElement(ownerDocument, tagName);
			case 'circle':
			case 'ellipse':
			case 'image':
			case 'line':
			case 'path':
			case 'polygon':
			case 'polyline':
			case 'rect':
			case 'use':
				return new MockSVGGraphicsElement(ownerDocument, tagName);
			case 'svg':
				return new MockSVGSVGElement(ownerDocument, tagName);
			default:
				return new MockSVGElement(ownerDocument, tagName);
		}
	} else {
		return new MockElement(ownerDocument, tagName, namespaceURI);
	}
}
var MockAnchorElement = class extends MockHTMLElement {
	constructor(ownerDocument) {
		super(ownerDocument, 'a');
	}
	get href() {
		return fullUrl(this, 'href');
	}
	set href(value) {
		this.setAttribute('href', value);
	}
	get pathname() {
		if (!this.href) {
			return '';
		}
		return new URL(this.href).pathname;
	}
};
var MockButtonElement = class extends MockHTMLElement {
	constructor(ownerDocument) {
		super(ownerDocument, 'button');
	}
};
patchPropAttributes(
	MockButtonElement.prototype,
	{
		type: String,
	},
	{
		type: 'submit',
	},
);
Object.defineProperty(MockButtonElement.prototype, 'form', {
	get() {
		return this.hasAttribute('form') ? this.getAttribute('form') : null;
	},
});
var MockImageElement = class extends MockHTMLElement {
	constructor(ownerDocument) {
		super(ownerDocument, 'img');
	}
	get draggable() {
		return this.getAttributeNS(null, 'draggable') !== 'false';
	}
	set draggable(value) {
		this.setAttributeNS(null, 'draggable', value);
	}
	get src() {
		return fullUrl(this, 'src');
	}
	set src(value) {
		this.setAttribute('src', value);
	}
};
patchPropAttributes(MockImageElement.prototype, {
	height: Number,
	width: Number,
});
var MockInputElement = class extends MockHTMLElement {
	constructor(ownerDocument) {
		super(ownerDocument, 'input');
	}
	get list() {
		const listId = this.getAttribute('list');
		if (listId) {
			return this.ownerDocument.getElementById(listId);
		}
		return null;
	}
};
patchPropAttributes(
	MockInputElement.prototype,
	{
		accept: String,
		autocomplete: String,
		autofocus: Boolean,
		capture: String,
		checked: Boolean,
		disabled: Boolean,
		form: String,
		formaction: String,
		formenctype: String,
		formmethod: String,
		formnovalidate: String,
		formtarget: String,
		height: Number,
		inputmode: String,
		max: String,
		maxLength: Number,
		min: String,
		minLength: Number,
		multiple: Boolean,
		name: String,
		pattern: String,
		placeholder: String,
		required: Boolean,
		readOnly: Boolean,
		size: Number,
		spellCheck: Boolean,
		src: String,
		step: String,
		type: String,
		value: String,
		width: Number,
	},
	{
		type: 'text',
	},
);
var MockFormElement = class extends MockHTMLElement {
	constructor(ownerDocument) {
		super(ownerDocument, 'form');
	}
};
patchPropAttributes(MockFormElement.prototype, {
	name: String,
});
var MockLinkElement = class extends MockHTMLElement {
	constructor(ownerDocument) {
		super(ownerDocument, 'link');
	}
	get href() {
		return fullUrl(this, 'href');
	}
	set href(value) {
		this.setAttribute('href', value);
	}
};
patchPropAttributes(MockLinkElement.prototype, {
	crossorigin: String,
	media: String,
	rel: String,
	type: String,
});
var MockMetaElement = class extends MockHTMLElement {
	constructor(ownerDocument) {
		super(ownerDocument, 'meta');
	}
};
patchPropAttributes(MockMetaElement.prototype, {
	charset: String,
	content: String,
	name: String,
});
var MockScriptElement = class extends MockHTMLElement {
	constructor(ownerDocument) {
		super(ownerDocument, 'script');
	}
	get src() {
		return fullUrl(this, 'src');
	}
	set src(value) {
		this.setAttribute('src', value);
	}
};
patchPropAttributes(MockScriptElement.prototype, {
	type: String,
});
var MockDOMMatrix = class _MockDOMMatrix {
	constructor() {
		this.a = 1;
		this.b = 0;
		this.c = 0;
		this.d = 1;
		this.e = 0;
		this.f = 0;
		this.m11 = 1;
		this.m12 = 0;
		this.m13 = 0;
		this.m14 = 0;
		this.m21 = 0;
		this.m22 = 1;
		this.m23 = 0;
		this.m24 = 0;
		this.m31 = 0;
		this.m32 = 0;
		this.m33 = 1;
		this.m34 = 0;
		this.m41 = 0;
		this.m42 = 0;
		this.m43 = 0;
		this.m44 = 1;
		this.is2D = true;
		this.isIdentity = true;
	}
	static fromMatrix() {
		return new _MockDOMMatrix();
	}
	inverse() {
		return new _MockDOMMatrix();
	}
	flipX() {
		return new _MockDOMMatrix();
	}
	flipY() {
		return new _MockDOMMatrix();
	}
	multiply() {
		return new _MockDOMMatrix();
	}
	rotate() {
		return new _MockDOMMatrix();
	}
	rotateAxisAngle() {
		return new _MockDOMMatrix();
	}
	rotateFromVector() {
		return new _MockDOMMatrix();
	}
	scale() {
		return new _MockDOMMatrix();
	}
	scaleNonUniform() {
		return new _MockDOMMatrix();
	}
	skewX() {
		return new _MockDOMMatrix();
	}
	skewY() {
		return new _MockDOMMatrix();
	}
	toJSON() {}
	toString() {}
	transformPoint() {
		return new MockDOMPoint();
	}
	translate() {
		return new _MockDOMMatrix();
	}
};
var MockDOMPoint = class {
	constructor() {
		this.w = 1;
		this.x = 0;
		this.y = 0;
		this.z = 0;
	}
	toJSON() {}
	matrixTransform() {
		return new MockDOMMatrix();
	}
};
var MockSVGRect = class {
	constructor() {
		this.height = 10;
		this.width = 10;
		this.x = 0;
		this.y = 0;
	}
};
var MockStyleElement = class extends MockHTMLElement {
	constructor(ownerDocument) {
		super(ownerDocument, 'style');
		this.sheet = new MockCSSStyleSheet(this);
	}
	get innerHTML() {
		return getStyleElementText(this);
	}
	set innerHTML(value) {
		setStyleElementText(this, value);
	}
	get innerText() {
		return getStyleElementText(this);
	}
	set innerText(value) {
		setStyleElementText(this, value);
	}
	get textContent() {
		return getStyleElementText(this);
	}
	set textContent(value) {
		setStyleElementText(this, value);
	}
};
var MockSVGElement = class extends MockElement {
	constructor() {
		super(...arguments);
		this.__namespaceURI = 'http://www.w3.org/2000/svg';
	}
	// SVGElement properties and methods
	get ownerSVGElement() {
		return null;
	}
	get viewportElement() {
		return null;
	}
	onunload() {}
	// SVGGeometryElement properties and methods
	get pathLength() {
		return 0;
	}
	isPointInFill(_pt) {
		return false;
	}
	isPointInStroke(_pt) {
		return false;
	}
	getTotalLength() {
		return 0;
	}
};
var MockSVGGraphicsElement = class extends MockSVGElement {
	getBBox(_options) {
		return new MockSVGRect();
	}
	getCTM() {
		return new MockDOMMatrix();
	}
	getScreenCTM() {
		return new MockDOMMatrix();
	}
};
var MockSVGSVGElement = class extends MockSVGGraphicsElement {
	createSVGPoint() {
		return new MockDOMPoint();
	}
};
var MockSVGTextContentElement = class extends MockSVGGraphicsElement {
	getComputedTextLength() {
		return 0;
	}
};
var MockBaseElement = class extends MockHTMLElement {
	constructor(ownerDocument) {
		super(ownerDocument, 'base');
	}
	get href() {
		return fullUrl(this, 'href');
	}
	set href(value) {
		this.setAttribute('href', value);
	}
};
var MockTemplateElement = class _MockTemplateElement extends MockHTMLElement {
	constructor(ownerDocument) {
		super(ownerDocument, 'template');
		this.content = new MockDocumentFragment(ownerDocument);
	}
	get innerHTML() {
		return this.content.innerHTML;
	}
	set innerHTML(html) {
		this.content.innerHTML = html;
	}
	cloneNode(deep) {
		const cloned = new _MockTemplateElement(null);
		cloned.attributes = cloneAttributes(this.attributes);
		const styleCssText = this.getAttribute('style');
		if (styleCssText != null && styleCssText.length > 0) {
			cloned.setAttribute('style', styleCssText);
		}
		cloned.content = this.content.cloneNode(deep);
		if (deep) {
			for (let i = 0, ii = this.childNodes.length; i < ii; i++) {
				const clonedChildNode = this.childNodes[i].cloneNode(true);
				cloned.appendChild(clonedChildNode);
			}
		}
		return cloned;
	}
};
var MockTitleElement = class extends MockHTMLElement {
	constructor(ownerDocument) {
		super(ownerDocument, 'title');
	}
	get text() {
		return this.textContent;
	}
	set text(value) {
		this.textContent = value;
	}
};
var MockUListElement = class extends MockHTMLElement {
	constructor(ownerDocument) {
		super(ownerDocument, 'ul');
	}
};
var MockSlotElement = class _MockSlotElement extends MockHTMLElement {
	constructor(ownerDocument) {
		super(ownerDocument, 'slot');
	}
	assignedNodes(opts) {
		let nodesToReturn = [];
		const ownerHost = this.getRootNode().host;
		if (!ownerHost) return nodesToReturn;
		if (ownerHost.childNodes.length) {
			if (this.name) {
				nodesToReturn = ownerHost.childNodes.filter(
					(n) => n.nodeType === 1 /* ELEMENT_NODE */ && n.getAttribute('slot') === this.name,
				);
			} else {
				nodesToReturn = ownerHost.childNodes.filter(
					(n) =>
						(n.nodeType === 1 /* ELEMENT_NODE */ && !n.getAttribute('slot')) || n.nodeType !== 1 /* ELEMENT_NODE */,
				);
			}
			if (nodesToReturn.length) return nodesToReturn;
		}
		if (!(opts == null ? void 0 : opts.flatten)) return this.childNodes.filter((n) => !(n instanceof _MockSlotElement));
		return this.childNodes.reduce((acc, node) => {
			if (node instanceof _MockSlotElement) {
				acc.push(...node.assignedNodes(opts));
			} else {
				acc.push(node);
			}
			return acc;
		}, []);
	}
	assignedElements(opts) {
		let elesToReturn = [];
		const ownerHost = this.getRootNode().host;
		if (!ownerHost) return elesToReturn;
		if (ownerHost.children.length) {
			if (this.name) {
				elesToReturn = ownerHost.children.filter((n) => n.getAttribute('slot') == this.name);
			} else {
				elesToReturn = ownerHost.children.filter((n) => !n.getAttribute('slot'));
			}
			if (elesToReturn.length) return elesToReturn;
		}
		if (!(opts == null ? void 0 : opts.flatten)) return this.children.filter((n) => !(n instanceof _MockSlotElement));
		return this.children.reduce((acc, node) => {
			if (node instanceof _MockSlotElement) {
				acc.push(...node.assignedElements(opts));
			} else {
				acc.push(node);
			}
			return acc;
		}, []);
	}
};
patchPropAttributes(MockSlotElement.prototype, {
	name: String,
});
var CanvasRenderingContext = class {
	constructor(context, contextAttributes) {
		this.context = context;
		this.contextAttributes = contextAttributes;
	}
	fillRect() {
		return;
	}
	clearRect() {}
	getImageData(_, __, w, h2) {
		return {
			data: new Array(w * h2 * 4),
		};
	}
	toDataURL() {
		return 'data:,';
	}
	putImageData() {}
	createImageData() {
		return {};
	}
	setTransform() {}
	drawImage() {}
	save() {}
	fillText() {}
	restore() {}
	beginPath() {}
	moveTo() {}
	lineTo() {}
	closePath() {}
	stroke() {}
	translate() {}
	scale() {}
	rotate() {}
	arc() {}
	fill() {}
	measureText() {
		return { width: 0 };
	}
	transform() {}
	rect() {}
	clip() {}
};
var MockCanvasElement = class extends MockHTMLElement {
	constructor(ownerDocument) {
		super(ownerDocument, 'canvas');
	}
	getContext(context, contextAttributes) {
		return new CanvasRenderingContext(context, contextAttributes);
	}
};
function fullUrl(elm, attrName) {
	const val = elm.getAttribute(attrName) || '';
	if (elm.ownerDocument != null) {
		const win2 = elm.ownerDocument.defaultView;
		if (win2 != null) {
			const loc = win2.location;
			if (loc != null) {
				try {
					const url = new URL(val, loc.href);
					return url.href;
				} catch (e) {}
			}
		}
	}
	return val.replace(/\'|\"/g, '').trim();
}
function patchPropAttributes(prototype, attrs, defaults = {}) {
	Object.keys(attrs).forEach((propName) => {
		const attr = attrs[propName];
		const defaultValue = defaults[propName];
		if (attr === Boolean) {
			Object.defineProperty(prototype, propName, {
				get() {
					return this.hasAttribute(propName);
				},
				set(value) {
					if (value) {
						this.setAttribute(propName, '');
					} else {
						this.removeAttribute(propName);
					}
				},
			});
		} else if (attr === Number) {
			Object.defineProperty(prototype, propName, {
				get() {
					const value = this.getAttribute(propName);
					return value ? parseInt(value, 10) : defaultValue === void 0 ? 0 : defaultValue;
				},
				set(value) {
					this.setAttribute(propName, value);
				},
			});
		} else {
			Object.defineProperty(prototype, propName, {
				get() {
					return this.hasAttribute(propName) ? this.getAttribute(propName) : defaultValue || '';
				},
				set(value) {
					this.setAttribute(propName, value);
				},
			});
		}
	});
}
MockElement.prototype.cloneNode = function (deep) {
	const cloned = createElement(this.ownerDocument, this.nodeName);
	cloned.attributes = cloneAttributes(this.attributes);
	const styleCssText = this.getAttribute('style');
	if (styleCssText != null && styleCssText.length > 0) {
		cloned.setAttribute('style', styleCssText);
	}
	if (deep) {
		for (let i = 0, ii = this.childNodes.length; i < ii; i++) {
			const clonedChildNode = this.childNodes[i].cloneNode(true);
			cloned.appendChild(clonedChildNode);
		}
	}
	return cloned;
};

// src/mock-doc/parse-html.ts
var sharedDocument;
function parseHtmlToDocument(html, ownerDocument = null) {
	if (ownerDocument == null) {
		if (sharedDocument == null) {
			sharedDocument = new MockDocument();
		}
		ownerDocument = sharedDocument;
	}
	return parseDocumentUtil(ownerDocument, html);
}

// src/mock-doc/console.ts
var consoleNoop = () => {};
function createConsole() {
	return {
		debug: consoleNoop,
		error: consoleNoop,
		info: consoleNoop,
		log: consoleNoop,
		warn: consoleNoop,
		dir: consoleNoop,
		dirxml: consoleNoop,
		table: consoleNoop,
		trace: consoleNoop,
		group: consoleNoop,
		groupCollapsed: consoleNoop,
		groupEnd: consoleNoop,
		clear: consoleNoop,
		count: consoleNoop,
		countReset: consoleNoop,
		assert: consoleNoop,
		profile: consoleNoop,
		profileEnd: consoleNoop,
		time: consoleNoop,
		timeLog: consoleNoop,
		timeEnd: consoleNoop,
		timeStamp: consoleNoop,
		context: consoleNoop,
		memory: consoleNoop,
	};
}

// src/mock-doc/headers.ts
var MockHeaders = class {
	constructor(init) {
		this._values = [];
		if (typeof init === 'object') {
			if (typeof init[Symbol.iterator] === 'function') {
				const kvs = [];
				for (const kv of init) {
					if (typeof kv[Symbol.iterator] === 'function') {
						kvs.push([...kv]);
					}
				}
				for (const kv of kvs) {
					this.append(kv[0], kv[1]);
				}
			} else {
				for (const key in init) {
					this.append(key, init[key]);
				}
			}
		}
	}
	append(key, value) {
		this._values.push([key, value + '']);
	}
	delete(key) {
		key = key.toLowerCase();
		for (let i = this._values.length - 1; i >= 0; i--) {
			if (this._values[i][0].toLowerCase() === key) {
				this._values.splice(i, 1);
			}
		}
	}
	entries() {
		const entries = [];
		for (const kv of this.keys()) {
			entries.push([kv, this.get(kv)]);
		}
		let index = -1;
		return {
			next() {
				index++;
				return {
					value: entries[index],
					done: !entries[index],
				};
			},
			[Symbol.iterator]() {
				return this;
			},
		};
	}
	forEach(cb) {
		for (const kv of this.entries()) {
			cb(kv[1], kv[0]);
		}
	}
	get(key) {
		const rtn = [];
		key = key.toLowerCase();
		for (const kv of this._values) {
			if (kv[0].toLowerCase() === key) {
				rtn.push(kv[1]);
			}
		}
		return rtn.length > 0 ? rtn.join(', ') : null;
	}
	has(key) {
		key = key.toLowerCase();
		for (const kv of this._values) {
			if (kv[0].toLowerCase() === key) {
				return true;
			}
		}
		return false;
	}
	keys() {
		const keys = [];
		for (const kv of this._values) {
			const key = kv[0].toLowerCase();
			if (!keys.includes(key)) {
				keys.push(key);
			}
		}
		let index = -1;
		return {
			next() {
				index++;
				return {
					value: keys[index],
					done: !keys[index],
				};
			},
			[Symbol.iterator]() {
				return this;
			},
		};
	}
	set(key, value) {
		for (const kv of this._values) {
			if (kv[0].toLowerCase() === key.toLowerCase()) {
				kv[1] = value + '';
				return;
			}
		}
		this.append(key, value);
	}
	values() {
		const values = this._values;
		let index = -1;
		return {
			next() {
				index++;
				const done = !values[index];
				return {
					value: done ? void 0 : values[index][1],
					done,
				};
			},
			[Symbol.iterator]() {
				return this;
			},
		};
	}
	[Symbol.iterator]() {
		return this.entries();
	}
};

// src/mock-doc/parser.ts
var MockDOMParser = class {
	parseFromString(htmlToParse, mimeType) {
		if (mimeType !== 'text/html') {
			console.error('XML parsing not implemented yet, continuing as html');
		}
		return parseHtmlToDocument(htmlToParse);
	}
};

// src/mock-doc/request-response.ts
var MockRequest = class _MockRequest {
	constructor(input, init = {}) {
		this._method = 'GET';
		this._url = '/';
		this.bodyUsed = false;
		this.cache = 'default';
		this.credentials = 'same-origin';
		this.integrity = '';
		this.keepalive = false;
		this.mode = 'cors';
		this.redirect = 'follow';
		this.referrer = 'about:client';
		this.referrerPolicy = '';
		if (typeof input === 'string') {
			this.url = input;
		} else if (input) {
			Object.assign(this, input);
			this.headers = new MockHeaders(input.headers);
		}
		Object.assign(this, init);
		if (init.headers) {
			this.headers = new MockHeaders(init.headers);
		}
		if (!this.headers) {
			this.headers = new MockHeaders();
		}
	}
	get url() {
		if (typeof this._url === 'string') {
			return new URL(this._url, location.href).href;
		}
		return new URL('/', location.href).href;
	}
	set url(value) {
		this._url = value;
	}
	get method() {
		if (typeof this._method === 'string') {
			return this._method.toUpperCase();
		}
		return 'GET';
	}
	set method(value) {
		this._method = value;
	}
	clone() {
		const clone = { ...this };
		clone.headers = new MockHeaders(this.headers);
		return new _MockRequest(clone);
	}
};
var MockResponse = class _MockResponse {
	constructor(body, init = {}) {
		this.ok = true;
		this.status = 200;
		this.statusText = '';
		this.type = 'default';
		this.url = '';
		this._body = body;
		if (init) {
			Object.assign(this, init);
		}
		this.headers = new MockHeaders(init.headers);
	}
	async json() {
		return JSON.parse(this._body);
	}
	async text() {
		return this._body;
	}
	clone() {
		const initClone = { ...this };
		initClone.headers = new MockHeaders(this.headers);
		return new _MockResponse(this._body, initClone);
	}
};

// src/mock-doc/global.ts
function patchWindow(winToBePatched) {
	const mockWin = new MockWindow(false);
	WINDOW_FUNCTIONS.forEach((fnName) => {
		if (typeof winToBePatched[fnName] !== 'function') {
			winToBePatched[fnName] = mockWin[fnName].bind(mockWin);
		}
	});
	WINDOW_PROPS.forEach((propName) => {
		if (winToBePatched === void 0) {
			Object.defineProperty(winToBePatched, propName, {
				get() {
					return mockWin[propName];
				},
				set(val) {
					mockWin[propName] = val;
				},
				configurable: true,
				enumerable: true,
			});
		}
	});
}
function addGlobalsToWindowPrototype(mockWinPrototype) {
	GLOBAL_CONSTRUCTORS.forEach(([cstrName, Cstr]) => {
		Object.defineProperty(mockWinPrototype, cstrName, {
			get() {
				return this['__' + cstrName] || Cstr;
			},
			set(cstr) {
				this['__' + cstrName] = cstr;
			},
			configurable: true,
			enumerable: true,
		});
	});
}
var WINDOW_FUNCTIONS = [
	'addEventListener',
	'alert',
	'blur',
	'cancelAnimationFrame',
	'cancelIdleCallback',
	'clearInterval',
	'clearTimeout',
	'close',
	'confirm',
	'dispatchEvent',
	'focus',
	'getComputedStyle',
	'matchMedia',
	'open',
	'prompt',
	'removeEventListener',
	'requestAnimationFrame',
	'requestIdleCallback',
	'URL',
];
var WINDOW_PROPS = [
	'customElements',
	'devicePixelRatio',
	'document',
	'history',
	'innerHeight',
	'innerWidth',
	'localStorage',
	'location',
	'navigator',
	'pageXOffset',
	'pageYOffset',
	'performance',
	'screenLeft',
	'screenTop',
	'screenX',
	'screenY',
	'scrollX',
	'scrollY',
	'sessionStorage',
	'CSS',
	'CustomEvent',
	'Event',
	'Element',
	'HTMLElement',
	'Node',
	'NodeList',
	'FocusEvent',
	'KeyboardEvent',
	'MouseEvent',
];
var GLOBAL_CONSTRUCTORS = [
	['CustomEvent', MockCustomEvent],
	['DocumentFragment', MockDocumentFragment],
	['DOMParser', MockDOMParser],
	['Event', MockEvent],
	['FocusEvent', MockFocusEvent],
	['Headers', MockHeaders],
	['KeyboardEvent', MockKeyboardEvent],
	['MouseEvent', MockMouseEvent],
	['Request', MockRequest],
	['Response', MockResponse],
	['ShadowRoot', MockDocumentFragment],
	['HTMLAnchorElement', MockAnchorElement],
	['HTMLBaseElement', MockBaseElement],
	['HTMLButtonElement', MockButtonElement],
	['HTMLCanvasElement', MockCanvasElement],
	['HTMLFormElement', MockFormElement],
	['HTMLImageElement', MockImageElement],
	['HTMLInputElement', MockInputElement],
	['HTMLLinkElement', MockLinkElement],
	['HTMLMetaElement', MockMetaElement],
	['HTMLScriptElement', MockScriptElement],
	['HTMLStyleElement', MockStyleElement],
	['HTMLTemplateElement', MockTemplateElement],
	['HTMLTitleElement', MockTitleElement],
	['HTMLUListElement', MockUListElement],
];

// src/mock-doc/history.ts
var MockHistory = class {
	constructor() {
		this.items = [];
	}
	get length() {
		return this.items.length;
	}
	back() {
		this.go(-1);
	}
	forward() {
		this.go(1);
	}
	go(_value) {}
	pushState(_state, _title, _url) {}
	replaceState(_state, _title, _url) {}
};

// src/mock-doc/intersection-observer.ts
var MockIntersectionObserver = class {
	constructor() {}
	disconnect() {}
	observe() {}
	takeRecords() {
		return [];
	}
	unobserve() {}
};

// src/mock-doc/location.ts
var MockLocation = class {
	constructor() {
		this.ancestorOrigins = null;
		this.protocol = '';
		this.host = '';
		this.hostname = '';
		this.port = '';
		this.pathname = '';
		this.search = '';
		this.hash = '';
		this.username = '';
		this.password = '';
		this.origin = '';
		this._href = '';
	}
	get href() {
		return this._href;
	}
	set href(value) {
		const url = new URL(value, 'http://mockdoc.stenciljs.com');
		this._href = url.href;
		this.protocol = url.protocol;
		this.host = url.host;
		this.hostname = url.hostname;
		this.port = url.port;
		this.pathname = url.pathname;
		this.search = url.search;
		this.hash = url.hash;
		this.username = url.username;
		this.password = url.password;
		this.origin = url.origin;
	}
	assign(_url) {}
	reload(_forcedReload) {}
	replace(_url) {}
	toString() {
		return this.href;
	}
};

// src/mock-doc/navigator.ts
var MockNavigator = class {
	constructor() {
		this.appCodeName = 'MockNavigator';
		this.appName = 'MockNavigator';
		this.appVersion = 'MockNavigator';
		this.platform = 'MockNavigator';
		this.userAgent = 'MockNavigator';
	}
};

// src/mock-doc/performance.ts
var MockPerformance = class {
	constructor() {
		this.timeOrigin = Date.now();
		this.eventCounts = /* @__PURE__ */ new Map();
	}
	addEventListener() {}
	clearMarks() {}
	clearMeasures() {}
	clearResourceTimings() {}
	dispatchEvent() {
		return true;
	}
	getEntries() {
		return [];
	}
	getEntriesByName() {
		return [];
	}
	getEntriesByType() {
		return [];
	}
	// Stencil's implementation of `mark` is non-compliant with the `Performance` interface. Because Stencil will
	// instantiate an instance of this class and may attempt to assign it to a variable of type `Performance`, the return
	// type must match the `Performance` interface (rather than typing this function as returning `void` and ignoring the
	// associated errors returned by the type checker)
	// @ts-ignore
	mark() {}
	// Stencil's implementation of `measure` is non-compliant with the `Performance` interface. Because Stencil will
	// instantiate an instance of this class and may attempt to assign it to a variable of type `Performance`, the return
	// type must match the `Performance` interface (rather than typing this function as returning `void` and ignoring the
	// associated errors returned by the type checker)
	// @ts-ignore
	measure() {}
	get navigation() {
		return {};
	}
	now() {
		return Date.now() - this.timeOrigin;
	}
	get onresourcetimingbufferfull() {
		return null;
	}
	removeEventListener() {}
	setResourceTimingBufferSize() {}
	get timing() {
		return {};
	}
	toJSON() {}
};
function resetPerformance(perf) {
	if (perf != null) {
		try {
			perf.timeOrigin = Date.now();
		} catch (e) {}
	}
}

// src/mock-doc/resize-observer.ts
var MockResizeObserver = class {
	constructor() {}
	disconnect() {}
	observe() {}
	takeRecords() {
		return [];
	}
	unobserve() {}
};

// src/mock-doc/shadow-root.ts
var MockShadowRoot = class extends MockDocumentFragment {
	get activeElement() {
		return null;
	}
	set adoptedStyleSheets(_adoptedStyleSheets) {
		throw new Error('Unimplemented');
	}
	get adoptedStyleSheets() {
		return [];
	}
	get cloneable() {
		return false;
	}
	get delegatesFocus() {
		return false;
	}
	get fullscreenElement() {
		return null;
	}
	get host() {
		let parent = this.parentElement();
		while (parent) {
			if (parent.nodeType === 11) {
				return parent;
			}
			parent = parent.parentElement();
		}
		return null;
	}
	get mode() {
		return 'open';
	}
	get pictureInPictureElement() {
		return null;
	}
	get pointerLockElement() {
		return null;
	}
	get serializable() {
		return false;
	}
	get slotAssignment() {
		return 'named';
	}
	get styleSheets() {
		return [];
	}
};

// src/mock-doc/storage.ts
var MockStorage = class {
	constructor() {
		this.items = /* @__PURE__ */ new Map();
	}
	key(_value) {}
	getItem(key) {
		key = String(key);
		if (this.items.has(key)) {
			return this.items.get(key);
		}
		return null;
	}
	setItem(key, value) {
		if (value == null) {
			value = 'null';
		}
		this.items.set(String(key), String(value));
	}
	removeItem(key) {
		this.items.delete(String(key));
	}
	clear() {
		this.items.clear();
	}
};

// src/mock-doc/window.ts
var nativeClearInterval = globalThis.clearInterval;
var nativeClearTimeout = globalThis.clearTimeout;
var nativeSetInterval = globalThis.setInterval;
var nativeSetTimeout = globalThis.setTimeout;
var nativeURL = globalThis.URL;
var nativeWindow = globalThis.window;
var MockWindow = class {
	constructor(html = null) {
		if (html !== false) {
			this.document = new MockDocument(html, this);
		} else {
			this.document = null;
		}
		this.performance = new MockPerformance();
		this.customElements = new MockCustomElementRegistry(this);
		this.console = createConsole();
		resetWindowDefaults(this);
		resetWindowDimensions(this);
	}
	addEventListener(type, handler) {
		addEventListener(this, type, handler);
	}
	alert(msg) {
		if (this.console) {
			this.console.debug(msg);
		} else {
			console.debug(msg);
		}
	}
	blur() {}
	cancelAnimationFrame(id) {
		this.__clearTimeout.call(nativeWindow || this, id);
	}
	cancelIdleCallback(id) {
		this.__clearTimeout.call(nativeWindow || this, id);
	}
	get CharacterData() {
		if (this.__charDataCstr == null) {
			const ownerDocument = this.document;
			this.__charDataCstr = class extends MockNode2 {
				constructor() {
					super(ownerDocument, 0, 'test', '');
					throw new Error('Illegal constructor: cannot construct CharacterData');
				}
			};
		}
		return this.__charDataCstr;
	}
	set CharacterData(charDataCstr) {
		this.__charDataCstr = charDataCstr;
	}
	clearInterval(id) {
		this.__clearInterval.call(nativeWindow || this, id);
	}
	clearTimeout(id) {
		this.__clearTimeout.call(nativeWindow || this, id);
	}
	close() {
		resetWindow(this);
	}
	confirm() {
		return false;
	}
	get CSS() {
		return {
			supports: () => true,
		};
	}
	get Document() {
		if (this.__docCstr == null) {
			const win2 = this;
			this.__docCstr = class extends MockDocument {
				constructor() {
					super(false, win2);
					throw new Error('Illegal constructor: cannot construct Document');
				}
			};
		}
		return this.__docCstr;
	}
	set Document(docCstr) {
		this.__docCstr = docCstr;
	}
	get DocumentFragment() {
		if (this.__docFragCstr == null) {
			const ownerDocument = this.document;
			this.__docFragCstr = class extends MockDocumentFragment {
				constructor() {
					super(ownerDocument);
					throw new Error('Illegal constructor: cannot construct DocumentFragment');
				}
			};
		}
		return this.__docFragCstr;
	}
	set DocumentFragment(docFragCstr) {
		this.__docFragCstr = docFragCstr;
	}
	get ShadowRoot() {
		return MockShadowRoot;
	}
	get DocumentType() {
		if (this.__docTypeCstr == null) {
			const ownerDocument = this.document;
			this.__docTypeCstr = class extends MockNode2 {
				constructor() {
					super(ownerDocument, 0, 'test', '');
					throw new Error('Illegal constructor: cannot construct DocumentType');
				}
			};
		}
		return this.__docTypeCstr;
	}
	set DocumentType(docTypeCstr) {
		this.__docTypeCstr = docTypeCstr;
	}
	get DOMTokenList() {
		if (this.__domTokenListCstr == null) {
			this.__domTokenListCstr = class MockDOMTokenList {};
		}
		return this.__domTokenListCstr;
	}
	set DOMTokenList(domTokenListCstr) {
		this.__domTokenListCstr = domTokenListCstr;
	}
	dispatchEvent(ev) {
		return dispatchEvent(this, ev);
	}
	get Element() {
		if (this.__elementCstr == null) {
			const ownerDocument = this.document;
			this.__elementCstr = class extends MockElement {
				constructor() {
					super(ownerDocument, '');
					throw new Error('Illegal constructor: cannot construct Element');
				}
			};
		}
		return this.__elementCstr;
	}
	fetch(input, init) {
		if (typeof fetch === 'function') {
			return fetch(input, init);
		}
		throw new Error(`fetch() not implemented`);
	}
	focus() {}
	getComputedStyle(_) {
		return {
			cssText: '',
			length: 0,
			parentRule: null,
			getPropertyPriority() {
				return null;
			},
			getPropertyValue() {
				return '';
			},
			item() {
				return null;
			},
			removeProperty() {
				return null;
			},
			setProperty() {
				return null;
			},
		};
	}
	get globalThis() {
		return this;
	}
	get history() {
		if (this.__history == null) {
			this.__history = new MockHistory();
		}
		return this.__history;
	}
	set history(hsty) {
		this.__history = hsty;
	}
	get JSON() {
		return JSON;
	}
	get HTMLElement() {
		if (this.__htmlElementCstr == null) {
			const ownerDocument = this.document;
			this.__htmlElementCstr = class extends MockHTMLElement {
				constructor() {
					super(ownerDocument, '');
					const observedAttributes = this.constructor.observedAttributes;
					if (Array.isArray(observedAttributes) && typeof this.attributeChangedCallback === 'function') {
						observedAttributes.forEach((attrName) => {
							const attrValue = this.getAttribute(attrName);
							if (attrValue != null) {
								this.attributeChangedCallback(attrName, null, attrValue);
							}
						});
					}
				}
			};
		}
		return this.__htmlElementCstr;
	}
	set HTMLElement(htmlElementCstr) {
		this.__htmlElementCstr = htmlElementCstr;
	}
	get IntersectionObserver() {
		return MockIntersectionObserver;
	}
	get ResizeObserver() {
		return MockResizeObserver;
	}
	get localStorage() {
		if (this.__localStorage == null) {
			this.__localStorage = new MockStorage();
		}
		return this.__localStorage;
	}
	set localStorage(locStorage) {
		this.__localStorage = locStorage;
	}
	get location() {
		if (this.__location == null) {
			this.__location = new MockLocation();
		}
		return this.__location;
	}
	set location(val) {
		if (typeof val === 'string') {
			if (this.__location == null) {
				this.__location = new MockLocation();
			}
			this.__location.href = val;
		} else {
			this.__location = val;
		}
	}
	matchMedia(media) {
		return {
			media,
			matches: false,
			addListener: (_handler) => {},
			removeListener: (_handler) => {},
			addEventListener: (_type, _handler) => {},
			removeEventListener: (_type, _handler) => {},
			dispatchEvent: (_ev) => {},
			onchange: null,
		};
	}
	get Node() {
		if (this.__nodeCstr == null) {
			const ownerDocument = this.document;
			this.__nodeCstr = class extends MockNode2 {
				constructor() {
					super(ownerDocument, 0, 'test', '');
					throw new Error('Illegal constructor: cannot construct Node');
				}
			};
		}
		return this.__nodeCstr;
	}
	get NodeList() {
		if (this.__nodeListCstr == null) {
			const ownerDocument = this.document;
			this.__nodeListCstr = class extends MockNodeList {
				constructor() {
					super(ownerDocument, [], 0);
					throw new Error('Illegal constructor: cannot construct NodeList');
				}
			};
		}
		return this.__nodeListCstr;
	}
	get navigator() {
		if (this.__navigator == null) {
			this.__navigator = new MockNavigator();
		}
		return this.__navigator;
	}
	set navigator(nav) {
		this.__navigator = nav;
	}
	get parent() {
		return null;
	}
	prompt() {
		return '';
	}
	open() {
		return null;
	}
	get origin() {
		return this.location.origin;
	}
	removeEventListener(type, handler) {
		removeEventListener(this, type, handler);
	}
	requestAnimationFrame(callback) {
		return this.setTimeout(() => {
			callback(Date.now());
		}, 0);
	}
	requestIdleCallback(callback) {
		return this.setTimeout(() => {
			callback({
				didTimeout: false,
				timeRemaining: () => 0,
			});
		}, 0);
	}
	scroll(_x, _y) {}
	scrollBy(_x, _y) {}
	scrollTo(_x, _y) {}
	get self() {
		return this;
	}
	get sessionStorage() {
		if (this.__sessionStorage == null) {
			this.__sessionStorage = new MockStorage();
		}
		return this.__sessionStorage;
	}
	set sessionStorage(locStorage) {
		this.__sessionStorage = locStorage;
	}
	setInterval(callback, ms, ...args) {
		if (this.__timeouts == null) {
			this.__timeouts = /* @__PURE__ */ new Set();
		}
		ms = Math.min(ms, this.__maxTimeout);
		if (this.__allowInterval) {
			const intervalId = this.__setInterval(() => {
				if (this.__timeouts) {
					this.__timeouts.delete(intervalId);
					try {
						callback(...args);
					} catch (e) {
						if (this.console) {
							this.console.error(e);
						} else {
							console.error(e);
						}
					}
				}
			}, ms);
			if (this.__timeouts) {
				this.__timeouts.add(intervalId);
			}
			return intervalId;
		}
		const timeoutId = this.__setTimeout.call(
			nativeWindow || this,
			() => {
				if (this.__timeouts) {
					this.__timeouts.delete(timeoutId);
					try {
						callback(...args);
					} catch (e) {
						if (this.console) {
							this.console.error(e);
						} else {
							console.error(e);
						}
					}
				}
			},
			ms,
		);
		if (this.__timeouts) {
			this.__timeouts.add(timeoutId);
		}
		return timeoutId;
	}
	setTimeout(callback, ms, ...args) {
		if (this.__timeouts == null) {
			this.__timeouts = /* @__PURE__ */ new Set();
		}
		ms = Math.min(ms, this.__maxTimeout);
		const timeoutId = this.__setTimeout.call(
			nativeWindow || this,
			() => {
				if (this.__timeouts) {
					this.__timeouts.delete(timeoutId);
					try {
						callback(...args);
					} catch (e) {
						if (this.console) {
							this.console.error(e);
						} else {
							console.error(e);
						}
					}
				}
			},
			ms,
		);
		if (this.__timeouts) {
			this.__timeouts.add(timeoutId);
		}
		return timeoutId;
	}
	get top() {
		return this;
	}
	get window() {
		return this;
	}
	onanimationstart() {}
	onanimationend() {}
	onanimationiteration() {}
	onabort() {}
	onauxclick() {}
	onbeforecopy() {}
	onbeforecut() {}
	onbeforepaste() {}
	onblur() {}
	oncancel() {}
	oncanplay() {}
	oncanplaythrough() {}
	onchange() {}
	onclick() {}
	onclose() {}
	oncontextmenu() {}
	oncopy() {}
	oncuechange() {}
	oncut() {}
	ondblclick() {}
	ondrag() {}
	ondragend() {}
	ondragenter() {}
	ondragleave() {}
	ondragover() {}
	ondragstart() {}
	ondrop() {}
	ondurationchange() {}
	onemptied() {}
	onended() {}
	onerror() {}
	onfocus() {}
	onfocusin() {}
	onfocusout() {}
	onformdata() {}
	onfullscreenchange() {}
	onfullscreenerror() {}
	ongotpointercapture() {}
	oninput() {}
	oninvalid() {}
	onkeydown() {}
	onkeypress() {}
	onkeyup() {}
	onload() {}
	onloadeddata() {}
	onloadedmetadata() {}
	onloadstart() {}
	onlostpointercapture() {}
	onmousedown() {}
	onmouseenter() {}
	onmouseleave() {}
	onmousemove() {}
	onmouseout() {}
	onmouseover() {}
	onmouseup() {}
	onmousewheel() {}
	onpaste() {}
	onpause() {}
	onplay() {}
	onplaying() {}
	onpointercancel() {}
	onpointerdown() {}
	onpointerenter() {}
	onpointerleave() {}
	onpointermove() {}
	onpointerout() {}
	onpointerover() {}
	onpointerup() {}
	onprogress() {}
	onratechange() {}
	onreset() {}
	onresize() {}
	onscroll() {}
	onsearch() {}
	onseeked() {}
	onseeking() {}
	onselect() {}
	onselectstart() {}
	onstalled() {}
	onsubmit() {}
	onsuspend() {}
	ontimeupdate() {}
	ontoggle() {}
	onvolumechange() {}
	onwaiting() {}
	onwebkitfullscreenchange() {}
	onwebkitfullscreenerror() {}
	onwheel() {}
};
addGlobalsToWindowPrototype(MockWindow.prototype);
function resetWindowDefaults(win2) {
	win2.__clearInterval = nativeClearInterval;
	win2.__clearTimeout = nativeClearTimeout;
	win2.__setInterval = nativeSetInterval;
	win2.__setTimeout = nativeSetTimeout;
	win2.__maxTimeout = 6e4;
	win2.__allowInterval = true;
	win2.URL = nativeURL;
}
function cloneWindow(srcWin, opts = {}) {
	if (srcWin == null) {
		return null;
	}
	const clonedWin = new MockWindow(false);
	if (!opts.customElementProxy) {
		srcWin.customElements = null;
	}
	if (srcWin.document != null) {
		const clonedDoc = new MockDocument(false, clonedWin);
		clonedWin.document = clonedDoc;
		clonedDoc.documentElement = srcWin.document.documentElement.cloneNode(true);
	} else {
		clonedWin.document = new MockDocument(null, clonedWin);
	}
	return clonedWin;
}
function constrainTimeouts(win2) {
	win2.__allowInterval = false;
	win2.__maxTimeout = 0;
}
function resetWindow(win2) {
	if (win2 != null) {
		if (win2.__timeouts) {
			win2.__timeouts.forEach((timeoutId) => {
				nativeClearInterval(timeoutId);
				nativeClearTimeout(timeoutId);
			});
			win2.__timeouts.clear();
		}
		if (win2.customElements && win2.customElements.clear) {
			win2.customElements.clear();
		}
		resetDocument(win2.document);
		resetPerformance(win2.performance);
		for (const key in win2) {
			if (win2.hasOwnProperty(key) && key !== 'document' && key !== 'performance' && key !== 'customElements') {
				delete win2[key];
			}
		}
		resetWindowDefaults(win2);
		resetWindowDimensions(win2);
		resetEventListeners(win2);
		if (win2.document != null) {
			try {
				win2.document.defaultView = win2;
			} catch (e) {}
		}
		win2.fetch = null;
		win2.Headers = null;
		win2.Request = null;
		win2.Response = null;
		win2.FetchError = null;
	}
}
function resetWindowDimensions(win2) {
	try {
		win2.devicePixelRatio = 1;
		win2.innerHeight = 768;
		win2.innerWidth = 1366;
		win2.pageXOffset = 0;
		win2.pageYOffset = 0;
		win2.screenLeft = 0;
		win2.screenTop = 0;
		win2.screenX = 0;
		win2.screenY = 0;
		win2.scrollX = 0;
		win2.scrollY = 0;
		win2.screen = {
			availHeight: win2.innerHeight,
			availLeft: 0,
			availTop: 0,
			availWidth: win2.innerWidth,
			colorDepth: 24,
			height: win2.innerHeight,
			keepAwake: false,
			orientation: {
				angle: 0,
				type: 'portrait-primary',
			},
			pixelDepth: 24,
			width: win2.innerWidth,
		};
	} catch (e) {}
}

// src/mock-doc/document.ts
var MockDocument = class _MockDocument extends MockHTMLElement {
	constructor(html = null, win2 = null) {
		super(null, null);
		this.nodeName = '#document' /* DOCUMENT_NODE */;
		this.nodeType = 9 /* DOCUMENT_NODE */;
		this.defaultView = win2;
		this.cookie = '';
		this.referrer = '';
		this.appendChild(this.createDocumentTypeNode());
		if (typeof html === 'string') {
			const parsedDoc = parseDocumentUtil(this, html);
			const documentElement = parsedDoc.children.find((elm) => elm.nodeName === 'HTML');
			if (documentElement != null) {
				this.appendChild(documentElement);
				setOwnerDocument(documentElement, this);
			}
		} else if (html !== false) {
			const documentElement = new MockHTMLElement(this, 'html');
			this.appendChild(documentElement);
			documentElement.appendChild(new MockHTMLElement(this, 'head'));
			documentElement.appendChild(new MockHTMLElement(this, 'body'));
		}
	}
	get dir() {
		return this.documentElement.dir;
	}
	set dir(value) {
		this.documentElement.dir = value;
	}
	get localName() {
		throw new Error('Unimplemented');
	}
	get location() {
		if (this.defaultView != null) {
			return this.defaultView.location;
		}
		return null;
	}
	set location(val) {
		if (this.defaultView != null) {
			this.defaultView.location = val;
		}
	}
	get baseURI() {
		const baseNode = this.head.childNodes.find((node) => node.nodeName === 'BASE');
		if (baseNode) {
			return baseNode.href;
		}
		return this.URL;
	}
	get URL() {
		return this.location.href;
	}
	get styleSheets() {
		return this.querySelectorAll('style');
	}
	get scripts() {
		return this.querySelectorAll('script');
	}
	get forms() {
		return this.querySelectorAll('form');
	}
	get images() {
		return this.querySelectorAll('img');
	}
	get scrollingElement() {
		return this.documentElement;
	}
	get documentElement() {
		for (let i = this.childNodes.length - 1; i >= 0; i--) {
			if (this.childNodes[i].nodeName === 'HTML') {
				return this.childNodes[i];
			}
		}
		const documentElement = new MockHTMLElement(this, 'html');
		this.appendChild(documentElement);
		return documentElement;
	}
	set documentElement(documentElement) {
		for (let i = this.childNodes.length - 1; i >= 0; i--) {
			if (this.childNodes[i].nodeType !== 10 /* DOCUMENT_TYPE_NODE */) {
				this.childNodes[i].remove();
			}
		}
		if (documentElement != null) {
			this.appendChild(documentElement);
			setOwnerDocument(documentElement, this);
		}
	}
	get head() {
		const documentElement = this.documentElement;
		for (let i = 0; i < documentElement.childNodes.length; i++) {
			if (documentElement.childNodes[i].nodeName === 'HEAD') {
				return documentElement.childNodes[i];
			}
		}
		const head = new MockHTMLElement(this, 'head');
		documentElement.insertBefore(head, documentElement.firstChild);
		return head;
	}
	set head(head) {
		const documentElement = this.documentElement;
		for (let i = documentElement.childNodes.length - 1; i >= 0; i--) {
			if (documentElement.childNodes[i].nodeName === 'HEAD') {
				documentElement.childNodes[i].remove();
			}
		}
		if (head != null) {
			documentElement.insertBefore(head, documentElement.firstChild);
			setOwnerDocument(head, this);
		}
	}
	get body() {
		const documentElement = this.documentElement;
		for (let i = documentElement.childNodes.length - 1; i >= 0; i--) {
			if (documentElement.childNodes[i].nodeName === 'BODY') {
				return documentElement.childNodes[i];
			}
		}
		const body = new MockHTMLElement(this, 'body');
		documentElement.appendChild(body);
		return body;
	}
	set body(body) {
		const documentElement = this.documentElement;
		for (let i = documentElement.childNodes.length - 1; i >= 0; i--) {
			if (documentElement.childNodes[i].nodeName === 'BODY') {
				documentElement.childNodes[i].remove();
			}
		}
		if (body != null) {
			documentElement.appendChild(body);
			setOwnerDocument(body, this);
		}
	}
	appendChild(newNode) {
		newNode.remove();
		newNode.parentNode = this;
		this.childNodes.push(newNode);
		return newNode;
	}
	createComment(data) {
		return new MockComment(this, data);
	}
	createAttribute(attrName) {
		return new MockAttr(attrName.toLowerCase(), '');
	}
	createAttributeNS(namespaceURI, attrName) {
		return new MockAttr(attrName, '', namespaceURI);
	}
	createElement(tagName) {
		if (tagName === '#document' /* DOCUMENT_NODE */) {
			const doc = new _MockDocument(false);
			doc.nodeName = tagName;
			doc.parentNode = null;
			return doc;
		}
		return createElement(this, tagName);
	}
	createElementNS(namespaceURI, tagName) {
		const elmNs = createElementNS(this, namespaceURI, tagName);
		return elmNs;
	}
	createTextNode(text) {
		return new MockTextNode(this, text);
	}
	createDocumentFragment() {
		return new MockDocumentFragment(this);
	}
	createDocumentTypeNode() {
		return new MockDocumentTypeNode(this);
	}
	getElementById(id) {
		return getElementById(this, id);
	}
	getElementsByName(elmName) {
		return getElementsByName(this, elmName.toLowerCase());
	}
	get title() {
		const title = this.head.childNodes.find((elm) => elm.nodeName === 'TITLE');
		if (title != null && typeof title.textContent === 'string') {
			return title.textContent.trim();
		}
		return '';
	}
	set title(value) {
		const head = this.head;
		let title = head.childNodes.find((elm) => elm.nodeName === 'TITLE');
		if (title == null) {
			title = this.createElement('title');
			head.appendChild(title);
		}
		title.textContent = value;
	}
};
function resetDocument(doc) {
	if (doc != null) {
		resetEventListeners(doc);
		const documentElement = doc.documentElement;
		if (documentElement != null) {
			resetElement(documentElement);
			for (let i = 0, ii = documentElement.childNodes.length; i < ii; i++) {
				const childNode = documentElement.childNodes[i];
				resetElement(childNode);
				childNode.childNodes.length = 0;
			}
		}
		for (const key in doc) {
			if (doc.hasOwnProperty(key) && !DOC_KEY_KEEPERS.has(key)) {
				delete doc[key];
			}
		}
		try {
			doc.nodeName = '#document' /* DOCUMENT_NODE */;
		} catch (e) {}
		try {
			doc.nodeType = 9 /* DOCUMENT_NODE */;
		} catch (e) {}
		try {
			doc.cookie = '';
		} catch (e) {}
		try {
			doc.referrer = '';
		} catch (e) {}
	}
}
var DOC_KEY_KEEPERS = /* @__PURE__ */ new Set([
	'nodeName',
	'nodeType',
	'nodeValue',
	'ownerDocument',
	'parentNode',
	'childNodes',
	'_shadowRoot',
]);
function getElementById(elm, id) {
	const children = elm.children;
	for (let i = 0, ii = children.length; i < ii; i++) {
		const childElm = children[i];
		if (childElm.id === id) {
			return childElm;
		}
		const childElmFound = getElementById(childElm, id);
		if (childElmFound != null) {
			return childElmFound;
		}
	}
	return null;
}
function getElementsByName(elm, elmName, foundElms = []) {
	const children = elm.children;
	for (let i = 0, ii = children.length; i < ii; i++) {
		const childElm = children[i];
		if (childElm.name && childElm.name.toLowerCase() === elmName) {
			foundElms.push(childElm);
		}
		getElementsByName(childElm, elmName, foundElms);
	}
	return foundElms;
}
function setOwnerDocument(elm, ownerDocument) {
	for (let i = 0, ii = elm.childNodes.length; i < ii; i++) {
		elm.childNodes[i].ownerDocument = ownerDocument;
		if (elm.childNodes[i].nodeType === 1 /* ELEMENT_NODE */) {
			setOwnerDocument(elm.childNodes[i], ownerDocument);
		}
	}
}

// src/hydrate/runner/create-window.ts
var templateWindows = /* @__PURE__ */ new Map();
function createWindowFromHtml(templateHtml, uniqueId) {
	let templateWindow = templateWindows.get(uniqueId);
	if (templateWindow == null) {
		templateWindow = new MockWindow(templateHtml);
		templateWindows.set(uniqueId, templateWindow);
	}
	const win2 = cloneWindow(templateWindow);
	return win2;
}
var Build = {
	isDev: BUILD.isDev ? true : false,
	isBrowser: true,
	isServer: false,
	isTesting: BUILD.isTesting ? true : false,
};

// src/utils/constants.ts
var PrimitiveType = /* @__PURE__ */ ((PrimitiveType2) => {
	PrimitiveType2['Undefined'] = 'undefined';
	PrimitiveType2['Null'] = 'null';
	PrimitiveType2['String'] = 'string';
	PrimitiveType2['Number'] = 'number';
	PrimitiveType2['SpecialNumber'] = 'number';
	PrimitiveType2['Boolean'] = 'boolean';
	PrimitiveType2['BigInt'] = 'bigint';
	return PrimitiveType2;
})(PrimitiveType || {});
var NonPrimitiveType = /* @__PURE__ */ ((NonPrimitiveType2) => {
	NonPrimitiveType2['Array'] = 'array';
	NonPrimitiveType2['Date'] = 'date';
	NonPrimitiveType2['Map'] = 'map';
	NonPrimitiveType2['Object'] = 'object';
	NonPrimitiveType2['RegularExpression'] = 'regexp';
	NonPrimitiveType2['Set'] = 'set';
	NonPrimitiveType2['Channel'] = 'channel';
	NonPrimitiveType2['Symbol'] = 'symbol';
	return NonPrimitiveType2;
})(NonPrimitiveType || {});
var TYPE_CONSTANT = 'type';
var VALUE_CONSTANT = 'value';
var SERIALIZED_PREFIX = 'serialized:';
var STENCIL_DEV_MODE = BUILD.isTesting
	? ['STENCIL:']
	: [
			'%cstencil',
			'color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px',
		];
var win = typeof window !== 'undefined' ? window : {};
var H = win.HTMLElement || class {};
var supportsShadow = BUILD.shadowDom;
var supportsConstructableStylesheets = BUILD.constructableCSS
	? /* @__PURE__ */ (() => {
			try {
				new CSSStyleSheet();
				return typeof new CSSStyleSheet().replaceSync === 'function';
			} catch (e) {}
			return false;
		})()
	: false;

// src/utils/helpers.ts
var isString = (v) => typeof v === 'string';

// src/utils/local-value.ts
var LocalValue = class _LocalValue {
	constructor(type, value) {
		if (type === 'undefined' /* Undefined */ || type === 'null' /* Null */) {
			this.type = type;
		} else {
			this.type = type;
			this.value = value;
		}
	}
	/**
	 * Creates a new LocalValue object with a string value.
	 *
	 * @param {string} value - The string value to be stored in the LocalValue object.
	 * @returns {LocalValue} - The created LocalValue object.
	 */
	static createStringValue(value) {
		return new _LocalValue('string' /* String */, value);
	}
	/**
	 * Creates a new LocalValue object with a number value.
	 *
	 * @param {number} value - The number value.
	 * @returns {LocalValue} - The created LocalValue object.
	 */
	static createNumberValue(value) {
		return new _LocalValue('number' /* Number */, value);
	}
	/**
	 * Creates a new LocalValue object with a special number value.
	 *
	 * @param {number} value - The value of the special number.
	 * @returns {LocalValue} - The created LocalValue object.
	 */
	static createSpecialNumberValue(value) {
		if (Number.isNaN(value)) {
			return new _LocalValue('number' /* SpecialNumber */, 'NaN');
		}
		if (Object.is(value, -0)) {
			return new _LocalValue('number' /* SpecialNumber */, '-0');
		}
		if (value === Infinity) {
			return new _LocalValue('number' /* SpecialNumber */, 'Infinity');
		}
		if (value === -Infinity) {
			return new _LocalValue('number' /* SpecialNumber */, '-Infinity');
		}
		return new _LocalValue('number' /* SpecialNumber */, value);
	}
	/**
	 * Creates a new LocalValue object with an undefined value.
	 * @returns {LocalValue} - The created LocalValue object.
	 */
	static createUndefinedValue() {
		return new _LocalValue('undefined' /* Undefined */);
	}
	/**
	 * Creates a new LocalValue object with a null value.
	 * @returns {LocalValue} - The created LocalValue object.
	 */
	static createNullValue() {
		return new _LocalValue('null' /* Null */);
	}
	/**
	 * Creates a new LocalValue object with a boolean value.
	 *
	 * @param {boolean} value - The boolean value.
	 * @returns {LocalValue} - The created LocalValue object.
	 */
	static createBooleanValue(value) {
		return new _LocalValue('boolean' /* Boolean */, value);
	}
	/**
	 * Creates a new LocalValue object with a BigInt value.
	 *
	 * @param {BigInt} value - The BigInt value.
	 * @returns {LocalValue} - The created LocalValue object.
	 */
	static createBigIntValue(value) {
		return new _LocalValue('bigint' /* BigInt */, value.toString());
	}
	/**
	 * Creates a new LocalValue object with an array.
	 *
	 * @param {Array} value - The array.
	 * @returns {LocalValue} - The created LocalValue object.
	 */
	static createArrayValue(value) {
		return new _LocalValue('array' /* Array */, value);
	}
	/**
	 * Creates a new LocalValue object with date value.
	 *
	 * @param {string} value - The date.
	 * @returns {LocalValue} - The created LocalValue object.
	 */
	static createDateValue(value) {
		return new _LocalValue('date' /* Date */, value);
	}
	/**
	 * Creates a new LocalValue object of map value.
	 * @param {Map} map - The map.
	 * @returns {LocalValue} - The created LocalValue object.
	 */
	static createMapValue(map2) {
		const value = [];
		Array.from(map2.entries()).forEach(([key, val]) => {
			value.push([_LocalValue.getArgument(key), _LocalValue.getArgument(val)]);
		});
		return new _LocalValue('map' /* Map */, value);
	}
	/**
	 * Creates a new LocalValue object from the passed object.
	 *
	 * @param object the object to create a LocalValue from
	 * @returns {LocalValue} - The created LocalValue object.
	 */
	static createObjectValue(object) {
		const value = [];
		Object.entries(object).forEach(([key, val]) => {
			value.push([key, _LocalValue.getArgument(val)]);
		});
		return new _LocalValue('object' /* Object */, value);
	}
	/**
	 * Creates a new LocalValue object of regular expression value.
	 *
	 * @param {string} value - The value of the regular expression.
	 * @returns {LocalValue} - The created LocalValue object.
	 */
	static createRegularExpressionValue(value) {
		return new _LocalValue('regexp' /* RegularExpression */, value);
	}
	/**
	 * Creates a new LocalValue object with the specified value.
	 * @param {Set} value - The value to be set.
	 * @returns {LocalValue} - The created LocalValue object.
	 */
	static createSetValue(value) {
		return new _LocalValue('set' /* Set */, value);
	}
	/**
	 * Creates a new LocalValue object with the given channel value
	 *
	 * @param {ChannelValue} value - The channel value.
	 * @returns {LocalValue} - The created LocalValue object.
	 */
	static createChannelValue(value) {
		return new _LocalValue('channel' /* Channel */, value);
	}
	/**
	 * Creates a new LocalValue object with a Symbol value.
	 *
	 * @param {Symbol} symbol - The Symbol value
	 * @returns {LocalValue} - The created LocalValue object
	 */
	static createSymbolValue(symbol) {
		const description = symbol.description || 'Symbol()';
		return new _LocalValue('symbol' /* Symbol */, description);
	}
	static getArgument(argument) {
		const type = typeof argument;
		switch (type) {
			case 'string' /* String */:
				return _LocalValue.createStringValue(argument);
			case 'number' /* Number */:
				if (Number.isNaN(argument) || Object.is(argument, -0) || !Number.isFinite(argument)) {
					return _LocalValue.createSpecialNumberValue(argument);
				}
				return _LocalValue.createNumberValue(argument);
			case 'boolean' /* Boolean */:
				return _LocalValue.createBooleanValue(argument);
			case 'bigint' /* BigInt */:
				return _LocalValue.createBigIntValue(argument);
			case 'undefined' /* Undefined */:
				return _LocalValue.createUndefinedValue();
			case 'symbol' /* Symbol */:
				return _LocalValue.createSymbolValue(argument);
			case 'object' /* Object */:
				if (argument === null) {
					return _LocalValue.createNullValue();
				}
				if (argument instanceof Date) {
					return _LocalValue.createDateValue(argument);
				}
				if (argument instanceof Map) {
					const map2 = [];
					argument.forEach((value, key) => {
						const objectKey = typeof key === 'string' ? key : _LocalValue.getArgument(key);
						const objectValue = _LocalValue.getArgument(value);
						map2.push([objectKey, objectValue]);
					});
					return _LocalValue.createMapValue(argument);
				}
				if (argument instanceof Set) {
					const set = [];
					argument.forEach((value) => {
						set.push(_LocalValue.getArgument(value));
					});
					return _LocalValue.createSetValue(set);
				}
				if (argument instanceof Array) {
					const arr = [];
					argument.forEach((value) => {
						arr.push(_LocalValue.getArgument(value));
					});
					return _LocalValue.createArrayValue(arr);
				}
				if (argument instanceof RegExp) {
					return _LocalValue.createRegularExpressionValue({
						pattern: argument.source,
						flags: argument.flags,
					});
				}
				return _LocalValue.createObjectValue(argument);
		}
		throw new Error(`Unsupported type: ${type}`);
	}
	asMap() {
		return {
			[TYPE_CONSTANT]: this.type,
			...(!((this.type === 'null' /* Null */ || this.type === 'undefined') /* Undefined */)
				? { [VALUE_CONSTANT]: this.value }
				: {}),
		};
	}
};

// src/utils/message-utils.ts
var catchError = (diagnostics, err2, msg) => {
	const diagnostic = {
		level: 'error',
		type: 'build',
		header: 'Build Error',
		messageText: 'build error',
		lines: [],
	};
	if (isString(msg)) {
		diagnostic.messageText = msg.length ? msg : 'UNKNOWN ERROR';
	} else if (err2 != null) {
		if (err2.stack != null) {
			diagnostic.messageText = err2.stack.toString();
		} else {
			if (err2.message != null) {
				diagnostic.messageText = err2.message.length ? err2.message : 'UNKNOWN ERROR';
			} else {
				diagnostic.messageText = err2.toString();
			}
		}
	}
	if (diagnostics != null && !shouldIgnoreError(diagnostic.messageText)) {
		diagnostics.push(diagnostic);
	}
	return diagnostic;
};
var hasError = (diagnostics) => {
	if (diagnostics == null || diagnostics.length === 0) {
		return false;
	}
	return diagnostics.some((d) => d.level === 'error' && d.type !== 'runtime');
};
var shouldIgnoreError = (msg) => {
	return msg === TASK_CANCELED_MSG;
};
var TASK_CANCELED_MSG = `task canceled`;

// src/utils/regular-expression.ts
var escapeRegExpSpecialCharacters = (text) => {
	return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
};

// src/utils/remote-value.ts
var RemoteValue = class _RemoteValue {
	/**
	 * Deserializes a LocalValue serialized object back to its original JavaScript representation
	 *
	 * @param serialized The serialized LocalValue object
	 * @returns The original JavaScript value/object
	 */
	static fromLocalValue(serialized) {
		const type = serialized[TYPE_CONSTANT];
		const value = VALUE_CONSTANT in serialized ? serialized[VALUE_CONSTANT] : void 0;
		switch (type) {
			case 'string' /* String */:
				return value;
			case 'boolean' /* Boolean */:
				return value;
			case 'bigint' /* BigInt */:
				return BigInt(value);
			case 'undefined' /* Undefined */:
				return void 0;
			case 'null' /* Null */:
				return null;
			case 'number' /* Number */:
				if (value === 'NaN') return NaN;
				if (value === '-0') return -0;
				if (value === 'Infinity') return Infinity;
				if (value === '-Infinity') return -Infinity;
				return value;
			case 'array' /* Array */:
				return value.map((item) => _RemoteValue.fromLocalValue(item));
			case 'date' /* Date */:
				return new Date(value);
			case 'map' /* Map */:
				const map2 = /* @__PURE__ */ new Map();
				for (const [key, val] of value) {
					const deserializedKey = typeof key === 'object' && key !== null ? _RemoteValue.fromLocalValue(key) : key;
					const deserializedValue = _RemoteValue.fromLocalValue(val);
					map2.set(deserializedKey, deserializedValue);
				}
				return map2;
			case 'object' /* Object */:
				const obj = {};
				for (const [key, val] of value) {
					obj[key] = _RemoteValue.fromLocalValue(val);
				}
				return obj;
			case 'regexp' /* RegularExpression */:
				const { pattern, flags } = value;
				return new RegExp(pattern, flags);
			case 'set' /* Set */:
				const set = /* @__PURE__ */ new Set();
				for (const item of value) {
					set.add(_RemoteValue.fromLocalValue(item));
				}
				return set;
			case 'symbol' /* Symbol */:
				return Symbol(value);
			default:
				throw new Error(`Unsupported type: ${type}`);
		}
	}
	/**
	 * Utility method to deserialize multiple LocalValues at once
	 *
	 * @param serializedValues Array of serialized LocalValue objects
	 * @returns Array of deserialized JavaScript values
	 */
	static fromLocalValueArray(serializedValues) {
		return serializedValues.map((value) => _RemoteValue.fromLocalValue(value));
	}
	/**
	 * Verifies if the given object matches the structure of a serialized LocalValue
	 *
	 * @param obj Object to verify
	 * @returns boolean indicating if the object has LocalValue structure
	 */
	static isLocalValueObject(obj) {
		if (typeof obj !== 'object' || obj === null) {
			return false;
		}
		if (!obj.hasOwnProperty(TYPE_CONSTANT)) {
			return false;
		}
		const type = obj[TYPE_CONSTANT];
		const hasTypeProperty = Object.values({ ...PrimitiveType, ...NonPrimitiveType }).includes(type);
		if (!hasTypeProperty) {
			return false;
		}
		if (type !== 'null' /* Null */ && type !== 'undefined' /* Undefined */) {
			return obj.hasOwnProperty(VALUE_CONSTANT);
		}
		return true;
	}
};

// src/utils/result.ts
var result_exports = {};
__export(result_exports, {
	err: () => err,
	map: () => map,
	ok: () => ok,
	unwrap: () => unwrap,
	unwrapErr: () => unwrapErr,
});
var ok = (value) => ({
	isOk: true,
	isErr: false,
	value,
});
var err = (value) => ({
	isOk: false,
	isErr: true,
	value,
});
function map(result, fn) {
	if (result.isOk) {
		const val = fn(result.value);
		if (val instanceof Promise) {
			return val.then((newVal) => ok(newVal));
		} else {
			return ok(val);
		}
	}
	if (result.isErr) {
		const value = result.value;
		return err(value);
	}
	throw 'should never get here';
}
var unwrap = (result) => {
	if (result.isOk) {
		return result.value;
	} else {
		throw result.value;
	}
};
var unwrapErr = (result) => {
	if (result.isErr) {
		return result.value;
	} else {
		throw result.value;
	}
};

// src/utils/serialize.ts
function serializeProperty(value) {
	if (
		['string', 'boolean', 'undefined'].includes(typeof value) ||
		(typeof value === 'number' && value !== Infinity && value !== -Infinity && !isNaN(value))
	) {
		return value;
	}
	const arg = LocalValue.getArgument(value);
	return SERIALIZED_PREFIX + btoa(JSON.stringify(arg));
}
function deserializeProperty(value) {
	if (typeof value !== 'string' || !value.startsWith(SERIALIZED_PREFIX)) {
		return value;
	}
	return RemoteValue.fromLocalValue(JSON.parse(atob(value.slice(SERIALIZED_PREFIX.length))));
}

// src/utils/util.ts
var lowerPathParam = (fn) => (p) => fn(p.toLowerCase());
var isDtsFile = lowerPathParam((p) => p.endsWith('.d.ts') || p.endsWith('.d.mts') || p.endsWith('.d.cts'));
var isTsFile = lowerPathParam((p) => !isDtsFile(p) && (p.endsWith('.ts') || p.endsWith('.mts') || p.endsWith('.cts')));
var isTsxFile = lowerPathParam((p) => p.endsWith('.tsx') || p.endsWith('.mtsx') || p.endsWith('.ctsx'));
var isJsxFile = lowerPathParam((p) => p.endsWith('.jsx') || p.endsWith('.mjsx') || p.endsWith('.cjsx'));
var isJsFile = lowerPathParam((p) => p.endsWith('.js') || p.endsWith('.mjs') || p.endsWith('.cjs'));

// src/utils/shadow-css.ts
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 *
 * This file is a port of shadowCSS from `webcomponents.js` to TypeScript.
 * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js
 * https://github.com/angular/angular/blob/master/packages/compiler/src/shadow_css.ts
 */
var _polyfillHost = '-shadowcsshost';
var _polyfillSlotted = '-shadowcssslotted';
var _polyfillHostContext = '-shadowcsscontext';
var _parenSuffix = ')(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))?([^,{]*)';
var _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');
var _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');
var _cssColonSlottedRe = new RegExp('(' + _polyfillSlotted + _parenSuffix, 'gim');
var _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';
var createSupportsRuleRe = (selector) => {
	const safeSelector = escapeRegExpSpecialCharacters(selector);
	return new RegExp(
		// First capture group: match any context before the selector that's not inside @supports selector()
		// Using negative lookahead to avoid matching inside @supports selector(...) condition
		`(^|[^@]|@(?!supports\\s+selector\\s*\\([^{]*?${safeSelector}))(${safeSelector}\\b)`,
		'g',
	);
};
var _colonSlottedRe = createSupportsRuleRe('::slotted');
var _colonHostRe = createSupportsRuleRe(':host');
var _colonHostContextRe = createSupportsRuleRe(':host-context');

// src/runtime/mode.ts
var setMode = (handler) => modeResolutionChain.push(handler);
var CAPTURE_EVENT_SUFFIX = 'Capture';
var CAPTURE_EVENT_REGEX = new RegExp(CAPTURE_EVENT_SUFFIX + '$');

// src/compiler/html/canonical-link.ts
var updateCanonicalLink = (doc, href) => {
	var _a2;
	let canonicalLinkElm = doc.head.querySelector('link[rel="canonical"]');
	if (typeof href === 'string') {
		if (canonicalLinkElm == null) {
			canonicalLinkElm = doc.createElement('link');
			canonicalLinkElm.setAttribute('rel', 'canonical');
			doc.head.appendChild(canonicalLinkElm);
		}
		canonicalLinkElm.setAttribute('href', href);
	} else {
		if (canonicalLinkElm != null) {
			const existingHref = canonicalLinkElm.getAttribute('href');
			if (!existingHref) {
				(_a2 = canonicalLinkElm.parentNode) == null ? void 0 : _a2.removeChild(canonicalLinkElm);
			}
		}
	}
};

// src/compiler/html/relocate-meta-charset.ts
var relocateMetaCharset = (doc) => {
	const head = doc.head;
	let charsetElm = head.querySelector('meta[charset]');
	if (charsetElm == null) {
		charsetElm = doc.createElement('meta');
		charsetElm.setAttribute('charset', 'utf-8');
	} else {
		charsetElm.remove();
	}
	head.insertBefore(charsetElm, head.firstChild);
};

// src/compiler/style/css-parser/parse-css.ts
var parseCss = (css, filePath) => {
	let lineno = 1;
	let column = 1;
	const diagnostics = [];
	const updatePosition = (str) => {
		const lines = str.match(/\n/g);
		if (lines) lineno += lines.length;
		const i = str.lastIndexOf('\n');
		column = ~i ? str.length - i : column + str.length;
	};
	const position = () => {
		const start = { line: lineno, column };
		return (node) => {
			node.position = new ParsePosition(start);
			whitespace();
			return node;
		};
	};
	const error = (msg) => {
		const srcLines = css.split('\n');
		const d = {
			level: 'error',
			type: 'css',
			language: 'css',
			header: 'CSS Parse',
			messageText: msg,
			absFilePath: filePath,
			lines: [
				{
					lineIndex: lineno - 1,
					lineNumber: lineno,
					errorCharStart: column,
					text: css[lineno - 1],
				},
			],
		};
		if (lineno > 1) {
			const previousLine = {
				lineIndex: lineno - 1,
				lineNumber: lineno - 1,
				text: css[lineno - 2],
				errorCharStart: -1,
				errorLength: -1,
			};
			d.lines.unshift(previousLine);
		}
		if (lineno + 2 < srcLines.length) {
			const nextLine = {
				lineIndex: lineno,
				lineNumber: lineno + 1,
				text: srcLines[lineno],
				errorCharStart: -1,
				errorLength: -1,
			};
			d.lines.push(nextLine);
		}
		diagnostics.push(d);
		return null;
	};
	const stylesheet = () => {
		const rulesList = rules();
		return {
			type: 14 /* StyleSheet */,
			stylesheet: {
				source: filePath,
				rules: rulesList,
			},
		};
	};
	const open = () => match(/^{\s*/);
	const close = () => match(/^}/);
	const match = (re) => {
		const m = re.exec(css);
		if (!m) return;
		const str = m[0];
		updatePosition(str);
		css = css.slice(str.length);
		return m;
	};
	const rules = () => {
		let node;
		const rules2 = [];
		whitespace();
		comments(rules2);
		while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {
			rules2.push(node);
			comments(rules2);
		}
		return rules2;
	};
	const whitespace = () => match(/^\s*/);
	const comments = (rules2) => {
		let c;
		rules2 = rules2 || [];
		while ((c = comment())) {
			rules2.push(c);
		}
		return rules2;
	};
	const comment = () => {
		const pos = position();
		if ('/' !== css.charAt(0) || '*' !== css.charAt(1)) return null;
		let i = 2;
		while ('' !== css.charAt(i) && ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1))) ++i;
		i += 2;
		if ('' === css.charAt(i - 1)) {
			return error('End of comment missing');
		}
		const comment2 = css.slice(2, i - 2);
		column += 2;
		updatePosition(comment2);
		css = css.slice(i);
		column += 2;
		return pos({
			type: 1 /* Comment */,
			comment: comment2,
		});
	};
	const selector = () => {
		const m = match(/^([^{]+)/);
		if (!m) return null;
		return trim(m[0])
			.replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, '')
			.replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, function (m2) {
				return m2.replace(/,/g, '\u200C');
			})
			.split(/\s*(?![^(]*\)),\s*/)
			.map(function (s) {
				return s.replace(/\u200C/g, ',');
			});
	};
	const declaration = () => {
		const pos = position();
		let prop = match(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);
		if (!prop) return null;
		prop = trim(prop[0]);
		if (!match(/^:\s*/)) return error(`property missing ':'`);
		const val = match(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/);
		const ret = pos({
			type: 4 /* Declaration */,
			property: prop.replace(commentre, ''),
			value: val ? trim(val[0]).replace(commentre, '') : '',
		});
		match(/^[;\s]*/);
		return ret;
	};
	const declarations = () => {
		const decls = [];
		if (!open()) return error(`missing '{'`);
		comments(decls);
		let decl;
		while ((decl = declaration())) {
			decls.push(decl);
			comments(decls);
		}
		if (!close()) return error(`missing '}'`);
		return decls;
	};
	const keyframe = () => {
		let m;
		const values = [];
		const pos = position();
		while ((m = match(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/))) {
			values.push(m[1]);
			match(/^,\s*/);
		}
		if (!values.length) return null;
		return pos({
			type: 9 /* KeyFrame */,
			values,
			declarations: declarations(),
		});
	};
	const atkeyframes = () => {
		const pos = position();
		let m = match(/^@([-\w]+)?keyframes\s*/);
		if (!m) return null;
		const vendor = m[1];
		m = match(/^([-\w]+)\s*/);
		if (!m) return error(`@keyframes missing name`);
		const name = m[1];
		if (!open()) return error(`@keyframes missing '{'`);
		let frame;
		let frames = comments();
		while ((frame = keyframe())) {
			frames.push(frame);
			frames = frames.concat(comments());
		}
		if (!close()) return error(`@keyframes missing '}'`);
		return pos({
			type: 8 /* KeyFrames */,
			name,
			vendor,
			keyframes: frames,
		});
	};
	const atsupports = () => {
		const pos = position();
		const m = match(/^@supports *([^{]+)/);
		if (!m) return null;
		const supports = trim(m[1]);
		if (!open()) return error(`@supports missing '{'`);
		const style = comments().concat(rules());
		if (!close()) return error(`@supports missing '}'`);
		return pos({
			type: 15 /* Supports */,
			supports,
			rules: style,
		});
	};
	const athost = () => {
		const pos = position();
		const m = match(/^@host\s*/);
		if (!m) return null;
		if (!open()) return error(`@host missing '{'`);
		const style = comments().concat(rules());
		if (!close()) return error(`@host missing '}'`);
		return pos({
			type: 6 /* Host */,
			rules: style,
		});
	};
	const atmedia = () => {
		const pos = position();
		const m = match(/^@media *([^{]+)/);
		if (!m) return null;
		const media = trim(m[1]);
		if (!open()) return error(`@media missing '{'`);
		const style = comments().concat(rules());
		if (!close()) return error(`@media missing '}'`);
		return pos({
			type: 10 /* Media */,
			media,
			rules: style,
		});
	};
	const atcustommedia = () => {
		const pos = position();
		const m = match(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);
		if (!m) return null;
		return pos({
			type: 2 /* CustomMedia */,
			name: trim(m[1]),
			media: trim(m[2]),
		});
	};
	const atpage = () => {
		const pos = position();
		const m = match(/^@page */);
		if (!m) return null;
		const sel = selector() || [];
		if (!open()) return error(`@page missing '{'`);
		let decls = comments();
		let decl;
		while ((decl = declaration())) {
			decls.push(decl);
			decls = decls.concat(comments());
		}
		if (!close()) return error(`@page missing '}'`);
		return pos({
			type: 12 /* Page */,
			selectors: sel,
			declarations: decls,
		});
	};
	const atdocument = () => {
		const pos = position();
		const m = match(/^@([-\w]+)?document *([^{]+)/);
		if (!m) return null;
		const vendor = trim(m[1]);
		const doc = trim(m[2]);
		if (!open()) return error(`@document missing '{'`);
		const style = comments().concat(rules());
		if (!close()) return error(`@document missing '}'`);
		return pos({
			type: 3 /* Document */,
			document: doc,
			vendor,
			rules: style,
		});
	};
	const atfontface = () => {
		const pos = position();
		const m = match(/^@font-face\s*/);
		if (!m) return null;
		if (!open()) return error(`@font-face missing '{'`);
		let decls = comments();
		let decl;
		while ((decl = declaration())) {
			decls.push(decl);
			decls = decls.concat(comments());
		}
		if (!close()) return error(`@font-face missing '}'`);
		return pos({
			type: 5 /* FontFace */,
			declarations: decls,
		});
	};
	const compileAtrule = (nodeName, nodeType) => {
		const re = new RegExp('^@' + nodeName + '\\s*([^;]+);');
		return () => {
			const pos = position();
			const m = match(re);
			if (!m) return null;
			const node = {
				type: nodeType,
			};
			node[nodeName] = m[1].trim();
			return pos(node);
		};
	};
	const atimport = compileAtrule('import', 7 /* Import */);
	const atcharset = compileAtrule('charset', 0 /* Charset */);
	const atnamespace = compileAtrule('namespace', 11 /* Namespace */);
	const atrule = () => {
		if (css[0] !== '@') return null;
		return (
			atkeyframes() ||
			atmedia() ||
			atcustommedia() ||
			atsupports() ||
			atimport() ||
			atcharset() ||
			atnamespace() ||
			atdocument() ||
			atpage() ||
			athost() ||
			atfontface()
		);
	};
	const rule = () => {
		const pos = position();
		const sel = selector();
		if (!sel) return error('selector missing');
		comments();
		return pos({
			type: 13 /* Rule */,
			selectors: sel,
			declarations: declarations(),
		});
	};
	class ParsePosition {
		constructor(start) {
			this.start = start;
			this.end = { line: lineno, column };
			this.source = filePath;
		}
	}
	ParsePosition.prototype.content = css;
	return {
		diagnostics,
		...addParent(stylesheet()),
	};
};
var trim = (str) => (str ? str.trim() : '');
var addParent = (obj, parent) => {
	const isNode = obj && typeof obj.type === 'string';
	const childParent = isNode ? obj : parent;
	for (const k in obj) {
		const value = obj[k];
		if (Array.isArray(value)) {
			value.forEach(function (v) {
				addParent(v, childParent);
			});
		} else if (value && typeof value === 'object') {
			addParent(value, childParent);
		}
	}
	if (isNode) {
		Object.defineProperty(obj, 'parent', {
			configurable: true,
			writable: true,
			enumerable: false,
			value: parent || null,
		});
	}
	return obj;
};
var commentre = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;

// src/compiler/style/css-parser/get-css-selectors.ts
var getCssSelectors = (sel) => {
	SELECTORS.all.length =
		SELECTORS.tags.length =
		SELECTORS.classNames.length =
		SELECTORS.ids.length =
		SELECTORS.attrs.length =
			0;
	sel = sel
		.replace(/\./g, ' .')
		.replace(/\#/g, ' #')
		.replace(/\[/g, ' [')
		.replace(/\>/g, ' > ')
		.replace(/\+/g, ' + ')
		.replace(/\~/g, ' ~ ')
		.replace(/\*/g, ' * ')
		.replace(/\:not\((.*?)\)/g, ' ');
	const items = sel.split(' ');
	for (let i = 0, l = items.length; i < l; i++) {
		items[i] = items[i].split(':')[0];
		if (items[i].length === 0) continue;
		if (items[i].charAt(0) === '.') {
			SELECTORS.classNames.push(items[i].slice(1));
		} else if (items[i].charAt(0) === '#') {
			SELECTORS.ids.push(items[i].slice(1));
		} else if (items[i].charAt(0) === '[') {
			items[i] = items[i].slice(1).split('=')[0].split(']')[0].trim();
			SELECTORS.attrs.push(items[i].toLowerCase());
		} else if (/[a-z]/g.test(items[i].charAt(0))) {
			SELECTORS.tags.push(items[i].toLowerCase());
		}
	}
	SELECTORS.classNames = SELECTORS.classNames.sort((a, b) => {
		if (a.length < b.length) return -1;
		if (a.length > b.length) return 1;
		return 0;
	});
	return SELECTORS;
};
var SELECTORS = {
	all: [],
	tags: [],
	classNames: [],
	ids: [],
	attrs: [],
};

// src/compiler/style/css-parser/serialize-css.ts
var serializeCss = (stylesheet, serializeOpts) => {
	const usedSelectors = serializeOpts.usedSelectors || null;
	const opts = {
		usedSelectors: usedSelectors || null,
		hasUsedAttrs: !!usedSelectors && usedSelectors.attrs.size > 0,
		hasUsedClassNames: !!usedSelectors && usedSelectors.classNames.size > 0,
		hasUsedIds: !!usedSelectors && usedSelectors.ids.size > 0,
		hasUsedTags: !!usedSelectors && usedSelectors.tags.size > 0,
	};
	const rules = stylesheet.rules;
	if (!rules) {
		return '';
	}
	const rulesLen = rules.length;
	const out = [];
	for (let i = 0; i < rulesLen; i++) {
		out.push(serializeCssVisitNode(opts, rules[i], i, rulesLen));
	}
	return out.join('');
};
var serializeCssVisitNode = (opts, node, index, len) => {
	var _a2;
	const nodeType = node.type;
	if (nodeType === 4 /* Declaration */) {
		return serializeCssDeclaration(node, index, len);
	}
	if (nodeType === 13 /* Rule */) {
		return serializeCssRule(opts, node);
	}
	if (nodeType === 1 /* Comment */) {
		if (((_a2 = node.comment) == null ? void 0 : _a2[0]) === '!') {
			return `/*${node.comment}*/`;
		} else {
			return '';
		}
	}
	if (nodeType === 10 /* Media */) {
		return serializeCssMedia(opts, node);
	}
	if (nodeType === 8 /* KeyFrames */) {
		return serializeCssKeyframes(opts, node);
	}
	if (nodeType === 9 /* KeyFrame */) {
		return serializeCssKeyframe(opts, node);
	}
	if (nodeType === 5 /* FontFace */) {
		return serializeCssFontFace(opts, node);
	}
	if (nodeType === 15 /* Supports */) {
		return serializeCssSupports(opts, node);
	}
	if (nodeType === 7 /* Import */) {
		return '@import ' + node.import + ';';
	}
	if (nodeType === 0 /* Charset */) {
		return '@charset ' + node.charset + ';';
	}
	if (nodeType === 12 /* Page */) {
		return serializeCssPage(opts, node);
	}
	if (nodeType === 6 /* Host */) {
		return '@host{' + serializeCssMapVisit(opts, node.rules) + '}';
	}
	if (nodeType === 2 /* CustomMedia */) {
		return '@custom-media ' + node.name + ' ' + node.media + ';';
	}
	if (nodeType === 3 /* Document */) {
		return serializeCssDocument(opts, node);
	}
	if (nodeType === 11 /* Namespace */) {
		return '@namespace ' + node.namespace + ';';
	}
	return '';
};
var serializeCssRule = (opts, node) => {
	var _a2, _b;
	const decls = node.declarations;
	const usedSelectors = opts.usedSelectors;
	const selectors = (_b = (_a2 = node.selectors) == null ? void 0 : _a2.slice()) != null ? _b : [];
	if (decls == null || decls.length === 0) {
		return '';
	}
	if (usedSelectors) {
		let i;
		let j;
		let include = true;
		for (i = selectors.length - 1; i >= 0; i--) {
			const sel = getCssSelectors(selectors[i]);
			include = true;
			let jlen = sel.classNames.length;
			if (jlen > 0 && opts.hasUsedClassNames) {
				for (j = 0; j < jlen; j++) {
					if (!usedSelectors.classNames.has(sel.classNames[j])) {
						include = false;
						break;
					}
				}
			}
			if (include && opts.hasUsedTags) {
				jlen = sel.tags.length;
				if (jlen > 0) {
					for (j = 0; j < jlen; j++) {
						if (!usedSelectors.tags.has(sel.tags[j])) {
							include = false;
							break;
						}
					}
				}
			}
			if (include && opts.hasUsedAttrs) {
				jlen = sel.attrs.length;
				if (jlen > 0) {
					for (j = 0; j < jlen; j++) {
						if (!usedSelectors.attrs.has(sel.attrs[j])) {
							include = false;
							break;
						}
					}
				}
			}
			if (include && opts.hasUsedIds) {
				jlen = sel.ids.length;
				if (jlen > 0) {
					for (j = 0; j < jlen; j++) {
						if (!usedSelectors.ids.has(sel.ids[j])) {
							include = false;
							break;
						}
					}
				}
			}
			if (!include) {
				selectors.splice(i, 1);
			}
		}
	}
	if (selectors.length === 0) {
		return '';
	}
	const cleanedSelectors = [];
	let cleanedSelector = '';
	if (node.selectors) {
		for (const selector of node.selectors) {
			cleanedSelector = removeSelectorWhitespace(selector);
			if (!cleanedSelectors.includes(cleanedSelector)) {
				cleanedSelectors.push(cleanedSelector);
			}
		}
	}
	return `${cleanedSelectors}{${serializeCssMapVisit(opts, decls)}}`;
};
var serializeCssDeclaration = (node, index, len) => {
	if (node.value === '') {
		return '';
	}
	if (len - 1 === index) {
		return node.property + ':' + node.value;
	}
	return node.property + ':' + node.value + ';';
};
var serializeCssMedia = (opts, node) => {
	const mediaCss = serializeCssMapVisit(opts, node.rules);
	if (mediaCss === '') {
		return '';
	}
	return '@media ' + removeMediaWhitespace(node.media) + '{' + mediaCss + '}';
};
var serializeCssKeyframes = (opts, node) => {
	const keyframesCss = serializeCssMapVisit(opts, node.keyframes);
	if (keyframesCss === '') {
		return '';
	}
	return '@' + (node.vendor || '') + 'keyframes ' + node.name + '{' + keyframesCss + '}';
};
var serializeCssKeyframe = (opts, node) => {
	var _a2, _b;
	return (
		((_b = (_a2 = node.values) == null ? void 0 : _a2.join(',')) != null ? _b : '') +
		'{' +
		serializeCssMapVisit(opts, node.declarations) +
		'}'
	);
};
var serializeCssFontFace = (opts, node) => {
	const fontCss = serializeCssMapVisit(opts, node.declarations);
	if (fontCss === '') {
		return '';
	}
	return '@font-face{' + fontCss + '}';
};
var serializeCssSupports = (opts, node) => {
	const supportsCss = serializeCssMapVisit(opts, node.rules);
	if (supportsCss === '') {
		return '';
	}
	return '@supports ' + node.supports + '{' + supportsCss + '}';
};
var serializeCssPage = (opts, node) => {
	var _a2, _b;
	const sel = (_b = (_a2 = node.selectors) == null ? void 0 : _a2.join(', ')) != null ? _b : '';
	return '@page ' + sel + '{' + serializeCssMapVisit(opts, node.declarations) + '}';
};
var serializeCssDocument = (opts, node) => {
	const documentCss = serializeCssMapVisit(opts, node.rules);
	const doc = '@' + (node.vendor || '') + 'document ' + node.document;
	if (documentCss === '') {
		return '';
	}
	return doc + '{' + documentCss + '}';
};
var serializeCssMapVisit = (opts, nodes) => {
	let rtn = '';
	if (nodes) {
		for (let i = 0, len = nodes.length; i < len; i++) {
			rtn += serializeCssVisitNode(opts, nodes[i], i, len);
		}
	}
	return rtn;
};
var removeSelectorWhitespace = (selector) => {
	let rtn = '';
	let char = '';
	let inAttr = false;
	selector = selector.trim();
	for (let i = 0, l = selector.length; i < l; i++) {
		char = selector[i];
		if (char === '[' && rtn[rtn.length - 1] !== '\\') {
			inAttr = true;
		} else if (char === ']' && rtn[rtn.length - 1] !== '\\') {
			inAttr = false;
		}
		if (!inAttr && CSS_WS_REG.test(char)) {
			if (CSS_NEXT_CHAR_REG.test(selector[i + 1])) {
				continue;
			}
			if (CSS_PREV_CHAR_REG.test(rtn[rtn.length - 1])) {
				continue;
			}
			rtn += ' ';
		} else {
			rtn += char;
		}
	}
	return rtn;
};
var removeMediaWhitespace = (media) => {
	var _a2;
	let rtn = '';
	let char = '';
	media = (_a2 = media == null ? void 0 : media.trim()) != null ? _a2 : '';
	for (let i = 0, l = media.length; i < l; i++) {
		char = media[i];
		if (CSS_WS_REG.test(char)) {
			if (CSS_WS_REG.test(rtn[rtn.length - 1])) {
				continue;
			}
			rtn += ' ';
		} else {
			rtn += char;
		}
	}
	return rtn;
};
var CSS_WS_REG = /\s/;
var CSS_NEXT_CHAR_REG = /[>\(\)\~\,\+\s]/;
var CSS_PREV_CHAR_REG = /[>\(\~\,\+]/;

// src/compiler/style/css-parser/used-selectors.ts
var getUsedSelectors = (elm) => {
	const usedSelectors = {
		attrs: /* @__PURE__ */ new Set(),
		classNames: /* @__PURE__ */ new Set(),
		ids: /* @__PURE__ */ new Set(),
		tags: /* @__PURE__ */ new Set(),
	};
	collectUsedSelectors(usedSelectors, elm);
	return usedSelectors;
};
var collectUsedSelectors = (usedSelectors, elm) => {
	if (elm != null && elm.nodeType === 1) {
		const children = elm.children;
		const tagName = elm.nodeName.toLowerCase();
		usedSelectors.tags.add(tagName);
		const attributes = elm.attributes;
		for (let i = 0, l = attributes.length; i < l; i++) {
			const attr = attributes.item(i);
			const attrName = attr.name.toLowerCase();
			usedSelectors.attrs.add(attrName);
			if (attrName === 'class') {
				const classList = elm.classList;
				for (let i2 = 0, l2 = classList.length; i2 < l2; i2++) {
					usedSelectors.classNames.add(classList.item(i2));
				}
			} else if (attrName === 'id') {
				usedSelectors.ids.add(attr.value);
			}
		}
		if (children) {
			for (let i = 0, l = children.length; i < l; i++) {
				collectUsedSelectors(usedSelectors, children[i]);
			}
		}
	}
};

// src/compiler/html/remove-unused-styles.ts
var removeUnusedStyles = (doc, diagnostics) => {
	try {
		const styleElms = doc.head.querySelectorAll(`style[data-styles]`);
		const styleLen = styleElms.length;
		if (styleLen > 0) {
			const usedSelectors = getUsedSelectors(doc.documentElement);
			for (let i = 0; i < styleLen; i++) {
				removeUnusedStyleText(usedSelectors, diagnostics, styleElms[i]);
			}
		}
	} catch (e) {
		catchError(diagnostics, e);
	}
};
var removeUnusedStyleText = (usedSelectors, diagnostics, styleElm) => {
	try {
		const parseResults = parseCss(styleElm.innerHTML);
		diagnostics.push(...parseResults.diagnostics);
		if (hasError(diagnostics)) {
			return;
		}
		try {
			styleElm.innerHTML = serializeCss(parseResults.stylesheet, {
				usedSelectors,
			});
		} catch (e) {
			diagnostics.push({
				level: 'warn',
				type: 'css',
				header: 'CSS Stringify',
				messageText: e,
				lines: [],
			});
		}
	} catch (e) {
		diagnostics.push({
			level: 'warn',
			type: 'css',
			header: 'CSS Parse',
			messageText: e,
			lines: [],
		});
	}
};

// src/hydrate/runner/inspect-element.ts
function inspectElement(results, elm, depth) {
	const children = [...Array.from(elm.children), ...Array.from(elm.shadowRoot ? elm.shadowRoot.children : [])];
	for (let i = 0, ii = children.length; i < ii; i++) {
		const childElm = children[i];
		const tagName = childElm.nodeName.toLowerCase();
		if (tagName.includes('-')) {
			const cmp = results.components.find((c) => c.tag === tagName);
			if (cmp != null) {
				cmp.count++;
				if (depth > cmp.depth) {
					cmp.depth = depth;
				}
			}
		} else {
			switch (tagName) {
				case 'a':
					const anchor = collectAttributes(childElm);
					anchor.href = childElm.href;
					if (typeof anchor.href === 'string') {
						if (!results.anchors.some((a) => a.href === anchor.href)) {
							results.anchors.push(anchor);
						}
					}
					break;
				case 'img':
					const img = collectAttributes(childElm);
					img.src = childElm.src;
					if (typeof img.src === 'string') {
						if (!results.imgs.some((a) => a.src === img.src)) {
							results.imgs.push(img);
						}
					}
					break;
				case 'link':
					const link = collectAttributes(childElm);
					link.href = childElm.href;
					if (typeof link.rel === 'string' && link.rel.toLowerCase() === 'stylesheet') {
						if (typeof link.href === 'string') {
							if (!results.styles.some((s) => s.link === link.href)) {
								delete link.rel;
								delete link.type;
								results.styles.push(link);
							}
						}
					}
					break;
				case 'script':
					const script = collectAttributes(childElm);
					if (childElm.hasAttribute('src')) {
						script.src = childElm.src;
						if (typeof script.src === 'string') {
							if (!results.scripts.some((s) => s.src === script.src)) {
								results.scripts.push(script);
							}
						}
					} else {
						const staticDataKey = childElm.getAttribute('data-stencil-static');
						if (staticDataKey) {
							results.staticData.push({
								id: staticDataKey,
								type: childElm.getAttribute('type'),
								content: childElm.textContent,
							});
						}
					}
					break;
			}
		}
		depth++;
		inspectElement(results, childElm, depth);
	}
}
function collectAttributes(node) {
	const parsedElm = {};
	const attrs = node.attributes;
	for (let i = 0, ii = attrs.length; i < ii; i++) {
		const attr = attrs.item(i);
		const attrName = attr.nodeName.toLowerCase();
		if (SKIP_ATTRS.has(attrName)) {
			continue;
		}
		const attrValue = attr.nodeValue;
		if (attrName === 'class' && attrValue === '') {
			continue;
		}
		parsedElm[attrName] = attrValue;
	}
	return parsedElm;
}
var SKIP_ATTRS = /* @__PURE__ */ new Set(['s-id', 'c-id']);

// src/hydrate/runner/patch-dom-implementation.ts
function patchDomImplementation(doc, opts) {
	let win2;
	if (doc.defaultView != null) {
		opts.destroyWindow = true;
		patchWindow(doc.defaultView);
		win2 = doc.defaultView;
	} else {
		opts.destroyWindow = true;
		opts.destroyDocument = false;
		win2 = new MockWindow(false);
	}
	if (win2.document !== doc) {
		win2.document = doc;
	}
	if (doc.defaultView !== win2) {
		doc.defaultView = win2;
	}
	const HTMLElement2 = doc.documentElement.constructor.prototype;
	if (typeof HTMLElement2.getRootNode !== 'function') {
		const elm = doc.createElement('unknown-element');
		const HTMLUnknownElement = elm.constructor.prototype;
		HTMLUnknownElement.getRootNode = getRootNode;
	}
	if (typeof doc.createEvent === 'function') {
		const CustomEvent2 = doc.createEvent('CustomEvent').constructor;
		if (win2.CustomEvent !== CustomEvent2) {
			win2.CustomEvent = CustomEvent2;
		}
	}
	try {
		win2.__stencil_baseURI = doc.baseURI;
	} catch (e) {
		Object.defineProperty(doc, 'baseURI', {
			get() {
				const baseElm = doc.querySelector('base[href]');
				if (baseElm) {
					return new URL(baseElm.getAttribute('href'), win2.location.href).href;
				}
				return win2.location.href;
			},
		});
	}
	return win2;
}
function getRootNode(opts) {
	const isComposed = opts != null && opts.composed === true;
	let node = this;
	while (node.parentNode != null) {
		node = node.parentNode;
		if (isComposed === true && node.parentNode == null && node.host != null) {
			node = node.host;
		}
	}
	return node;
}

// src/hydrate/runner/render-utils.ts
function normalizeHydrateOptions(inputOpts) {
	const outputOpts = Object.assign(
		{
			serializeToHtml: false,
			destroyWindow: false,
			destroyDocument: false,
		},
		inputOpts || {},
	);
	if (typeof outputOpts.clientHydrateAnnotations !== 'boolean') {
		outputOpts.clientHydrateAnnotations = true;
	}
	if (typeof outputOpts.constrainTimeouts !== 'boolean') {
		outputOpts.constrainTimeouts = true;
	}
	if (typeof outputOpts.maxHydrateCount !== 'number') {
		outputOpts.maxHydrateCount = 300;
	}
	if (typeof outputOpts.runtimeLogging !== 'boolean') {
		outputOpts.runtimeLogging = false;
	}
	if (typeof outputOpts.timeout !== 'number') {
		outputOpts.timeout = 15e3;
	}
	if (Array.isArray(outputOpts.excludeComponents)) {
		outputOpts.excludeComponents = outputOpts.excludeComponents.filter(filterValidTags).map(mapValidTags);
	} else {
		outputOpts.excludeComponents = [];
	}
	if (Array.isArray(outputOpts.staticComponents)) {
		outputOpts.staticComponents = outputOpts.staticComponents.filter(filterValidTags).map(mapValidTags);
	} else {
		outputOpts.staticComponents = [];
	}
	return outputOpts;
}
function filterValidTags(tag) {
	return typeof tag === 'string' && tag.includes('-');
}
function mapValidTags(tag) {
	return tag.trim().toLowerCase();
}
function generateHydrateResults(opts) {
	if (typeof opts.url !== 'string') {
		opts.url = `https://hydrate.stenciljs.com/`;
	}
	if (typeof opts.buildId !== 'string') {
		opts.buildId = createHydrateBuildId();
	}
	const results = {
		buildId: opts.buildId,
		diagnostics: [],
		url: opts.url,
		host: null,
		hostname: null,
		href: null,
		pathname: null,
		port: null,
		search: null,
		hash: null,
		html: null,
		httpStatus: null,
		hydratedCount: 0,
		anchors: [],
		components: [],
		imgs: [],
		scripts: [],
		staticData: [],
		styles: [],
		title: null,
	};
	try {
		const url = new URL(opts.url, `https://hydrate.stenciljs.com/`);
		results.url = url.href;
		results.host = url.host;
		results.hostname = url.hostname;
		results.href = url.href;
		results.port = url.port;
		results.pathname = url.pathname;
		results.search = url.search;
		results.hash = url.hash;
	} catch (e) {
		renderCatchError(results, e);
	}
	return results;
}
var createHydrateBuildId = () => {
	let chars = 'abcdefghijklmnopqrstuvwxyz';
	let buildId = '';
	while (buildId.length < 8) {
		const char = chars[Math.floor(Math.random() * chars.length)];
		buildId += char;
		if (buildId.length === 1) {
			chars += '0123456789';
		}
	}
	return buildId;
};
function renderBuildDiagnostic(results, level, header, msg) {
	const diagnostic = {
		level,
		type: 'build',
		header,
		messageText: msg,
		relFilePath: void 0,
		absFilePath: void 0,
		lines: [],
	};
	if (results.pathname) {
		if (results.pathname !== '/') {
			diagnostic.header += ': ' + results.pathname;
		}
	} else if (results.url) {
		diagnostic.header += ': ' + results.url;
	}
	results.diagnostics.push(diagnostic);
	return diagnostic;
}
function renderBuildError(results, msg) {
	return renderBuildDiagnostic(results, 'error', 'Hydrate Error', msg || '');
}
function renderCatchError(results, err2) {
	const diagnostic = renderBuildError(results);
	if (err2 != null) {
		if (err2.stack != null) {
			diagnostic.messageText = err2.stack.toString();
		} else {
			if (err2.message != null) {
				diagnostic.messageText = err2.message.toString();
			} else {
				diagnostic.messageText = err2.toString();
			}
		}
	}
	return diagnostic;
}

// src/hydrate/runner/runtime-log.ts
function runtimeLogging(win2, opts, results) {
	try {
		const pathname = win2.location.pathname;
		win2.console.error = (...msgs) => {
			const errMsg = msgs
				.reduce((errMsg2, m) => {
					if (m) {
						if (m.stack != null) {
							return errMsg2 + ' ' + String(m.stack);
						} else {
							if (m.message != null) {
								return errMsg2 + ' ' + String(m.message);
							}
						}
					}
					return String(m);
				}, '')
				.trim();
			if (errMsg !== '') {
				renderCatchError(results, errMsg);
				if (opts.runtimeLogging) {
					runtimeLog(pathname, 'error', [errMsg]);
				}
			}
		};
		win2.console.debug = (...msgs) => {
			renderBuildDiagnostic(results, 'debug', 'Hydrate Debug', [...msgs].join(', '));
			if (opts.runtimeLogging) {
				runtimeLog(pathname, 'debug', msgs);
			}
		};
		if (opts.runtimeLogging) {
			['log', 'warn', 'assert', 'info', 'trace'].forEach((type) => {
				win2.console[type] = (...msgs) => {
					runtimeLog(pathname, type, msgs);
				};
			});
		}
	} catch (e) {
		renderCatchError(results, e);
	}
}
function runtimeLog(pathname, type, msgs) {
	global.console[type].apply(global.console, [`[ ${pathname}  ${type} ] `, ...msgs]);
}

// src/hydrate/runner/window-initialize.ts
var docData = {
	hostIds: 0,
	rootLevelIds: 0,
	staticComponents: /* @__PURE__ */ new Set(),
};
function initializeWindow(win2, doc, opts, results) {
	if (typeof opts.url === 'string') {
		try {
			win2.location.href = opts.url;
		} catch (e) {}
	}
	if (typeof opts.userAgent === 'string') {
		try {
			win2.navigator.userAgent = opts.userAgent;
		} catch (e) {}
	}
	if (typeof opts.cookie === 'string') {
		try {
			doc.cookie = opts.cookie;
		} catch (e) {}
	}
	if (typeof opts.referrer === 'string') {
		try {
			doc.referrer = opts.referrer;
		} catch (e) {}
	}
	if (typeof opts.direction === 'string') {
		try {
			doc.documentElement.setAttribute('dir', opts.direction);
		} catch (e) {}
	}
	if (typeof opts.language === 'string') {
		try {
			doc.documentElement.setAttribute('lang', opts.language);
		} catch (e) {}
	}
	if (typeof opts.buildId === 'string') {
		try {
			doc.documentElement.setAttribute('data-stencil-build', opts.buildId);
		} catch (e) {}
	}
	try {
		win2.customElements = null;
	} catch (e) {}
	if (opts.constrainTimeouts) {
		constrainTimeouts(win2);
	}
	runtimeLogging(win2, opts, results);
	doc[STENCIL_DOC_DATA] = docData;
	return win2;
}

// src/hydrate/runner/render.ts
var NOOP = () => {};
function streamToString(html, option) {
	return renderToString(html, option, true);
}
function renderToString(html, options, asStream) {
	const opts = normalizeHydrateOptions(options);
	opts.serializeToHtml = true;
	opts.fullDocument = typeof opts.fullDocument === 'boolean' ? opts.fullDocument : true;
	opts.serializeShadowRoot =
		typeof opts.serializeShadowRoot === 'undefined' ? 'declarative-shadow-dom' : opts.serializeShadowRoot;
	opts.constrainTimeouts = false;
	return hydrateDocument(html, opts, asStream);
}
function hydrateDocument(doc, options, asStream) {
	const opts = normalizeHydrateOptions(options);
	let win2 = null;
	const results = generateHydrateResults(opts);
	if (hasError(results.diagnostics)) {
		return Promise.resolve(results);
	}
	if (typeof doc === 'string') {
		try {
			opts.destroyWindow = true;
			opts.destroyDocument = true;
			win2 = new MockWindow(doc);
			if (!asStream) {
				return render2(win2, opts, results).then(() => results);
			}
			return renderStream(win2, opts, results);
		} catch (e) {
			if (win2 && win2.close) {
				win2.close();
			}
			win2 = null;
			renderCatchError(results, e);
			return Promise.resolve(results);
		}
	}
	if (isValidDocument(doc)) {
		try {
			opts.destroyDocument = false;
			win2 = patchDomImplementation(doc, opts);
			if (!asStream) {
				return render2(win2, opts, results).then(() => results);
			}
			return renderStream(win2, opts, results);
		} catch (e) {
			if (win2 && win2.close) {
				win2.close();
			}
			win2 = null;
			renderCatchError(results, e);
			return Promise.resolve(results);
		}
	}
	renderBuildError(results, `Invalid html or document. Must be either a valid "html" string, or DOM "document".`);
	return Promise.resolve(results);
}
async function render2(win2, opts, results) {
	if ('process' in globalThis && typeof process.on === 'function' && !process.__stencilErrors) {
		process.__stencilErrors = true;
		process.on('unhandledRejection', (e) => {
			console.log('unhandledRejection', e);
		});
	}
	initializeWindow(win2, win2.document, opts, results);
	const beforeHydrateFn = typeof opts.beforeHydrate === 'function' ? opts.beforeHydrate : NOOP;
	try {
		await Promise.resolve(beforeHydrateFn(win2.document));
		return new Promise((resolve) => {
			if (Array.isArray(opts.modes)) {
				modeResolutionChain.length = 0;
				opts.modes.forEach((mode) => setMode(mode));
			}
			return hydrateFactory(win2, opts, results, afterHydrate, resolve);
		});
	} catch (e) {
		renderCatchError(results, e);
		return finalizeHydrate(win2, win2.document, opts, results);
	}
}
function renderStream(win2, opts, results) {
	async function* processRender() {
		const renderResult = await render2(win2, opts, results);
		yield renderResult.html;
	}
	return stream.Readable.from(processRender());
}
async function afterHydrate(win2, opts, results, resolve) {
	const afterHydrateFn = typeof opts.afterHydrate === 'function' ? opts.afterHydrate : NOOP;
	try {
		await Promise.resolve(afterHydrateFn(win2.document));
		return resolve(finalizeHydrate(win2, win2.document, opts, results));
	} catch (e) {
		renderCatchError(results, e);
		return resolve(finalizeHydrate(win2, win2.document, opts, results));
	}
}
function finalizeHydrate(win2, doc, opts, results) {
	try {
		inspectElement(results, doc.documentElement, 0);
		if (opts.removeUnusedStyles !== false) {
			try {
				removeUnusedStyles(doc, results.diagnostics);
			} catch (e) {
				renderCatchError(results, e);
			}
		}
		if (typeof opts.title === 'string') {
			try {
				doc.title = opts.title;
			} catch (e) {
				renderCatchError(results, e);
			}
		}
		results.title = doc.title;
		if (opts.removeScripts) {
			removeScripts(doc.documentElement);
		}
		try {
			updateCanonicalLink(doc, opts.canonicalUrl);
		} catch (e) {
			renderCatchError(results, e);
		}
		try {
			relocateMetaCharset(doc);
		} catch (e) {}
		if (!hasError(results.diagnostics)) {
			results.httpStatus = 200;
		}
		try {
			const metaStatus = doc.head.querySelector('meta[http-equiv="status"]');
			if (metaStatus != null) {
				const metaStatusContent = metaStatus.getAttribute('content');
				if (metaStatusContent && metaStatusContent.length > 0) {
					results.httpStatus = parseInt(metaStatusContent, 10);
				}
			}
		} catch (e) {}
		if (opts.clientHydrateAnnotations) {
			doc.documentElement.classList.add('hydrated');
		}
		if (opts.serializeToHtml) {
			results.html = serializeDocumentToString(doc, opts);
		}
	} catch (e) {
		renderCatchError(results, e);
	}
	destroyWindow(win2, doc, opts, results);
	return results;
}
function destroyWindow(win2, doc, opts, results) {
	if (!opts.destroyWindow) {
		return;
	}
	try {
		if (!opts.destroyDocument) {
			win2.document = null;
			doc.defaultView = null;
		}
		if (win2.close) {
			win2.close();
		}
	} catch (e) {
		renderCatchError(results, e);
	}
}
function serializeDocumentToString(doc, opts) {
	return serializeNodeToHtml(doc, {
		approximateLineWidth: opts.approximateLineWidth,
		outerHtml: false,
		prettyHtml: opts.prettyHtml,
		removeAttributeQuotes: opts.removeAttributeQuotes,
		removeBooleanAttributeQuotes: opts.removeBooleanAttributeQuotes,
		removeEmptyAttributes: opts.removeEmptyAttributes,
		removeHtmlComments: opts.removeHtmlComments,
		serializeShadowRoot: opts.serializeShadowRoot,
		fullDocument: opts.fullDocument,
	});
}
function isValidDocument(doc) {
	return (
		doc != null &&
		doc.nodeType === 9 &&
		doc.documentElement != null &&
		doc.documentElement.nodeType === 1 &&
		doc.body != null &&
		doc.body.nodeType === 1
	);
}
function removeScripts(elm) {
	const children = elm.children;
	for (let i = children.length - 1; i >= 0; i--) {
		const child = children[i];
		removeScripts(child);
		if (child.nodeName === 'SCRIPT' || (child.nodeName === 'LINK' && child.getAttribute('rel') === 'modulepreload')) {
			child.remove();
		}
	}
}

exports.createWindowFromHtml = createWindowFromHtml;
exports.deserializeProperty = deserializeProperty;
exports.hydrateDocument = hydrateDocument;
exports.renderToString = renderToString;
exports.serializeDocumentToString = serializeDocumentToString;
exports.serializeProperty = serializeProperty;
exports.streamToString = streamToString;
